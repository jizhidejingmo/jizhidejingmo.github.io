<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="YownYang, iOS, Weex, YownYang's blog, iPhoneX, Xcode9, iOS11" />





  <link rel="alternate" href="/atom.xml" title="YownYang's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="这是翻译《Effective Objective-C 2.0》的第五章：内存管理">
<meta property="og:type" content="article">
<meta property="og:title" content="译《Effective Objective-C 2.0》第五章">
<meta property="og:url" content="http://yoursite.com/2017/07/01/Memory Management/index.html">
<meta property="og:site_name" content="YownYang's blog">
<meta property="og:description" content="这是翻译《Effective Objective-C 2.0》的第五章：内存管理">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.1.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.2.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.3.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.4.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.5.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.6.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.7.png">
<meta property="og:updated_time" content="2017-07-08T07:48:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="译《Effective Objective-C 2.0》第五章">
<meta name="twitter:description" content="这是翻译《Effective Objective-C 2.0》的第五章：内存管理">
<meta name="twitter:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/01/Memory Management/"/>





  <title> 译《Effective Objective-C 2.0》第五章 | YownYang's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1261580070&web_id=1261580070" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YownYang's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            个人简历
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/01/Memory Management/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YownYang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="YownYang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="YownYang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                译《Effective Objective-C 2.0》第五章
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-01T17:55:58+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这是翻译《Effective Objective-C 2.0》的第五章：内存管理</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>无论任何面向对象语言，内存管理都是重要的一部分，例如<code>Objective-C</code>。想写出高效无bug的语言，对其语言的内存管理模型一定要了解。</p>
<p>如果你理解了类似规则，你会发现<code>Objective-C</code>的内存管理貌似也不是很复杂，特别当你使用ARC时。ARC将所有的内存管理都交给了编译器，可以让开发者专注业务逻辑。</p>
<h3 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h3><p><code>Objective-C</code>使用引用计数去管理内存，这意味着每个对象都有一个计数器用于增加和减少引用计数。当你想使用某个对象时就增加引用计数，当你不再使用某个对象时，就减少引用计数。当对象引用计数为0，这个对象不再有任何使用者，这时他就会被释放。上面所述是主要概念，如果你想写出优秀的代码，即使你使用ARC(看第30节)机制，你也需要理解上述概念。</p>
<p>在Mac上，垃圾回收机制在10.8之后被废弃，在iOS上更是从来都不能使用。所以理解引用计数就至关重要了，因为你不能在iOS和Mac上使用垃圾回收了。</p>
<p>如果你已经使用了ARC，那你应该知道所有与引用计数相关的方法都无法调用了，暂且忘掉这些吧。在ARC中，这是真的。但是这是讲述引用计数必须的一部分，并且ARC也是一种引用计数机制，所以还是要讲述这些在ARC下无法使用的方法。</p>
<h4 id="引用计数如何工作"><a href="#引用计数如何工作" class="headerlink" title="引用计数如何工作"></a>引用计数如何工作</h4><p>在引用计数机制下，计数器是代表每个对象有多少事物想令此对象继续存在。这涉及到了一个叫做保留计数的东西，但是他也被称作引用计数。下面三个<code>NSObject</code>的协议方法可以操作引用计数的增加和减少：</p>
<ul>
<li><strong>retain</strong> 增加引用计数</li>
<li><strong>release</strong> 减少引用计数</li>
<li><strong>autorelease</strong> 稍后减少引用计数，当自动释放池释放时减少(我们将在第34节第150页讨论自动释放池)</li>
</ul>
<p>其中有一个叫做<code>retainCount</code>的方法，但是它不是很准确，即使在调试环境下也是。所以我跟苹果都不推荐你使用它。具体信息看第36节。</p>
<p>每个对象创建时引用计数最少为1。如果想要对象存活，就调用<code>retain</code>方法。当某部分代码不再需要这个对象时就调用<code>release</code>或者<code>autorelease</code>。当引用计数为0时，对象被释放，这意味着这块内存被标为可复用。一旦对象被释放，那么该对象的任何引用都是无效的。</p>
<p>图5.1展示了一个对象的创建，持有和两次释放。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.1.png" alt=""><br><strong>Figure 5.1</strong> 一个对象的整个生命周期内它的引用计数的增加和减少</p>
<p>在一个应用的生命周期内，有许多对象被创建。这些对象往往跟另一个对象有所关联。例如，有一个代表人的对象，它会对一个用字符串表示的人名进行引用，也可能有别的引用，例如一个代表它朋友的结合，这些构成了一个对象表。如果一个对象对另一个对象持有一个强引用，那么前者持有后者。这个意思是当某个对象对其余对象有使用的意图时，就可以通过持有的方式保证后者被释放。当它不在需要后者时，再对后者进行释放。</p>
<p>图5.2的对象表中，<code>ObjectA</code>同时被<code>ObjectB</code>和<code>ObjectC</code>持有。当<code>ObjectB</code>和<code>ObjectC</code>不在持有<code>ObjectA</code>并且<code>ObjectA</code>引用计数为0时，<code>ObjectA</code>会被释放。<code>ObjectB</code>和<code>ObjectC</code>被其余对象持有，而其余对象又被别的对象持有。如果你查找整个对象表，你会发现一个根对象。在Mac中，根对象是<code>NSApplication</code>；在iOS中，根对象是<code>UIApplication</code>。这两个对象都是程序启动时创建的一个单例对象。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.2.png" alt=""><br><strong>Figure 5.2</strong> 对象表展示一个对象被释放之前它的引用的释放</p>
<p>下面的代码将帮助你理解上图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</div><div class="line">[array addObject:number];</div><div class="line">[number release];</div><div class="line">// do something with &apos;array&apos;</div><div class="line">[array release];</div></pre></td></tr></table></figure>
<p>如前面展示的一样，上述代码在ARC下无法编译通过。因为显式调用了<code>release</code>方法。在<code>Objective-C</code>中，调用<code>alloc</code>方法返回的对象由调用者持有。也就是说，调用者通过 <code>alloc</code>方法表达了想让对象存在的想法。但是有一点需要注意，这时它的引用计数并不一定是1。它有可能比1大，因为<code>alloc</code>或者<code>initWithInt:</code>的实现里面有别的对象对他有引用。这样，这个对象的引用计数就最少为1了。你应该这样理解引用计数这个概念。你不应该认为引用计数是几，只应该说清楚引用计数增加或者减少。</p>
<p>然后<code>number</code>对象被添加进数组。数组通过<code>addObject:</code>方法一直保持<code>number</code>的引用。<br>这时，<code>number</code>对象的引用计数最少是2。然后，这段代码不再需要<code>number</code>变量，所以释放它。这时引用计数最少是1。这时，<code>number</code>变量不再可以安全的使用。它调用<code>release</code>的意思是不再能保证所指对象是否存活了。当然，在这个例子中，我们很明显可以知道它在调用了<code>release</code>之后仍然是存活的，因为数组还在引用它。但是不要假定一个对象存活，就是不要像下面这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</div><div class="line">[array addObject:number];</div><div class="line">[number release];</div><div class="line">NSLog(@&quot;number = %@&quot;, number);</div></pre></td></tr></table></figure>
<p>这样的代码即使在这个环境下可以运行，它也不是好的做法。不论出现任何原因导致<code>number</code>对象的引用计数为0，然后被释放，那么当你调用<code>NSLog</code>的时候，程序就可能会崩溃掉了。这里为什么说是可能呢？因为对象释放之后，只是将内存放回可用内存池。如果在你调用<code>NSLog</code>时，内存还没有被覆盖，那么该对象仍然存在，就不会发生崩溃。因此，过早释放对象会造成难以调试的问题。</p>
<p>为了减少这种对象已经被释放的潜在风险，你经常能看到在<code>release</code>之后将对象设为nil的代码。这能确保不会通过指针调用一个无效的对象，这种指针被称为悬垂指针。例如，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</div><div class="line">[array addObject:number];</div><div class="line">[number release];</div><div class="line">number = nil;</div></pre></td></tr></table></figure>
<h4 id="属性存取器的内存管理"><a href="#属性存取器的内存管理" class="headerlink" title="属性存取器的内存管理"></a>属性存取器的内存管理</h4><p>正像前面说的那样，对象链接在一起构成了对象表。上面例子中的数组通过对对象进行<code>retain</code>操作持有它们。同样，其它对象也可以使用属性持有其它对象，并通过存取方法去获得或者设置实例变量。如果属性是一个强引用，则设置的属性值会被保留。一个叫做<code>foo</code>的属性的，它有一个叫做<code>_foo</code>的实例变量，它的<code>setter</code>方法像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setFoo:(id)foo &#123;  </div><div class="line">    [foo retain];</div><div class="line">    [_foo release];</div><div class="line">    _foo = foo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>保存新值，释放旧值。然后更新实例变量指向新的值。这个命令是重要的。如果旧值在新值保留前释放并且这两个值是相同的，这意味着这个对象可能会被过早的释放。后面的<code>retain</code>操作也无法使这个对象存活，然后这个实例变量将会变成一个悬垂指针。</p>
<h4 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h4><p>在<code>Objective-C</code>的引用计数中有一个重要结构，那就是自动释放池。调用<code>release</code>的会直接减少引用计数(可能导致对象直接释放)，你也可以使用<code>autorelease</code>，它会在之后执行释放操作，通常是在下一次循环事件时递减，不过也可能更早(具体看第34节)。</p>
<p>这个功能是非常有用的，特别是当一个方法返回一个对象时。在这种情况下，我们并不想另调用者手动保存其值。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSString*)stringValue &#123;</div><div class="line">    </div><div class="line">    NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self];</div><div class="line">    return str;</div><div class="line">&#125;</div><div class="line">```在这个例子中，`str`的引用计数最少为1，因为调用`alloc`方法会使引用计数加1，并且也没有对应的释放。引用计数加1意味着你作为调用者，必须在某个时刻将其释放，即引用计数减1。但是这并不意味着它的引用计数是1。它可能是更多，因为你不知道`initWithFormat:`的实现细节。你要考虑的是如何处理这一次的保留操作。 </div><div class="line">但是你不能在这个方法里面释放它，因为它需要返回后才能释放。所以这里应该使用`autorelease`去保证对象可以正常返回，然后进行释放。也就是说，这个方法可以保证对象跨越方法调用边界之后仍然存活。实际上，这个释放会在当前自动释放池释放时(看第34节)发生，除非你创建了自己的自动释放池，否则它会在当前线程的下次事件时释放。对这个字符串对象使用这个方法如下：</div></pre></td></tr></table></figure>
<ul>
<li><p>(NSString*)stringValue {</p>
<p>  NSString *str = [[NSString alloc] initWithFormat:@”I am this: %@”, self];<br>  return [str autorelease];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在这个方法返回时，对象一定存活。所以这个对象可以这样使用了：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NSString *str = [self stringValue];<br>NSLog(@”The string is: %@”, str);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里不再需要更多的内存管理了，因为`str`对象已经自动释放，达到引用计数平衡了。因为自动释放池要到下一次事件循环才会释放，所以在使用`NSLog`时，不需要再进行保留了。但是，如果对象需要被持有，例如一个实例变量，对象需要`retain`并在稍后使用`release`：</div></pre></td></tr></table></figure></p>
<p>_instanceVariable = [[self stringValue] retain];<br>// …<br>[_instanceVariable release];<br>```</p>
<p>所以<code>autorelease</code>可以延长对象的生命周期，使其跨越方法调用边界之后仍然存在。</p>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>使用引用计数时常遇到的一个场景是循环应用，它发生在多个对象相互引用的时候。它会导致内存泄露，因为没有办法调用到这些循环引用的对象，并将其引用计数设为0。在循环引用中，每个对象都会被最少一个对象持有。在图5.3中，每一个对象都有另外两个对象的引用。在这个循环中，所有对象的引用计数都是1。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.3.png" alt=""><br><strong>Figure 5.3</strong> 一个循环引用的对象表</p>
<p>在垃圾回收中，这种情况会被标记为孤岛。这种情况下，垃圾回收器会将三个对象都释放掉。很遗憾在<code>Objective-C</code>的引用计数中不存在这种做法。这个问题的常用做法是使用弱引用(看第33节)或者将这些对象中的某一个放弃持有其它对象。上述的两种做法都可以打破循环引用，这样内存泄露就不存在了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>以引用计数方式进行内存管理是基于计数器进行增加和减少的。一个对象创建后，它的引用计数最少为1。如果引用计数为正，则对象存活。如果引用计数为0，则对象被释放。</li>
<li>在对象的整个生命周期中，一个对象通过引用来保留和释放其他对象。保留和释放会增加和减少引用计数。</li>
</ul>
<h3 id="ARC使引用计数更加简单"><a href="#ARC使引用计数更加简单" class="headerlink" title="ARC使引用计数更加简单"></a>ARC使引用计数更加简单</h3><p>理解引用计数概念是很简单的(看第29节)，但是<code>retain</code>和<code>release</code>出现的场景很是频繁。所以<code>Clang</code>编译器搞了一个静态解析器，用于指出引用计数出现问题的地方。例如，考虑下面代码片段的引用计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ([self shouldLogMessage]) &#123;</div><div class="line">        </div><div class="line">    NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self];</div><div class="line">    NSLog(@&quot;message = %@&quot;, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码有一个内存泄露，因为在判断语句的结尾，<code>message</code>对象没有释放。因为出了条件语句后，就没办法引用它了，对象就泄露了。判断内存泄露的规则很简单。它调用了<code>NSString</code>的<code>alloc</code>方法生成了一个对象，使其引用计数最少为1。但是它没有释放。这些规则很容易表达，电脑可以轻易使用这些规则并告诉我们哪个对象发生了泄露。这就是静态编译器要做的事情。</p>
<p>静态分析还有更深层次的用途。因为它可以告诉你哪个地方发生了内存泄露，所以它也可以在需要的地方添加<code>retain</code>或者<code>release</code>，是吧？ARC就是由这个概念诞生的。ARC的就像它名字说的那样：使引用计数自动化。所以上面的代码会在判断语句结束的地方自动加上<code>release</code>操作，自动添加后的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ([self shouldLogMessage]) &#123;</div><div class="line">        </div><div class="line">    NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self];</div><div class="line">    NSLog(@&quot;message = %@&quot;, message);</div><div class="line">    [message release]; ///&lt; Added by ARC</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要记住的是即使使用了ARC，引用计数仍是在执行的。只不过添加<code>retain</code>或者<code>release</code>的操作是ARC做的。除了为方法返回的对象处理内存管理语义ARC还做了更多的事，稍后你将看到。不过这些功能，都是基于核心内存管理语义构建的，这套标准适用于整个<code>Objective-C</code>。</p>
<p>由于ARC会自动的调用<code>retains, releases, autoreleases</code>，所以你在ARC下直接调用内存管理方法是不合法的。尤其是，你不能调用下面这些方法：</p>
<ul>
<li>retain</li>
<li>release</li>
<li>autorelease</li>
<li>dealloc</li>
</ul>
<p>在ARC下，你直接调用上述方法的任意一个都会导致编译错误，因为你这样做会导致ARC无法正常工作。你必须相信ARC可以处理好这些，这会使某些开发者不是很放心。</p>
<p>实际上，ARC并没有通过正常的<code>Objective-C</code>派发机制去调用这些方法，它直接调用了底层的C函数。这是一种优化，因为<code>retain</code>和<code>release</code>方法调用的是很频繁的，并且也可以减少CPU的工作量。例如，<code>retain</code>是等价于<code>objc_retain</code>的。这就是为什么覆写<code>retain, release, autorelease</code>这些方法是非法的，因为它们并不是直接调用的。对于本章节的其余部分，我仍将讲述与底层C函数等价的<code>Objective-C</code>方法。这对那些使用过手动管理引用计数的人更友好。</p>
<h4 id="ARC中的方法命名规则"><a href="#ARC中的方法命名规则" class="headerlink" title="ARC中的方法命名规则"></a>ARC中的方法命名规则</h4><p>在<code>Objective-C</code>中，将内存管理语义通过方法名表现出来是惯例，而ARC则将其确定为硬性规则。规则是很简单的并且跟方法名有关联的。一个返回对象的方法，如果方法以下列名词开头，它的所有权归属调用者：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>归属调用者的意思是调用那四种方法的调用者需要管理返回值的释放。这是说，返回对象有一个正的引用计数，调用者需要去平衡这一次引用计数。如果有别的对象对其进行了保存或者进行了<code>autorelease</code>，那么它的引用计数会大于1，这就是为什么说<code>retainCount</code>方法没有什么用的原因(看第36节)。</p>
<p>任意别的方法名都代表返回对象的所有权不归属于调用者。这种情况下，对象将自动调用<code>autorelease</code>，这样返回对象的值就可以在跨越边界调用后仍旧有效。如果想确保对象仍然存活，可以调用<code>retain</code>保留它。</p>
<p>ARC自动处理所有需要操作的内存管理规则，包括代码返回值的<code>autorelease</code>，就像下面代码展示的那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">+ (EOCPerson*)newPerson &#123;</div><div class="line">    EOCPerson *person = [[EOCPerson alloc] init];</div><div class="line">    return person;</div><div class="line">    /**</div><div class="line">     * The method name begins with &apos;new&apos;, and since &apos;person&apos; * already has an unbalanced +1 retain count from the</div><div class="line">     * &apos;alloc&apos;, no retains, releases, or autoreleases are</div><div class="line">     * required when returning.</div><div class="line">     */</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (EOCPerson*)somePerson &#123;</div><div class="line">    </div><div class="line">    EOCPerson *person = [[EOCPerson alloc] init];</div><div class="line">    return person;</div><div class="line">    /**</div><div class="line">     * The method name does not begin with one of the &quot;owning&quot;</div><div class="line">     * prefixes, therefore ARC will add an autorelease when</div><div class="line">     * returning &apos;person&apos;.</div><div class="line">     * The equivalent manual reference counting statement is:</div><div class="line">     * return [person autorelease];</div><div class="line">     */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doSomething &#123;</div><div class="line">    </div><div class="line">    EOCPerson *personOne = [EOCPerson newPerson];</div><div class="line">    // ...</div><div class="line">    EOCPerson *personTwo = [EOCPerson somePerson];</div><div class="line">    // ...</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * At this point, &apos;personOne&apos; and &apos;personTwo&apos; go out of</div><div class="line">     * scope, therefore ARC needs to clean them up as required.</div><div class="line">     * - &apos;personOne&apos; was returned as owned by this block of</div><div class="line">     * code, so it needs to be released.</div><div class="line">     * - &apos;personTwo&apos; was returned not owned by this block of</div><div class="line">     *  code, so it does not need to be released.</div><div class="line">     * The equivalent manual reference counting cleanup code</div><div class="line">     * is:</div><div class="line">     * [personOne release]; */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ARC通过名称来约定内存管理的规则，新手往往感觉不可思议。很少有其他语言像<code>Objective-C</code>一样把命名看的这么重要。适应这种模式对于成为一个好的<code>Objective-C</code>开发者是重要的。在这个过程中，ARC帮助你做了大量的工作。</p>
<p>ARC除了为你添加<code>retain、release</code>这些方法，还有一些其他好处。它也会做一些手动难以完成或者不能完成的操作。例如，ARC能互相抵消<code>retain、release、autorelease</code>的互相操作。如果某个对象多次进行<code>retain</code>和<code>release</code>，ARC可以成对的移除它们。</p>
<p>ARC也包含有运行期组件。这些优化发生在运行时，这些就是我们为什么应该在ARC下进行开发。前面提到某个对象需要在返回时进行<code>autorelease</code>。但是调用者需要代码存活就会对它进行<code>retain</code>操作，就像下面这个情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// From a class where _myPerson is a strong instance variable</div><div class="line">_myPerson = [EOCPerson personWithName:@&quot;Bob Smith&quot;];</div></pre></td></tr></table></figure>
<p>调用<code>personWithName:</code>返回了一个自动释放的<code>EOCPerson</code>对象。但是编译器也需要去给那个实例变量添加<code>retain</code>操作，因为它是一个强引用。因此上面的代码等价于下面的手动代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCPerson *tmp = [EOCPerson personWithName:@&quot;Bob Smith&quot;];</div><div class="line">_myPerson = [tmp retain];</div></pre></td></tr></table></figure>
<p>你会发现这里的<code>autorelease</code>和<code>retain</code>都是多余的。去除它们两个可以获得更好的性能收益。但是在ARC下的代码需要考虑向后兼容性，即需要去兼容非ARC的代码。ARC可以移除<code>autorelease</code>这个概念，并且指定所有的方法返回的对象的引用计数都加1。但是，它需要向后兼容。</p>
<p>但是ARC可以在运行时检测到这种多余的行为，即<code>autorelease</code>操作后面跟<code>retain</code>。当一个对象自动释放时，它会调用一个特殊函数，而不是对象的<code>autorelease</code>方法，它叫做<code>objc_autoreleaseReturnValue</code>。这个函数会检查当前函数返回后的那段代码。如果它发现在返回对象后会对对象进行<code>retain</code>操作，它会设置全局数据结构(取决于处理器)中的一个标志，而不执行<code>release</code>操作。同样，对一个自动释放对象进行<code>retain</code>的代码，也不会调用<code>retain</code>，而是执行一个叫做<code>objc_retainAutoreleasedReturnValue</code>的方法。这个方法会检查标志是否存在，如果存在，就不执行<code>retain</code>。对标志进行设置和检查是快过使用<code>autorelease</code>和<code>retain</code>的。</p>
<p>下面的代码展示了ARC是如何使用特殊函数进行优化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Within EOCPerson class</div><div class="line">+ (EOCPerson*)personWithName:(NSString*)name &#123;</div><div class="line">    EOCPerson *person = [[EOCPerson alloc] init];</div><div class="line">    person.name = name;</div><div class="line">    objc_autoreleaseReturnValue(person);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Code using EOCPerson class</div><div class="line">EOCPerson *tmp = [EOCPerson personWithName:@&quot;Matt Galloway&quot;];</div><div class="line">_myPerson = objc_retainAutoreleasedReturnValue(tmp);</div></pre></td></tr></table></figure>
<p>为了求得最佳优化，特殊函数在不同处理器都有不同表现。下面的伪代码展示了大概流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">id objc_autoreleaseReturnValue(id object) &#123;</div><div class="line">    if ( /* caller will retain object */ ) &#123;</div><div class="line">        set_flag(object);</div><div class="line">        return object; ///&lt; No autorelease</div><div class="line">    &#125; else &#123;</div><div class="line">        return [object autorelease];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">id objc_retainAutoreleasedReturnValue(id object) &#123;</div><div class="line">    if (get_flag(object)) &#123;</div><div class="line">        clear_flag(object);</div><div class="line">        return object; ///&lt; No retain</div><div class="line">    &#125; else &#123;</div><div class="line">        return [object retain];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_autoreleaseReturnValue</code>函数如何检测需要保留对象呢。这取决于处理器。只有编译器的作者知道怎么实现它的，因为它需要使用检查机器码。除了编译器的作者谁知道调用的方法是怎么实现的。</p>
<p>这只是编译器在运行期的一种优化。所以使用ARC是一个好的建议。编译器和运行时日渐成熟，我相信会有更多的优化技术的出现。</p>
<h4 id="变量的内存管理语义"><a href="#变量的内存管理语义" class="headerlink" title="变量的内存管理语义"></a>变量的内存管理语义</h4><p>ARC也可以处理本地变量和实例变量的内存管理。通常每个变量都对对象持有强引用。这点是非常重要的，特别是实例变量，因为对象相同的代码，在手动引用计数和自动引用计数都是不一样的。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line">    </div><div class="line">    id _object;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line"></div><div class="line">- (void)setup &#123;</div><div class="line"></div><div class="line">    _object = [EOCOtherClass new];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在手动管理引用计数下，<code>_object</code>实例变量不会自动保留这个值，但是在ARC下会。因此，在ARC下编译这个代码，方法会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setup &#123;</div><div class="line">    id tmp = [EOCOtherClass new];</div><div class="line">    _object = [tmp retain];</div><div class="line">    [tmp release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，这种情况下，<code>retain</code>和<code>release</code>都可以取消掉。所以ARC这样做了，就像转换前的代码一样。但是当它发生在设置<code>setter</code>方法时。如果不使用ARC，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(id)object &#123;</div><div class="line">    [_object release];</div><div class="line">    _object = [object retain];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这样做有一个问题。那就是如果设置的新值和已有的值相同会发生什么？如果这个对象仅有一个引用，那么<code>release</code>会导致这个对象的引用计数变为0并且释放这个对象。后面的<code>retain</code>操作将会导致应用程序崩溃。使用ARC则不可能发生这种错误。ARC下等价的<code>setter</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(id)object &#123;</div><div class="line">    </div><div class="line">    _object = object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ARC执行一种安全的设置变量的方法，先保存新值，然后释放旧值，最后设置实例变量的值。你可能在MRC下已经明白这个问题了并且能正确编写，但是在ARC下你无需考虑这种类似的边界情况。</p>
<p>本地和实例变量可以通过下面这些修饰符进行语义改变：</p>
<ul>
<li>__strong 默认修饰符，这种情况下，变量会被保存。</li>
<li>__unsafe_unretained 这个值不会被保留，这样是不安全的，因为你再次使用它时，可能它已经被释放了。</li>
<li>__weak 这个值也不会被保留，但它是安全的，因为它会在变量为空时，自动设置为nil。</li>
<li>__autoreleasing 把对象按引用传递时始终它，当返回时它会被释放。</li>
</ul>
<p>例如，想令变量与不使用ARC时一样，可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line">    </div><div class="line">    id __weak _weakObject;</div><div class="line">    id __unsafe_unretained _unsafeUnretainedObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这种情况下，当设置实例变量时，对象不会被保留。只有在使用新版运行时库(Mac OS X 10.7、iOS 5.0)的时候，<code>weak</code>修饰符才会自动将实例变量置为nil，因为它需要依赖依稀新的特性。</p>
<p>当我们在块(看第40节)中使用本地变量时，通常使用标示符去打破循环引用。块自动的引用所有它捕获的对象，这样加入那些对象中的某一个也保留有块，就会造成循环引用。使用<code>__weak</code>修饰变量可以打破循环应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:@&quot;http://www.example.com/&quot;];</div><div class="line">EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">EOCNetworkFetcher * __weak weakFetcher = fetcher;</div><div class="line">[fetcher startWithCompletion:^(BOOL success)&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;Finished fetching from %@&quot;, weakFetcher.url);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="ARC清理实例变量"><a href="#ARC清理实例变量" class="headerlink" title="ARC清理实例变量"></a>ARC清理实例变量</h4><p>就像上面展示的一样，ARC会处理实例变量的内存管理。如果要这样做，ARC就需要在释放时期生成清理的代码。凡是使用强引用的变量，ARC都会在<code>dealloc</code>方法中释放它。而在MRC下，需要你自己实现<code>dealloc</code>方法就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    [_foo release];</div><div class="line">    [_bar release];</div><div class="line">    [super dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用了ARC，<code>dealloc</code>方法就不需要这样写了；因为ARC会借用<code>Objective-C++</code>的一项功能来实现清理。在释放时，<code>Objective-C++</code>对象会调用所有C++对象的析构函数。当编译器发现对象包含<code>C++</code>对象时，它会生成一个叫做<code>.cxx_destruct</code>的方法。ARC借助此方法生成清理内存所有的代码。</p>
<p>但是，如果有不是<code>Objective-C</code>的对象，你仍然需要去手动清理，例如<code>CoreFoundation</code>对象，或者是<code>malloc()</code>分配的堆内存。但是你不需要像之前那样去调用父类的<code>dealloc</code>方法。在ARC下不能直接调用<code>dealloc</code>方法。所以ARC会自动在<code>.cxx_destruct</code>中生成并运行代码，也会在生成的代码中自动调用父类的<code>dealloc</code>方法。在ARC下，一个<code>dealloc</code>方法大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    CFRelease(_coreFoundationObject);</div><div class="line">    free(_heapAllocatedMemoryBlob);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于ARC会生成这个方法，所以一般不需要实现<code>dealloc</code>方法。这可以减少项目源码的大小，并减少模板代码。</p>
<h4 id="覆写内存管理方法"><a href="#覆写内存管理方法" class="headerlink" title="覆写内存管理方法"></a>覆写内存管理方法</h4><p>在非ARC时代，是可以覆写内存管理方法的。例如，一个单例类通常会覆写<code>release</code>方法，使其什么也不做，因为单例类不需要释放啊。在ARC就不能这样，因为这会影响ARC对对象声明周期的分析。而且，由于不能调用和覆写这些方法，所以ARC就可以不使用<code>Objective-C</code>的消息派发系统从而对<code>retain, release, autorelease</code>方法进行优化。相应的，可以直接调用运行期的C函数。ARC可以对这些进行优化例如刚才说的对一个返回对象进行<code>autorelease</code>操作，然后接着又进行<code>retain</code>操作。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>ARC使开发者不用担心内存管理。使用ARC也可以减少类的模板代码。</li>
<li>ARC管理对象生命周期的办法就是在合适地方插入<code>retain</code>或者<code>release</code>。ARC下变量可以通过修饰符去改变内存管理语义，MRC下只能手动进行<code>retain</code>或者<code>release</code>。</li>
<li>方法名字已经指出了返回对象的内存管理语义。ARC将这些规则确定为必须遵守的规则。</li>
<li>ARC仅能处理<code>Objective-C</code>对象。特别是不能处理<code>CoreFoundation</code>的对象，它们必须使用<code>CFRetain/CFRelease</code>去处理。</li>
</ul>
<h3 id="在deaclloc中释放引用并清除监听状态"><a href="#在deaclloc中释放引用并清除监听状态" class="headerlink" title="在deaclloc中释放引用并清除监听状态"></a>在deaclloc中释放引用并清除监听状态</h3><p>一个对象走完生命周期后会被释放，那个释放的入口就是<code>dealloc</code>方法。在对象的整个生命周期中，释放只会被调用一次，当对象的引用计数为0时。不过什么时候调用就不知道了。也就是说，你可能通过你手动调用<code>retain</code>或<code>release</code>大概推测出它什么时候调用，但其实这是由系统决定的，它会在你不知道的时候进行释放。你永远不该调用<code>dealloc</code>本身。系统会在运行时在正确时间调用它。而且<code>dealloc</code>被调用后，对象都不再有效，后面的方法也是无效的。</p>
<p>那么你应该在<code>dealloc</code>中做什么呢？主要要做的应该是释放对象的所有持有。这个意思是释放所有的<code>Objective-C</code>对象，ARC会自动帮你添加进<code>dealloc</code>方法，通过自动生成<code>.cxx_destrucr</code>(看第30节)方法。任何非<code>Objective-C</code>也应该在这里释放。例如，<code>CoreFoundation</code>的对象需要释放，因为它是纯C的API。</p>
<p>另一个需要在<code>dealloc</code>中做的事情是清除所有的观察者行为。如果有对象注册了通知者，那么这里是一个移除通知的好地方。这样就不会向这个对象发送通知了，否则会导致应用程序崩溃。</p>
<p>一个<code>dealloc</code>方法大概像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">   </div><div class="line">    CFRelease(coreFoundationObject);</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意当你使用MRC而不是ARC时，你应该在这些方法后面调用<code>[super dealloc]</code>。ARC会自动在后面调用，这也是一个ARC比MRC安全简单的原因。并且使用MRC，你不得不讲每个需要释放的<code>Objective-C</code>对象添加进来。</p>
<p>即便如此，你不应该在这里释放开销较大或者系统的稀缺资源。例如文件描述符，套接字，大块内存。你不应该依赖<code>dealloc</code>方法去释放这些对象，因为有时候别的东西也会持有这些对象。这样会造成你不需要某个系统稀缺资源，但是却还在持有它，这是不合理的。通常的做法是当程序不再使用它时，实现别的办法进行释放。这样资源的声明周期就是明确的了。</p>
<p>比如一个管理套接字链接的对象，它需要有清理的方法。或许是一个数据库链接。这样类的接口大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCServerConnection : NSObject</div><div class="line"></div><div class="line">- (void)open:(NSString*)address;</div><div class="line">- (void)close;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当需要使用时，可以调用<code>open</code>方法打开链接；当链接结束时，可以调用<code>close</code>方法。<code>close</code>方法一定要在链接对象释放前调用；否则，会被认为是一个项目错误，就像你不得不使用<code>retain</code>和<code>release</code>去平衡引用计数一样。</p>
<p>另一个在别的清理方法释放资源的理由是实际上对象的<code>dealloc</code>方法不一定会被调用。边界情况下，当程序意外退出时，对象可能仍然存在。这些对象没有接收到释放信息。相应的，当系统终止后，它们占用的资源也会返回给系统。所以不调用<code>dealloc</code>方法也是一种优化。这也说明不是每个对象都会调用释放方法的。在Mac OS X和iOS中都有一个应用的协议方法，当程序结束时会调用。这个方法可以被用来清理某些必须要清理的对象。</p>
<p>在Mac OS X中，程序结束会调用的协议方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillTerminate:(NSNotification *)notification;</div></pre></td></tr></table></figure>
<p>在iOS中，程序结束会调用的协议方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillTerminate:(UIApplication *)application;</div></pre></td></tr></table></figure>
<p>如果对象管理着某些资源，那么在<code>dealloc</code>中也应该调用它们的清理方法，以减少意外情况。如果有意外情况发生，那么有一个好办法是，输出一句信息去指明程序发生了一个错误。这是一个编程错误，因为这个关闭方法需要在对象释放前调用；否则，这个方法就不会有效果了。输出信息会警告开发者改正这个问题。在<code>dealloc</code>中去关闭资源依然是一个避免内存泄漏的好习惯。下面有一个这样的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)close &#123;</div><div class="line">    </div><div class="line">    /* clean up resources */</div><div class="line">    _closed = YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    if (!_closed) &#123;</div><div class="line">       </div><div class="line">        NSLog(@&quot;ERROR: close was not called before dealloc!&quot;);</div><div class="line">        [self close];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果关闭方法没有调用，那么相比输出一个错误，你应该去抛出一个异常指出程序发生了一个严重的错误。另外就是要避免在<code>dealloc</code>方法中调用别的对象。在上面的例子中，在<code>dealloc</code>中调用了一个方法。但那是一个特殊情况：去查明程序错误。无论在这里调用什么方法都不太合适，因为这里的对象已经接近尾声了。如果别的方法还会异步执行任务或者调用它们自己的方法，等到对象执行完任务，对象早被释放了。这会导致很多问题并且可能导致程序崩溃，因为它们会回调告诉对象任务执行完了。如果对象早已被释放，那么就会发生错误。</p>
<p>另外，调用释放方法的线程会进行最终释放，使所有对象的引用计数为0。有些方法需要运行在特定的线程，例如主线程。如果在<code>dealloc</code>中调用它们，无法保证它们运行在正确的线程。没有什么常规代码可以保证它们安全的运行在正确的线程，因为对象已经处于释放状态了，并且运行时已经对内部的数据结构进行释放标示了。</p>
<p>也应该避免在<code>dealloc</code>中调用属性存取器，因为它们可以被覆盖并且去执行一些在释放期不安全的操作。比如，某个对象可能通过KVO监听属性，并且监听者想去做一些事情，例如试图保留对象，或使用这个将被回收的对象。这样做会导致在运行期出现一些莫名错误，并可能导致程序崩溃。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dealloc</code>方法里面只应该被用来释放对象以及取消注册，例如KVO或者NSNotificationCenter通知。</li>
<li>如果一个对象持有系统资源，例如文件标示符，那么应该有一个方法去释放资源。当资源使用结束时，类的使用者应该调用关闭方法。</li>
<li>避免在<code>dealloc</code>方法中调用执行异步操作的方法或者只能正常状态执行的方法。</li>
</ul>
<h3 id="小心异常安全代码的内存管理"><a href="#小心异常安全代码的内存管理" class="headerlink" title="小心异常安全代码的内存管理"></a>小心异常安全代码的内存管理</h3><p>现代语言中，异常是一个常见的语言功能。C中不存在异常，但<code>C++</code>和<code>Objective-C</code>中存在异常。实际上，在当前的运行时系统中，<code>C++</code>和<code>Objective-C</code>的异常都是通用的，这意味着一个语言抛出的异常可以被另一个语言捕获。</p>
<p><code>Objective-C</code>的错误模型表示只有发生致命错误时才应该使用异常，你可能仍需要错误代码去捕获并处理异常。比如使用<code>Objective-C++</code>或者不受你控制的第三方库代码时，应该捕获异常。而且，有些系统库仍在使用异常，仿佛回到了异常频繁使用的年代。例如，如果你想去取消一个尚未注册的观察者，那么KVO就会抛出一个异常。</p>
<p>当异常发生时会带来一个内存管理问题。在<code>try</code>块里面，如果保留了一个对象，然后再对象释放前抛出了异常，那么对象将会发生泄漏除非在<code>catch</code>块中进行处理。C++的析构函数由<code>Objective-C</code>的异常处理来运行。这对于C++是非常重要的，因为这会缩短对象的声明周期，所以抛出异常时要调用析构函数；否则，对象内存将会泄露，特别是别的系统资源，例如文件权柄，是更容易泄露的。</p>
<p>异常处理机制会自动销毁对象，不过在MRC环境下处理对象销毁有些麻烦。考虑下面的<code>Objective-C</code>代码，它是在MRC下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">    EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">    [object release];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>乍看起来，它似乎是正确的。但是如果<code>doSomethingThatMayThrow</code>方法抛出异常呢？下面一行的释放代码将不会运行，因为异常会直接跳入<code>catch</code>块。所以当抛出异常时，这个对象将会泄露。这不是一个好主意。使用<code>@finally</code>块可以解决这个问题，不论是否抛出异常，<code>@finally</code>块一定会运行也只会运行一次。例如，代码将会转换成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">EOCSomeClass *object;</div><div class="line">@try &#123;</div><div class="line">    object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div><div class="line">@finally &#123;</div><div class="line">    [object release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对象是在<code>@try</code>块之外声明的，因为需要在<code>@finally</code>块中使用它。如果所有的对象都需要释放那是非常单调的。而且，如果这里的逻辑更加复杂，<code>@try</code>块内状态更多，那么是非常容易忽略释放的，从而导致潜在的泄露风险。如果一个稀缺资源的对象泄露，例如文件标示符或者数据库连接，那么这个泄露就是灾难性的，因为最后应用程序占用的所有的系统资源都不会释放。</p>
<p>在ARC下，这种情况会更加严重。下面是与之等价的ARC环境下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">    EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在问题更严重了；你不能将释放放在<code>@finally</code>的块内了，因为不能调用<code>release</code>了。你可能会认为ARC已经处理了这种情况。默认情况下并没有做；因为这样做需要给对象添加大量模板代码，当有异常抛出时追踪对象清理。当抛出异常时，这段代码会严重影响性能。这段额外的代码也会增加应用程序的大小。总之这不是一个好的建议。</p>
<p>虽然默认状态下未开启，但是ARC支持这种异常安全机制。你可以在编译器中使用<code>-fobjc-arc-exceptions</code>开启。其默认不开启的原因是<code>Objective-C</code>定义异常应该只在该异常会导致应用重大错误时抛出(看第21节)。因此，如果应用程序将要终结，那么潜在的内存泄露就无所谓了。所以在应用程序将要终结时添加安全代码是没有什么意义的。</p>
<p>当编译器处于<code>Objective-C++</code>模式时，会自动打开这个<code>-fobjc-arc-exceptions</code>标示。因为C++的异常处理代码在ARC下与<code>Objective-C</code>的额外异常安全代码类似，所以在ARC下自动开启这些代码对性能影响并不大。而且，C++代码用的太多，<code>Objective-C</code>开发者可能也想使用异常处理。</p>
<p>如果你在MRC下开发并且一定要捕捉异常，那么一定记得正确的清理你的代码。如果你在ARC下开发并且一定要捕捉异常，那么你需要开启<code>-fobjc-arc-exceptions</code>标示符。但最重要的是，如果你发现你使用了大量的异常捕捉，那么考虑使用<code>NSError-style</code>重构代替，如第21节展示的一样。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果捕捉了异常，一定要将在<code>@try</code>块中的代码处理干净。</li>
<li>默认情况下，在异常发生时ARC并不会处理干净代码。你可以通过一个编译器标示符开启它，但这会使得代码包变大和运行时花费变大。</li>
</ul>
<h3 id="使用弱引用避免循环引用"><a href="#使用弱引用避免循环引用" class="headerlink" title="使用弱引用避免循环引用"></a>使用弱引用避免循环引用</h3><p>在对象表中会有一种典型的情况，那就是每个对象都持有对方的引用。当它发生在引用计数模型下时，例如<code>Objective-C</code>的内存管理模型，那么某个地方肯定会发生内存泄露，因为最后没有对象持有循环的对象的引用。因此，没有对象可以访问循环引用，循环引用中的对象也不会被释放，因为它们相互持有保证对方的存活。</p>
<p>在最简单的循环引用中，两个对象互相持有。图5.4展示了一个例子。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.4.png" alt=""><br><strong>Figure 5.4</strong> 两个互相持有强引用的对象构成了循环引用。</p>
<p>循环引用是非常容易理解的并且也可以通过看代码找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCClassA;</div><div class="line">@class EOCClassB;</div><div class="line"></div><div class="line">@interface EOCClassA : NSObject</div><div class="line">@property (nonatomic, strong) EOCClassB *other;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCClassB : NSObject</div><div class="line">@property (nonatomic, strong) EOCClassA *other;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>从代码可以轻易的看出来这个潜在的循环引用；如果将<code>EOCClassA</code>中属性设置为<code>EOCClassB</code>的实例变量，将<code>EOCClassB</code>的属性设置为<code>EOCClassA</code>的实例变量，那么就会发生像图5.4那样的循环引用。</p>
<p>循环引用的结果肯定是内存泄露。当对循环引用中对象的最后一个引用移除时，就会发生内存泄露。这意味着没有对象可以访问它们。在图5.5当<code>ObjectB</code>对象的最后一个引用被移除时，一个涉及四个对象的复杂循环引用就产生了。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.5.png" alt=""><br><strong>Figure 5.5</strong> 当对象表中的循环引用的对象的最后引用被移除，循环引用就会发生内存泄露</p>
<p>在MAC OS X上有个选项可以使用垃圾回收机制，垃圾回收机制会找到循环引用的地方并且清理掉没有任何引用的循环引用。但是垃圾回收机制在MAC OS X 10.8被废弃了，在iOS上更是没存在过。因此，在写代码时，需要注意这个循环引用问题并确保它不会发生。</p>
<p>最好的避免循环引用的办法是使用弱引用。这样引用的一方总是非持有关系。通过<code>unsafe_unretained</code>特质也能达到这个效果。下面的例子中使用了这个特质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCClassA;</div><div class="line">@class EOCClassB;</div><div class="line"></div><div class="line">@interface EOCClassA : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) EOCClassB *other;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCClassB : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, unsafe_unretained) EOCClassA *other;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这里，<code>EOCClassB</code>的<code>other</code>属性不会持有<code>EOCClassA</code>实例变量。这个叫做<code>unsafe_unretained</code>的特质指明属性是不安全的并且不会保留对象。如果设置的对象已经被释放了，那么调用它会导致程序崩溃。因为该属性不会保留对象，所以对象有可能被释放。</p>
<p><code>unsafe_unretained</code>特质与<code>assign</code>特质语义相同。但是，<code>assign</code>通常用在基础类型(int, float, structs, etc.)，<code>unsafe_unretained</code>用于对象类型。这个特质本身就表明对象可能无法安全使用。</p>
<p>不过ARC给<code>Objective-C</code>打来了一项功能那就是可以使用安全的弱引用：一个叫做<code>weak</code>的属性特质，它的作用跟<code>unsafe_unretained</code>相同。但是当对象释放时，它会自动将属性设置为nil。在上面的例子中，可以这样修改<code>EOCClassB</code>的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) EOCClassA *other;</div></pre></td></tr></table></figure>
<p>图5.6展示了<code>unsafe_unretained</code>和<code>weak</code>的不同之处。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.6.png" alt=""><br><strong>Figure 5.6</strong> 当属性指向的对象释放时，<code>unsafe_unretained</code>和<code>weak</code>的不同之处</p>
<p>当使用<code>unsafe_unretained</code>时，<code>EOCClassB</code>的<code>other</code>属性仍然指向一个已经释放的对象；当使用<code>weak</code>时，<code>EOCClassB</code>的<code>other</code>属性将会指向nil。</p>
<p>但是，使用<code>weak</code>特质不应成为你偷懒的借口。在上面的例子中，当<code>EOCClassA</code>的对象释放后，如果<code>EOCClassB</code>属性仍然指向它，那是一个编程错误。如果发生了这种事情，那就是一个bug。你应该确保这种情况不会发生。但是使用<code>weak</code>特质比使用<code>unsafe_unretained</code>特质安全是肯定的。相对比应用崩溃，应用可能更能接受展示错误的数据。这么做无疑对终端用户更好。但是，在所指对象销毁后，仍使用弱引用，那仍是一个bug。例如有一个用户界面，它有一个属性持有数据源对象，用户界面需要展示数据。假如这样一个属性是弱引用。如果数据源在元素展示之前被释放，那么弱引用意味着虽然不会崩溃但用户界面不会显示任何数据。</p>
<p>通常的规则是如果你不持有一个对象，那么就不要保留它。但是有个例外，那就是集合，集合类虽然不直接持有内容，但它要它所属的对象来保留这些元素。有一个例子，对象的引用会指向自己并不拥有的对象，比如委托模式。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>可以通过使用<code>weak</code>避免循环引用。</li>
<li>弱引用可能会也可能不会自动清空。自动清空是由ARC带来的一个在运行期实现的新功能。自动清空的弱引用是安全的，它永远不会引用一个已经释放的对象。</li>
</ul>
<h3 id="使用自动释放池降低高峰内存值"><a href="#使用自动释放池降低高峰内存值" class="headerlink" title="使用自动释放池降低高峰内存值"></a>使用自动释放池降低高峰内存值</h3><p><code>Objective-C</code>对象的存活是受到引用计数(看第29节)控制的。<code>Objective-C</code>的引用计数体系中的一个功能被称作自动释放吃。释放一个对象要么通过调用<code>releas</code>直接减少引用计数，要么通过调用<code>autorelease</code>添加一个自动释放池。一个自动释放池实际上是一个集合对象，它会在将来某个时刻进行释放。当一个自动释放池释放时，自动释放池内所有的对象立即发送<code>release</code>消息。</p>
<p>创建一个自动释放池的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这里没有自动自释放池，当对象发送<code>autorelease</code>消息时，你将会看下类似下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Object 0xabcd0123 of class __NSCFString autoreleased</div><div class="line">with no pool in place - just leaking - break on objc_</div><div class="line">autoreleaseNoPool() to debug</div></pre></td></tr></table></figure>
<p>但是你通常不需要担心这个事。因为一个运行在Mac OS X或者iOS上的应用程序，它们都是处于Cocoa(或者Cocoa Touch)环境。系统都会给你创建一些线程，例如主线程或者GCD机制中的线程，每个线程都会有一个自动释放池，每次事件循环它们都会被清空。因此，你不需要创建自动释放池块。通常，你在应用程序的入口，即<code>main</code>函数那里会看到一个自动释放池包裹了整个应用程序。例如，一个iOS应用的<code>main</code>函数通常是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从技术上讲，这个自动释放池不是必须的。只有在程序中止的时候，整个操作系统才需要释放所有的内存。但是没有它，<code>UIApplicationMain</code>自动释放的对象就没有自动释放池可以放置了，然后会输出一个警告信息。所以这个自动释放池就是最外围用来捕捉自动释放对象的池。</p>
<p>大括号定义了自动释放池的作用范围。在第一个大括号创建自动释放池，在超出作用域后自动释放。因此任何在这个池中的对象都会在最后发送<code>release</code>消息。自动释放池可以嵌套。当一个对象是自动释放时，它会自动添加进最近的自动释放池。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">	NSString *string = [NSString stringWithFormat:@&quot;1 = %i&quot;, 1]; </div><div class="line">	@autoreleasepool &#123;</div><div class="line">		NSNumber *number = [NSNumber numberWithInt:1]; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在前面那个例子中，有两个使用工厂方法创建的对象，它们会自动释放(看第30节)。那个字符串对象将会被加入外层的自动释放池，数值对象将会被加入内层的释放池。嵌套自动释放池可以带来优势，那就是可以控制应用程序的峰值内存不会过高。</p>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; 100000; i++) &#123; </div><div class="line">	[self doSomethingWithInt:i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>doSomethingWithInt:</code>方法创建了很多临时对象，它们将会加入自动释放池。例如，那些对象可能是字符串。即使你不在后面使用它们，这些对象仍旧存活，因为它们在自动释放池内，准备释放并回收。但是自动释放池不到下一次事件循环不会释放。这意味着在这次事件循环中，会有越来越多的对象被创建并加入自动释放池。直到最后，事件循环结束，它才会被释放。但是这样在事件循环期间，应用程序的内存肯定会暴增并在最后释放的时候内存暴减。</p>
<p>这种情况是不好的，特别是如果这个事件循环的长度不固定，取决于用户输入。例如，下面从数据库获取集合对象。代码可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *databaseRecords = /* ... */; </div><div class="line">NSMutableArray *people = [NSMutableArray new]; </div><div class="line">for (NSDictionary *record in databaseRecords) &#123;</div><div class="line">	EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class="line">	[people addObject:person]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>EOCPerson</code>类可能会创建非常多的临时对象，就像刚才那个例子。如果数据库记录是庞大的，那么就会有大量的临时对象一直存活，而它们本应被早收回的。可以在这里增加一个自动释放池帮助提前回收。如果在循环内部包裹一个自动释放池块，那么任何自动释放的对象都是在超出这个池作用域时释放而不是主线程的自动释放池。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *databaseRecords = /* ... */; </div><div class="line">NSMutableArray *people = [NSMutableArray new]; </div><div class="line">for (NSDictionary *record in databaseRecords) &#123;</div><div class="line">	@autoreleasepool &#123; </div><div class="line">		EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; </div><div class="line">		[people addObject:person];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加了新的自动释放池后，应用程序的内存峰值会一直持续在稳定的水平。内存峰值是指应用程序某个时间段内的最大使用内存。添加自动释放池可以降低这个峰值，因为它会在块结束时释放某些对象。这些临时对象就是需要释放的一部分。</p>
<p>可以把自动释放池比喻成栈。当一个自动释放池被创建，它被推入栈；当它释放时，它从栈中弹出。当一个对象是自动释放时，它自动被放入栈顶的自动释放池。</p>
<p>是否添加自动释放池优化取决于你的应用程序。首先监视内存的峰值然后再决定是否需要使用自动释放池。虽然自动释放池消耗不大，但还是有消耗的，所以如果不需要使用，就避免创建自动释放池。</p>
<p>如果你是一个在ARC出现之前的<code>Objective-C</code>程序员，那么你还记得老式的语法，即使用一个叫做<code>NSAutoreleasePool</code>的对象。这是一个特殊对象，它不同于正常对象，它设计出来就是代表自动释放池的，就像新的块语法一样。这个不是每次for循环都会释放的，它是一个稍重的自动释放池，它通常用在偶尔需要释放的内容上，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSArray *databaseRecords = /* ... */; </div><div class="line">NSMutableArray *people = [NSMutableArray new]; </div><div class="line">int i = 0;</div><div class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; </div><div class="line">for (NSDictionary *record in databaseRecords) &#123;</div><div class="line">	EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class="line">	[people addObject:person];</div><div class="line">	// Drain the pool only every 10 cycles</div><div class="line">	if (++i == 10) &#123; </div><div class="line">		[pool drain];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// Also drain at the end in case the loop is not a multiple of 10</div><div class="line">[pool drain];</div></pre></td></tr></table></figure>
<p>不过这种代码风格不再需要了。使用新的语法，ARC带来的更轻量级的自动释放池。所以如果你有代码需要在循环内部释放，你可以使用自动释放池块去包括那部分代码，这样每次循环都会自动创建并清空自动释放池。</p>
<p><code>@autoreleasepool</code>语法还有一个好处就是它有自己的作用域，这样可以帮助你避免使用那些已经被自动释放的对象。例如，考虑下面的代码风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; </div><div class="line">id object = [self createObject];</div><div class="line">[pool drain];</div><div class="line">[self useObject:object];</div></pre></td></tr></table></figure>
<p>这略微夸大了问题，但是它确实存在。<code>useObject:</code>可能会调用一个释放过的对象。但是，相同点在新样式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">	id object = [self createObject];</div><div class="line">&#125;</div><div class="line">[self useObject:object];</div></pre></td></tr></table></figure>
<p>这样的代码是无法通过编译的，因为对象变量在作用域外是无效的，所以<code>useObject:</code>不能使用它。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>自动释放池排在栈中，当对象发送<code>autorelease</code>消息时，自动将他加入栈顶层的自动释放池。</li>
<li>正确的使用自动释放池可以帮助降低应用程序的内存峰值。</li>
<li>现在的自动释放池使用新的<code>@autoreleasepool</code>语法。</li>
</ul>
<h3 id="使用僵尸对象调试内存管理问题"><a href="#使用僵尸对象调试内存管理问题" class="headerlink" title="使用僵尸对象调试内存管理问题"></a>使用僵尸对象调试内存管理问题</h3><p>一直以来，调式内存问题都是麻烦的。向一个已经释放的对象发送消息是不安全的，这点跟我们所想是一样的。但是有时候它会正常工作，有时候它不会。这取决于那块内存是否已经被覆写了。这块内存是否被用来做其它事情呢，又无法确定，所以偶尔会发生崩溃。有时，那块内存仅有一部分被覆写，所以还有部分二进制有效。还有一种可能，就是覆写这块内存区域的是一个有效对象。这时，运行时会把消息传递给新对象，它能或者不能响应这个消息。如果能响应消息，应用不会崩溃，但是你会想为什么收到消息的不是想象中的那个呢？如果它不能响应消息，那么应用依旧会崩溃。</p>
<p>幸运的是，Cocoa的僵尸对象功能可以处理这些情况。当在调试功能打开时，运行时会将所有被销毁实例转换成一个特殊的僵尸对象而不是销毁它们。这种对象的内存不会被回收，因为也就不会被覆写。当僵尸对象收到消息时，它会抛出一个异常，并说明发送消息的对象以及转换僵尸对象前的对象。使用僵尸对象是调式内存管理问题的最佳办法。</p>
<p>这项功能是通过设置<code>NSZombieEnabled</code>环境变量为YES使用的。例如，如果你使用脚本并且在Mac OS X上运行它，你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NSZombieEnabled=&quot;YES&quot; </div><div class="line">./app</div></pre></td></tr></table></figure>
<p>当给僵尸对象发送消息时，将会在控制台输出一条消息，并且应用程序会终止。这条消息看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** -[CFString respondsToSelector:]: message sent to </div><div class="line">deallocated instance 0x7ff9e9c080e0</div></pre></td></tr></table></figure>
<p>你也可以在Xcode中设置这个环境变量，当你从Xcode运行时，它会自动读取。为了这样做，你需要编译应用程序的<code>scheme</code>，选择<code>Run</code>配置，然后点击<code>Diagnostics</code>标签，最后打开<code>Enable Zombie Objects</code>。图5.7展示了Xcode的设置界面，以及打开僵尸对象的选项。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.7.png" alt=""><br><strong>Figure 5.7</strong> 在Xcode的scheme编辑器中打开僵尸对象</p>
<p>那么僵尸对象是如何工作的呢？它实现在<code>Objective-C</code>运行期、<code>Foundation</code>、<code>CoreFoundation</code>框架的底层。当一个对象被释放时，如果这个功能开启了，就会多一步操作。多出来的一步就是将对象转化为一个僵尸对象而不是直接释放。</p>
<p>去看多出来的一步做了什么，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt; </div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line">@end</div><div class="line"></div><div class="line">void PrintClassInfo(id obj) &#123;</div><div class="line"> </div><div class="line">    Class cls = object_getClass(obj);</div><div class="line">    Class superCls = class_getSuperclass(cls);</div><div class="line">    NSLog(@&quot;=== %s : %s ===&quot;, class_getName(cls), class_getName(superCls));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">    </div><div class="line">    EOCClass *obj = [[EOCClass alloc] init];</div><div class="line">    NSLog(@&quot;Before release:&quot;);</div><div class="line">    PrintClassInfo(obj);</div><div class="line">    [obj release];</div><div class="line">    NSLog(@&quot;After release:&quot;);</div><div class="line">    PrintClassInfo(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码使用MRC是的更容易看清对象如何转化为僵尸对象。ARC会使<code>obj</code>对象尽可能的长时间存活，意味着这个简单的例子不会转化为僵尸对象。这意思不是说在ARC下对象不会转化为僵尸对象。使用ARC这个内存bug依然存在，只不过需要更复杂的代码才能表现出来。</p>
<p>上述例子中有一个函数用来输出给定对象的类和父类的名字。代码使用了<code>object_getClass()</code>方法，这是一个运行时函数，而不是给类发送<code>Objective-C</code>消息。如果那个对象是一个僵尸对象，发送任何<code>Objective-C</code>消息都会导致打印错误信息，并使得应用崩溃。上述代码的输出像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Before release:</div><div class="line">=== EOCClass : NSObject === </div><div class="line">After release:</div><div class="line">=== _NSZombie_EOCClass : nil ===</div></pre></td></tr></table></figure>
<p>对象的类从<code>EOCClass</code>变为<code>_NSZombie_EOCClass</code>了。但是这个类从哪里来的呢？代码里面没有定义这个类啊。而且，在启用僵尸对象功能后，编译器给每个类创建一个额外的类那效率也太低了。这个类是在运行时第一个<code>EOCClass</code>对象转变为僵尸对象时生成的。它使用了运行时函数，用来操作类列表。</p>
<p>僵尸类是从一个叫做<code>_NSZombie_</code>的模板类复制的。僵尸类并不做太多的事请，它仅仅是作为一个标记。你将会看到它如何做为一个标记的。首先看下面的伪代码，它展示了如何如何根据需要创建僵尸类并将对象转化为僵尸对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// Obtain the class of the object being deallocated</div><div class="line">Class cls = object_getClass(self); </div><div class="line"></div><div class="line">// Get the class&apos;s name</div><div class="line">const char *clsName = class_getName(cls); </div><div class="line"></div><div class="line">// Prepend _NSZombie_ to the class name</div><div class="line">const char *zombieClsName = &quot;_NSZombie_&quot; + clsName; </div><div class="line"></div><div class="line">// See if the specific zombie class exists</div><div class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</div><div class="line"></div><div class="line">// If the specific zombie class doesn&apos;t exist, </div><div class="line">// then it needs to be created</div><div class="line">if (!zombieCls) &#123;</div><div class="line">	// Obtain the template zombie class called _NSZombie_</div><div class="line">	Class baseZombieCls = objc_lookUpClass(&quot;_NSZombie_&quot;);</div><div class="line">	</div><div class="line">	// Duplicate the base zombie class, where the new class&apos;s </div><div class="line">	// name is the prepended string from above</div><div class="line">	zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0);</div><div class="line">	// Perform normal destruction of the object being deallocated</div><div class="line">&#125;</div><div class="line"></div><div class="line">objc_destructInstance(self);</div><div class="line"></div><div class="line">// Set the class of the object being deallocated </div><div class="line">// to the zombie class</div><div class="line">objc_setClass(self, zombieCls);</div><div class="line">// The class of &apos;self&apos; is now _NSZombie_OriginalClass</div></pre></td></tr></table></figure>
<p>这个过程发生在<code>NSObject</code>对象的<code>dealloc</code>方法中。当<code>NSZombieEnabled</code>环境开启时，运行时会交换(看第13节)<code>dealloc</code>方法的实现和前面的代码实现。在这个过程的最后，对象的类已经变为<code>_NSZombie_OriginalClass</code>类了，其中<code>OriginalClass</code>是它本来类的类名。</p>
<p>重要的是，这个对象的内存并没有被释放。因此，这块内存不会被再次使用。尽管它发生了内存泄露，但它是一个调试工具并且不会将其发布在正式包中，所以不要在意这个。</p>
<p>但是系统为什么会为每一个僵尸对象创建一个新类呢？这样做是因为当给僵尸对象发送消息时，可以确定它原来的类是什么。如果所有对象的类都是<code>_NSZombie_</code>，那么原来类的名字就不知道了。通过运行时的<code>objc_duplicateClass()</code>函数创建一个新类，拷贝整个僵尸类然后给一个新的名字。它的父类，实例变量，方法都跟原来一模一样。另一个方法是通过继承<code>_NSZombie_</code>类创建一个新类而不是拷贝它。但是使用相应函数时，它的效率没有直接拷贝的高。</p>
<p>僵尸类的作用体现在消息转发机制(看第12节)中。<code>_NSZombie_</code>类不实现任何方法。它也不需要任何父类，因此它自身就是一个根类，就像<code>NSObject</code>一样，只有一个叫做isa的实例变量，它是所有<code>Objective-C</code>根类都要有的。这个轻量级的类不实现任何方法，所以所有发送给它的消息都会走完整的消息转发机制。</p>
<p>消息转发机制的核心是<code>___forwarding___</code>，你可能在调式的时候通过栈回溯看到过它。它要做的第一件事就是检查接受消息的类的名字。如果名字前缀是<code>_NSZombie_</code>，那么就肯定它是一个僵尸对象，那么就会特殊处理。应用程序会在这里终止，然后打印一条消息指出接受消息的类的类型。这时就可以看出来在僵尸类命中加入原类名的好处了。将<code>_NSZombie_</code>从僵尸类名中移除就是原来类的名字了。下面的伪代码展示了发生的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Obtain the object&apos;s class</div><div class="line">Class cls = object_getClass(self); </div><div class="line">// Get the class&apos;s name</div><div class="line">const char *clsName = class_getName(cls);</div><div class="line">// Check if the class is prefixed with _NSZombie_</div><div class="line">if (string_has_prefix(clsName, &quot;_NSZombie_&quot;) &#123;</div><div class="line">	 // If so, this object is a zombie</div><div class="line">	// Get the original class name by skipping past the</div><div class="line">	// _NSZombie_, i.e. taking the substring from character 10 </div><div class="line">	const char *originalClsName = substring_from(clsName, 10);</div><div class="line">	// Get the selector name of the message</div><div class="line">	const char *selectorName = sel_getName(_cmd);</div><div class="line">	// Log a message to indicate which selector is</div><div class="line">	// being sent to which zombie</div><div class="line">	Log(&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;, originalClsName, selectorName, self);</div><div class="line">	// Kill the application</div><div class="line">	abort(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尝试给开头的那个例子进行扩展，给将是对象发送消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EOCClass *obj = [[EOCClass alloc] init]; </div><div class="line">NSLog(@&quot;Before release:&quot;); </div><div class="line">PrintClassInfo(obj);</div><div class="line">[obj release]; </div><div class="line">NSLog(@&quot;After release:&quot;); </div><div class="line">PrintClassInfo(obj);</div><div class="line">NSString *desc = [obj description];</div></pre></td></tr></table></figure>
<p>如果僵尸对象开启了，你将会看到下面的输出信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Before release:</div><div class="line">=== EOCClass : NSObject ===</div><div class="line">After release:</div><div class="line">=== _NSZombie_EOCClass : nil ===</div><div class="line">*** -[EOCClass description]: message sent to deallocated instance 0x7fc821c02a00</div></pre></td></tr></table></figure>
<p>如你所见，上面的信息清楚的展示了选择器已经对象的原来类，也指出了已释放的消息接受对象的指针值。如果你在做功能调试，这个信息是非常有用的，如果与合适的工具配合使用，例如Instruments，那会有更好的效果。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>当一个对象释放时，它可以转化为一个僵尸对象而不用释放。这个功能仅能通过<code>NSZombieEnabled</code>环境变量开启。</li>
<li>对象转换为僵尸对象是通过更改它的isa指针值去指向特殊僵尸类。僵尸类可以响应所有发给僵尸对象的消息，然后会打印一条信息，程序终止。</li>
</ul>
<h3 id="避免使用retainCount"><a href="#避免使用retainCount" class="headerlink" title="避免使用retainCount"></a>避免使用retainCount</h3><p><code>Objective-C</code>使用引用技术去管理内存(看第29节)。每个对象都有一个计数器去确定有多少别的事物希望它保持存活。当一个对象呗创建，它的引用计数一样大于0。<code>retain</code>和<code>release</code>会使引用计数增加或减少。当引用计数为0时，对象被释放销毁。</p>
<p><code>NSObject</code>的协议定义了一个方法允许你获取某个对象当前的引用计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)retainCount</div></pre></td></tr></table></figure>
<p>但是，ARC已经废弃了这个方法。实际上，在ARC下，如果你试图调用它，编译器将会抛出一个错误，就像<code>retain、release、autorelease</code>这些方法一样。即使官方已经废弃了它，但还是有人无解它，并且应该避免使用它。如果你不使用ARC，你仍然可以使用它，并且没有编译器错误。所以理解为什么要避免使用这个方法是非常重要的。</p>
<p>这个方法看起来很有用的。因为它返回了引用计数，毕竟这个属性对每个对象都是很重要的。但个问题就在于，引用计数通常与开发者所应关注的没什么关系。即使你只是在调试环境下使用，它也不是有帮助的。</p>
<p>避免使用的主要原因是这个方法返回的值引用计数是在某个时间的值。因为这个值不包含将要减去的引用计数，例如在一个自动释放池中，这个值并不能真的代表引用计数。因此，下面的代码是有问题的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while ([object retainCount]) &#123; </div><div class="line">	[object release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这代码的第一个错误点在于它没有考虑可能有自动释放的情况，只是一直减少引用计数直到释放为止。如果对象处于一个自动释放池，这时自动释放池释放了，那么这个对象也会释放，那么肯定会崩溃了。</p>
<p>其次，这代码是危险的，因为<code>retainCount</code>永远不会返回0；因为有时系统会对对象释放行为进行优化，意思是当它释放时，如果它的引用计数是1，会直接执行销毁。否则，才会减少引用计数并销毁。因此，引用计数永远不会是1。不幸的是，即使这种代码有时能正常运行，那也是运气大于判断。当对象回收后，如果while循环还在运行，那么现代运行时很可能直接让其崩溃。</p>
<p>这样的代码不该使用。这样的代码实现的应该交由内存管理去处理。当你想让某个对象释放时，你应该确保它在该处已经达到引用计数平衡了。如果没有释放，应该查明是否有引用计数未平衡并且查明为什么没释放。</p>
<p>你可能尝试使用<code>retainCount</code>并且疑惑为什么返回值有时候非常巨大。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;Some string&quot;;</div><div class="line">NSLog(@&quot;string retainCount = %lu&quot;, [string retainCount]);</div><div class="line">NSNumber *numberI = @1;</div><div class="line">NSLog(@&quot;numberI retainCount = %lu&quot;, [number retainCount]);</div><div class="line">NSNumber *numberF = @3.141f;</div><div class="line">NSLog(@&quot;numberF retainCount = %lu&quot;, [numberFloat retainCount]);</div></pre></td></tr></table></figure>
<p>在64位Mac OS X 10.8.2，使用Clang 4.1编译，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string retainCount = 18446744073709551615 </div><div class="line">numberI retainCount = 9223372036854775807 </div><div class="line">numberF retainCount = 1</div></pre></td></tr></table></figure>
<p>第一个值是2^64 - 1，第二个值是2^63 - 1。对象的引用计数为什么这么大，因为它们代表了单一对象。如果可以，系统会将字符串实现为单一对象的。如果像本例一样，字符串是一个编译期常量。在这种情况下，编译器会制作一个特殊的对象，代替<code>NSString</code>对象在二进制文件中的位置，并在运行时使用常量代替它。在这种设计下，<code>NSNumber</code>也是类似的对象；指针包含了所有的数字信息。运行时系统会在消息转发时发现这个标签，并对其做相应操作，使其行为和一个真正的<code>NSNumber</code>对象一样。这种优化仅使用这种特定的值，比如例子中的浮点数值就没有做这种优化，它的引用计数就是1。</p>
<p>另外，这种单一对象的引用计数永远不会发生改变。保留和释放都是空操作。即使两个单一对象，它们的引用计数值也不一样，系统借此指出，不要考虑使用引用计数作什么。如果你更改<code>NSNumber</code>对象的引用计数，当它是一个标签指针时，那么代码就会发生错误。</p>
<p>那么，你只想用<code>retainCount</code>去调试呢？即使这样，它也没什么用。这个值可能没你想的那么精确，就像它处于自动释放池中。而且，其他库也可能去释放或者保留对象。如果你检查引用计数，你可能以为自己错了，因为可能有其余库修改了它的引用计数啊。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id object = [self createObject];</div><div class="line">[opaqueObject doSomethingWithObject:object];</div><div class="line">NSLog(@&quot;retainCount = %lu&quot;, [object retainCount]);</div></pre></td></tr></table></figure>
<p>它的引用计数是多少？可以是任何值吧。<code>doSomethingWithObject:</code>方法里面集合可能添加了这个对象，增加引用计数。或者可能多次保留对象并自动释放它，其中的某些自动释放池可能稍后才会清空。所以这引用计数没你想的那样有用。</p>
<p>你什么时候可以使用引用计数？最好的答案是：永远不用，尤其是苹果在引入ARC后已经将其废弃。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul>
<li>引用计数看似有用，实则无用，因为任何时间点，绝对引用计数都无法代表对象的完整生命面貌。</li>
<li>当在ARC环境下时，<code>retainCount</code>方法被废弃，如果使用它还会导致编译器报错。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/19/Protocols and Categories/" rel="next" title="译《Effective Objective-C 2.0》第四章">
                <i class="fa fa-chevron-left"></i> 译《Effective Objective-C 2.0》第四章
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/08/Blocks and Grand Central Dispatch/" rel="prev" title="译《Effective Objective-C 2.0》第六章">
                译《Effective Objective-C 2.0》第六章 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58d6a53e969b167f" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg5OC80NDc1"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="YownYang" />
          <p class="site-author-name" itemprop="name">YownYang</p>
          <p class="site-description motion-element" itemprop="description">匆匆那年 匆匆那天</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yownyang" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://roxyhuang.github.io/" title="NeoHuang" target="_blank">NeoHuang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://kalasearch.cn/" title="kalasearch" target="_blank">kalasearch</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://kalasearch.cn/" title="卡拉搜索" target="_blank">卡拉搜索</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解引用计数"><span class="nav-number">2.</span> <span class="nav-text">理解引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数如何工作"><span class="nav-number">2.1.</span> <span class="nav-text">引用计数如何工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性存取器的内存管理"><span class="nav-number">2.2.</span> <span class="nav-text">属性存取器的内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动释放池"><span class="nav-number">2.3.</span> <span class="nav-text">自动释放池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环引用"><span class="nav-number">2.4.</span> <span class="nav-text">循环引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">2.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC使引用计数更加简单"><span class="nav-number">3.</span> <span class="nav-text">ARC使引用计数更加简单</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ARC中的方法命名规则"><span class="nav-number">3.1.</span> <span class="nav-text">ARC中的方法命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量的内存管理语义"><span class="nav-number">3.2.</span> <span class="nav-text">变量的内存管理语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARC清理实例变量"><span class="nav-number">3.3.</span> <span class="nav-text">ARC清理实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆写内存管理方法"><span class="nav-number">3.4.</span> <span class="nav-text">覆写内存管理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-1"><span class="nav-number">3.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在deaclloc中释放引用并清除监听状态"><span class="nav-number">4.</span> <span class="nav-text">在deaclloc中释放引用并清除监听状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">4.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小心异常安全代码的内存管理"><span class="nav-number">5.</span> <span class="nav-text">小心异常安全代码的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-3"><span class="nav-number">5.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用弱引用避免循环引用"><span class="nav-number">6.</span> <span class="nav-text">使用弱引用避免循环引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-4"><span class="nav-number">6.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用自动释放池降低高峰内存值"><span class="nav-number">7.</span> <span class="nav-text">使用自动释放池降低高峰内存值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-5"><span class="nav-number">7.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用僵尸对象调试内存管理问题"><span class="nav-number">8.</span> <span class="nav-text">使用僵尸对象调试内存管理问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-6"><span class="nav-number">8.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免使用retainCount"><span class="nav-number">9.</span> <span class="nav-text">避免使用retainCount</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-7"><span class="nav-number">9.1.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YownYang</span>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





 
  <script type="text/javascript">
   (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>
 




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
