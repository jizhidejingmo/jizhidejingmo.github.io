<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="YownYang, iOS, Weex, YownYang's blog" />





  <link rel="alternate" href="/atom.xml" title="YownYang's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识">
<meta property="og:type" content="article">
<meta property="og:title" content="译《Effective Objective-C 2.0》第一章">
<meta property="og:url" content="http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/index.html">
<meta property="og:site_name" content="YownYang's blog">
<meta property="og:description" content="这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png">
<meta property="og:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.2.png">
<meta property="og:updated_time" content="2017-05-18T10:13:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="译《Effective Objective-C 2.0》第一章">
<meta name="twitter:description" content="这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识">
<meta name="twitter:image" content="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/"/>





  <title> 译《Effective Objective-C 2.0》第一章 | YownYang's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1261580070&web_id=1261580070" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YownYang's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YownYang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="YownYang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="YownYang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                译《Effective Objective-C 2.0》第一章
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-29T14:48:05+08:00">
                2017-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。</p>
<p>书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。</p>
<h3 id="了解Objective-C的本源"><a href="#了解Objective-C的本源" class="headerlink" title="了解Objective-C的本源"></a>了解Objective-C的本源</h3><p>Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 	Messaging (Objective-C)</div><div class="line">	Object *obj = [Object new];</div><div class="line">	[obj performWith:parameter1 and:parameter2];</div><div class="line">	</div><div class="line">// 	Function calling (C++)</div><div class="line">	Object *obj = new Object;</div><div class="line">	obj-&gt;perform(parameter1, parameter2);</div></pre></td></tr></table></figure>
<p>两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。</p>
<p>Objective-C在运行时做了更多的工作而不是编译时。<code>runtime</code>包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，<code>runtime</code>包含所有内存管理的方法。本质上，<code>runtime</code>是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当<code>runtime</code>更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。</p>
<p>Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure>
<p>这种语法大多来源于C，声明一个叫做<code>someString</code>的变量，类型是<code>NSString *</code>。它的意思是这是一个<code>NSString</code>类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	NSString stackString;</div><div class="line">//	error:interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p><code>someString</code>变量指向某个内存地址，在堆上初始化，包含一个<code>NSString</code>对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div><div class="line">NSString *anotherString = someString;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png" alt=""></p>
<p><strong>Figure 1.1</strong> 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它</p>
<p>这仅有一个<code>NSString</code>实例，但有两个变量指向同它。这两个变量的类型是<code>NSString *</code>，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：<code>NSString</code>实例的内存地址。</p>
<p>图1.1说明了这个结构。<code>NSString</code>实例存储了表示实际字符串所需要的字节。</p>
<p>在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。</p>
<p>Objective-C堆上的内存管理是已经抽象的。你不需要使用<code>malloc</code>和<code>free</code>去初始化和释放对象内存。Objective-C的<code>runtime</code>通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。</p>
<p>有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如<code>CGRect</code>，来源于<code>CoreGraphics</code>框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGRect frame;</div><div class="line">frame.origin.x = 0.0f;</div><div class="line">frame.origin.y = 10.0f;</div><div class="line">frame.size.width = 100.0f;</div><div class="line">frame.siez.height = 150.0f;</div></pre></td></tr></table></figure>
<p><code>CGRect</code>是一个C的结构体，定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGRect &#123;</div><div class="line">	CGRect origin;</div><div class="line">	CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CGRect CGRect;</div></pre></td></tr></table></figure>
<p>这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如<code>CGRect</code>。</p>
<p>在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>Objective-C是C的超集，添加了面向对象的功能。</li>
<li>Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。 </li>
<li>Objective-C是运行时而不是编译时，通过消息决定代码如何运行。</li>
<li>了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。</li>
</ul>
<h3 id="减少在头文件中使用import"><a href="#减少在头文件中使用import" class="headerlink" title="减少在头文件中使用import"></a>减少在头文件中使用import</h3><p>Objective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有<code>.h</code>的是头文件，带有<code>.m</code>的是实现文件。当你创建一个类时，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对所有类来说，导入<code>Foundation.h</code>是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建<code>UIViewController</code>的子类。这些类的头文件将会导入<code>UIKit.h</code>。</p>
<p>目前来讲，这个类的写法是没问题的。它导入了整个<code>Foundation</code>框架，但是并不需要在意。<code>EOCPerson</code>类继承自<code>Foundation</code>框架中的某一个类，它将会使用框架的一大部分功能。继承自<code>UIViewController</code>的类也是一样，它将会使用<code>UIKit</code>框架的一大部分功能。</p>
<p>随着时间的推移，你可能创建了一叫做<code>EOCEmployer</code>的新类。然后你决定一个<code>EOCPerson</code>实例持有一个<code>EOCEmployer</code>实例。所以你提前给它加了一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个问题出现了，当你编译时发现<code>EOCEmployer</code>是缺失的。这个时候编译器一定会提示你在<code>EOCPerson.h</code>中导入<code>EOCEmployer.h</code>。通常你是在<code>EOCPerson.h</code>顶部加入导入的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCEmployer.h&quot;</div></pre></td></tr></table></figure>
<p>这将使他正常编译，但这是一个坏的习惯。因为编译<code>EOCPerson</code>不需要知道<code>EOCEmployer</code>的详细信息。仅需要知道有一个叫做<code>EOCEmployer</code>的类存在即可。幸运的是，有一个办法可以告诉编译器这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@class EOCEmployer;</div></pre></td></tr></table></figure>
<p>这叫做向前声明这个类。这样<code>EOCPerson</code>的头文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCEmployer;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当你为了在实现文件中使用它时，你需要知道<code>EOCEmployer</code>的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line">#import &quot;EOCEmployer.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果<code>EOCEmployer.h</code>是在<code>EOCPerson.h</code>中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。</p>
<p>使用前向声明会缓解两个类互相引用的问题。考虑下当<code>EOCEmployer</code>有两个方法去添加和移除<code>EOCPerson</code>的实例会发生什么，在头文件像这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)addEmployee:(EOCPerson *)person;</div><div class="line">- (void)removeEmployee:(EOCPerson *)person;</div></pre></td></tr></table></figure>
<p>这时，在相反的情况下处于同样的原因，<code>EOCPerson</code>类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用<code>#import</code>而不是<code>#include</code>可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。</p>
<p>有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。</p>
<p>例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCRectangle.h</div><div class="line">#import &quot;EOCShape.h&quot;</div><div class="line">#import &quot;EOCDrawable.h&quot;</div><div class="line"></div><div class="line">@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;</div><div class="line"></div><div class="line">@property (nonatomic, assign) float width;</div><div class="line">@property (nonatomic, assign) float height;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果<code>EOCDrawable</code>协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。</p>
<p>即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即<code>.m</code>中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。</p>
<p>每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。</li>
<li>有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。</li>
</ul>
<h3 id="多使用Literal-Syntax少使用与之等价的方法"><a href="#多使用Literal-Syntax少使用与之等价的方法" class="headerlink" title="多使用Literal Syntax少使用与之等价的方法"></a>多使用Literal Syntax少使用与之等价的方法</h3><hr>
<p>译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。</p>
<hr>
<p>当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用<code>Foundation</code>去书写Objective-C代码，你通常在练习中使用它们。这些类是<code>NSString、NSNumber、NSArray、NSDictionary</code>。它们的数据结构即是它们自身所代表的意思。</p>
<p>众所周知Objective-C拥有冗长的语法。这是真的。然而，自从<code>Objective-C 1.0</code>开始，有一个非常简单的办法去创建一个<code>NSString</code>对象。它被称为<strong>String Literal</strong>并且看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;Effective Objective-C 2.0&quot;;</div></pre></td></tr></table></figure>
<p>这种类型的语法是不存在的，通常创建一个<code>NSString</code>对象是需要调用<code>alloc</code>方法后，调用<code>init</code>方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括<code>NSNumber、NSArray、NSDictionary</code>的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。</p>
<h4 id="Literal-Numbers"><a href="#Literal-Numbers" class="headerlink" title="Literal Numbers"></a>Literal Numbers</h4><p>有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用<code>NSNumber</code>实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</div></pre></td></tr></table></figure>
<p>它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = @1;</div></pre></td></tr></table></figure>
<p>如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有<code>NSNumber</code>实例可以代表的数据类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSNumber *intNumber = @1;</div><div class="line">NSNumber *floatNumber = @2.5f;</div><div class="line">NSNumber *doubleNumber = @3.14159;</div><div class="line">NSNumber *boolNumber = @YES;</div><div class="line">NSNumber *charNumber = @&apos;a&apos;;</div></pre></td></tr></table></figure>
<p>这种Literal Syntax也适用于表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x = 5;</div><div class="line">float y = 6.32f;</div><div class="line">NSNumber *expressionNumber = @(x * y);</div></pre></td></tr></table></figure>
<p>使用Literal Syntax对于数值来说是非常有用的。这样做可以使<code>NSNumber</code>对象更简洁明了，因为声明的大部分是值而不是多余的语法。</p>
<h4 id="Literal-Arrays"><a href="#Literal-Arrays" class="headerlink" title="Literal Arrays"></a>Literal Arrays</h4><p>数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</div></pre></td></tr></table></figure>
<p>使用Literal Syntax之后，仅需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];</div></pre></td></tr></table></figure>
<p>这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用<code>objectAtIndex: method:</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = [animals objectAtIndex:1];</div></pre></td></tr></table></figure>
<p>而使用Literal Syntax，只需要像下面的做法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = animals[1];</div></pre></td></tr></table></figure>
<p>这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。</p>
<p>然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的<a href="https://www.zhihu.com/question/20651624?sort=created" target="_blank" rel="external">语法糖</a>。这个异常看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception </div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;*** </div><div class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to </div><div class="line">insert nil object from objects[0]&apos;</div></pre></td></tr></table></figure>
<p>这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id object1 = /*...*/;</div><div class="line">id object2 = /*...*/;</div><div class="line">id object3 = /*...*/;</div><div class="line">    </div><div class="line">NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];</div><div class="line">NSArray *arrayB = @[object1, object2, object3];</div></pre></td></tr></table></figure>
<p>现在考虑这样一个场景，当<strong>object1</strong>和<strong>object3</strong>指向一个有效的<code>Objective-C</code>对象，但是<strong>object2</strong>是空的。这literal array，<strong>arrayB</strong>，将会抛出一个异常。然而，<strong>arrayA</strong> 仍将会被创建但只包含<strong>object1</strong>对象。原因是<code>arrayWithObjects:</code>方法添加参数，遇到nil终止，这比预想的结束的早。</p>
<p>这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。</p>
<h4 id="Literal-Dictionaries"><a href="#Literal-Dictionaries" class="headerlink" title="Literal Dictionaries"></a>Literal Dictionaries</h4><p>字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是<code>Objective-C</code>代码中常用的。创建一个使用是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:</div><div class="line">		@&quot;Matt&quot;, @&quot;firstName&quot;, </div><div class="line">		@&quot;Galloway&quot;, @&quot;lastName&quot;, </div><div class="line">		[NSNumber numberWithInt:28], @&quot;age&quot;, </div><div class="line">		nil];</div></pre></td></tr></table></figure>
<p>这令人相当困惑，因为这顺序是<strong>object, key, object, key, …</strong>。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = </div><div class="line">	@&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, </div><div class="line">	  @&quot;lastName&quot; : @&quot;Galloway&quot;, </div><div class="line">	  @&quot;age&quot; : @28&#125;;</div></pre></td></tr></table></figure>
<p>这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是<code>Objective-C</code>对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个<code>NSNumber</code>实例中。但是Literal Syntax意味着它只是一个额外的字符。</p>
<p>就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于<code>dictionaryWithObjectsAndKeys:</code>方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。</p>
<p>另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = [personData objectForKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>与之等价的Literal Syntax是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = personData[@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。</p>
<h4 id="Mutable-Arrays-and-Dictionaries"><a href="#Mutable-Arrays-and-Dictionaries" class="headerlink" title="Mutable Arrays and Dictionaries"></a>Mutable Arrays and Dictionaries</h4><p>以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];</div><div class="line">[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>通过Literal Syntax设置时这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutableArray[1] = @&quot;dog&quot;;</div><div class="line">mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;;</div></pre></td></tr></table></figure>
<h4 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h4><p>使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于<code>NSArray、NSNumber、NSDictionary</code>是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用<code>NSString</code>类。</p>
<p>同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，<code>mutableCopy</code>必须被调用，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy];</div></pre></td></tr></table></figure>
<p>它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。</li>
<li>通过下标法访问数组或者字典。</li>
<li>使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。</li>
</ul>
<h3 id="优先使用类型常量，减少使用-define预处理"><a href="#优先使用类型常量，减少使用-define预处理" class="headerlink" title="优先使用类型常量，减少使用#define预处理"></a>优先使用类型常量，减少使用#define预处理</h3><p>在写代码时，你经常想去定义一个常量。例如，一个<code>UIView</code>类出现和消失时它自身的动画。你可能想定义一个常量来代表动画持续的时间。你已经学会了<code>Objective-C</code>和<code>C</code>的基础，所以你决定使用的方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ANIMATION_DURATION 0.3</div></pre></td></tr></table></figure>
<p>这是一个预处理指定；每当在你的代码中出现<code>ANIMATION_DURATION</code>字符，就用0.3替代。这看起来就是你想要的，但是这种定义没有类型信息。它就像是声明了一个叫做“duration”的事物意指它的value与时间有关系，但它并不是明确的。并且，它会将所有<code>ANIMATION_DURATION</code>替换掉，如果它声明在头文件中，别的任何导入了这个头文件的类都将被替代。</p>
<p>为了解决这个问题，你应该使用编译器。有一个比使用预处理更好的办法，去定义一个常量。例如，下面这种定义常量类型为<code>NSTimeInterval</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>注意这种格式，它是有类型信息的，这种用法是好的，因为我们可以清楚地知道常量的定义。它的类型是<code>NSTimeInterval</code>，并且它有助于指出变量的使用。如果你定义了许多常量，它将会帮助以后阅读代码的人。</p>
<p>也会指出这个变量如何命名的。通常的惯例是在常量前面加上小写字母<code>k</code>（加k的原因据说是constant的首字母读音，或者德语一般写作konstant）并将其放置在实现文件中。对于需要暴露给其它类的常量，通常使用其类名作为前缀。第19节展示了更多的命名标准。</p>
<p>在哪里定义常量是重要的。有时，使用预处理定义常量是诱人的，但这是一个坏的习惯，特别是命名方式没有遵循标准的时候，它们不会冲突。例如：<code>ANIMATION_DURATION</code>常量定义在头文件是一个坏的命名。它将显示在所有导入了这个头文件的文件中。甚至作为标准的<code>static const</code>也不该出现在头文件中。自从<code>Objective-C</code>不使用命名空间（namespaces），上面的代码将会声明一个叫做<code>kAnimationDuration</code>的全局变量。它的名字前缀应该使用其所作用的类的名字，例如<code>EOCViewClassAnimationDuration</code>。第19节展示了更多的关于使用清晰命名的方案。</p>
<p>一个不需要暴露给外界的常量，应该在需要使用它的实现文件中定义。例如，如果那个动画持续时间的常量被用在一个<code>UIView</code>的子类，子类在一个iOS应用中，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//EOCAnimatedView.h</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface EOCAnimatedView : UIView</div><div class="line">- (void)animate;</div><div class="line">@end</div><div class="line"></div><div class="line">//EOCAnimatedView.m</div><div class="line">#import &quot;EOCAnimatedView.h&quot;</div><div class="line"></div><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div><div class="line"></div><div class="line">@implementation EOCAnimatedView</div><div class="line">- (void)animate &#123;</div><div class="line">    </div><div class="line">    [UIView animateWithDuration:kAnimationDuration</div><div class="line">                     animations:^()&#123;</div><div class="line">                     	//  Perform animations</div><div class="line">                     &#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用<code>static const</code>声明常量是重要的。使用<code>const</code>修饰符代表如果你试图在之后修改值，编译器将会报错。在这种情况下，这种做法是必需的。这个值不应该被改变。<code>static</code>修饰符的意思是其作用范围在定义它的编译单元内。编译器将其接收到的内容编译成一个目标文件，这个目标文件就是编译单元。在<code>Objective-C</code>中，每一个编译单元就是每一个实现文件。所以在前面的例子中，<code>kAnimationDuration</code>将被声明在<code>EOCAnimatedView.m</code>生成的目标文件中。如果变量没有使用<code>static</code>修饰，编译器将会创建一个外部符号给它。如果另一个编译单元也声明了一个相同名字的变量，将会抛出一个类似的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _ kAnimationDuration in:</div><div class="line">	EOCAnimatedView.o</div><div class="line">	EOCOtherView.o</div></pre></td></tr></table></figure>
<p>实际上，当使用<code>static</code>和<code>const</code>声明一个变量时，编译器最终不会创建一个符号，而是使用存在的值去替代变量，就像宏定义一样。谨记，无论如何，显示类型信息的做法是更好的。</p>
<p>有时，你会想给外部暴漏一个常量。例如，如果你的类使用<code>NSNotificationCenter</code>通知别的类，你可能想这样做。这个功能是一个对象发送通知，另一个对象注册并接收它。通知有一个字符串做名字，并且你可能将其声明为一个外部可见的常量。这样做的意思是可以让任何一个想去注册接收通知的类不需要知道实际的字符名字，而仅使用这个常量。</p>
<p>这种常量需要出现在全局的符号表中，从而可以在声明它之外的编译单元使用。因此，这些常量需要声明在不同与<code>static const</code>示例的地方。这个变量应该像这样被声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// In the header file</div><div class="line">extern NSString *const EOCStringConstant;</div><div class="line"></div><div class="line">// In the implementation file</div><div class="line">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</div></pre></td></tr></table></figure>
<p>这个常量声明在头文件，定义在实现文件。在常量类型中，<code>const</code>修饰符是非常重要的。这些声明是从后向前读的，意思是在这种情况下，<code>EOCStringConstant</code>是一个常量指向一个字符串。这正是我们想要的；常量不允许修改所指向的字符串对象。</p>
<p>当编译器在文件中发现一个<code>extern</code>修饰的常量被使用时，<code>extern</code>关键字会告诉编译器，在导入的类中去寻找。这个关键字告诉编译器在全局符号表中有一个<code>EOCStringConstant</code>的符号。这意味着编译器可以不知道常量的定义而去使用它。编译器简单的知道当文件链接为二进制文件时常量是存在的。</p>
<p>常量必须被定义并且仅定义一次。它通常定义在实现文件，声明在它的头文件。编译器将会为从实现文件生成的目标文件的数据段中的字符串分配存储空间。无论它在哪里被使用，当这个目标文件跟其他文件链接生成最后的二进制时，链接器都将能找到它的全局符号。</p>
<p>实际上，符号出现在全局符号表的意思是你应该小心常量的命名。例如，一个处理登录的类会在登录后对整个应用发送一个通知。这个通知看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// EOCLoginManager.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">extern NSString *const EOCLoginManagerDidLoginNotification;</div><div class="line"></div><div class="line">@interface EOCLoginManager : NSObject</div><div class="line">- (void)login;</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCLoginManager.m</div><div class="line">#import &quot;EOCLoginManager.h&quot;</div><div class="line"></div><div class="line">NSString *const EOCLoginManagerDidLoginNotification =</div><div class="line">	@&quot;EOCLoginManagerDidLoginNotification&quot;;</div><div class="line"></div><div class="line">@implementation EOCLoginManager</div><div class="line"></div><div class="line">- (void)login &#123;</div><div class="line">    // Perfoem login asynchronously, then call &apos;p_didLogin&apos;.</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_didLogin &#123;</div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter]</div><div class="line">      postNotificationName:EOCLoginManagerDidLoginNotification</div><div class="line">      					object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意常量的名字。常量前缀使用类的名字是谨慎的并且可以帮助你去避免冲突。这在整个系统框架中都是常见的。<code>UIKit</code>，例如，将通知名称以相同的办法声明为全局常量。这些名字包括<code>UIApplicationDidEnterBackgroundNotification</code>和<code>UIApplicationWillEnterForegroundNotification</code>.</p>
<p>其它类型的常量同样可以这样做。如果动画持续时间需要暴露在<code>EOCAnimatiedView</code>类之外，在上面的例子中，你可以这样声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//EOCAnimatedView.h</div><div class="line">extern const NSTimeInterval kAnimationDuration;</div><div class="line"></div><div class="line">//EOCAnimatedView.m</div><div class="line">const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>用这种方法定义一个常量是优于使用宏定义的，因为编译器可以确定这个值不能被改变。在<code>EOCAnimatedView.m</code>定义一次，它的值可以在任何地方使用。一个宏定义可以重复定义，意味着一个程序的不同部分可能使用了不同的值。</p>
<p>综上所述，对于常量避免使用宏定义。相反，使用编译器可以观察的常量，如在实现文件中使用<code>static</code>、<code>const</code>声明常量。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>避免宏定义。它们不包含任何类型信息并且可以在编译前被简单的查找替换。它们可以重新定义并且没有警告，使得整个应用的值不一致。</li>
<li>使用<code>static</code>、<code>const</code>在实现文件中定义特定编译单元的常量。这些常量将不会被暴露在全局字符表中，所以它们的名字不需要命名空间。</li>
<li>使用<code>extern</code>在头文件声明它们，在关联的实现文件定义它们。这些常量将出现在全局字符表，所以它们的名字应该需要命名空间，通常使用类名作为前缀是合理的。</li>
</ul>
<h3 id="使用枚举表示状态、选项、状态码"><a href="#使用枚举表示状态、选项、状态码" class="headerlink" title="使用枚举表示状态、选项、状态码"></a>使用枚举表示状态、选项、状态码</h3><p>因为<code>Objective-C</code>是基于<code>C</code>的，<code>C</code>的所有功能<code>Objective-C</code>都是适用的。其中一个就是枚举类型，<code>enum</code>。它在系统框架中被广泛使用，但是常常被开发者忽略。它用于定义命名常量是非常有用的，例如，错误状态码和定义选项是可以组合的。感谢<code>C++11</code>标准支持了它，最近的系统版本包含枚举类型。是的，<code>Objective-C</code>也得益于<code>C++11</code>的标准。</p>
<p>枚举仅仅是命名常量的一种方法。一个简单的枚举集合可以用来表示一个对象的状态。例如，一个socket链接使用枚举表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用一个枚举意味着代码是可读的，因为每一个状态可以通过一个易读的值去代表。在枚举中编译器给每个成员一个唯一的值，从0开始每个成员加1。这种枚举是依靠编译器支持的但需要足够的位数去表示枚举。在前面的枚举中，仅需要1个字节就够了，因为它的最大值是2。</p>
<p>然而定义枚举变量的方式却不太简洁，需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure>
<p>如果每次不用使用<code>enum</code>只使用<code>EOCConnectionState</code>就好了。为了这样做，你添加一个<code>typedef</code>给枚举定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef enum EOCConnectionState EOCConnectionState;</div></pre></td></tr></table></figure>
<p>它的意思是使用<code>EOCConnectionState</code>代替<code>enum EOCConnectionState</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure>
<p><code>C++11</code>标准的问世给枚举带来了一些变化。其中一个变化是可以决定使用哪种“数据类型”去存储枚举类型。这样做的好处是可以使用向前声明了。如果不指定数据类型，枚举类型无法使用向前声明，因为编译器无法知道数据类型的大小。因此，当用到枚举类型时，编译器无法知道应该给变量分配多大的空间。</p>
<p>给枚举指定数据类型，你可以使用下面这种语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger &#123; /*...*/&#125;;</div></pre></td></tr></table></figure>
<p>上面代码的意思是保证枚举的变量类型是<code>NSInteger</code>。如果你乐意，这种类型的向前声明可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger;</div></pre></td></tr></table></figure>
<p>你可以给枚举成员定义一个确切的值，而不是让编译器帮你指定。这语法看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected = 1,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这意思是<code>EOCConnectionStateDisconnected</code>的值为1而不是0.别的成员变量的值同之前一样，依次递增1。例如，<code>EOCConnectionStateConnected</code>的值就是3。</p>
<p>另一种使用枚举类型的情况是去定义选项，特指当选项可以组合在一起时。只要当各选项定义的对，那么就可以使用“按位或运算符”去组合它们。例如，考虑下面的枚举类型，在<code>iOS</code>的<code>UI</code>框架中，用来表示某个视图如何调整大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing &#123;</div><div class="line">    UIViewAutoresizingNone                 = 0,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每一个选项都可以开启或者关闭，使用上面的语法可以控制它因为每个选项都仅有单一的一位值去代表它自身。使用“按位或操作”可以组合多个选项。例如：<code>UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight</code>。图1.2展示了每个枚举成员和组合两个成员后的位布局。</p>
<p>通过“按位与操作”是可以判断出某个选项是否启用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing resizing =  </div><div class="line">    UIViewAutoresizingFlexibleWidth |  </div><div class="line">    UIViewAutoresizingFlexibleHeight;  </div><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;  </div><div class="line">       // UIViewAutoresizingFlexibleWidth is set  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.2.png" alt=""></p>
<p><strong>图1.2</strong>每个选项值的二进制表示形式，以及两个选项值运用“按位或运算”之后的二进制形式。</p>
<p>枚举在系统框架中使用非常广泛。另一个例子是<code>iOS</code>中的<code>UIKit</code>框架中的，用枚举值列举视图所支持的方向并告诉系统。它使用一个叫做<code>UIInterfaceOrientationMask</code>的枚举类型来实现，并且你可以实现一个叫做<code>supportedInterfaceOrientations</code>的方法去告诉系统视图所支持的方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)supportedInterfaceOrientations &#123;  </div><div class="line">  return UIInterfaceOrientationMaskPortrait |  </div><div class="line">         UIInterfaceOrientationMaskLandscapeLeft;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Foundation</code>框架中有一些辅助宏定义，用这些宏定义可以指定枚举值的数据类型。它们提供了向后兼容性，当编译器支持新的语法特性时，它们使用新的语法；当编译器只支持旧语法特性时，它们使用旧的语法特性。这些宏是由<code>#define</code>预处理指令定义的。一个支持像<code>EOCConnectionState</code>这种普通类型的枚举，另一个支持像<code>UIViewAutoresizing</code>这种一系列选项的枚举。你可以像下面这样使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123;  </div><div class="line">    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,  </div><div class="line">    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,  </div><div class="line">    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,  </div><div class="line">    EOCPermittedDirectionRight = 1 &lt;&lt; 3,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些宏的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L&amp;&amp;  </div><div class="line">        (__has_extension(cxx_strong_enums) ||  </div><div class="line">         __has_feature(objc_fixed_enum))  </div><div class="line">    ) ||  </div><div class="line">    (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))  </div><div class="line">    #define NS_ENUM(_type, _name)  </div><div class="line">           enum _name : _type _name; enum _name : _type  </div><div class="line">    #if (__cplusplus)  </div><div class="line">        #define NS_OPTIONS(_type, _name)  </div><div class="line">               type _name; enum : _type  </div><div class="line">    #else  </div><div class="line">        #define NS_OPTIONS(_type, _name)  </div><div class="line">               enum _name : _type _name; enum _name : _type  </div><div class="line">    #endif  </div><div class="line">#else  </div><div class="line">    #define NS_ENUM(_type, _name) _type _name; enum  </div><div class="line">    #define NS_OPTIONS(_type, _name) _type _name; enum  </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>由于要处理不同的情况所以要用多种方式去定义两个宏。第一个判断是检查编译器是否支持新式枚举的特性。这个布尔逻辑看起来相当复杂，但它的意思就是判断编译器是否支持新特性。如果不支持，那么就用老的方式。</p>
<p>如果新特性是可用的，那么<code>NS_ENUM</code>宏所定义的类型展开后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectionState : NSUInteger EOCConnectionState;  </div><div class="line">enum EOCConnectionState : NSUInteger &#123;  </div><div class="line">    EOCConnectionStateDisconnected,  </div><div class="line">    EOCConnectionStateConnecting,  </div><div class="line">    EOCConnectionStateConnected,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>NS_OPTIONS</code>宏的展开是取决于编译形式的。如果以<code>C++</code>形式编译，那么<code>NS_OPTIONS</code>宏展开与<code>NS_ENUM</code>宏展开是不一样的，否则是一样的。为什么？因为<code>C++</code>环境下两个枚举值通过<code>按位或运算</code>结果与非<code>C++</code>环境下是不同的。前面已经提到了，作为选项的枚举值经常会通过<code>按位或运算</code>进行组合。当两个值通过<code>按位或运算</code>后，<code>C++</code>认为它们所代表的值类型是<code>NSUInteger</code>。并且也不允许饮食转换为枚举类型。为了说明这个，我们考虑将<code>EOCPermittedDirection</code>以<code>NS_ENUM</code>形式展开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCPermittedDirection : int EOCPermittedDirection;  </div><div class="line">enum EOCPermittedDirection : int &#123;  </div><div class="line">    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,  </div><div class="line">    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,  </div><div class="line">    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,  </div><div class="line">    EOCPermittedDirectionRight = 1 &lt;&lt; 3,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCPermittedDirection permittedDirections =  </div><div class="line">    EOCPermittedDirectionLeft | EOCPermittedDirectionUp;</div></pre></td></tr></table></figure>
<p>当在<code>C++</code>或者<code>Objective-C++</code>环境下，将会出现下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error: cannot initialize a variable of type  </div><div class="line">&apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos;</div></pre></td></tr></table></figure>
<p>你必须将通过<code>按位或操作</code>的结果显示的转化为<code>EOCPermittedDirection</code>。所以，在<code>C++</code>的环境下应该使用<code>NS_OPTIONS</code>，省去显示转化这一步。因此，如果需要<code>按位或操作</code>的枚举值应当尽量使用<code>NS_OPTIONS</code>，而不需要的，则使用<code>NS_ENUM</code>。</p>
<p>枚举可以用在很多情况下。选项和状态已经在前面讲过了；然后更多的情况同样适用。对错误使用状态码是一个好的习惯。把逻辑含义相似的代码放入一个枚举中，用于替代使用预定义和常量。另一个好的地方是样式。例如，你有一个<code>UI</code>元素可以创建不同的样式，一个枚举集合可以完美的表示每个样式。</p>
<p>最后一点是关于在<code>switch</code>中使用枚举变量。又是，你会这样定义它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;  </div><div class="line">    EOCConnectionStateDisconnected,  </div><div class="line">    EOCConnectionStateConnecting,  </div><div class="line">    EOCConnectionStateConnected,  </div><div class="line">&#125;;  </div><div class="line"> </div><div class="line">switch (_currentState) &#123;  </div><div class="line">    EOCConnectionStateDisconnected:  </div><div class="line">        // Handle disconnected state  </div><div class="line">        break;  </div><div class="line">    EOCConnectionStateConnecting:  </div><div class="line">        // Handle connecting state  </div><div class="line">        break;  </div><div class="line">    EOCConnectionStateConnected:  </div><div class="line">        // Handle connected state  </div><div class="line">        break;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们习惯在<code>switch</code>语句中加上默认分支。然而，当使用枚举值表示状态时，最好不要写一个默认分支。这样做的原因是，当你在稍后添加了一个新的状态，那么编译器将会警告你，提示你有新的状态未加入<code>switch</code>分支。如果有一个默认的分支，编译器将会处理它，那么编译器将不会发出警告。这个问题同样适用于别的使用<code>NS_ENUM</code>的定义中。例如，你定义一个<code>UI</code>元素，你将会希望每个情况都有一个确定的样式。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用枚举来表示状态机的状态，传递给函数的选项，或者错误码，并且起一个易读的名字。</li>
<li>如果把一个传递给方法的选项表示为枚举类型，同时还需要多重操作，可以将它们的值设为2的幂，然后通过<code>按位或操作</code>将其组合起来。</li>
<li>使用<code>NS_ENUM</code>和<code>NS_OPTIONS</code>宏最好给枚举定义一个明确的数据类型。这样做的意思是确定枚举的数据类型是开发者设置的，而不是编译器指定的。</li>
<li>在<code>switch</code>中使用枚举时，不要设置默认分支。这样在你添加新枚举后，编译器会提醒你添加新分支。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/17/BasePrinciple_Img/" rel="next" title="基本内容图解">
                <i class="fa fa-chevron-left"></i> 基本内容图解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/14/Object, Messaging, and the Runtime/" rel="prev" title="译《Effective Objective-C 2.0》第二章">
                译《Effective Objective-C 2.0》第二章 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58d6a53e969b167f" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yNzg5OC80NDc1"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="YownYang" />
          <p class="site-author-name" itemprop="name">YownYang</p>
          <p class="site-description motion-element" itemprop="description">匆匆那年 匆匆那天</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yownyang" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://roxyhuang.github.io/" title="NeoHuang" target="_blank">NeoHuang</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#了解Objective-C的本源"><span class="nav-number">2.</span> <span class="nav-text">了解Objective-C的本源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">2.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减少在头文件中使用import"><span class="nav-number">3.</span> <span class="nav-text">减少在头文件中使用import</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-1"><span class="nav-number">3.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多使用Literal-Syntax少使用与之等价的方法"><span class="nav-number">4.</span> <span class="nav-text">多使用Literal Syntax少使用与之等价的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Literal-Numbers"><span class="nav-number">4.1.</span> <span class="nav-text">Literal Numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Literal-Arrays"><span class="nav-number">4.2.</span> <span class="nav-text">Literal Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Literal-Dictionaries"><span class="nav-number">4.3.</span> <span class="nav-text">Literal Dictionaries</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutable-Arrays-and-Dictionaries"><span class="nav-number">4.4.</span> <span class="nav-text">Mutable Arrays and Dictionaries</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Limitations"><span class="nav-number">4.5.</span> <span class="nav-text">Limitations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">4.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先使用类型常量，减少使用-define预处理"><span class="nav-number">5.</span> <span class="nav-text">优先使用类型常量，减少使用#define预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-3"><span class="nav-number">5.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用枚举表示状态、选项、状态码"><span class="nav-number">6.</span> <span class="nav-text">使用枚举表示状态、选项、状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-4"><span class="nav-number">6.1.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YownYang</span>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





 
  <script type="text/javascript">
   (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>
 




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
