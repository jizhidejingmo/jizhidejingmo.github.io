<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YownYang&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-14T03:07:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YownYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第三章</title>
    <link href="http://yoursite.com/2017/06/08/Interface%20and%20API%20Design/"/>
    <id>http://yoursite.com/2017/06/08/Interface and API Design/</id>
    <published>2017-06-08T07:42:59.000Z</published>
    <updated>2017-06-14T03:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第三章：接口和API设计</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一旦你构建过一个应用程序，那么你可能会想在将来的项目中重用部分代码。你甚至可能想要发布一些代码给他人使用。即使你认为你不会这样做，你也可能在别的地方用到。当你阅读过本节，它将帮你写出合适的接口声明。这意味着你需要理解各种缺陷，才能写出标准模板一样的<code>Objective-C</code>代码。</p>
<p>近年来，随着iOS的问世，带来了大量的开源社区和流行的组件，你经常会在自己的项目里使用别人的代码。相似的，别人也可能会使用你的代码，所以写出清晰的代码可以使别人更快、更容易的整合你的代码。并且谁也不知道，你写下的某个库会不会被成千上万的应用使用呢！</p>
<h3 id="使用前缀名去避免命名空间冲突"><a href="#使用前缀名去避免命名空间冲突" class="headerlink" title="使用前缀名去避免命名空间冲突"></a>使用前缀名去避免命名空间冲突</h3><p>不像别的语言，<code>Objective-C</code>没有命名空间功能。由于这个原因，如果没有采取措施去避免，命名冲突是非常容易出现的。由于符号重复编译错误，命名冲突对应用的影响是可能导致项目无法链接，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _OBJC_METACLASS_$_EOCTheClass in:</div><div class="line">	build/something.o</div><div class="line">	build/something_else.o</div><div class="line">duplicate symbol _OBJC_CLASS_$_EOCTheClass in:</div><div class="line">	build/something.o</div><div class="line">	build/something_else.o</div></pre></td></tr></table></figure>
<p>这个错误结果是因为某个符号在<code>EOCTheClass</code>类和其元类(看第14节)的符号表定义了两次。在应用程序的两部分代码中，同时存在<code>EOCTheClass</code>类的两个实现，那个符号也就自然会定义两次。</p>
<p>更糟糕的是，如果在链接时没有发现某个库包含了一份重复的代码，而是在运行时加载。在这种情况下，动态加载器将会遭遇重复符号错误并且导致应用程序崩溃。</p>
<p>仅有一种办法去避免这个问题就是去使用一个粗糙的命名空间：给所有的名字加上一个确定的前缀。这个前缀应该选择你公司名字或者应用名字或者两者结合。例如，如果你的公司名字叫做Effective Widgets，你可能决定在应用中使用<code>EWS</code>前缀，如果是<code>EWB</code>前缀，仅仅因为你的应用叫做Effective Browser。即使你加上了前缀也不会没有名称冲突，但是会减少发生的次数。</p>
<p>如果你使用<code>Cocoa</code>创建应用程序，需要注意苹果已经表明可能会使用任意两个字母作为前缀，所以在这种情况下，你应该选择三个字母做前缀。例如，如果你不遵守这项约定并使用了<code>TW</code>作为前缀，那么将会产生问题。当<code>iOS 5.0</code>的SDK发布时，它带来了<code>Twitter</code>框架，并且选择<code>TW</code>作为前缀，有一个叫做<code>TWRequest</code>的类用于支持<code>Twitter API</code>的<code>HTTP</code>请求。如果你的公司叫做Tiny Widgets，并且有你自己用的<code>API</code>，那么你很大可能会有一个叫做<code>TWRequest</code>的类。</p>
<p>在你的应用中，前缀不该带有类名但应该适用于所有的类。第25节讲述了如果类别基于存在的类，类别名字和方法名字前缀的重要性。另一个常被忽视的问题是与C函数的冲突或者你在类的实现文件中使用的全局变量。通常很容易忘记全局变量在编译后的目标文件中是作为顶级符号出现的。例如，在<code>iOS SDK</code>中的<code>AudioToolbox</code>框架，它有一个函数用于播放一个声音文件。你可以给它一个回调从而在它结束时调用它。你可能会去写一个类，当声音文件播放结束时，去调用它，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">//  EOCSoundPlayer.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCSoundPlayer;</div><div class="line">@protocol EOCSoundPlayerDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)soundPlayerDidFinish:(EOCSoundPlayer*)player;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCSoundPlayer : NSObject</div><div class="line">@property (nonatomic, weak) id &lt;EOCSoundPlayerDelegate&gt; delegate;</div><div class="line">- (id)initWithURL:(NSURL *)url;</div><div class="line">- (void)playSound;</div><div class="line">@end</div><div class="line"></div><div class="line">//  EOCSoundPlayer.m</div><div class="line">#import &quot;EOCSoundPlayer.h&quot;</div><div class="line">#import &lt;AudioToolbox/AudioToolbox.h&gt;</div><div class="line"></div><div class="line">void completion(SystemSoundID ssID, void *clientData) &#123;</div><div class="line">    </div><div class="line">    EOCSoundPlayer *player = (__bridge EOCSoundPlayer*)clientData;</div><div class="line">    </div><div class="line">    if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) &#123;</div><div class="line">        </div><div class="line">        [player.delegate soundPlayerDidFinish:player];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@implementation EOCSoundPlayer &#123;</div><div class="line">    SystemSoundID _systemSoundID;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL *)url &#123;</div><div class="line">    </div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        </div><div class="line">        AudioServicesCreateSystemSoundID((__bridge CFURLRef)url,</div><div class="line">                                         &amp;_systemSoundID);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    AudioServicesDisposeSystemSoundID(_systemSoundID);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)playSound &#123;</div><div class="line">    </div><div class="line">    AudioServicesAddSystemSoundCompletion(</div><div class="line">                                          _systemSoundID,</div><div class="line">                                          NULL,</div><div class="line">                                          NULL,</div><div class="line">                                          completion,</div><div class="line">                                          (__bridge void*)self);</div><div class="line">    AudioServicesPlaySystemSound(_systemSoundID);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这看起来没什么问题，但是从这个目标文件的符号表中发现了一点不同，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">00000230 t -[EOCSoundPlayer .cxx_destruct]</div><div class="line">0000014c t -[EOCSoundPlayer dealloc]</div><div class="line">000001e0 t -[EOCSoundPlayer delegate]</div><div class="line">0000009c t -[EOCSoundPlayer initWithURL:]</div><div class="line">00000198 t -[EOCSoundPlayer playSound]</div><div class="line">00000208 t -[EOCSoundPlayer setDelegate:]</div><div class="line">00000b88 S _OBJC_CLASS_$_EOCSoundPlayer</div><div class="line">00000bb8 S _OBJC_IVAR_$_EOCSoundPlayer._delegate</div><div class="line">00000bb4 S _OBJC_IVAR_$_EOCSoundPlayer._systemSoundID</div><div class="line">00000b9c S _OBJC_METACLASS_$_EOCSoundPlayer</div><div class="line">00000000 T _completion</div><div class="line">00000bf8 s l_OBJC_$_INSTANCE_METHODS_EOCSoundPlayer</div><div class="line">00000c48 s l_OBJC_$_INSTANCE_VARIABLES_EOCSoundPlayer</div><div class="line">00000c78 s l_OBJC_$_PROP_LIST_EOCSoundPlayer</div><div class="line">00000c88 s l_OBJC_CLASS_RO_$_EOCSoundPlayer</div><div class="line">00000bd0 s l_OBJC_METACLASS_RO_$_EOCSoundPlayer</div></pre></td></tr></table></figure>
<p>注意符号表的中间部分，有一个符号叫做_completion。它是<code>completion</code>函数创建的用于在声音播放结束时做一些事情。即使它是在实现文件实现的，并且没有在头文件声明它，它依然作为顶级符号出现在这里。因此，如果某处创建的函数也叫做<code>completion</code>，那么将会出现一个错误，像下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _completion in: </div><div class="line">	build/EOCSoundPlayer.o </div><div class="line">	build/EOCAnotherClass.o</div></pre></td></tr></table></figure>
<p>更糟糕的是如果你把库给别人用，他们在自己的应用中使用它。如果你暴漏了一个类似<code>_completion</code>的符号，任何使用你这个库的人都可能会创建一个叫做<code>_completion</code>的函数，这是非常不幸的。</p>
<p>所以你应该给它加上类似于C函数的前缀。例如，在之前的例子中，你可以将<code>completion</code>命名为<code>EOCSoundPlayerCompletion</code>。如果符号曾在回溯堆栈时出现，即使出现问题，也是异域排查的。</p>
<p>当你使用第三方库或者将你的代码制作成库给别人使用时，你要特别小心重复符号的问题。当你在你的应用程序中使用了第三方库时，重复符号错误是容易发生的。在这种情况下，通常会使用自己的前缀去给所有的第三方库加上前缀。例如，如果你的库叫做<code>EOCLibrary</code>并且你添加了一个叫做<code>XYZLibrary</code>的库，你将给<code>XYZLibrary</code>添加<code>EOC</code>前缀。然后应用程序使用<code>XYZLibrary</code>时，就没有命名冲突的机会了，如图3.1。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%203.1.png" alt=""></p>
<p><strong>Figure 3.1</strong> 避免第三方库两次编译：一次应用程序本身另一次是库本身</p>
<p>仔细检查并更改所有的名字，看起来是件乏味的事情，但如果你想避免命名冲突，那是很有用的。你可能会问为什么需要这样做，并且为什么应用程序不能简单的包含<code>XYZLibrary</code>库本身并且使用它的实现。这也是可以的，但你考虑下面这个场景，你的应用程序包含另一个第三方库，叫做<code>ABCLibrary</code>，并且它也使用了<code>XYZLibrary</code>。在这种情况下，如果你和<code>ABCLibrary</code>库的作者都没有前缀，那么应用程序仍将发生重复符号的错误。或者你使用<code>XYZLibrary</code>的X版本，但是应用需要的功能是Y版本，那么它将会自动拷贝。如果你在开发的时候使用流行的第三方库，你将经常看到这种类型的前缀。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>选择一个适合的前缀，可以是公司名，应用名，或者都可以。并且一直使用这个前缀。</li>
<li>当你使用的第三方库依赖你自己的库，考虑给它的名字加上你的前缀。</li>
</ul>
<h3 id="提供指定的初始化器"><a href="#提供指定的初始化器" class="headerlink" title="提供指定的初始化器"></a>提供指定的初始化器</h3><p>所有的对象都需要初始化。当你初始化一个对象时，有时你不需要给他任何信息，有时需要。这种情况通常出现在没有信息就不能执行相应的方法的情况。例如，<code>iOS</code>的<code>UIKit</code>框架中的<code>UITableViewCell</code>，组中不同类型的cell需要不同的类型和标示符，这样可以使用cell对象的复用功能，而不需要一直去创建。在初始化时，赋予对象执行任务所需的信息，在术语上称为指定初始化器。</p>
<p>一个类中有多种方法去创建实例，那么这个类可能会有多个初始化方法。这是很好的，但是应该其余方法调用指定的初始化方法。一个例子是<code>NSDate</code>，像下面这样的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id)init- (id)initWithString:(NSString*)string- (id)initWithTimeIntervalSinceNow:(NSTimeInterval)seconds </div><div class="line">- (id)initWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate*)refDate- (id)initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds- (id)initWithTimeIntervalSince1970:(NSTimeInterval)seconds</div></pre></td></tr></table></figure>
<p>上述情况中的指定初始化器是<code>- (id)initWithTimeIntervalSinceReferenceDate:</code>，类中的文档说明了这一点。它的意思是别的初始化方法其实都是调用了这个初始化方法。因此，指定的初始化器是存储内部数据的唯一地方。如果需要改变数据存储，那么仅需要改变这个方法就可以了。</p>
<p>例如，考虑一个代表范围的类。它的接口应该像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCRectangle : NSObject@property (nonatomic, assign, readonly) float width; </div><div class="line">@property (nonatomic, assign, readonly) float height; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意上述属性是只读(看第18节)的。这意味着矩形对象不能在外部修改它的属性。所以你可能创建一个这样的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width </div><div class="line"> 			andHeight:(float)height&#123;	if ((self = [super init])) &#123;		_width = width;		_height = height; </div><div class="line">	&#125;	return self; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果某些调用使用<code>[[EOCRectangle alloc] init]</code>去创建实例呢？这样做是合法的，因为<code>EOCRectangle</code>的父类是<code>NSObject</code>，<code>NSObject</code>实现了一个叫做<code>init</code>的方法，它将所有的对象设置为0(或者是等价于0的数据类型)。如果这个方法被调用，那么<code>EOCRectangle</code>实例的宽和高都将为0。虽然这可能是你想要的，但是你可能更喜欢设置一个默认值，或者通过抛出异常告诉调用者，必须使用你的指定的初始化方法。在<code>EOCRectangle</code>这种情况下，它可能会这样覆盖<code>init</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Using default values- (id)init &#123;	return [self initWithWidth:5.0f andHeight:10.0f];&#125;</div><div class="line">// Throwing an exception- (id)init &#123;	@throw [NSException			  exceptionWithName:NSInternalInconsistencyException </div><div class="line">			  reason:@&quot;Must use initWithWidth:andHeight: instead.&quot;			  userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意设置默认值的版本如何调用初始化方法的。它也可以通过直接设置<code>_width</code>和<code>_height</code>两个实例变量。然而，如果类的存储发生了一些变化。例如，通过一个结构体去存储宽和高的值的集合，你将会需要修改两个方法的逻辑。在这个简单例子中，这还不算坏，但是想象下一个复杂的类有很多初始化方法和复杂的数据。那么将会很容易忘记修改其中的一个，从而导致冲突。</p>
<p>想象下，你现在想去给<code>EOCRectangle</code>创建一个叫做<code>EOCSquare</code>的子类。这种使用场景很常见，但是初始化器该怎么办？很明显，应该强制宽和高相等，因为它是一个正方形！所以你可能决定这样创建初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCRectangle.h&quot;</div><div class="line">@interface EOCSquare : EOCRectangle </div><div class="line">- (id)initWithDimension:(float)dimension; </div><div class="line">@end@implementation EOCSquare</div><div class="line">- (id)initWithDimension:(float)dimension &#123;	return [super initWithWidth:dimension andHeight:dimension];&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>它将变成<code>EOCSquare</code>的初始化器。注意它如何调用父类的指定初始化器。如果你往回看了<code>EOCRectangle</code>的指定初始化器，你将会看到它也调用了父类的指定初始化器。指定初始化器链条是重要的。然而，它仍然可能调用<code>initWithWidth:andHeight:</code>或者<code>init</code>方法去创建对象。你当然不想这样喽，因为有人可能会创建一个宽高不一致的正方形。这是一个重要的点在你子类化某个类时。在子类中如果你有一个不同名字的指定初始化器，你应该总是覆盖指定初始化器。在<code>EOCSquare</code>这种情况下，你可以覆盖<code>EOCRectangle</code>的指定初始化器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123; </div><div class="line">	 float dimension = MAX(width, height);	 return [self initWithDimension:dimension];&#125;</div></pre></td></tr></table></figure>
<p>注意<code>EOCSquare</code>的指定初始化器是如何调用的。在这种实现情况下，如果调用者调用<code>init</code>方法，仍将产生神奇的事情。回想下<code>EOCRectangle</code>类，<code>init</code>方法的实现是去调用自身的指定初始化器，并且设置默认值。它仍然工作，但是因为<code>initWithWidth:andHeight:</code>方法已经被覆盖，所以它会调用<code>EOCSquare</code>的实现，它会依次调用初始化方法。这样一切正常，并不会创建一个宽高不等的正方形。</p>
<p>有时，你并不想去覆盖父类的指定初始化器，因为没有意义。例如，你可能会觉得一个<code>EOCSquare</code>对象使用<code>initWithWidth:andHeight:</code>方法创建很奇怪。你可能会认为它是一个使用错误。这种情况下，通常的做法是覆盖这个方法并且抛出一个异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123; </div><div class="line">	 @throw [NSException			  exceptionWithName:NSInternalInconsistencyException </div><div class="line">			  reason:@&quot;Must use initWithDimension: instead.&quot;			  userInfo:nil];&#125;</div></pre></td></tr></table></figure>
<p>这看起来有点过于严格，但有时是必要的，这样可以保持内部数据的一致性。在<code>EOCRectangle</code>和<code>EOCSquare</code>这种情况下，这意味着如果调用<code>init</code>方法会抛出错误，因为<code>init</code>方法会调用<code>initWithWidth:andHeight:</code>。这时，你可能会去重写<code>init</code>方法，并让其调用<code>initWithDimension:</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)init &#123;	return [self initWithDimension:5.0f];&#125;</div></pre></td></tr></table></figure>
<p>然而，在<code>Objective-C</code>中，抛出异常代表这是一个致命错误(看21节)，如果不能初始化实例，抛出异常应该是最后的选择。</p>
<p>在一些情况下，你可能需要多个指定初始化器。当对象可以以两种不同方式去初始化，那么就需要不止一个指定初始化器了。一个例子是<code>NSCoding</code>的协议，这是一种序列化机制，允许对象进行编码和解码。这种机制在<code>Appkit</code>和<code>UIKit</code>中也是使用广泛的，这两个UI框架分别源于<code>Mac OS X</code>和<code>iOS</code>，并且给对象提供用XML序列化NIB的能力，视图控制器控制解压缩。</p>
<p><code>NSCoding</code>协议定义了序列化时应该实现下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithCoder:(NSCoder*)decoder;</div></pre></td></tr></table></figure>
<p>这种方法通常不是你的主要的指定初始化器，因为它还需要解码器去解码它。例外，如果父类也实现了<code>NSCoding</code>协议，那也需要调用父类的<code>initWithCoder:</code>方法。严格来说，你有两个指定初始化器，因为不止一个初始化方法调用父类的初始化方法。</p>
<p>应用到<code>EOCRectangle</code>类是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject &lt;NSCoding&gt; </div><div class="line">@property (nonatomic, assign, readonly) float width; </div><div class="line">@property (nonatomic, assign, readonly) float height; </div><div class="line">- (id)initWithWidth:(float)width			andHeight:(float)height; </div><div class="line">@end</div><div class="line">@implementation EOCRectangle// Designated initializer- (id)initWithWidth:(float)width </div><div class="line">			andHeight:(float)height&#123;	if ((self = [super init])) &#123;		_width = width;		_height = height; </div><div class="line">	&#125;	return self; </div><div class="line">&#125;</div><div class="line">// Superclass&apos;s designated initializer- (id)init &#123;	return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Initializer from NSCoding- (id)initWithCoder:(NSCoder*)decoder &#123;// Call through to super&apos;s designated initializer </div><div class="line">	if ((self = [super init])) &#123;		_width = [decoder decodeFloatForKey:@&quot;width&quot;];		_height = [decoder decodeFloatForKey:@&quot;height&quot;]; </div><div class="line">	&#125;return self; </div><div class="line">&#125;@end</div></pre></td></tr></table></figure>
<p>注意<code>NSCoding</code>的初始化方法，它调用了父类的初始化而不是它自己的初始化。然而，如果父类也实现了<code>NSCoding</code>，它将调用<code>NSCoding</code>自身的指定初始化器。例如下面的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCRectangle.h&quot;</div><div class="line">@interface EOCSquare : EOCRectangle </div><div class="line">- (id)initWithDimension:(float)dimension; </div><div class="line">@end</div><div class="line">@implementation EOCSquare// Designated initializer- (id)initWithDimension:(float)dimension &#123;	return [super initWithWidth:dimension andHeight:dimension];&#125;// Superclass designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; </div><div class="line">	float dimension = MAX(width, height);	return [self initWithDimension:dimension];&#125;// NSCoding designated initializer- (id)initWithCoder:(NSCoder*)decoder &#123;	if ((self = [super initWithCoder:decoder])) &#123;	// EOCSquare&apos;s specific initializer</div><div class="line">	&#125;	return self; </div><div class="line">&#125;@end</div></pre></td></tr></table></figure>
<p>所有的初始化方法都调用到父类的实现，即<code>initWithCoder:</code>。子类在初始化的任何事情之前调用它，先完成父类的初始化。这样，<code>EOCSquare</code>也可以完全兼容<code>NSCoding</code>协议。如果你是调用你自己的初始化方法或者别的父类的初始化方法，对于<code>EOCSquare</code>的实例来说，<code>EOCRectangle</code>的<code>initWithCoder:</code>方法永远不会被调用，并且宽高两个实例变量永远不会被解码。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在你的类中指定初始化器，并且用文档标明它。所有的别的初始化器都应该调用它。</li>
<li>如果子类的初始化器不同于父类的初始化器，确保你覆写了父类的初始化器。</li>
<li>当子类覆写了父类的初始化器，不应该抛出异常。</li>
</ul>
<h3 id="实现description方法"><a href="#实现description方法" class="headerlink" title="实现description方法"></a>实现description方法</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第三章：接口和API设计&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第二章</title>
    <link href="http://yoursite.com/2017/05/14/Object,%20Messaging,%20and%20the%20Runtime/"/>
    <id>http://yoursite.com/2017/05/14/Object, Messaging, and the Runtime/</id>
    <published>2017-05-14T06:57:56.000Z</published>
    <updated>2017-06-09T03:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<code>Objective-C</code>等面向对象的语言中，对象就是基石，提供数据存储和传递的功能。消息是在过程中对象之间进行数据传递和执行操作。深入理解这些功能如何工作对于构建高效和可维护代码是至关重要的。</p>
<p>当程序运行后，<code>Objective-C</code>中的<code>runtime</code>为其提供相关支持。<code>runtime</code>提供了关键的函数使对象之间可以传递消息以及创建类实例的所有逻辑。理解这一切如何工作会使你成为一个更好的开发者。</p>
<h3 id="理解属性"><a href="#理解属性" class="headerlink" title="理解属性"></a>理解属性</h3><p>属性是<code>Objective-C</code>的一个功能，用于对象对数据的封装。<code>Objective-C</code>对象通常会把它们所需要的数据保存为各种实例变量。实例变量的访问通常通过存取方法。<code>getter</code>方法用来读取变量，<code>setter</code>方法用来设置变量。这个概念是标准的，并且通过属性这个功能成为了<code>Objective-C 2.0</code>的一部分，这让开发者令编译器去自动生成读写方法。这个功能引入了一个新语法即点语法，通过点语法访问数据存储可以减少代码的冗长。你可能已经使用了属性，但你可能不知道它所有的功能。而且，还有很多与之相关的问题。第6节主要说明哪些问题可以通过属性解决并且指出主要的功能。</p>
<p>用一个类去表示一个人的信息可能要存储名字，出生日期，地址等等。你可能这样在一个类的公共接口中声明这些变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCPerson : NSObject &#123;</div><div class="line">    </div><div class="line">@public</div><div class="line">    NSString *_firstName;</div><div class="line">    NSString *_lastName;</div><div class="line">@private</div><div class="line">    NSString *_someInternalData;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你从事过<code>Java</code>或者<code>C++</code>开发，这种写法是熟悉的，你可以定义变量的作用域。然而，这种技术在<code>Objective-C</code>中很少使用。这种方法的问题是在编译时就定义了对象的布局。无论任何时候访问<code>_firstName</code>变量，都会通过编译器偏移硬编码去访问存储对象的内存空间。如果你不在<code>_firstName</code>之前添加任何变量这样做都是没问题的。例如：假设在<code>_firstName</code>之前添加一个变量：</p>
<hr>
<p>译者言：由于对象布局在编译时已定，对象内存偏移量自然固定，此处硬编码代指偏移量。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject &#123;</div><div class="line">    </div><div class="line">@public</div><div class="line">    NSDate *_dateOfBirth;</div><div class="line">    NSString *_firstName;</div><div class="line">    NSString *_lastName;</div><div class="line">@private</div><div class="line">    NSString *_someInternalData;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>之前的偏移量代表<code>_firstName</code>而现在代表<code>_dateOfBirth</code>了。任何通过硬编码读取的地方都将读取到一个错误的值。为了说明这一点，假设指针是4个字节，图2.1分别展示了添加<code>_dateOfBirth</code>变量之前和之后的类的内存布局。<br><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.1.png" alt=""></p>
<p><strong>Figure 2.1</strong> 添加变量前类的布局和添加变量后类的布局</p>
<p>当类定义发生变化时，如果代码使用了编译时的偏移量那么将出现问题，除非重新编译。例如，一个代码库中的代码使用了旧的类定义。如果链接的代码使用了新的类定义，那么在运行时将出现不兼容的情况。为了解决这个问题，各种语言都提出了自己的解决办法。<code>Objective-C</code>的做法是，将实例变量看做特殊的变量，由类变量(第14节详细的讲述了类对象)去存储它的偏移量。在运行时，会去查找偏移量，当类定义发生改变，偏移量也随之改变。这样无论如何访问一个变量，都会使用正确的偏移量。你甚至可以在运行期间给类添加实例变量。这就是稳固的<code>ABI</code>(应用程序二进制接口)。<code>ABI</code>定义了许多内容，其中一项是生成代码时的规则。稳固的<code>ABI</code>也意味着你可以在一个分类中或者实现文件中定义实例变量。因此，你不需要在接口文件中声明所有的实例变量，因此你不需要在公共接口中泄露任何你的内部实现信息。</p>
<p>另一种解决这个问题的办法是使用存取方法而不是直接访问实例变量。虽然属性最终仍是由实例变量实现的，但是属性提供了一种简洁的抽象。你可以自己编写存取方法，但是在标准的<code>Objective-C</code>代码格式中，存取方法遵循严格的命名规则。因为严格的命名，<code>Objective-C</code>才能根据变量名自动创建存取方法。这就是<code>@property</code>语法的来源。</p>
<p>在对象接口的定义中使用<code>@property</code>，这是一种标准的写法，以提供对象的存取方法。因此，可以把属性当做一种简称，通过它去访问一个给定类型和给定名字的变量。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject</div><div class="line">@property NSString *firstName;</div><div class="line">@property NSString *lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对于类的使用者，上面的代码是等价于下面的代码的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject</div><div class="line">- (NSString *)firstName;</div><div class="line">- (void)setFirstName:(NSString *)firstName;</div><div class="line">- (NSString *)lastName;</div><div class="line">- (void)setLastName:(NSString *)lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用属性，你可以使用点语法。在<code>C</code>中你访问栈结构体的成员也是使用类似语法。编译器会将点语法转化为存取方法，与你直接调用是一样的。因此，使用点语法和直接调用时没有任何差异的。下面展示了等价的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EOCPerson *aPerson = [EOCPerson new];</div><div class="line">    </div><div class="line">aPerson.firstName = @&quot;Bob&quot;; // Same as;</div><div class="line">[aPerson setFirstName:@&quot;Bob&quot;];</div><div class="line">    </div><div class="line">NSString *lastName = aPerson.lastName; // Same as;</div><div class="line">NSString *lastName = [aPerson lastName];</div></pre></td></tr></table></figure>
<p>属性的好处还不止这些。如果你使用它，编译器将会通过一个叫做自动合成的功能生成那些方法代码。需要强调的是，编译器会在编译时自动生成代码，所以你在编辑器中是看不到自动合成的方法的。除了自动生成上述代码，编译器也会自动生成一个合适类型的变量，并且会在名字前面加下划线。在前面的代码中，他自动生成了两个变量：<code>_firstName</code>和<code>_lastName</code>。通过在类实现中使用<code>@synthesize</code>语法，这两个实例变量名字是可以控制的，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementation EOCPerson</div><div class="line">@synthesize firstName = _myFirstName;</div><div class="line">@synthesize lastName = _myLastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用上面的语法会产生两个实例变量，分别叫做<code>_myFirstName</code>和<code>_myLastName</code>，用于代替默认生成的。不过一般不会去改变默认的变量名；然而如果你不喜欢使用下划线去命名变量，你可以使用这个方法去设置你想要的。但是我建议你使用默认的命名规则，如果每个人都遵循这个规则，那么每个人读代码都是容易理解的。</p>
<p>如果你不想编译器给你自动生成存取方法，你可以自己去实现这些方法。然而，如果你仅实现了存取方法中的一个，那么编译器仍会自动生成另一个方法。另一种阻止它自动生成的办法是使用<code>@dynamic</code>关键字，这会告诉编译器不要自动生成实例变量返回给属性并且不会自动生成存取方法。而且，当编译代码访问这个属性时，编译器将会忽略实际上存取方法还没有定义的情况，并且相信它在运行时是可以使用的。例如，如果一个类继承自<code>NSManagedObject</code>类，它的存取方法需要在运行时动态创建。<code>NSManagedObject</code>类之所以这样做是因为子类的属性不是实例变量。它的数据来源于后台数据库。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSManagedObject</div><div class="line">@property NSString *firstName;</div><div class="line">@property NSString *lastName;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">@dynamic firstName, lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个类中，编译器不会自动生成存取方法或者实例变量。如果你尝试去访问某个属性，编译器也没有警告信息。</p>
<h4 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h4><p>属性的另一个问题是你应该知道它所有的特质。你可以通过它去影响编译器生成的存取方法。例如下面这个属性使用了三个特质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readwrite, copy) NSString *firstName;</div></pre></td></tr></table></figure>
<p>属性可以使用4类特质。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>通常，生成的存取方法包含锁去保持原子性。如果你设置了<code>nonatomic</code>特质，那么就不会有锁了。请注意，尽管没有<code>atomic</code>特质(<code>atomic</code>特质是由你不设置<code>nonatomic</code>特质得来的)，但是你仍何以在属性特质中写上，并且编译器不会报错。如果你自己实现存取方法，你应该指定与其相符的原子性。</p>
<h4 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h4><ul>
<li><strong>readwrite</strong> 读写权限时，<code>getter</code>和<code>setter</code>方法都是可用的。如果属性是自动合成的，那么编译器将会自动生成两个方法。</li>
<li><strong>readonly</strong> 只读权限时，只有<code>getter</code>方法是可用的，如果属性是自动合成的，那么编译器将只生成<code>getter</code>方法。当你想暴漏一个只读属性给外部，并且需要在内部重新定义它为可读写时，你可以使用它。第27节讲了更多内容。</li>
</ul>
<h4 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h4><p>属性用于封装数据，数据需要有具体的所有权。它仅仅影响setter方法。例如，用<code>setter</code>方法设置一个值时，它是应该保持新值还是将其直接赋给底层实例变量?当编译器自动生成存取方法时，它要取决于这些特质去生成代码。如果你自己实现存取方法，你应该指定与其相符的特质。</p>
<ul>
<li><strong>assign</strong> 它的<code>setter</code>方法只会简单的给标量类型的值赋值，例如<code>CGFloat</code>或者<code>NSInteger</code>。</li>
<li><strong>strong</strong> 这种特质表示定义了一个拥有关系。当为这个属性赋值时，首先持有新值，接着释放旧值，然后将新值赋给这个属性。</li>
<li><strong>weak</strong> 这种特质表示定义了一个非拥有关系。当为这个属性赋值时，它是不持有新值的；也不释放旧值。它是类似于<code>assign</code>特质的，但当目标对象释放时，它的值会被自动置为nil。</li>
<li><strong>unsafe_unretained</strong> 它同<code>assign</code>语义相似，但是它适用于对象类型，它表达了一个非拥有关系，当目标对象销毁时，它不会自动置为nil，这点与<code>weak</code>是有区别的。</li>
<li><strong>copy</strong> 这种特质类似<code>strong</code>特质，定义一个拥有关系；然而，它是用拷贝替代持有新值的。当属性是类似与<code>NSString *</code>时，经常用此特质保证其封装性，因为可能通过<code>setter</code>方法给予其一个可变值。如果赋的值是可变的，那么这个属性的类型可能就在对象不知道的情况下改变。所以就需要使用<code>copy</code>特质去使对象中的字符串不会在无意中被改变。任何需要保持不可变的对象都应该使用<code>copy</code>去修饰。</li>
</ul>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>通过使用下面的特质可以控制存取方法的名字：</p>
<ul>
<li><p><strong>getter=<name></name></strong> 指定<code>getter</code>的名字。当你想给一个<code>Boolean</code>属性加上is前缀时，通常使用这个方法。例如，在<code>UISwitch</code>类中，表示状态开关的属性就是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,getter=isOn) BOOL on;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>setter=<name></name></strong> 指定<code>setter</code>的名字。这个方法不常用的。</p>
</li>
</ul>
<p>你可以通过这些特质细微的控制自动生成的存取方法。然而，需要谨记的是，如果你实现了自己的存取方法，你应该遵循指定的特质。例如，一个属性使用了<code>copy</code>特质，你需要在<code>setter</code>中拷贝它。否则，会误导属性的使用者。而且，如果不遵守这个约定，那么将会产生bug。</p>
<p>即使你可以通过别的方法设置属性，你也要遵循定义时的特质。例如，考虑扩充下<code>EOCPerson</code>类。属性声明时，使用了<code>copy</code>特质，因为它可能是可变的。这个类也增加了一个初始化方法，用于设置名和姓的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSManagedObject</div><div class="line"></div><div class="line">@property (copy) NSString *firstName;</div><div class="line">@property (copy) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString *)firstName</div><div class="line">               lastName:(NSString *)lastName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在实现自定义初始化方法时，遵循定义时的<code>copy</code>语义是非常重要的。因为属性定义就像类和对象之间的协议一样。所以初始化的代码应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</div><div class="line">    </div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        </div><div class="line">        _firstName = [firstName copy];</div><div class="line">        _lastName = [lastName copy];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会问为什么不简单的使用属性的<code>setter</code>方式去设置，如果总是使用<code>setter</code>设置，那将会保证属性的正确设置。你永远不该在<code>init</code>方法中使用存取方法，具体请看第7节。</p>
<p>如果你已经读了第18节，你应该知道，最好使对象不可变。将上述内容应用在<code>EOCPerson</code>类中，你需要设置两个属性为<code>readonly</code>。在初始化中设置它们的值，然后它们将不能被修改。在本例中，对你使用的值使用内存管理语义是重要的。所以属性定义的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (copy, readonly) NSString *firstName;</div><div class="line">@property (copy, readonly) NSString *lastName;</div></pre></td></tr></table></figure>
<p>因为是只读属性，所以编译器不会为其自动生成<code>setter</code>方法。这样做是重要的，可以表明在初始化时设置了这两个属性值。没有这样的声明，使用这个类的人就可能不知道已经在<code>init</code>方法中使用了<code>copy</code>，因此他们可能会在调用初始化方法之前自行拷贝。这种操作是多余且低效的。</p>
<p>如果你想知道<code>atomic</code>和<code>nonatomic</code>的区别。前面说过，使用了<code>atomic</code>的属性的存取方法会自动加锁确保原子性。这个意思是如果两个线程同时对属性进行读写操作，这个值不论在任何时候始终是有效的。如果不加所得情况下，当一个线程正在进行修改时，另一个线程进行读取，可能会将其未修改完的值读出来。如果发生了这种情况，读到的值可能是无效的。</p>
<p>如果你是在iOS中开发，那么你会注意到所有属性声明为<code>nonatomic</code>。这样做的历史原因是，加锁消耗比较大，可能会产生性能问题。通常，原子性并不是必须的，因为它不能确保线程安全，需要更深层次的锁定机制才能保证其线程安全。例如，即使使用了原子性，一个线程在连续读取某个属性值时，另一个线程修改了这个属性，仍将不能确保读到的是正确的值。因此，在iOS开发中你将一直使用<code>nonatomic</code>去修饰属性。但是在Mac OS X中，你不需要担心<code>atomic</code>带来的性能问题。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>@property</code>语法提供了一种对象封装数据的定义。</li>
<li>使用正确的特质提供数据存储。</li>
<li>在设置属性所对应的实例变量时，需要遵循该属性的语义。</li>
<li>在iOS中使用<code>nonatomic</code>，因为它会严重消耗性能。</li>
</ul>
<h3 id="在对象内部直接访问实例变量"><a href="#在对象内部直接访问实例变量" class="headerlink" title="在对象内部直接访问实例变量"></a>在对象内部直接访问实例变量</h3><p>属性总是用于访问外部对象的实例变量，但是在<code>Objective-C</code>社区中如何访问内部变量却是争执不休的。有些建议仍使用属性去访问实例变量，有些建议直接访问实例变量，有些两者混用。作者强烈推荐在读取实例变量时直接访问而在设置值时使用属性访问。</p>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject  </div><div class="line">@property (nonatomic, copy) NSString *firstName;  </div><div class="line">@property (nonatomic, copy) NSString *lastName;  </div><div class="line"> </div><div class="line">// Convenience for firstName + &quot; &quot; + lastName:  </div><div class="line">- (NSString*)fullName;  </div><div class="line">- (void)setFullName:(NSString*)fullName;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这两个便捷方法<code>fullName</code>和<code>setFullName</code>可能是这样实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (NSString*)fullName &#123;  </div><div class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,  </div><div class="line">            self.firstName, self.lastName];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">/** The following assumes all full names have exactly 2  </div><div class="line"> *  parts. The method could be rewritten to support more  </div><div class="line"> *  exotic names.  </div><div class="line"> */  </div><div class="line">- (void)setFullName:(NSString*)fullName &#123;  </div><div class="line">    NSArray *components =  </div><div class="line">        [fullName componentsSeparatedByString:@&quot; &quot;];  </div><div class="line">    self.firstName = [components objectAtIndex:0];  </div><div class="line">    self.lastName = [components objectAtIndex:1];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>setter</code>和<code>getter</code>中，我们使用点语法访问实例变量。假设现在重写<code>setter</code>和<code>getter</code>方法直接访问变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (NSString*)fullName &#123;  </div><div class="line">    return [NSStringstringWithFormat:@&quot;%@ %@&quot;,  </div><div class="line">            _firstName, _lastName];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (void)setFullName:(NSString*)fullName &#123;  </div><div class="line">    NSArray *components =  </div><div class="line">        [fullName componentsSeparatedByString:@&quot; &quot;];  </div><div class="line">    _firstName = [components objectAtIndex:0];  </div><div class="line">    _lastName = [components objectAtIndex:1];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两种方式是有些许差异的：</p>
<ul>
<li>毫无疑问直接访问实例变量是更快的，因为它不需要通过<code>Objective-C</code>方法派发(看第11节)。编译器通过代码直接访问存储对象实例的内存空间。</li>
<li>直接调用实例变量会绕过<code>setter</code>的内存管理语义。例如，你的属性声明了<code>copy</code>特质，直接调用实例变量不会发生<code>copy</code>事件。新的值将会被保存，旧的值将会被释放。</li>
<li>当直接访问实例变量时，KVO不会被触发。这可能会是一个问题，不过这主要取决你对这个对象的行为。</li>
<li>通过属性访问可以更轻易的定位到与这个属性有关的问题，因为你可以给<code>setter</code>、<code>getter</code>方法添加断点去看谁在什么时候访问了这个属性。</li>
</ul>
<p>一个好的折中的办法是在写时通过<code>setter</code>方法设置，读时直接调用实例变量。这样做可以在读时有更高的效率，在写时也不会失去控制。最重要的是通过<code>setter</code>方法去写将保证你遵循内存管理语义。然而，这样做会有一些小的问题。</p>
<p>第一个问题是当你的值是在初始化方法中设置的时候。这里，你应该一直使用直接调用实例变量的方法，因为子类可能重写了它的<code>setter</code>方法。考虑下<code>EOCPerson</code>有一个叫做<code>EOCSmithPerson</code>的子类，这个类是专门用于表示名字叫<code>smith</code>的。这个子类可能会覆盖<code>lastName</code>的<code>setter</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setLastName:(NSString*)lastName &#123;  </div><div class="line">    if (![lastName isEqualToString:@&quot;Smith&quot;]) &#123;  </div><div class="line">        [NSException raise:NSInvalidArgumentException  </div><div class="line">                    format:@&quot;Last name must be Smith&quot;];  </div><div class="line">    &#125;  </div><div class="line">    self.lastName = lastname;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>EOCPerson</code>基类可能在初始化时将名字设为空字符。如果它通过<code>setter</code>方法去这样设置，那么子类的<code>setter</code>将会被调用并且会抛出一个异常。然而，在有一些情况中，你必须在初始化时使用<code>setter</code>方法。当实例变量是声明在一个父类中的时候；你不能通过直接调用实例变量时，那么你必须使用<code>setter</code>方法。</p>
<p>另一个问题是当属性使用懒加载时。在这种情况下，你必须通过<code>getter</code>访问；如果没有，那个实例变量将永远不会初始化。例如，<code>EOCPerson</code>类可能有一个属性通过一个复杂对象去代表人脑。如果这个属性很少用并且初始化成本较高的，你可能在<code>getter</code>中使用懒加载，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (EOCBrain*)brain &#123;  </div><div class="line">    if (!_brain) &#123;  </div><div class="line">        _brain = [Brain new];  </div><div class="line">    &#125;  </div><div class="line">    return _brain;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你直接调用实例变量且没有调用过<code>getter</code>方法，大脑这个属性永远不会创建，所以你需要通过属性的存取方法去访问它。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在内部使用数据时，通过直接调用实例变量来读，通过调用属性来写。</li>
<li>在初始化和销毁中，不论读还是写都通过实例变量直接访问。</li>
<li>当你使用了懒加载时，你需要使用属性去读。</li>
</ul>
<h3 id="理解对象的等同性"><a href="#理解对象的等同性" class="headerlink" title="理解对象的等同性"></a>理解对象的等同性</h3><p>比较对象相等是非常有用的。然而，使用等于操作符去判断相等通常不是你想做的，因为这样做比较的是它们的指针本身，而不是指针指向的对象。相应的，你应该使用声明在<code>NSObject</code>协议中的<code>isEqual:</code>方法去检验两个对象是否相等。通常情况下，两个不同类的对象总是不相等的。如果你已经知道你要检查的两个对象是同一个类，那么你可以使用它们自己提供的相同性检测方法。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *foo = @&quot;Badger 123&quot;;  </div><div class="line">NSString *bar = [NSString stringWithFormat:@&quot;Badger %i&quot;, 123];  </div><div class="line">BOOL equalA = (foo == bar); //&lt; equalAequalA = NO </div><div class="line">BOOL equalB = [foo isEqual:bar]; //&lt; equalBequalB = YES </div><div class="line">BOOL equalC = [foo isEqualToString:bar]; //&lt; equalCequalC = YES</div></pre></td></tr></table></figure>
<p>你可以看到等号操作符与使用等价方法的不同。<code>NSString</code>是一个自己实现了等价比较方法的类，方法名叫做<code>isEqualToString:</code>。使用这个方法的对象一定是一个<code>NSString</code>对象；否则，比较结果就会返回undefined。使用这个方法是比使用<code>isEqual:</code>更快的，它需要别的步骤，因为它不知道比较的对象是什么类型的。</p>
<p>这两个方法的核心等价判断是<code>NSObject</code>的协议方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object;</div><div class="line">- (NSUInteger)hash;</div></pre></td></tr></table></figure>
<p>这两个<code>NSObject</code>类的方法的默认实现是只有两个对象指向相同的地址时才相等。为了在自定义对象中覆写这些方法，你必须去了解它们的原理。任意两个对象使用<code>isEqual:</code>方法比对结果是相等，那么它们的<code>hash</code>方法也一定会返回相同的值。然而，两个对象的<code>hash</code>方法返回相同的值，它们<code>isEqual:</code>方法的比对结果不一定相等。</p>
<p>例如，考虑下面的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject  </div><div class="line">@property (nonatomic, copy) NSString *firstName;  </div><div class="line">@property (nonatomic, copy) NSString *lastName;  </div><div class="line">@property (nonatomic, assign) NSUInteger age;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果所有条件都是相等的，那么两个<code>EOCPerson</code>对象相等。所以<code>isEqual:</code>方法应该这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object &#123;  </div><div class="line">    if (self == object) return YES;  </div><div class="line">    if ([self class] != [object class]) return NO;  </div><div class="line"> </div><div class="line">    EOCPerson *otherPerson = (EOCPerson*)object;  </div><div class="line">    if (![_firstName isEqualToString:otherPerson.firstName])  </div><div class="line">        return NO;  </div><div class="line">    if (![_lastName isEqualToString:otherPerson.lastName])  </div><div class="line">        return NO;  </div><div class="line">    if (_age != otherPerson.age)  </div><div class="line">        return NO;  </div><div class="line">    return YES;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，对比两个对象的指针是否相同。如果指针相同，那么对象一定相等，因为它们是同一个对象。其次，比较两个对象的类。如果两个对象的类不同，那么两个对象不相等。毕竟，一个<code>EOCPerson</code>类不可能等于<code>EOCDog</code>类。当然，你可能希望一个<code>EOCPerson</code>实例等于它一个子类的实例；例如，<code>EOCSmithPerson</code>。这说明在继承层次中，判断相等性是一个常见问题。当你实现了<code>isEqual:</code>方法时，你应该考虑这个问题。最后，没一个属性去检查相等性。如果它们中的任何一个不相等，那么两个对象被认为是不相等；否则，它们是相等的。</p>
<p>接下来实现<code>hash</code>方法。回想一下相等性原则，当两个对象相等，那么它们的哈希码一定相等，但是两个对象的哈希码相等，它们本身却不一定相等。因此如果你复写了<code>isEqual:</code>方法，通常也会覆写<code>hash</code>方法。一个更好的<code>hash</code>方法是像下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;  </div><div class="line">    return 1337;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可是，如果在集合中使用这种办法，这将可能会产生性能问题。因为集合使用哈希表中的哈希码做索引。一个集合的实现是使用哈希存储对象到不同的数组。当给集合添加新对象时，会根据哈希码找到与其对应的数组，对比所有对象，看其是否与新加对象相等。如果相等，说明新加的对象已经在集合里面了。因此，如果所有的对象哈希码都一样，那么在集合中已有1000000个对象时，每次给集合添加对象都会遍历对比这1000000个对象。</p>
<p>另一种实现哈希方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;  </div><div class="line">    NSString *stringToHash =  </div><div class="line">        [NSStringstringWithFormat:@&quot;%@:%@:%i&quot;,  </div><div class="line">            _firstName, _lastName, _age];  </div><div class="line">    return [stringToHash hash];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次的哈希算法是通过创建一个字符串并将字符串的哈希码返回。这么做符合约定，因为两个相等的<code>EOCPerson</code>总会生成相等哈希码。然而，这种方法是比返回单一数值的速度慢的，因为你需要创建一个字符串。当给一个集合添加对象时，这仍会导致性能问题，因为要给集合添加对象，仍然需要去计算对象的hash值。</p>
<p>第三种也是最后一种方法是创建一个类似于这样的哈希码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;  </div><div class="line">    NSUInteger firstNameHash = [_firstName hash];  </div><div class="line">    NSUInteger lastNameHash = [_lastName hash];  </div><div class="line">    NSUInteger ageHash = _age;  </div><div class="line">    return firstNameHash ^ lastNameHash ^ ageHash;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法是一个这种的办法，既能保持一定的效率，又能使生成的哈希码在一定范围之内。当然，这样还会导致生成相同的哈希码的碰撞，但是至少不会重复太多次。在编写哈希码时，你应该基于当前的业务要求去权衡哈希碰撞频率和创建哈希的性能消耗。</p>
<h4 id="特定类的等同性方法"><a href="#特定类的等同性方法" class="headerlink" title="特定类的等同性方法"></a>特定类的等同性方法</h4><p>除了前面说的<code>NSString</code>类提供了特定的等同性方法，还提供特定方法的类还有<code>NSArray(isEqualToArray:)</code>和<code>NSDictionary(isEqualToDictionary:)</code>，如果对比的对象不是数组或者字典，这两种方法都会抛出异常。<code>Objective-C</code>在编译器并没有严格的类行检测，这样就容易使用错误的对象去对比，所以你应该确定当前对象的类型是正确的。</p>
<p>如果等同性对比比较频繁，那么你可能会创建自己的等同性方法；因此，效率高的重要原因是不需要检查类型。另一个原因是，提供一个指定方法是用于修饰的，它看起来是更好、更易读的，这也是<code>NSString</code>类提供<code>isEqualToString:</code>方法的动机之一。使用此种方法的代码是更易读的，并且也不需要再去检查两个对比对象的类型了。</p>
<p>如果你创建一个特定等同性方法，你需要覆盖<code>isEqual:</code>方法并且通过判断两个对比对象的类型是否相同。如果不相同，就使用父类的实现方法去判断。例如，<code>EOCPerson</code>类的实现应该像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123;  </div><div class="line">    if (self == object) return YES;  </div><div class="line"> </div><div class="line">    if (![_firstName isEqualToString:otherPerson.firstName])  </div><div class="line">        return NO;  </div><div class="line">    if (![_lastName isEqualToString:otherPerson.lastName])  </div><div class="line">        return NO;  </div><div class="line">    if (_age != otherPerson.age)  </div><div class="line">        return NO;  </div><div class="line">    return YES;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (BOOL)isEqual:(id)object &#123;  </div><div class="line">    if ([self class] == [object class]) &#123;  </div><div class="line">        return [self isEqualToPerson:(EOCPerson*)object];  </div><div class="line">    &#125; else &#123;  </div><div class="line">        return [super isEqual:object];  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="等同性对比的深度"><a href="#等同性对比的深度" class="headerlink" title="等同性对比的深度"></a>等同性对比的深度</h4><p>当你创建一个等价方法时，你需要决定是检查整个对象的等同性或者仅仅只是一些条件的等同性。<code>NSArray</code>的对比方法是先对比两个数组包含的个数，其次遍历它们，使用<code>isEqual:</code>对比每个元素。如果所有的元素都相等，那么可以认为两个数组相等，这是深度等同性对比。不过有时你仅需要判断一部分数据段是相等的，这对于等同性对比也是可以的。</p>
<p>例如，使用<code>EOCPerson</code>类，如果实例来源于一个数据库，它们可能会添加一个属性用于唯一标示，即使用数据库中的主键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property NSUInteger identifier;</div></pre></td></tr></table></figure>
<p>在这种情况下，可能仅仅需要去检查<code>identifier</code>是否匹配即可，尤其是如果<code>identifier</code>属性特质被声明为只读，那么你可以确定如果两个对象拥有同样的表示符，它们确实代表了相同的对象并且相等。这可以避免对比每个<code>EOCPerson</code>对象的每个数据位，如果你确定它们的标示符相等，那么剩下的数据也相等，因为它们是相同的数据源。</p>
<p>在你的等同性方法中，是否需要检查所有条件的等同性，取决于被检测的对象。只有你才知道在什么情况下两个实例相等。</p>
<h4 id="容器中可变类的等同性"><a href="#容器中可变类的等同性" class="headerlink" title="容器中可变类的等同性"></a>容器中可变类的等同性</h4><p>考虑一个重要的情况，在容器中添加一个可变类。一旦你将一个对象添加入一个集合中，那么这个对象的哈希码不应该再改变。前面，我说了集合是根据哈希码去存储对象的。如果哈希码一旦发生变化，集合中的对象将会产生一个错误。为了解决这个问题，你可以确保哈希码不是根据可变部分的对象计算出来的或者保证一旦放入集合中就不再修改它。在第18节，我详细阐述了为了你需要使对象不可变。对于这个问题，下面有一个很好的例子。</p>
<p>通过测试<code>NSMutableSet</code>和<code>NSMutableArrays</code>，你可以看到这个问题。开始的时候给集合添加一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *set = [NSMutableSetnew];  </div><div class="line"> </div><div class="line">NSMutableArray *arrayA = [@[@1, @2] mutableCopy];  </div><div class="line">[set addObject:arrayA];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1,2))&#125;</div></pre></td></tr></table></figure>
<p>集合中现在有一个对象：带有两个元素的数组。现在使用相同的方法给集合添加一个同样顺序的数组，下面的代码展示了给集合添加一个新的数组以及添加后集合的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arrayB = [@[@1, @2] mutableCopy];  </div><div class="line">[set addObject:arrayB];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1,2))&#125;</div></pre></td></tr></table></figure>
<p>这个集合仍然只保存了一个对象，因为新添加的数组对象是已经在集合中存在的了。现在我们添加一个跟集合中不同的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arrayC = [@[@1] mutableCopy];  </div><div class="line">[set addObject:arrayC];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1),(1,2))&#125;</div></pre></td></tr></table></figure>
<p>果然，集合现在包含了两个数组：一个原来的数组和一个新的数组，因为<code>arrayC</code>与集合中已有的数组不相等。最后，我们修改<code>arrayC</code>使其等于之前集合中的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[arrayC addObject:@2];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1,2),(1,2))&#125;</div></pre></td></tr></table></figure>
<p>哦，我的天，现在在集合中存在两个相同的数组了。这个集合没有遵守集合的定义，但是我们现在却无法确保这点了。因为我们修改了一个已经在集合中的对象了。如果我们拷贝这个集合，将会更加可怕：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSSet *setB = [set copy];  </div><div class="line">NSLog(@&quot;setB = %@&quot;, setB);  </div><div class="line">// Output: setB = &#123;((1,2))&#125;</div></pre></td></tr></table></figure>
<p>这个拷贝出来的集合仅有一个对象，这个集合像是先创建一个空的集合，然后逐步从原集合中添加元素得到的。这可能是也可能不是你想要的结果。你可能想要忽视这个错误，按原样复制一个集合。或者你就是想这样做。这两种拷贝情况都是有效的，这进一步说明了刚才的问题，如果修改某个已经加入集合的对象，将会产生不可预料的情况。</p>
<p>举这个例子是想告诉大家，当你修改某个已经加入集合的对象会造成什么后果。这不是说不能这样做，而是你这样做了之后要考虑其后果。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果想检测等同性，你需要提供<code>isEqual:</code>和<code>hash</code>方法。</li>
<li>相同的对象，哈希码一定是相等的；但是哈希码相等，对象却不一定相等。</li>
<li>确定你对比对象同等性时是否需要对比每个对象。</li>
<li>编写哈希算法时，应该使用计算速度快并且碰撞几率低的算法。</li>
</ul>
<h3 id="使用类簇模式隐藏实现细节"><a href="#使用类簇模式隐藏实现细节" class="headerlink" title="使用类簇模式隐藏实现细节"></a>使用类簇模式隐藏实现细节</h3><p>在一个抽象基类中，使用类簇可以很好的隐藏实现细节。在<code>Objective-C</code>的系统框架中，这种模式是非常普遍的。<code>UIKit</code>中有一个例子，就是<code>iOS</code>的UI框架中的<code>UIButton</code>类。创建一个按钮，你会调用下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (UIButton*)buttonWithType:(UIButtonType)buttonType;</div></pre></td></tr></table></figure>
<p>返回对象的类型取决于按钮类型。所有的子类都继承自相同的基类，即<code>UIButton</code>类。这样做使用者就不需要关心生成的按钮类型以及按钮如何绘画的具体细节。这一切只需要知道如何创建一个按钮；如何设置标题这样的属性；如何设置点击的动作。</p>
<p>回到按钮绘画的问题上面，它可以通过使用一个类去处理所有按钮的绘画并且基于它们的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;  </div><div class="line">    if (_type == TypeA) &#123;  </div><div class="line">        // Draw TypeA button  </div><div class="line">    &#125; else if (_type == TypeB) &#123;  </div><div class="line">        // Draw TypeB button  </div><div class="line">    &#125; /* ... */  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看起来是清晰的，但是如果有许多方法基于这个类型的切换去绘制，那么这个方法就会变得非常笨重。一个好的程序员会对这进行重构，通过创建多个子类去实现特定的功能用于对应每种按钮类型。然而这样做需要使用者知道所有的子类。这时就该使用类簇模式了，这种模式提供多个子类，并通过将其实现细节隐藏在基类，用以保持头文件的干净。你不需要创建子类的实例，你通过基类创建它们即可。</p>
<h4 id="创建一个类簇"><a href="#创建一个类簇" class="headerlink" title="创建一个类簇"></a>创建一个类簇</h4><p>有一个关于如何创建类簇的例子，考虑一个处理雇员的类，这个类包含雇员的名字和销售额以及每天该做的工作。但是每个雇员每天的工作是不一样的。管理者不关心每个雇员如何完成任务，他只会告诉每个雇员该做什么。</p>
<p>首先，你需要定义这个基类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123;  </div><div class="line">    EOCEmployeeTypeDeveloper,  </div><div class="line">    EOCEmployeeTypeDesigner,  </div><div class="line">    EOCEmployeeTypeFinance,  </div><div class="line">&#125;;  </div><div class="line"> </div><div class="line">@interface EOCEmployee : NSObject  </div><div class="line"> </div><div class="line">@property (copy) NSString *name;  </div><div class="line">@property NSUInteger salary;  </div><div class="line"> </div><div class="line">// Helper for creating Employee objects  </div><div class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;  </div><div class="line"> </div><div class="line">// Make Employees do their respective day&apos;s work  </div><div class="line">- (void)doADaysWork;  </div><div class="line"> </div><div class="line">@end  </div><div class="line"> </div><div class="line">@implementation EOCEmployee  </div><div class="line"> </div><div class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;  </div><div class="line">    switch (type) &#123;  </div><div class="line">        case EOCEmployeeTypeDeveloper:  </div><div class="line">            return [EOCEmployeeDeveloper new];  </div><div class="line">            break;  </div><div class="line">        case EOCEmployeeTypeDesigner:  </div><div class="line">            return [EOCEmployeeDesigner new];  </div><div class="line">            break;  </div><div class="line">        case EOCEmployeeTypeFinance:  </div><div class="line">            return [EOCEmployeeFinance new];  </div><div class="line">            break;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (void)doADaysWork &#123;  </div><div class="line">    // Subclasses implement this.  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>每一个具体的子类继承自基类。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface EOCEmployeeDeveloper : EOCEmployee  </div><div class="line">@end  </div><div class="line"> </div><div class="line">@implementation EOCEmployeeDeveloper  </div><div class="line"> </div><div class="line">- (void)doADaysWork &#123;  </div><div class="line">    [self writeCode];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个例子中，这个基类实现了一个基类方法的声明，它通过雇员的类型去创建并初始化不同的实例。这个工厂模式是创建一个类簇的一种方法。</p>
<p>不幸的是，<code>Objective-C</code>语言没有指定一个类是基类的功能。相应的，开发者通常会在这个类中写明类的用法。在这种情况下，头文件没有声明初始化方法，它意味着实例变量并不是立即创建的。另一种确定没使用基类实例的方法是在基类的<code>doADaysWork</code>方法中抛出一个异常。然而，这种做法是非常极端的并且也不是必需的。</p>
<p>还有一个点需要注意的，当使用的对象的类是类簇的一个成员时，要注意它的类型信息(看第14节)。因为你可能认为你创建的是某个类的实例，但实际上确实它的某个子类的实例。在前面的例子中，你可能以为调用<code>[employee isMemberOfClass:[EOCEmployee class]]</code>的结果是<code>YES</code>，但<code>employee</code>其实不是<code>EOCEmployee</code>类初始化的对象，而是其子类，所以它会返回<code>NO</code>。</p>
<h4 id="Cocoa中的类簇"><a href="#Cocoa中的类簇" class="headerlink" title="Cocoa中的类簇"></a>Cocoa中的类簇</h4><p>系统框架中有许多类簇。大多数的集合类都是类簇，例如<code>NSArray</code>和它对应的可变类<code>NSMutableArray</code>。所以，实际上它有两个基类：一个可变数组和一个不可变数组。它仍然是一个类簇但是却有两个公共接口。不可变类中定义的方法适用于所有的数组，可变类定义的方法仅适用于可变数组。实际上类簇意味着它们在实现自身时可以共享代码，以及可以在创建时把不可变数组变为可变数组，反之亦然。</p>
<p>在<code>NSArray</code>中，当你创建一个实例时，它其实是另一个类创建的实例，这个类的用途就是占位。之后这个占位数组会转化为另一个的实例，而那个类则是<code>NSArray</code>的具体子类。这是一个很好的实现，但它超出了本书的讲解范围。</p>
<p>理解像<code>NSArray</code>这样的类是一个类簇是重要的，因为别的原因，你可能会写出这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = /* ... */;  </div><div class="line">if ([maybeAnArray class] == [NSArray class]) &#123;  </div><div class="line">        // Will never be hit  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了<code>NSArray</code>是一个类簇，可以使你理解上面的代码是错误的，其中<code>if</code>语句的条件永远不可能为真。<code>[maybeAnArray class]</code>返回的类永远不可能是<code>NSArray</code>类，因为<code>NSArray</code>初始化方法返回的变量是由隐藏在类簇内部的某个隐藏类实现的。</p>
<p>注意在类簇中对比实例变量的类是可以的。不适用之前的方法，你应该使用类型信息查询方法。第14节讲述了那些方法。替换之前类对象等同性比较方法，你因该这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = /* ... */;  </div><div class="line">if ([maybeAnArray isKindOfClass:[NSArray class]]) &#123;  </div><div class="line">        // Will be hit  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给类簇添加具体的子类是正常的需求，但是这么做的时候要小心。在<code>Emloyee</code>的例子中，如果没有工厂方法代码，去添加新的子类是不可能的。在<code>Cocoa</code>的类簇中，例如<code>NSArray</code>，它是可以的，但是有一些规则必须去遵守。这几条规则如下：</p>
<ul>
<li><p>子类应该继承自类簇的抽象基类。</p>
<p>  在<code>NSArray</code>中，它可以继承自不可变数组的基类或者可变数组的基类。</p>
</li>
<li><p>子类应该定义自己的存储方式。</p>
<p>  开发者编写<code>NSArray</code>子类时，经常在这个问题上受阻。子类必须用一个实例标量存储数组中的对象。这看起来与我们预想相反，我们以为<code>NSArray</code>自己会存储它们。但是请记住，<code>NSArray</code>仅仅是一个包在其他隐藏对象外面的壳，它只是定义了一些数组通用的接口。对于这个子类来说，可以是用<code>NSArray</code>来保存其实例。</p>
</li>
<li><p>子类应当覆写父类文档中指明需要覆写的方法。    </p>
<p>  每个抽象基类都有一些方法需要子类一定实现的。在<code>NSArray</code>中，需要实现的方法有<code>count</code>和<code>objectAtIndex:</code>。另外的方法，像<code>lastObject</code>，不需要去实现，因为可以使用前两个方法实现这个方法。</p>
</li>
</ul>
<p>实现子类时所需要遵循的规范一般都在类的文档中，所以你首先应该阅读它们。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类簇模式可以使用一套简单的公共接口隐藏实现的细节。</li>
<li>类簇在系统框架中是经常使用的。</li>
<li>在定义类簇的子类时，需要注意遵循基类的协议。如果有文档，那么首先阅读它。</li>
</ul>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><p>有时，你想在对象中存储信息。通常，你通常会从那个对象类继承一个子类，然后使用子类去存储。然而，你不能一直这样做，因为类的实例可能是因为某种机制所创建的，并且你不能使这种机制使用你的类创建实例。这时候<code>Objective-C</code>中一个叫做<code>Associated Objects</code>的功能就派上用场了。</p>
<p>对象关联其它对象，并使用一个键去表示它。它们使用存储策略是维持存储对象的内存管理语义。这个存储策略由<code>objc_AssociationPolicy</code>的枚举值定义，表2.1展示了它所包含的值，同事还列出了与之等价的属性的特质(第6节讲述了属性的信息)。</p>
<p><strong>Table 2.1</strong> 对象关联类型<br><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Table%202.1.png" alt=""></p>
<p>关联对象的管理是使用下面语法实现的：</p>
<ul>
<li><p><code>void objc_setAssociatedObject(id object, void*key, id value, 
objc_AssociationPolicy policy)</code></p>
<p>使用给定的键和存储策略为对象设置关联对象值。</p>
</li>
<li><p><code>id objc_getAssociatedObject(id object, void*key)</code></p>
<p>使用给定的键从对象中获取关联对象值。</p>
</li>
<li><p><code>void objc_removeAssociatedObjects(id object)</code></p>
<p>移除对象的所有关联对象。</p>
</li>
</ul>
<p>关联对象的存取方法是类似字典对象这种的，字典通过调用<code>[object setObject:value forKey:key]</code>与<code>[object objectForKey:key]</code>存取，关联对象同样使用特定的键存储关联的值。但是有一个重要的不同需要知道，关联对象的键是个指针。而字典对象的键是一个字符串，只需要字符串相同就可以了。但是关联对象的键必须是同一个指针才可以匹配。因此，关联对象通常使用全局静态变量作为键。</p>
<h4 id="一个使用关联对象的例子"><a href="#一个使用关联对象的例子" class="headerlink" title="一个使用关联对象的例子"></a>一个使用关联对象的例子</h4><p>在iOS开发中，经常会使用<code>UIAlertView</code>类，给用户提供一个基于当前视图的弹窗。当用户点击按钮时有一个代理协议用于处理这个点击事件；然而，使用代理协议需要拆分创建代码和点击事件。由于代码分成两块，所以读起来有些不方便。下面有一个使用<code>UIAlertView</code>的例子，与我们一般写法一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)askUserAQuestion &#123;  </div><div class="line">    UIAlertView *alert = [[UIAlertView alloc]  </div><div class="line">                             initWithTitle:@&quot;Question&quot;  </div><div class="line">                               message:@&quot;What do you want to do?&quot;  </div><div class="line">                                 delegate:self  </div><div class="line">                        cancelButtonTitle:@&quot;Cancel&quot;  </div><div class="line">                        otherButtonTitles:@&quot;Continue&quot;, nil];  </div><div class="line">        [alert show];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">// UIAlertViewDelegate protocol method  </div><div class="line">- (void)alertView:(UIAlertView *)alertView  </div><div class="line">        clickedButtonAtIndex:(NSInteger)buttonIndex  </div><div class="line">&#123;  </div><div class="line">    if (buttonIndex == 0) &#123;  </div><div class="line">        [self doCancel];  </div><div class="line">    &#125; else &#123;  </div><div class="line">        [self doContinue];  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想在同一个类弹出超过一个弹窗，那么这种写法将会变得更加凌乱，因为你接着需要通过代理方法去检查弹窗的参数，并基于此选择相应的逻辑。如果弹窗创建时就可以决定每个按钮该做什么，那么逻辑就会清楚很多。这时可以使用关联对象去处理。一个解决办法是当创建弹窗时给它设置一个block并且当协议方法触发时调用这个blcok。它实现是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt; </div><div class="line"> </div><div class="line">static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;;  </div><div class="line"> </div><div class="line">- (void)askUserAQuestion &#123;  </div><div class="line">    UIAlertView *alert = [[UIAlertViewalloc]  </div><div class="line">                             initWithTitle:@&quot;Question&quot;  </div><div class="line">                               message:@&quot;What do you want to do?&quot;  </div><div class="line">                                  delegate:self  </div><div class="line">                        cancelButtonTitle:@&quot;Cancel&quot;  </div><div class="line">                        otherButtonTitles:@&quot;Continue&quot;, nil];  </div><div class="line"> </div><div class="line">        void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123;  </div><div class="line">          if (buttonIndex == 0) &#123;  </div><div class="line">              [self doCancel];  </div><div class="line">        &#125; else &#123;  </div><div class="line">            	 [self doContinue];  </div><div class="line">        &#125;  </div><div class="line">    &#125;;  </div><div class="line"> </div><div class="line">      objc_setAssociatedObject(alert,  </div><div class="line">                               EOCMyAlertViewKey,  </div><div class="line">                               block,  </div><div class="line">	                            BJC_ASSOCIATION_COPY);  </div><div class="line"> </div><div class="line">      [alert show];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">// UIAlertViewDelegate protocol method  </div><div class="line">- (void)alertView:(UIAlertView*)alertView  </div><div class="line">        clickedButtonAtIndex:(NSInteger)buttonIndex  </div><div class="line">&#123;  </div><div class="line">    void (^block)(NSInteger) =  </div><div class="line">        objc_getAssociatedObject(alertView, EOCMyAlertViewKey);  </div><div class="line">    block(buttonIndex);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用这种方法，创建弹窗的代码和回调结果的代码都在同一个位置，这样比之前的代码更易读，因为你不需要在两处代码之间来回看就可知道为什么使用弹窗了。然而使用这种办法你需要小心一个问题，如果block捕捉了某些变量，这可能会造成循环引用。关于这个问题更具体的信息请看第40节。</p>
<p>如你所见，这种方法是非常好用的，但是你应该确保仅仅是你没有别的办法达到你想做的时再去使用它。如果滥用它，你的代码将会很快超出控制并且难以排查问题。循环引用产生的原因是难以发现的，因为关联对象之间并没有明确的定义，内存管理语义定义在关联时期，而不是声明时期。所以当你使用这种方法时需要小心，不要因为某处可以用它就使用它。另一个实现弹窗的办法是创建子类，将block作为一个属性添加进子类。如果多次使用弹窗时，我认为使用这种办法是优于使用关联对象的。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>关联对象提供了一种方法去关联两个对象。</li>
<li>定义关联对象时可使用内存管理语义去模仿属性的拥有或非拥有关系。</li>
<li>当另一种方法不能实现时，才去使用关联对象，因为它可能产生难以查找的异常。</li>
</ul>
<h3 id="理解objc-msgSend的作用"><a href="#理解objc-msgSend的作用" class="headerlink" title="理解objc_msgSend的作用"></a>理解objc_msgSend的作用</h3><p>在<code>Objective-C</code>中通过对象调用方法是做的最多的事情之一。在<code>Objective-C</code>术语中，它被称作消息传递。消息有名字或者选择器，带有参数，并且可能会有一个返回值。</p>
<p>因为<code>Objective-C</code>是C的超集，去了解C中的函数调用时一个好的主意。众所周知，C的函数调用时静态绑定，即在编译时就知道函数的调用。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">void printHello() &#123;  </div><div class="line">    printf(&quot;Hello, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line">void printGoodbye() &#123;  </div><div class="line">    printf(&quot;Goodbye, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">void doTheThing(int type) &#123;  </div><div class="line">    if (type == 0) &#123;  </div><div class="line">        printHello();  </div><div class="line">    &#125; else &#123;  </div><div class="line">        printGoodbye();  </div><div class="line">    &#125;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略内联函数这种情况，当上述代码编译时，<code>printHello</code>函数和<code>printGoodbye</code>函数是已知的，编译器会直接发出指令去调用函数。在指令集中函数的地址就是有效的硬编码。现在考虑下下述代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">void printHello() &#123;  </div><div class="line">    printf(&quot;Hello, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line">void printGoodbye() &#123;  </div><div class="line">    printf(&quot;Goodbye, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">void doTheThing(int type) &#123;  </div><div class="line">    void (*fnc)();  </div><div class="line">    if (type == 0) &#123;  </div><div class="line">        fnc = printHello;  </div><div class="line">    &#125; else &#123;  </div><div class="line">        fnc = printGoodbye;  </div><div class="line">    &#125;  </div><div class="line">    fnc();  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里就需要使用动态绑定了，因为在运行时之前都不知道函数如何调用。在第一个和第二个例子中，编译器生成的指令集是不同的。第一个例子中，函数的调用是在if和else这两种情况中的。第二个例子中，仅有一个调用，不过是有一定代价的，即待调用的函数地址无法硬编码在指令集中，而是要在运行期读取出来。</p>
<p>在<code>Obejctvie-C</code>中，当传递消息给对象时，是通过动态绑定机制去决定调用哪个方法的。在底层所有的方法都是普通的C函数，但是当对象接收到信息后，调用哪一个方法完全取决于运行时，甚至可以在程序运行过程去修改它，这使得<code>Objective-C</code>成为一门真正的动态语言。</p>
<p>给对象发送消息看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>someObject</code>是消息接收者，<code>messageName:</code>是选择器。选择器和参数的组合被称作消息。当编译器看到这个消息时，它将这个消息转化为一条标准的C函数，所调用的函数是消息传递机制中的核心函数，叫做<code>objc_msgSend</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_msgSend(id self, SEL cmd, ...)</div></pre></td></tr></table></figure>
<p>这是一个参数个数可变的参数，它可以接受两个或两个以上的参数。第一个参数是消息接收者，第二个参数是选择器(SEL的类型是selector)，剩下的参数就是消息参数，顺序与它们传递时一致。选择器指的是方法的名字。在计算机术语中，选择器和方法这两个术语经常交替使用。编译器会将上面的例子中的消息转化成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id returnValue = objc_msgSend(someObject,  </div><div class="line">                              @selector(messageName:),  </div><div class="line">                              parameter);</div></pre></td></tr></table></figure>
<p><code>objc_msgSend</code>函数会依据消息接收者和选择器去调用合适的方法。为了做到这一点，这个函数会去查找消息接收者所属类中的方法实现列表，如果能查找到与接收器名字匹配的方法，就跳转至其实现代码。如果没有找到，这个函数会遍历其继承层次查找这个方法并跳转至其实现代码。如果仍没有找到匹配的方法，那么就执行消息转发。更详细的消息转发机制请看第12节。</p>
<p>这样说来，调用一个方法会需要很多步骤。幸运的是，<code>objc_msgSend</code>会在快速查找表中缓存结果，每个类都有这样一块缓存，所以后面给相同的类和方法组合发送消息是非常快速的。即使这样，快速查找仍然是比静态绑定方法的速度慢的，但是一旦方法缓存，也不会差太多。实际上，消息传递并不是一个应用程序的瓶颈。如果是，你可以编写纯C函数，只在调用需要时，将<code>Objective-C</code>对象状态传递进去。</p>
<p>上面说的仅仅基于确定的消息。另外的边缘情形则需要交给<code>Objective-C</code>运行时的另一些函数：</p>
<ul>
<li><p><code>objc_msgSend_stret</code></p>
<p>如果发送的消息返回结构体，那么可交由此函数处理。当返回的类型是结构体且能被放进CPU寄存器时，使用这个函数处理。如果寄存器不能容纳返回类型，那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</p>
</li>
<li><p><code>objc_msgSend_fpret</code></p>
<p>如果发送消息的返回值是浮点数，那么可交由此函数处理。某些处理器调用函数时，需要对浮点型寄存器进行特殊处理，这意味着标准的<code>objc_msgSend</code>是不适合的。这个函数存在的作用是处理x86等架构中的一些特殊的情况。</p>
</li>
<li><p><code>objc_msgSendSuper</code></p>
<p>发送消息给父类，例如<code>[super message:parameter]</code>，使用这个方法。它也有两个等价于<code>objc_msgSend_stret</code>和<code>objc_msgSend_fpret</code>的函数，用于处理发给父类的消息。</p>
</li>
</ul>
<p>刚才提到过，<code>objc_msgSend</code>等函数一旦搜寻到正确的方法实现就跳转至其实现代码。之所以能这样做，是因为每个<code>Objective-C</code>对象方法都能看做是一个简单的C函数，它的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</div></pre></td></tr></table></figure>
<p>函数的名字可能不像上面那样，但我用类和选择器去组合它，仅仅是为了说明它的原理。每个类里面都有一张表，其中的指针会指向函数，以选择器名字为键去查找。<code>objc_msgSend</code>等函数正是通过这张表来寻找应该执行的方法并跳至其实现的。注意原型和<code>objc_msgSend</code>函数很相似，但这不是巧合。它简化跳转方法并且可以更好的使用尾调用优化。</p>
<p>当一个方法的最后一行是调用另一个函数，那么就可以使用尾调用优化。编译器可产生跳转至下一个函数的指令码，也不用生成新的栈帧。这仅当一个函数最后的操作是调用另一个函数且不需要使用返回值做任何事情，才能执行尾调用优化。这项优化对<code>objc_msgSend</code>是非常重要的，因为没有它，每次调用<code>Objective-C</code>方法，栈将会在栈踪迹中显示所有<code>objc_msgSend</code>调用的函数。并且，也将会经常发生栈溢出现象。</p>
<p>实际上，你在写<code>Objective-C</code>代码时，不需要担心这些问题，但是理解这些操作的本质对开发来说是有益的。如果你理解了在发送消息时发生了什么，你可以了解你的代码是如何执行的并且在调试时，也能理解为什么栈回溯中总会出现<code>objc_msgSend</code>函数。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>一个消息由一个接收者，一个选择器，参数组成。给对象发送消息相当于对象调用方法。</li>
<li>当调用时，所有的消息都需要通过动态消息发送系统来处理，它会查找方法的实现然后运行它们。</li>
</ul>
<h3 id="理解消息转发"><a href="#理解消息转发" class="headerlink" title="理解消息转发"></a>理解消息转发</h3><p>第11节解释了理解对象消息机制是重要的。第12节探讨当对象遇到无法处理的消息时发生了什么。类可以理解消息仅仅是因为它实现了相对应的方法。类接收到一个无法理解的信息会发生错误，但它并不是发生在编译时。因为方法是在运行时被添加到类中的，所以编译器并不知道对应的方法是否存在。当某个类接受到一个它不理解的消息，对象通过使用消息转发，一个允许开发者预处理的设计。开发者可以通过它去处理那些类无法理解的消息。</p>
<p>即使你不知道消息转发，但你可能已经遇到过由消息转发流程处理的消息了。每次你在控制台看到这样的信息，它是因为你给某个对象传递了消息但是那个对象无法处理它，所以它通过转发机制，将消息转发给了<code>NSObject</code>的默认实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-[__NSCFNumber lowercaseString]: unrecognized selector sent to  </div><div class="line">instance 0x87  </div><div class="line">*** Terminating app due to uncaught exception  </div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber  </div><div class="line">lowercaseString]: unrecognized selector sent to instance 0x87&apos;</div></pre></td></tr></table></figure>
<p>这是从<code>NSObject</code>的<code>doesNotRecognizeSelector:</code>方法抛出的一个异常，它告诉你这个消息的接收者类型是<code>__NSCFNumber</code>，并且这个接收者无法理解这个叫做<code>lowercasrString</code>的选择器。在上述示例中这并不奇怪，因为<code>NSNumber</code>是没有那个方法的(<code>__NSCFNumber是为了实现无缝桥接而使用的内部类，当你初始化一个NSNumber实例时，它会被创建</code>)。在这个例子中，应用程序最后以崩溃而告终，但是你可以在你的类中拦截到转发机制去执行你想要的逻辑替代崩溃。</p>
<p>转发路径是分为两大阶段的。第一个阶段是给接收者的类一个机会去动态的添加一个方法，用于处理未知的选择器。这叫做动态方法解析。第二个阶段涉及完整的消息转发机制。如果运行时间已经过了第一阶段，那么接收者就无法再以添加方法的方式去相应选择器。所以它告诉接收者自己去尝试处理。这也分为两步。首先，它会问别的对象是否接受这个消息。如果有，运行时会转移消息并结束消息转发。如果没有替代的接收者，则启动完整的转发机制，使用<code>NSInvocation</code>对象去把所有与消息有关的细节包装起来并给开发者最后一个机会去处理它。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>当一个对象接收到一个它不能理解的方法时，在它所属类中调用的第一个方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector;</div></pre></td></tr></table></figure>
<p>这个方法带有一个当前类无对应实现的选择器并且返回一个布尔值指示是否在运行期有可以对应选择器的实例方法添加到本类。因此，在触发其余转发机制之前这个类有第二次机会去添加对应的实现。还有一个类似的方法，叫做<code>resolveClassMethod:</code>，当一个未实现的方法是类方法而不是实例方法时会调用它。</p>
<p>使用这种方法依赖于这个方法实现已经是可用的，准备动态的插入类中。这个方法经常被用做实现<code>@dynamic</code>属性(看第6节)，例如在<code>CoreData</code>中访问NSManagedObjects属性，因为访问方法需要去手动实现，这样属性才可以在编译时被知道。</p>
<p>这样一个<code>resolveInstanceMethod:</code>实现，对于使用<code>@dynamic</code>属性看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">id autoDictionaryGetter(id self, SEL _cmd);  </div><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value);  </div><div class="line"> </div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector &#123;  </div><div class="line">    NSString *selectorString = NSStringFromSelector(selector);  </div><div class="line">    if ( /* selector is from a @dynamic property */ ) &#123;  </div><div class="line">        if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;  </div><div class="line">            class_addMethod(self,  </div><div class="line">                            selector,  </div><div class="line">                            (IMP)autoDictionarySetter,  </div><div class="line">                            &quot;v@:@&quot;);  </div><div class="line">        &#125; else &#123;  </div><div class="line">            class_addMethod(self,  </div><div class="line">                            selector,  </div><div class="line">                            (IMP)autoDictionaryGetter,  </div><div class="line">                            &quot;@@:&quot;);  </div><div class="line">        &#125;  </div><div class="line">        return YES;  </div><div class="line">    &#125;  </div><div class="line">return [super resolveInstanceMethod:selector];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先将选择器转为一个字符串，并且检查它是否是一个<code>setter</code>方法。如果前缀带有set字符，假定它是一个<code>setter</code>方法；否则，假定它是一个<code>getter</code>方法。在每种情况下，都会对给定选择器的类添加一个方法，它指向一个C函数的实现。在这些C函数中将会通过代码来控制类使用某种数据结构去存储属性数据。例如，在<code>CoreData</code>中，这些方法将通过后端数据库去检索或更新值。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>第二步处理未知选择器的方法是询问接收者是否有一个可用的替代接收者去处理相应的消息。这个方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)selector</div></pre></td></tr></table></figure>
<p>传递未知的选择器并且返回符合预期的接收者，当未找到符合预期的接收者，将返回nil。这个方法可以让我们通过组合来模拟多重继承的某些特性。一个对象内部可能还有一系列别的对象，在这个方法中它可以返回能够处理的选择器相关的内部对象，并使其在外界看来像是它亲自处理一样。</p>
<p>注意，我们无法再这一步对消息做出改变。如果消息需要在发送给备用接收者之前做改变，那么我们需要使用完整的转发机制。</p>
<h4 id="完整转发机制"><a href="#完整转发机制" class="headerlink" title="完整转发机制"></a>完整转发机制</h4><p>如果转发算法已经走到这一步，那么能做的事仅有使用完整的转发机制了。首先创建一个<code>NSInvocaton</code>对象，用于包含不能处理的消息的所有细节。这个对象包含选择器，目标接收者，和参数。在触发<code>NSInvocaton</code>对象可时，这将导致消息派发系统去将消息派发给指定的对象。</p>
<p>此步骤调用的转发方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation*)invocation</div></pre></td></tr></table></figure>
<p>一个简单的实现是改变这个对象的目标并触发它。这样的实现与备用接收者是等价的，但是很少有人使用这么简单的实现。更有用的实现是可以在调用前通过某些办法改变这个消息，比如拼接另一个参数或者改变选择器。</p>
<p>实现此方法时，如果发现调用不是由该类处理，那么应该调用它的父类去处理。这意味着在继承链上的所有父类都有机会去处理这个调用，直至<code>NSObject</code>的实现。如果最后该消息仍没有处理，那么仍会调用<code>doesNotRecognizeSelector:</code>抛出异常。</p>
<h4 id="完整的转发机制图"><a href="#完整的转发机制图" class="headerlink" title="完整的转发机制图"></a>完整的转发机制图</h4><p>图2.2这张流程图描述了消息转发机制处理消息的各个步骤。</p>
<p>在每一步，接收者都有机会去处理消息。每一步处理代价都比上一步大。最好的处理时机在第一部，因为方法在运行时被添加将会被运行时缓存，当你使用同一个类的实例再次调用时，它不需要再走转发机制就可以找到这个选择器了。如果能找到一个备用接收者，那么在第二步处理是优于第三步处理的。在第三步中，仅是修改有关的调用目标，那在第二步做这个是比第三步更简单的，并且也不需要再去创建<code>NSInvocaton</code>对象。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.2.png" alt=""></p>
<h4 id="动态方法解析的完整示例"><a href="#动态方法解析的完整示例" class="headerlink" title="动态方法解析的完整示例"></a>动态方法解析的完整示例</h4><p>为了说明如何使用消息转发机制，下面的例子展示了使用动态方法解析显现<code>@dynamic</code>属性。考虑一个对象允许你存储任何对象进去，类似一个字典，但需要通过属性提供存取方法。这个类的设计思路是你可以添加属性定义并使用<code>@dynamic</code>声明它，类将处理存储和获取方法。这听起来是不是很不错？</p>
<p>这个类的接口大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt; </div><div class="line"> </div><div class="line">@interface EOCAutoDictionary : NSObject  </div><div class="line">@property (nonatomic, strong) NSString *string;  </div><div class="line">@property (nonatomic, strong) NSNumber *number;  </div><div class="line">@property (nonatomic, strong) NSDate *date;  </div><div class="line">@property (nonatomic, strong) id opaqueObject;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个例子中，这些属性具体是什么是不重要的。我之所以写这么多类型只是为了展示这个功能的强大。在类的内部，每一个属性将都存放在字典中，所以类开始的实现是下面这样的，包含使用<code>@dynamic</code>声明属性，这样这些属性的实例变量和存取方法就不会自动生成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import “EOCAutoDictionary.h&quot;  </div><div class="line">#import &lt;objc/runtime.h&gt; </div><div class="line"> </div><div class="line">@interface EOCAutoDictionary ()  </div><div class="line">@property (nonatomic, strong) NSMutableDictionary *backingStore;  </div><div class="line">@end  </div><div class="line">@implementation EOCAutoDictionary  </div><div class="line"> </div><div class="line">@dynamic string, number, date, opaqueObject;  </div><div class="line"> </div><div class="line">- (id)init &#123;  </div><div class="line">    if ((self = [super init])) &#123;  </div><div class="line">         _backingStore = [NSMutableDictionary new];  </div><div class="line">    &#125;  </div><div class="line">    return self;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是本例重要的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector &#123;  </div><div class="line">    NSString *selectorString = NSStringFromSelector(selector);  </div><div class="line">    if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;  </div><div class="line">        class_addMethod(self,  </div><div class="line">                        selector,  </div><div class="line">                        (IMP)autoDictionarySetter,  </div><div class="line">                        &quot;v@:@&quot;);  </div><div class="line">    &#125; else &#123;  </div><div class="line">        class_addMethod(self,  </div><div class="line">                        selector,  </div><div class="line">                        (IMP)autoDictionaryGetter,  </div><div class="line">                        &quot;@@:&quot;);  </div><div class="line">    &#125;  </div><div class="line">    return YES;  </div><div class="line">&#125;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>首次调用一个位于<code>EOCAutoDictionary</code>实例中的属性时，运行时找不到对应的选择器，因为它们即没有直接实现也没有自动合成。例如，假如要向<code>opaqueObject</code>对象写入信息，那么将会调用<code>setOpaqueObject:</code>方法。同理，在读取该属性时，会调用<code>opaqueObject</code>方法。<code>resolveInstanceMethod:</code>方法会检测方法是不是含有set前缀，以此区分<code>setter</code>和<code>getter</code>方法。在每种情况下，都会向类中增加一个方法去处理选择器，这两个方法分别是<code>autoDictionarySetter</code>及<code>autoDictionaryGetter</code>函数的指针。这时就可以使用运行时的<code>class_addMethod</code>方法，给类动态的添加方法，用于处理对应的选择器，并且带有所添加方法的指针。最后一个参数表示实现方法的类型编码。在本例中，编码开头的字符表示方法的返回值类型，后续字符则表示其所接受的各个参数。</p>
<p><code>getter</code>函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">id autoDictionaryGetter(id self, SEL _cmd) &#123;  </div><div class="line">        // Get the backing store from the object  </div><div class="line">        EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;  </div><div class="line">        NSMutableDictionary *backingStore = typedSelf.backingStore;  </div><div class="line"> </div><div class="line">        // The key is simply the selector name  </div><div class="line">        NSString *key = NSStringFromSelector(_cmd);  </div><div class="line"> </div><div class="line">        // Return the value  </div><div class="line">        return [backingStore objectForKey:key];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，<code>setter</code>函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value) &#123;  </div><div class="line">        // Get the backing store from the object  </div><div class="line">        EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;  </div><div class="line">        NSMutableDictionary *backingStore = typedSelf.backingStore;  </div><div class="line"> </div><div class="line">        /** The selector will be for example, &quot;setOpaqueObject:&quot;.  </div><div class="line">          *  We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first  </div><div class="line">          *  letter of the remainder.  </div><div class="line">          */  </div><div class="line">        NSString *selectorString = NSStringFromSelector(_cmd);  </div><div class="line">        NSMutableString *key = [selectorString mutableCopy];  </div><div class="line"> </div><div class="line">        // Remove the &apos;:&apos; at the end  </div><div class="line">    	 [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];  </div><div class="line"> </div><div class="line">        // Remove the &apos;set&apos; prefix  </div><div class="line">        [key deleteCharactersInRange:NSMakeRange(0, 3)];  </div><div class="line"> </div><div class="line">        // Lowercase the first character  </div><div class="line">        NSString *lowercaseFirstChar =  </div><div class="line">        	[[key substringToIndex:1] lowercaseString];  </div><div class="line">    	 [key replaceCharactersInRange:NSMakeRange(0, 1)  </div><div class="line">           					withString:lowercaseFirstChar];  </div><div class="line"> </div><div class="line">       if (value) &#123;  </div><div class="line">      		 [backingStore setObject:value forKey:key];  </div><div class="line">   		 &#125; else &#123;  </div><div class="line">        	 [backingStore removeObjectForKey:key];  </div><div class="line">    	 &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>EOCAutoDictionary</code>的方法很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EOCAutoDictionary *dict = [EOCAutoDictionary new];  </div><div class="line">dict.date = [NSDate dateWithTimeIntervalSince1970:475372800];  </div><div class="line">NSLog(@&quot;dict.date = %@&quot;, dict.date);  </div><div class="line">// Output: dict.date = 1985-01-24 00:00:00 +0000</div></pre></td></tr></table></figure>
<p>其它属性在字典中的实现也类似于日期属性，如果要添加新的属性，也可以使用<code>@property</code>定义，<code>@dynamic</code>声明它。在iOS的<code>CoreAnimation</code>框架中，<code>CALayer</code>类也是用来类似的方法。这是的<code>CALayer</code>成为可以兼容键值对容器的类，这意味着你可以随意添加键值对，并以属性的方法访问它。于是，开发者就可以向其中新增自定义的属性了，这些属性值的存储工作由基类直接负责，我们只需在CALayer的子类中定义新属性即可。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果对象无法响应选择器，则进入消息转发流程。</li>
<li>运行时的动态方法解析可以使我们给类添加我们需要使用的方法。</li>
<li>对象可以把无法处理的选择器交给其他对象去处理。</li>
<li>当前述步骤未处理选择器时，启动完成的转发机制。</li>
</ul>
<h3 id="考虑使用方法交换去调式不透明方法"><a href="#考虑使用方法交换去调式不透明方法" class="headerlink" title="考虑使用方法交换去调式不透明方法"></a>考虑使用方法交换去调式不透明方法</h3><p>在<code>Objective-C</code>中，当给对象发送消息时，它的一系列调用是发生在运行期的，第11节详细阐述了这个过程。你可能会在运行时修改给定选择器的对应方法。这是可以的。这个功能有巨大的用途，你可以使用它修改类中的方法对于某些你没有代码的方法，不需要子类和重载方法。因此，这个新的函数可以被所有类的实例使用而不仅是重载方法的子类实例。这种方法通常被称为<code>Method Swizzling</code>。</p>
<p>一个类的方法列表中包含一个选择器名字列表用于映射，告诉动态消息系统在哪里找到给定方法的实现。这个实现是作为函数指针被存储的，叫做<code>IMP</code>s，如下面的原型：<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.3.png" alt=""></p>
<p><strong>Figure 2.3</strong> <code>NSString</code>的选择器表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id (*IMP)(id, SEL, ...)</div></pre></td></tr></table></figure>
<p><code>NSString</code>类可以响应这些选择器的调用<code>lowercaseString</code>，<code>uppercaseString</code>，<code>capitalizedString</code>以及其它方法。每一个选择器指向一个不同的实现，类似于图2.3。</p>
<p><code>Objective-C</code>运行时暴露的一些方法可以操作这张表。你可以给列表添加选择器，改变实现指向，或者交换两个选择器的实现。执行其中的一些操作，类方法表可能像图2.4。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.4.png" alt=""></p>
<p><strong>Figure 2.4</strong> 执行了一些操作后，<code>NSString</code>选择器的表</p>
<p>添加了一个新的叫做<code>newSelector</code>选择器，改变了<code>capitalizedString</code>的实现，并且交换了<code>lowercaseString</code>和<code>uppercaseString</code>的实现。上述修改均无须编写子类，只要修改了方法表的布局，就会反映到程序中所有的<code>NSString</code>实例之上。怎么样，这是一个强大的功能吧。</p>
<p>这节的话题会讲述两个方法交换的过程。这样做可以为已有方法添加新功能。在讲述如何给已有方法添加功能之前，我将先讲述如何去交换两个已经存在的方法。交换方法实现，你应该使用下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void method_exchangeImplementations(Method m1, Method m2)</div></pre></td></tr></table></figure>
<p>这个函数中的参数用于交换。它们可以通过下面的函数获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector)</div></pre></td></tr></table></figure>
<p>这个方法使用给定的选择器在类中去检索方法。在前面的例子中，交换<code>lowercaseString</code>和<code>uppercaseString</code>的实现，需要执行下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Method originalMethod =  </div><div class="line">    class_getInstanceMethod([NSStringclass],  </div><div class="line">                            @selector(lowercaseString));  </div><div class="line">Method swappedMethod =  </div><div class="line">    class_getInstanceMethod([NSStringclass],  </div><div class="line">                            @selector(uppercaseString));  </div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>从这时起，所有的<code>NSString</code>实例调用<code>lowercaseString</code>方法时，都会调用<code>uppercaseString</code>的实现，反之亦然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;ThIs iS tHe StRiNg&quot;;  </div><div class="line"> </div><div class="line">NSString *lowercaseString = [string lowercaseString];  </div><div class="line">NSLog(@&quot;lowercaseString = %@&quot;, lowercaseString);  </div><div class="line">// Output: lowercaseString = THIS IS THE STRING  </div><div class="line"> </div><div class="line">NSString *uppercaseString = [string uppercaseString];  </div><div class="line">NSLog(@&quot;uppercaseString = %@&quot;, uppercaseString);  </div><div class="line">// Output: uppercaseString = this is the string</div></pre></td></tr></table></figure>
<p>上面展示了如何交换两个方法实现，但是在实际使用中，简单的交换两个实现不是非常有用的。毕竟，你为什么要交换<code>lowercaseString</code>和<code>uppercaseString</code>的实现，它们已经做的不错了。你没有任何理由去交换它们。但是同样的方法可以用来给已有的方法添加新功能。假如你想记录调用<code>lowercaseString</code>时的某些信息。同样的办法可以达到这个目的。它需要你去实现一个新的方法并包含你想要的功能，然后通过交换去替代掉原有方法。</p>
<p>可以使用category去添加的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSString (EOCMyAdditions)  </div><div class="line">- (NSString*)eoc_myLowercaseString;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个方法与原有的<code>lowercaseString</code>方法交换，交换后的方法表如图2.5。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.5.png" alt=""></p>
<p>新方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@implementation NSString (EOCMyAdditions)  </div><div class="line">- (NSString*)eoc_myLowercaseString &#123;  </div><div class="line">    NSString *lowercase = [self eoc_myLowercaseString];  </div><div class="line">    NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);  </div><div class="line">    return lowercase;  </div><div class="line">&#125;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这看起来像是会陷入递归调用的死循环，但是要记住它们的实现已经交换了。所以在运行时，当查找<code>eoc_myLowercaseString</code>选择器时，它会调用<code>lowercaseString</code>的实现。最后，交换两个方法的实现，像下面这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Method originalMethod =  </div><div class="line">    class_getInstanceMethod([NSString class],  </div><div class="line">                            @selector(lowercaseString));  </div><div class="line">Method swappedMethod =  </div><div class="line">    class_getInstanceMethod([NSString class],  </div><div class="line">                            @selector(eoc_myLowercaseString));  </div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>从现在起，所有的<code>NSString</code>实例调用<code>lowercaseString</code>方法时，都会在日志中打印出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;ThIs iS tHe StRiNg&quot;;  </div><div class="line">NSString *lowercaseString = [string lowercaseString];  </div><div class="line">// Output: ThIs iS tHe StRiNg =&gt; this is the string</div></pre></td></tr></table></figure>
<p>通过这个方案，开发者可以对那些无法知道实现的方法增加日志输出，这对调试来时是非常有用的。然而此方法也应只在调试模式使用它。很少有人在全局类中使用它。不要因为你能使用它就去用它。过多的使用会使你的代码难以阅读和难以控制。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在运行时可以给类中添加方法或者替换某个指定的选择器的实现。</li>
<li>使用一个方法实现去替代另一个方法实现，叫做<code>Method Swizzling</code>，开发者通常用其为已有方法添加功能。</li>
<li>在调试模式下，通过运行时去修改方法实现是好的做法，但是不能滥用。</li>
</ul>
<h3 id="理解类对象"><a href="#理解类对象" class="headerlink" title="理解类对象"></a>理解类对象</h3><p><code>Objective-C</code>实际上是一门极其动态的语言。第11节讲述了在运行时如何查找一个方法的实现，第12节讲述了当一个类不能响应一个确定的选择器时的转发机制。但是消息接收者是什么：那个对象自身？runtime怎么知道那个对象的类型？在编译时对象的类型并未绑定，而是在运行时确定的。此外，一个特殊的类型<code>id</code>，它可以表示任意的<code>Objective-C</code>对象类型。通常，指定的对象类型是已知的，所以编译器才能在它认为接收者无法接收某条消息时发出警告。相反的，当对象类型是<code>id</code>时，编译器将假定它可以相应所有的消息。</p>
<p>从第12节你可以知道，编译器无法知道一个确定类型到底能理解多少选择器，因为它们可以在运行时动态添加。然而，即使知道可能会在运行时添加方法，编译器也觉得可以在某个头文件中看到方法原型的定义，这样它可以知道完整的方法签名，用于生成消息派发所需的正确代码。</p>
<p>在运行时检查对象的类型也被称作内省，这是一个强大且有用的功能，它作为<code>NSObject</code>协议的一部分内置在<code>Foundation</code>框架中，凡是由公共根类(NSObject与NSProxy)继承来的类都要遵守它。使用这些方法而不是直接对比对象的类是明智的，我将在后面讲述为什么不要直接对比。不过在介绍类型信息查询技术之前，我们先讲一些基础知识，看看<code>Objective-C</code>对象的本质是什么。</p>
<p>每一个<code>Objective-C</code>对象实例指向一块内存区域。这就是为什么当你声明一个变量时，看到类型后面有一个<code>*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *pointerVariable = @&quot;Some string&quot;;</div></pre></td></tr></table></figure>
<p>编过C语言程序的人都知道这是什么意思。对于没写过C语言的程序员来说，<code>pointerVariable</code>是一个存放内存地址的变量，而<code>NSString</code>自身的数据就存于那个地址中。因此这个变量指向<code>NSString</code>实例。所有的<code>Objective-C</code>对象都是这样的；如果想在栈上初始化一个对象，你将会收到一个来自编译器的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String stackVariable = @&quot;Some string&quot;;  </div><div class="line">// error: interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p>通用的对象类型<code>id</code>，它本身就是一个指针，所以你可以这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id genericTypedString = @&quot;Some string&quot;;</div></pre></td></tr></table></figure>
<p>这个定义的语义与<code>NSString*</code>是相同的。它们的区别在于指明类型的情况下，对于这个实例如果你尝试调用一个类中不存在的方法，编译器可以帮助你检查，并且发出警告信息。</p>
<p>在<code>runtime</code>的头文件中，所有的对象的数据结构都是这样定义的，<code>id</code>类型本身也在这定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_object &#123;  </div><div class="line">    Class isa;  </div><div class="line">&#125; *id;</div></pre></td></tr></table></figure>
<p>因此，每个对象的首个成员是<code>Class</code>类型的变量。这个变量定义了对象所属的类型，常常被称为<code>isa</code>指针。例如，刚才的例子中的对象是一个<code>NSString</code>。类对象也定义在<code>runtime</code>的头文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;  </div><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa;  </div><div class="line">    Class super_class;  </div><div class="line">    const char *name;  </div><div class="line">    long version;  </div><div class="line">    long info;  </div><div class="line">    long instance_size;  </div><div class="line">    struct objc_ivar_list *ivars;  </div><div class="line">    struct objc_method_list **methodLists;  </div><div class="line">    struct objc_cache *cache;  </div><div class="line">    struct objc_protocol_list *protocols;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个结构体存放类的元数据，例如类实例的方法实现和实例变量。实际上这个结构体也有一个<code>isa</code>指针，并且是第一个变量，它意味着<code>Class</code>自身也是一个<code>Objective-C</code>对象。这个结构体也有另一个变量，叫做<code>super_class</code>，这个是类的父类。类的类型是另一个类，叫做元类，用来表述类对象本身所具备的元数据。类方法就定义在元类中，因为它可以理解成类对象的实例方法。每个类仅有一个类对象，每个类对象也只有一个元类。</p>
<p>一个叫做<code>someClass</code>的类继承自<code>NSObject</code>，继承链如图2.6。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.6.png" alt=""></p>
<p><strong>Figure 2.6</strong> <code>SomeClass</code>的实例继承链，它继承自<code>NSObject</code>，包含元类的继承。</p>
<p><code>super_class</code>指针确立了继承关系，<code>isa</code>指针则描述了实例所属的类。你可以通过操作这个布局来执行内省(检查对象的类型)。你可以通过它找到一个对象是否可以响应某个确定的选择器并且遵循某个确定的协议，并且确定对象所属类的继承信息。</p>
<h4 id="检查类的继承"><a href="#检查类的继承" class="headerlink" title="检查类的继承"></a>检查类的继承</h4><p>内省方法可以用作去检查类的继承。你可以使用<code>isMemberOfClass:</code>判断一个对象是否是某个确定类的实例，或者使用<code>isKindOfClass:</code>去检查某个对象是否是某个确定类或者任何继承自它的类的实例。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *dict = [NSMutableDictionary new];  </div><div class="line">[dict isMemberOfClass:[NSDictionary class]]; ///&lt; NO </div><div class="line">[dict isMemberOfClass:[NSMutableDictionary class]]; ///&lt; YES </div><div class="line">[dict isKindOfClass:[NSDictionary class]]; ///&lt; YES </div><div class="line">[dict isKindOfClass:[NSArray class]]; ///&lt; NO</div></pre></td></tr></table></figure>
<p>像这种内省类型的原理是通过<code>isa</code>指针获得对象的类，并且使用<code>super_class</code>去遍历整条继承链。由于对象类型是动态的，所以这个功能是非常重要的。<code>Objective-C</code>与你了解的其他语言不同，在<code>Objective-C</code>中，必须查询类型信息，才能完全了解对象的真实类型。</p>
<p>由于<code>Objective-C</code>使用动态类型绑定，所以查询对象所属类的功能是非常有用的。当你从集合中获取对象时，内省是非常常用的，因为它们不是强类型，意思是指当对象是从集合中获取的时候，它们通常是<code>id</code>类型。如果需要知道具体的类型，那么就可以使用内省：例如，想根据数组中存储的对象生成以逗号分隔的字符串，并将其存至文本文件，就可以使用下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array &#123;  </div><div class="line">    NSMutableString *string = [NSMutableString new];  </div><div class="line">    for (id object in array) &#123;  </div><div class="line">        if ([object isKindOfClass:[NSString class]]) &#123;  </div><div class="line">            [string appendFormat:@&quot;%@,&quot;, object];  </div><div class="line">        &#125; else if ([object isKindOfClass:[NSNumber class]]) &#123;  </div><div class="line">            [string appendFormat:@&quot;%d,&quot;, [object intValue]];  </div><div class="line">        &#125; else if ([object isKindOfClass:[NSData class]]) &#123;  </div><div class="line">            NSString *base64Encoded = /* base64 encoded data */;  </div><div class="line">            [string appendFormat:@&quot;%@,&quot;, base64Encoded];  </div><div class="line">        &#125; else &#123;  </div><div class="line">            // Type not supported  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return string;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>去检查类对象的等价性也是可以的。如果你要这样做，那么可以使用<code>==</code>操作符而不要使用你对比对象时常用的<code>isEqual:</code>方法(看第8节)。理由是在一个应用程序中，没个类都是单例，并且每个类仅会有一个类对象存在。因此，另外一种可以准确判断对象是否为某类实例的办法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id object = /* ... */;  </div><div class="line">if ([object class] == [EOCSomeClass class]) &#123;  </div><div class="line">    // &apos;object&apos; is an instance of EOCSomeClass  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使能这样做，你也应该使用内省方法去判断而不是直接调用<code>==</code>操作符，因为内省方法可以完整的处理消息转发(看第12节)的情况。考虑下一个对象将它的所有选择器都转发给另一个对象了，这样的对象叫做代理，并且对于这些类似的对象都以<code>NSProxy</code>为根类。</p>
<p>通常情况下，假如这样的代理对象调用<code>class</code>方法，那将返回代理类(例如：<code>NSProxy</code>的子类)，而非接受的代理的对象所属的类。然而，如果是这样的内省方法，例如<code>isKindOfClass:</code>，那么代理对象会把这个方法转发给接受代理的对象。这意味着这条消息的返回值与直接在接受代理对象上面查询的结果是一样的。因此，这样检查出来的类对象与调用<code>class</code>方法返回的类对象不同，<code>class</code>方法所返回的类表示发起代理的对象，而非接受代理的对象。</p>
<h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul>
<li>每个实例都有一个<code>isa</code>指针，用于表明它的类型与指向类对象，而类对象构成了类的继承链。</li>
<li>当在编译时不能确实对象类型时，应该使用内省去确定对象的具体类型。</li>
<li>应该总是使用内省去检查对象类型，而不是直接对比类对象，因为对象可能实现了消息转发。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第一章</title>
    <link href="http://yoursite.com/2017/04/29/Accustoming%20Yourself%20to%20Objective-C/"/>
    <id>http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/</id>
    <published>2017-04-29T06:48:05.000Z</published>
    <updated>2017-05-18T10:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。</p>
<p>书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。</p>
<h3 id="了解Objective-C的本源"><a href="#了解Objective-C的本源" class="headerlink" title="了解Objective-C的本源"></a>了解Objective-C的本源</h3><p>Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 	Messaging (Objective-C)</div><div class="line">	Object *obj = [Object new];</div><div class="line">	[obj performWith:parameter1 and:parameter2];</div><div class="line">	</div><div class="line">// 	Function calling (C++)</div><div class="line">	Object *obj = new Object;</div><div class="line">	obj-&gt;perform(parameter1, parameter2);</div></pre></td></tr></table></figure>
<p>两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。</p>
<p>Objective-C在运行时做了更多的工作而不是编译时。<code>runtime</code>包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，<code>runtime</code>包含所有内存管理的方法。本质上，<code>runtime</code>是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当<code>runtime</code>更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。</p>
<p>Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure>
<p>这种语法大多来源于C，声明一个叫做<code>someString</code>的变量，类型是<code>NSString *</code>。它的意思是这是一个<code>NSString</code>类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	NSString stackString;</div><div class="line">//	error:interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p><code>someString</code>变量指向某个内存地址，在堆上初始化，包含一个<code>NSString</code>对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div><div class="line">NSString *anotherString = someString;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png" alt=""></p>
<p><strong>Figure 1.1</strong> 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它</p>
<p>这仅有一个<code>NSString</code>实例，但有两个变量指向同它。这两个变量的类型是<code>NSString *</code>，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：<code>NSString</code>实例的内存地址。</p>
<p>图1.1说明了这个结构。<code>NSString</code>实例存储了表示实际字符串所需要的字节。</p>
<p>在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。</p>
<p>Objective-C堆上的内存管理是已经抽象的。你不需要使用<code>malloc</code>和<code>free</code>去初始化和释放对象内存。Objective-C的<code>runtime</code>通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。</p>
<p>有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如<code>CGRect</code>，来源于<code>CoreGraphics</code>框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGRect frame;</div><div class="line">frame.origin.x = 0.0f;</div><div class="line">frame.origin.y = 10.0f;</div><div class="line">frame.size.width = 100.0f;</div><div class="line">frame.siez.height = 150.0f;</div></pre></td></tr></table></figure>
<p><code>CGRect</code>是一个C的结构体，定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGRect &#123;</div><div class="line">	CGRect origin;</div><div class="line">	CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CGRect CGRect;</div></pre></td></tr></table></figure>
<p>这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如<code>CGRect</code>。</p>
<p>在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>Objective-C是C的超集，添加了面向对象的功能。</li>
<li>Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。 </li>
<li>Objective-C是运行时而不是编译时，通过消息决定代码如何运行。</li>
<li>了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。</li>
</ul>
<h3 id="减少在头文件中使用import"><a href="#减少在头文件中使用import" class="headerlink" title="减少在头文件中使用import"></a>减少在头文件中使用import</h3><p>Objective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有<code>.h</code>的是头文件，带有<code>.m</code>的是实现文件。当你创建一个类时，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对所有类来说，导入<code>Foundation.h</code>是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建<code>UIViewController</code>的子类。这些类的头文件将会导入<code>UIKit.h</code>。</p>
<p>目前来讲，这个类的写法是没问题的。它导入了整个<code>Foundation</code>框架，但是并不需要在意。<code>EOCPerson</code>类继承自<code>Foundation</code>框架中的某一个类，它将会使用框架的一大部分功能。继承自<code>UIViewController</code>的类也是一样，它将会使用<code>UIKit</code>框架的一大部分功能。</p>
<p>随着时间的推移，你可能创建了一叫做<code>EOCEmployer</code>的新类。然后你决定一个<code>EOCPerson</code>实例持有一个<code>EOCEmployer</code>实例。所以你提前给它加了一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个问题出现了，当你编译时发现<code>EOCEmployer</code>是缺失的。这个时候编译器一定会提示你在<code>EOCPerson.h</code>中导入<code>EOCEmployer.h</code>。通常你是在<code>EOCPerson.h</code>顶部加入导入的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCEmployer.h&quot;</div></pre></td></tr></table></figure>
<p>这将使他正常编译，但这是一个坏的习惯。因为编译<code>EOCPerson</code>不需要知道<code>EOCEmployer</code>的详细信息。仅需要知道有一个叫做<code>EOCEmployer</code>的类存在即可。幸运的是，有一个办法可以告诉编译器这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@class EOCEmployer;</div></pre></td></tr></table></figure>
<p>这叫做向前声明这个类。这样<code>EOCPerson</code>的头文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCEmployer;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当你为了在实现文件中使用它时，你需要知道<code>EOCEmployer</code>的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line">#import &quot;EOCEmployer.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果<code>EOCEmployer.h</code>是在<code>EOCPerson.h</code>中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。</p>
<p>使用前向声明会缓解两个类互相引用的问题。考虑下当<code>EOCEmployer</code>有两个方法去添加和移除<code>EOCPerson</code>的实例会发生什么，在头文件像这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)addEmployee:(EOCPerson *)person;</div><div class="line">- (void)removeEmployee:(EOCPerson *)person;</div></pre></td></tr></table></figure>
<p>这时，在相反的情况下处于同样的原因，<code>EOCPerson</code>类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用<code>#import</code>而不是<code>#include</code>可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。</p>
<p>有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。</p>
<p>例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCRectangle.h</div><div class="line">#import &quot;EOCShape.h&quot;</div><div class="line">#import &quot;EOCDrawable.h&quot;</div><div class="line"></div><div class="line">@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;</div><div class="line"></div><div class="line">@property (nonatomic, assign) float width;</div><div class="line">@property (nonatomic, assign) float height;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果<code>EOCDrawable</code>协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。</p>
<p>即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即<code>.m</code>中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。</p>
<p>每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。</li>
<li>有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。</li>
</ul>
<h3 id="多使用Literal-Syntax少使用与之等价的方法"><a href="#多使用Literal-Syntax少使用与之等价的方法" class="headerlink" title="多使用Literal Syntax少使用与之等价的方法"></a>多使用Literal Syntax少使用与之等价的方法</h3><hr>
<p>译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。</p>
<hr>
<p>当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用<code>Foundation</code>去书写Objective-C代码，你通常在练习中使用它们。这些类是<code>NSString、NSNumber、NSArray、NSDictionary</code>。它们的数据结构即是它们自身所代表的意思。</p>
<p>众所周知Objective-C拥有冗长的语法。这是真的。然而，自从<code>Objective-C 1.0</code>开始，有一个非常简单的办法去创建一个<code>NSString</code>对象。它被称为<strong>String Literal</strong>并且看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;Effective Objective-C 2.0&quot;;</div></pre></td></tr></table></figure>
<p>这种类型的语法是不存在的，通常创建一个<code>NSString</code>对象是需要调用<code>alloc</code>方法后，调用<code>init</code>方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括<code>NSNumber、NSArray、NSDictionary</code>的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。</p>
<h4 id="Literal-Numbers"><a href="#Literal-Numbers" class="headerlink" title="Literal Numbers"></a>Literal Numbers</h4><p>有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用<code>NSNumber</code>实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</div></pre></td></tr></table></figure>
<p>它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = @1;</div></pre></td></tr></table></figure>
<p>如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有<code>NSNumber</code>实例可以代表的数据类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSNumber *intNumber = @1;</div><div class="line">NSNumber *floatNumber = @2.5f;</div><div class="line">NSNumber *doubleNumber = @3.14159;</div><div class="line">NSNumber *boolNumber = @YES;</div><div class="line">NSNumber *charNumber = @&apos;a&apos;;</div></pre></td></tr></table></figure>
<p>这种Literal Syntax也适用于表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x = 5;</div><div class="line">float y = 6.32f;</div><div class="line">NSNumber *expressionNumber = @(x * y);</div></pre></td></tr></table></figure>
<p>使用Literal Syntax对于数值来说是非常有用的。这样做可以使<code>NSNumber</code>对象更简洁明了，因为声明的大部分是值而不是多余的语法。</p>
<h4 id="Literal-Arrays"><a href="#Literal-Arrays" class="headerlink" title="Literal Arrays"></a>Literal Arrays</h4><p>数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</div></pre></td></tr></table></figure>
<p>使用Literal Syntax之后，仅需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];</div></pre></td></tr></table></figure>
<p>这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用<code>objectAtIndex: method:</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = [animals objectAtIndex:1];</div></pre></td></tr></table></figure>
<p>而使用Literal Syntax，只需要像下面的做法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = animals[1];</div></pre></td></tr></table></figure>
<p>这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。</p>
<p>然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的<a href="https://www.zhihu.com/question/20651624?sort=created" target="_blank" rel="external">语法糖</a>。这个异常看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception </div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;*** </div><div class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to </div><div class="line">insert nil object from objects[0]&apos;</div></pre></td></tr></table></figure>
<p>这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id object1 = /*...*/;</div><div class="line">id object2 = /*...*/;</div><div class="line">id object3 = /*...*/;</div><div class="line">    </div><div class="line">NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];</div><div class="line">NSArray *arrayB = @[object1, object2, object3];</div></pre></td></tr></table></figure>
<p>现在考虑这样一个场景，当<strong>object1</strong>和<strong>object3</strong>指向一个有效的<code>Objective-C</code>对象，但是<strong>object2</strong>是空的。这literal array，<strong>arrayB</strong>，将会抛出一个异常。然而，<strong>arrayA</strong> 仍将会被创建但只包含<strong>object1</strong>对象。原因是<code>arrayWithObjects:</code>方法添加参数，遇到nil终止，这比预想的结束的早。</p>
<p>这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。</p>
<h4 id="Literal-Dictionaries"><a href="#Literal-Dictionaries" class="headerlink" title="Literal Dictionaries"></a>Literal Dictionaries</h4><p>字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是<code>Objective-C</code>代码中常用的。创建一个使用是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:</div><div class="line">		@&quot;Matt&quot;, @&quot;firstName&quot;, </div><div class="line">		@&quot;Galloway&quot;, @&quot;lastName&quot;, </div><div class="line">		[NSNumber numberWithInt:28], @&quot;age&quot;, </div><div class="line">		nil];</div></pre></td></tr></table></figure>
<p>这令人相当困惑，因为这顺序是<strong>object, key, object, key, …</strong>。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = </div><div class="line">	@&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, </div><div class="line">	  @&quot;lastName&quot; : @&quot;Galloway&quot;, </div><div class="line">	  @&quot;age&quot; : @28&#125;;</div></pre></td></tr></table></figure>
<p>这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是<code>Objective-C</code>对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个<code>NSNumber</code>实例中。但是Literal Syntax意味着它只是一个额外的字符。</p>
<p>就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于<code>dictionaryWithObjectsAndKeys:</code>方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。</p>
<p>另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = [personData objectForKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>与之等价的Literal Syntax是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = personData[@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。</p>
<h4 id="Mutable-Arrays-and-Dictionaries"><a href="#Mutable-Arrays-and-Dictionaries" class="headerlink" title="Mutable Arrays and Dictionaries"></a>Mutable Arrays and Dictionaries</h4><p>以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];</div><div class="line">[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>通过Literal Syntax设置时这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutableArray[1] = @&quot;dog&quot;;</div><div class="line">mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;;</div></pre></td></tr></table></figure>
<h4 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h4><p>使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于<code>NSArray、NSNumber、NSDictionary</code>是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用<code>NSString</code>类。</p>
<p>同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，<code>mutableCopy</code>必须被调用，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy];</div></pre></td></tr></table></figure>
<p>它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。</li>
<li>通过下标法访问数组或者字典。</li>
<li>使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。</li>
</ul>
<h3 id="优先使用类型常量，减少使用-define预处理"><a href="#优先使用类型常量，减少使用-define预处理" class="headerlink" title="优先使用类型常量，减少使用#define预处理"></a>优先使用类型常量，减少使用#define预处理</h3><p>在写代码时，你经常想去定义一个常量。例如，一个<code>UIView</code>类出现和消失时它自身的动画。你可能想定义一个常量来代表动画持续的时间。你已经学会了<code>Objective-C</code>和<code>C</code>的基础，所以你决定使用的方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ANIMATION_DURATION 0.3</div></pre></td></tr></table></figure>
<p>这是一个预处理指定；每当在你的代码中出现<code>ANIMATION_DURATION</code>字符，就用0.3替代。这看起来就是你想要的，但是这种定义没有类型信息。它就像是声明了一个叫做“duration”的事物意指它的value与时间有关系，但它并不是明确的。并且，它会将所有<code>ANIMATION_DURATION</code>替换掉，如果它声明在头文件中，别的任何导入了这个头文件的类都将被替代。</p>
<p>为了解决这个问题，你应该使用编译器。有一个比使用预处理更好的办法，去定义一个常量。例如，下面这种定义常量类型为<code>NSTimeInterval</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>注意这种格式，它是有类型信息的，这种用法是好的，因为我们可以清楚地知道常量的定义。它的类型是<code>NSTimeInterval</code>，并且它有助于指出变量的使用。如果你定义了许多常量，它将会帮助以后阅读代码的人。</p>
<p>也会指出这个变量如何命名的。通常的惯例是在常量前面加上小写字母<code>k</code>（加k的原因据说是constant的首字母读音，或者德语一般写作konstant）并将其放置在实现文件中。对于需要暴露给其它类的常量，通常使用其类名作为前缀。第19节展示了更多的命名标准。</p>
<p>在哪里定义常量是重要的。有时，使用预处理定义常量是诱人的，但这是一个坏的习惯，特别是命名方式没有遵循标准的时候，它们不会冲突。例如：<code>ANIMATION_DURATION</code>常量定义在头文件是一个坏的命名。它将显示在所有导入了这个头文件的文件中。甚至作为标准的<code>static const</code>也不该出现在头文件中。自从<code>Objective-C</code>不使用命名空间（namespaces），上面的代码将会声明一个叫做<code>kAnimationDuration</code>的全局变量。它的名字前缀应该使用其所作用的类的名字，例如<code>EOCViewClassAnimationDuration</code>。第19节展示了更多的关于使用清晰命名的方案。</p>
<p>一个不需要暴露给外界的常量，应该在需要使用它的实现文件中定义。例如，如果那个动画持续时间的常量被用在一个<code>UIView</code>的子类，子类在一个iOS应用中，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//EOCAnimatedView.h</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface EOCAnimatedView : UIView</div><div class="line">- (void)animate;</div><div class="line">@end</div><div class="line"></div><div class="line">//EOCAnimatedView.m</div><div class="line">#import &quot;EOCAnimatedView.h&quot;</div><div class="line"></div><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div><div class="line"></div><div class="line">@implementation EOCAnimatedView</div><div class="line">- (void)animate &#123;</div><div class="line">    </div><div class="line">    [UIView animateWithDuration:kAnimationDuration</div><div class="line">                     animations:^()&#123;</div><div class="line">                     	//  Perform animations</div><div class="line">                     &#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用<code>static const</code>声明常量是重要的。使用<code>const</code>修饰符代表如果你试图在之后修改值，编译器将会报错。在这种情况下，这种做法是必需的。这个值不应该被改变。<code>static</code>修饰符的意思是其作用范围在定义它的编译单元内。编译器将其接收到的内容编译成一个目标文件，这个目标文件就是编译单元。在<code>Objective-C</code>中，每一个编译单元就是每一个实现文件。所以在前面的例子中，<code>kAnimationDuration</code>将被声明在<code>EOCAnimatedView.m</code>生成的目标文件中。如果变量没有使用<code>static</code>修饰，编译器将会创建一个外部符号给它。如果另一个编译单元也声明了一个相同名字的变量，将会抛出一个类似的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _ kAnimationDuration in:</div><div class="line">	EOCAnimatedView.o</div><div class="line">	EOCOtherView.o</div></pre></td></tr></table></figure>
<p>实际上，当使用<code>static</code>和<code>const</code>声明一个变量时，编译器最终不会创建一个符号，而是使用存在的值去替代变量，就像宏定义一样。谨记，无论如何，显示类型信息的做法是更好的。</p>
<p>有时，你会想给外部暴漏一个常量。例如，如果你的类使用<code>NSNotificationCenter</code>通知别的类，你可能想这样做。这个功能是一个对象发送通知，另一个对象注册并接收它。通知有一个字符串做名字，并且你可能将其声明为一个外部可见的常量。这样做的意思是可以让任何一个想去注册接收通知的类不需要知道实际的字符名字，而仅使用这个常量。</p>
<p>这种常量需要出现在全局的符号表中，从而可以在声明它之外的编译单元使用。因此，这些常量需要声明在不同与<code>static const</code>示例的地方。这个变量应该像这样被声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// In the header file</div><div class="line">extern NSString *const EOCStringConstant;</div><div class="line"></div><div class="line">// In the implementation file</div><div class="line">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</div></pre></td></tr></table></figure>
<p>这个常量声明在头文件，定义在实现文件。在常量类型中，<code>const</code>修饰符是非常重要的。这些声明是从后向前读的，意思是在这种情况下，<code>EOCStringConstant</code>是一个常量指向一个字符串。这正是我们想要的；常量不允许修改所指向的字符串对象。</p>
<p>当编译器在文件中发现一个<code>extern</code>修饰的常量被使用时，<code>extern</code>关键字会告诉编译器，在导入的类中去寻找。这个关键字告诉编译器在全局符号表中有一个<code>EOCStringConstant</code>的符号。这意味着编译器可以不知道常量的定义而去使用它。编译器简单的知道当文件链接为二进制文件时常量是存在的。</p>
<p>常量必须被定义并且仅定义一次。它通常定义在实现文件，声明在它的头文件。编译器将会为从实现文件生成的目标文件的数据段中的字符串分配存储空间。无论它在哪里被使用，当这个目标文件跟其他文件链接生成最后的二进制时，链接器都将能找到它的全局符号。</p>
<p>实际上，符号出现在全局符号表的意思是你应该小心常量的命名。例如，一个处理登录的类会在登录后对整个应用发送一个通知。这个通知看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// EOCLoginManager.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">extern NSString *const EOCLoginManagerDidLoginNotification;</div><div class="line"></div><div class="line">@interface EOCLoginManager : NSObject</div><div class="line">- (void)login;</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCLoginManager.m</div><div class="line">#import &quot;EOCLoginManager.h&quot;</div><div class="line"></div><div class="line">NSString *const EOCLoginManagerDidLoginNotification =</div><div class="line">	@&quot;EOCLoginManagerDidLoginNotification&quot;;</div><div class="line"></div><div class="line">@implementation EOCLoginManager</div><div class="line"></div><div class="line">- (void)login &#123;</div><div class="line">    // Perfoem login asynchronously, then call &apos;p_didLogin&apos;.</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_didLogin &#123;</div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter]</div><div class="line">      postNotificationName:EOCLoginManagerDidLoginNotification</div><div class="line">      					object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意常量的名字。常量前缀使用类的名字是谨慎的并且可以帮助你去避免冲突。这在整个系统框架中都是常见的。<code>UIKit</code>，例如，将通知名称以相同的办法声明为全局常量。这些名字包括<code>UIApplicationDidEnterBackgroundNotification</code>和<code>UIApplicationWillEnterForegroundNotification</code>.</p>
<p>其它类型的常量同样可以这样做。如果动画持续时间需要暴露在<code>EOCAnimatiedView</code>类之外，在上面的例子中，你可以这样声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//EOCAnimatedView.h</div><div class="line">extern const NSTimeInterval kAnimationDuration;</div><div class="line"></div><div class="line">//EOCAnimatedView.m</div><div class="line">const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>用这种方法定义一个常量是优于使用宏定义的，因为编译器可以确定这个值不能被改变。在<code>EOCAnimatedView.m</code>定义一次，它的值可以在任何地方使用。一个宏定义可以重复定义，意味着一个程序的不同部分可能使用了不同的值。</p>
<p>综上所述，对于常量避免使用宏定义。相反，使用编译器可以观察的常量，如在实现文件中使用<code>static</code>、<code>const</code>声明常量。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>避免宏定义。它们不包含任何类型信息并且可以在编译前被简单的查找替换。它们可以重新定义并且没有警告，使得整个应用的值不一致。</li>
<li>使用<code>static</code>、<code>const</code>在实现文件中定义特定编译单元的常量。这些常量将不会被暴露在全局字符表中，所以它们的名字不需要命名空间。</li>
<li>使用<code>extern</code>在头文件声明它们，在关联的实现文件定义它们。这些常量将出现在全局字符表，所以它们的名字应该需要命名空间，通常使用类名作为前缀是合理的。</li>
</ul>
<h3 id="使用枚举表示状态、选项、状态码"><a href="#使用枚举表示状态、选项、状态码" class="headerlink" title="使用枚举表示状态、选项、状态码"></a>使用枚举表示状态、选项、状态码</h3><p>因为<code>Objective-C</code>是基于<code>C</code>的，<code>C</code>的所有功能<code>Objective-C</code>都是适用的。其中一个就是枚举类型，<code>enum</code>。它在系统框架中被广泛使用，但是常常被开发者忽略。它用于定义命名常量是非常有用的，例如，错误状态码和定义选项是可以组合的。感谢<code>C++11</code>标准支持了它，最近的系统版本包含枚举类型。是的，<code>Objective-C</code>也得益于<code>C++11</code>的标准。</p>
<p>枚举仅仅是命名常量的一种方法。一个简单的枚举集合可以用来表示一个对象的状态。例如，一个socket链接使用枚举表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用一个枚举意味着代码是可读的，因为每一个状态可以通过一个易读的值去代表。在枚举中编译器给每个成员一个唯一的值，从0开始每个成员加1。这种枚举是依靠编译器支持的但需要足够的位数去表示枚举。在前面的枚举中，仅需要1个字节就够了，因为它的最大值是2。</p>
<p>然而定义枚举变量的方式却不太简洁，需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure>
<p>如果每次不用使用<code>enum</code>只使用<code>EOCConnectionState</code>就好了。为了这样做，你添加一个<code>typedef</code>给枚举定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef enum EOCConnectionState EOCConnectionState;</div></pre></td></tr></table></figure>
<p>它的意思是使用<code>EOCConnectionState</code>代替<code>enum EOCConnectionState</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure>
<p><code>C++11</code>标准的问世给枚举带来了一些变化。其中一个变化是可以决定使用哪种“数据类型”去存储枚举类型。这样做的好处是可以使用向前声明了。如果不指定数据类型，枚举类型无法使用向前声明，因为编译器无法知道数据类型的大小。因此，当用到枚举类型时，编译器无法知道应该给变量分配多大的空间。</p>
<p>给枚举指定数据类型，你可以使用下面这种语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger &#123; /*...*/&#125;;</div></pre></td></tr></table></figure>
<p>上面代码的意思是保证枚举的变量类型是<code>NSInteger</code>。如果你乐意，这种类型的向前声明可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger;</div></pre></td></tr></table></figure>
<p>你可以给枚举成员定义一个确切的值，而不是让编译器帮你指定。这语法看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected = 1,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这意思是<code>EOCConnectionStateDisconnected</code>的值为1而不是0.别的成员变量的值同之前一样，依次递增1。例如，<code>EOCConnectionStateConnected</code>的值就是3。</p>
<p>另一种使用枚举类型的情况是去定义选项，特指当选项可以组合在一起时。只要当各选项定义的对，那么就可以使用“按位或运算符”去组合它们。例如，考虑下面的枚举类型，在<code>iOS</code>的<code>UI</code>框架中，用来表示某个视图如何调整大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing &#123;</div><div class="line">    UIViewAutoresizingNone                 = 0,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每一个选项都可以开启或者关闭，使用上面的语法可以控制它因为每个选项都仅有单一的一位值去代表它自身。使用“按位或操作”可以组合多个选项。例如：<code>UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight</code>。图1.2展示了每个枚举成员和组合两个成员后的位布局。</p>
<p>通过“按位与操作”是可以判断出某个选项是否启用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing resizing =  </div><div class="line">    UIViewAutoresizingFlexibleWidth |  </div><div class="line">    UIViewAutoresizingFlexibleHeight;  </div><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;  </div><div class="line">       // UIViewAutoresizingFlexibleWidth is set  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.2.png" alt=""></p>
<p><strong>图1.2</strong>每个选项值的二进制表示形式，以及两个选项值运用“按位或运算”之后的二进制形式。</p>
<p>枚举在系统框架中使用非常广泛。另一个例子是<code>iOS</code>中的<code>UIKit</code>框架中的，用枚举值列举视图所支持的方向并告诉系统。它使用一个叫做<code>UIInterfaceOrientationMask</code>的枚举类型来实现，并且你可以实现一个叫做<code>supportedInterfaceOrientations</code>的方法去告诉系统视图所支持的方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)supportedInterfaceOrientations &#123;  </div><div class="line">  return UIInterfaceOrientationMaskPortrait |  </div><div class="line">         UIInterfaceOrientationMaskLandscapeLeft;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Foundation</code>框架中有一些辅助宏定义，用这些宏定义可以指定枚举值的数据类型。它们提供了向后兼容性，当编译器支持新的语法特性时，它们使用新的语法；当编译器只支持旧语法特性时，它们使用旧的语法特性。这些宏是由<code>#define</code>预处理指令定义的。一个支持像<code>EOCConnectionState</code>这种普通类型的枚举，另一个支持像<code>UIViewAutoresizing</code>这种一系列选项的枚举。你可以像下面这样使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123;  </div><div class="line">    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,  </div><div class="line">    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,  </div><div class="line">    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,  </div><div class="line">    EOCPermittedDirectionRight = 1 &lt;&lt; 3,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些宏的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L&amp;&amp;  </div><div class="line">        (__has_extension(cxx_strong_enums) ||  </div><div class="line">         __has_feature(objc_fixed_enum))  </div><div class="line">    ) ||  </div><div class="line">    (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))  </div><div class="line">    #define NS_ENUM(_type, _name)  </div><div class="line">           enum _name : _type _name; enum _name : _type  </div><div class="line">    #if (__cplusplus)  </div><div class="line">        #define NS_OPTIONS(_type, _name)  </div><div class="line">               type _name; enum : _type  </div><div class="line">    #else  </div><div class="line">        #define NS_OPTIONS(_type, _name)  </div><div class="line">               enum _name : _type _name; enum _name : _type  </div><div class="line">    #endif  </div><div class="line">#else  </div><div class="line">    #define NS_ENUM(_type, _name) _type _name; enum  </div><div class="line">    #define NS_OPTIONS(_type, _name) _type _name; enum  </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>由于要处理不同的情况所以要用多种方式去定义两个宏。第一个判断是检查编译器是否支持新式枚举的特性。这个布尔逻辑看起来相当复杂，但它的意思就是判断编译器是否支持新特性。如果不支持，那么就用老的方式。</p>
<p>如果新特性是可用的，那么<code>NS_ENUM</code>宏所定义的类型展开后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectionState : NSUInteger EOCConnectionState;  </div><div class="line">enum EOCConnectionState : NSUInteger &#123;  </div><div class="line">    EOCConnectionStateDisconnected,  </div><div class="line">    EOCConnectionStateConnecting,  </div><div class="line">    EOCConnectionStateConnected,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>NS_OPTIONS</code>宏的展开是取决于编译形式的。如果以<code>C++</code>形式编译，那么<code>NS_OPTIONS</code>宏展开与<code>NS_ENUM</code>宏展开是不一样的，否则是一样的。为什么？因为<code>C++</code>环境下两个枚举值通过<code>按位或运算</code>结果与非<code>C++</code>环境下是不同的。前面已经提到了，作为选项的枚举值经常会通过<code>按位或运算</code>进行组合。当两个值通过<code>按位或运算</code>后，<code>C++</code>认为它们所代表的值类型是<code>NSUInteger</code>。并且也不允许饮食转换为枚举类型。为了说明这个，我们考虑将<code>EOCPermittedDirection</code>以<code>NS_ENUM</code>形式展开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCPermittedDirection : int EOCPermittedDirection;  </div><div class="line">enum EOCPermittedDirection : int &#123;  </div><div class="line">    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,  </div><div class="line">    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,  </div><div class="line">    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,  </div><div class="line">    EOCPermittedDirectionRight = 1 &lt;&lt; 3,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCPermittedDirection permittedDirections =  </div><div class="line">    EOCPermittedDirectionLeft | EOCPermittedDirectionUp;</div></pre></td></tr></table></figure>
<p>当在<code>C++</code>或者<code>Objective-C++</code>环境下，将会出现下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error: cannot initialize a variable of type  </div><div class="line">&apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos;</div></pre></td></tr></table></figure>
<p>你必须将通过<code>按位或操作</code>的结果显示的转化为<code>EOCPermittedDirection</code>。所以，在<code>C++</code>的环境下应该使用<code>NS_OPTIONS</code>，省去显示转化这一步。因此，如果需要<code>按位或操作</code>的枚举值应当尽量使用<code>NS_OPTIONS</code>，而不需要的，则使用<code>NS_ENUM</code>。</p>
<p>枚举可以用在很多情况下。选项和状态已经在前面讲过了；然后更多的情况同样适用。对错误使用状态码是一个好的习惯。把逻辑含义相似的代码放入一个枚举中，用于替代使用预定义和常量。另一个好的地方是样式。例如，你有一个<code>UI</code>元素可以创建不同的样式，一个枚举集合可以完美的表示每个样式。</p>
<p>最后一点是关于在<code>switch</code>中使用枚举变量。又是，你会这样定义它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;  </div><div class="line">    EOCConnectionStateDisconnected,  </div><div class="line">    EOCConnectionStateConnecting,  </div><div class="line">    EOCConnectionStateConnected,  </div><div class="line">&#125;;  </div><div class="line"> </div><div class="line">switch (_currentState) &#123;  </div><div class="line">    EOCConnectionStateDisconnected:  </div><div class="line">        // Handle disconnected state  </div><div class="line">        break;  </div><div class="line">    EOCConnectionStateConnecting:  </div><div class="line">        // Handle connecting state  </div><div class="line">        break;  </div><div class="line">    EOCConnectionStateConnected:  </div><div class="line">        // Handle connected state  </div><div class="line">        break;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们习惯在<code>switch</code>语句中加上默认分支。然而，当使用枚举值表示状态时，最好不要写一个默认分支。这样做的原因是，当你在稍后添加了一个新的状态，那么编译器将会警告你，提示你有新的状态未加入<code>switch</code>分支。如果有一个默认的分支，编译器将会处理它，那么编译器将不会发出警告。这个问题同样适用于别的使用<code>NS_ENUM</code>的定义中。例如，你定义一个<code>UI</code>元素，你将会希望每个情况都有一个确定的样式。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用枚举来表示状态机的状态，传递给函数的选项，或者错误码，并且起一个易读的名字。</li>
<li>如果把一个传递给方法的选项表示为枚举类型，同时还需要多重操作，可以将它们的值设为2的幂，然后通过<code>按位或操作</code>将其组合起来。</li>
<li>使用<code>NS_ENUM</code>和<code>NS_OPTIONS</code>宏最好给枚举定义一个明确的数据类型。这样做的意思是确定枚举的数据类型是开发者设置的，而不是编译器指定的。</li>
<li>在<code>switch</code>中使用枚举时，不要设置默认分支。这样在你添加新枚举后，编译器会提醒你添加新分支。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>基本内容图解</title>
    <link href="http://yoursite.com/2017/04/17/BasePrinciple_Img/"/>
    <id>http://yoursite.com/2017/04/17/BasePrinciple_Img/</id>
    <published>2017-04-17T11:32:16.000Z</published>
    <updated>2017-04-17T11:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Some principle！！！</p>
<a id="more"></a>
<p>最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解:<img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E7%BC%96%E8%AF%91%E5%9E%8B:%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.jpeg" alt=""></p>
<p>就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后…<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpeg" alt=""></p>
<p>突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6.png" alt=""></p>
<p>对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Some principle！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://yoursite.com/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码解析</title>
    <link href="http://yoursite.com/2017/03/14/Weex_3/"/>
    <id>http://yoursite.com/2017/03/14/Weex_3/</id>
    <published>2017-03-14T11:26:52.000Z</published>
    <updated>2017-03-24T04:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0</p>
<a id="more"></a>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。</p>
<p>WeexDemo的入口是<code>[WXSDKEngine initSDKEnvironment];</code>。这个Method的主要代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];</div><div class="line">NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">[WXSDKEngine initSDKEnvironment:script];</div></pre></td></tr></table></figure>
<p>首先，读取一个叫做main.js的文件内容，然后将其内容作为<code>[WXSDKEngine initSDKEnvironment:script]</code>初始化的参数。<br>我们继续来看这个method的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!script || script.length &lt;= 0) &#123;</div><div class="line">        WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;);</div><div class="line">        return;</div><div class="line">&#125;</div><div class="line">[self registerDefaults];</div><div class="line">[[WXSDKManager bridgeMgr] executeJsFramework:script];</div></pre></td></tr></table></figure>
<h3 id="注册和执行"><a href="#注册和执行" class="headerlink" title="注册和执行"></a>注册和执行</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>首先，是对传递进来的js代码做判断，其次调用了一个<code>registerDefaults</code>的method，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    [self _registerDefaultComponents];</div><div class="line">    [self _registerDefaultModules];</div><div class="line">    [self _registerDefaultHandlers];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="Register-Componet"><a href="#Register-Componet" class="headerlink" title="Register Componet"></a>Register Componet</h5><p>这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz</div><div class="line">&#123;</div><div class="line">    [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties</div><div class="line">&#123;</div><div class="line">    if (!name || !clazz) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">    [WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</div><div class="line">    NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name];</div><div class="line">    dict[@&quot;type&quot;] = name;</div><div class="line">    if (properties) &#123;</div><div class="line">        NSMutableDictionary *props = [properties mutableCopy];</div><div class="line">        if ([dict[@&quot;methods&quot;] count]) &#123;</div><div class="line">            [props addEntriesFromDictionary:dict];</div><div class="line">        &#125;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[props]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。<code>@&quot;append&quot;:@&quot;tree&quot;</code>代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，<code>@&quot;append&quot;:@&quot;node&quot;</code>代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用<code>WXComponentFactory</code>进行注册，在这之前先讲几个相关类的功能，免得迷糊。</p>
<ul>
<li>WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承</li>
<li>WXComponentConfig: 继承<code>WXInvocationConfig</code>类，存储每个Component的method、name、classname</li>
<li>WXComponentFactory：单例类，通过字典存储<code>WXComponentConfig</code>对象，通过每个<code>WXComponentConfig</code>对象操作每个Component的method、name、classname。</li>
</ul>
<p>首先通过<code>WXComponentFactory</code>调用<code>- (void)registerComponent:(NSString 
*)name withClass:(Class)clazz withPros:(NSDictionary *)pros</code>方法注册。使用Assert判断，然后创建一个<code>WXComponentConfig</code>对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用<code>[config registerMethods];</code>将类中的method通过runtime存储在<code>WXComponentConfig</code>中，存取时加锁保证安全。其次调用<code>- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name</code>方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法<code>registerComponents</code>，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">export function registerComponents (newComponents) &#123;</div><div class="line">  if (Array.isArray(newComponents)) &#123;</div><div class="line">    newComponents.forEach(component =&gt; &#123;</div><div class="line">      if (!component) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      if (typeof component === &apos;string&apos;) &#123;</div><div class="line">        components[component] = true</div><div class="line">      &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123;</div><div class="line">        components[component.type] = component</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Register-Module"><a href="#Register-Module" class="headerlink" title="Register Module"></a>Register Module</h5><p>注册Module，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;);   </div><div class="line">NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];</div><div class="line">NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];</div><div class="line">[[WXSDKManager bridgeMgr] registerModules:dict];</div></pre></td></tr></table></figure>
<p>先介绍几个类：</p>
<ul>
<li>WXModuleConfig：继承<code>WXInvocationConfig</code>类，存储每个Component的method、name</li>
<li>WXModuleFactory：单例类，通过字典操作<code>WXModuleConfig</code>对象</li>
</ul>
<p>查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法<code>registerModules</code>。</p>
<h5 id="Register-Handler"><a href="#Register-Handler" class="headerlink" title="Register Handler"></a>Register Handler</h5><p>注册Handler，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">[WXHandlerFactory registerHandler:handler withProtocol:protocol];</div></pre></td></tr></table></figure>
<p>照例介绍几个类：</p>
<ul>
<li>WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储</li>
</ul>
<p>注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。</p>
<h4 id="ExecuteJs"><a href="#ExecuteJs" class="headerlink" title="ExecuteJs"></a>ExecuteJs</h4><p>最后调用<code>[[WXSDKManager bridgeMgr] executeJsFramework:script];</code>执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。</p>
<p>首先介绍几个类：</p>
<ul>
<li>WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能</li>
<li>WXSDKManager：单例类，通过一个字典存储所有<code>WXSDKInstance</code>实例，key是一个唯一值；一个<code>WXBridgeManager</code>实例</li>
<li>WXBridgeManager：单例类，注册，渲染功能都通过调用<code>WXBridgeContext</code>对象去跟JS交互</li>
<li>WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。</li>
<li>WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使<code>WXBridgeContext</code>调用</li>
</ul>
<p>现在可以从那句代码开始讲了，<code>[WXSDKManager bridgeMgr]</code>这个对象是一个单例，他在JS线程调用<code>executeJsFramework</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (!script) return;</div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">WXPerformBlockOnBridgeThread(^()&#123;</div><div class="line">    [weakSelf.bridgeCtx executeJsFramework:script];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>先是判空，其次weakSelf防止循环引用，然后在一个叫做<code>&quot;com.taobao.weex.bridge&quot;</code>的线程调用<code>executeJsFramework</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">WXAssertBridgeThread();</div><div class="line">WXAssertParam(script);</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_START(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">[self.jsBridge executeJSFramework:script];</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_END(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">if ([self.jsBridge exception]) &#123;</div><div class="line">    NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]];</div><div class="line">    WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);</div><div class="line">&#125; else &#123;</div><div class="line">    WX_MONITOR_SUCCESS(WXMTJSFramework);</div><div class="line">    //the JSFramework has been load successfully.</div><div class="line">    self.frameworkLoadFinished = YES;</div><div class="line">    </div><div class="line">    [self executeAllJsService];</div><div class="line">    </div><div class="line">    JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil];</div><div class="line">    if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123;</div><div class="line">        [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //execute methods which has been stored in methodQueue temporarily.</div><div class="line">    for (NSDictionary *method in _methodQueue) &#123;</div><div class="line">        [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [_methodQueue removeAllObjects];</div><div class="line">    </div><div class="line">    WX_MONITOR_PERF_END(WXPTInitalize);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先断言当前线程是否是<code>&quot;com.taobao.weex.bridge&quot;</code>线程，其次断言js代码，使用<code>WXBridgeProtocol</code>协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。</p>
<h3 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h3><h4 id="JavaScriptCore简介"><a href="#JavaScriptCore简介" class="headerlink" title="JavaScriptCore简介"></a>JavaScriptCore简介</h4><p>上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。</p>
<ul>
<li>JSVirtualMachine：为JavaScript提供运行资源</li>
<li>JSContext：为JavaScript提供运行环境</li>
<li>JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量</li>
</ul>
<h4 id="JavaScriptCore示例"><a href="#JavaScriptCore示例" class="headerlink" title="JavaScriptCore示例"></a>JavaScriptCore示例</h4><p>这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了：</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];</div><div class="line">NSLog(@&quot;%@&quot;, value); 输出5</div><div class="line">context[@&quot;sum&quot;] = @&quot;40&quot;;</div><div class="line">NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40</div></pre></td></tr></table></figure>
<p>首先初始化一个JSContext对象，可以使用<code>JSVirtualMachine</code>对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个<code>JSVirtualMachine</code>对象，所以这个js运行的资源，不可或缺。</p>
<p>第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。</p>
<p>第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。</p>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</div><div class="line">        context.exception = exception;</div><div class="line">        NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另一个要注意的点就是这里，JavaScriptCore会在<code>exceptionHandler</code>中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用<code>[JSContext currentContext]</code>获取当前的context。如果直接引用外部的context会造成循环饮用。</p>
<h5 id="invokeMethod"><a href="#invokeMethod" class="headerlink" title="invokeMethod"></a>invokeMethod</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;];    </div><div class="line">JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];</div><div class="line">NSLog(@&quot;%@&quot;, sum); 输出7</div></pre></td></tr></table></figure>
<p>初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexCallJS.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码文件夹的解释</title>
    <link href="http://yoursite.com/2017/03/14/Weex_2/"/>
    <id>http://yoursite.com/2017/03/14/Weex_2/</id>
    <published>2017-03-14T08:01:24.000Z</published>
    <updated>2017-03-15T03:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0</p>
<a id="more"></a>
<h3 id="Weex文件夹"><a href="#Weex文件夹" class="headerlink" title="Weex文件夹"></a>Weex文件夹</h3><pre><code>*最不重要的文件夹：Controller、Debug、Handler
*不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket
*稍微重要的文件夹：Component、Module、Protocol
*重要的文件夹：Display、Events、Layout、View
*最重要的文件夹：Bridge、Engine、Manager、Model
</code></pre><blockquote>
<p>Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油；</p>
<p>Debug：一个调试类，酱油；</p>
<p>Handler：两个类实现了两个Weex的Protocol，酱油；</p>
<p>Loader：一个类是Network的回调实现，一个类是WebSocket的回调。</p>
<p>Monitor：一个监测的类，输出一些信息。</p>
<p>Network:一个小型的网络请求库</p>
<p>Utility：一些常用方法的封装</p>
<p>WebSocket：对SRWebSocket的封装</p>
<p>Componet：对各种view的封装，如果需要扩展view就跟这个有关</p>
<p>Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method</p>
<p>Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。</p>
<p>Display：WXComponent的展示</p>
<p>Events：WXComponent的事件</p>
<p>Layout：WXComponent的布局</p>
<p>View：WXComponent的View</p>
<p>Bridge：Weex与NativeJS之间的桥接</p>
<p>Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等</p>
<p>Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。</p>
<p>Manager：Weex中各种管理的类</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Book</title>
    <link href="http://yoursite.com/2017/02/26/ReadBook_iOS/"/>
    <id>http://yoursite.com/2017/02/26/ReadBook_iOS/</id>
    <published>2017-02-26T11:03:08.000Z</published>
    <updated>2017-04-01T03:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS相关书籍…</p>
<a id="more"></a>
<ol>
<li><strong>《iOS7应用开发技术详解》</strong>在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如<strong>14.2</strong>手势事件、<strong>11.3.5</strong>的<code>UIViewAutoresizing</code>等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看<strong>16</strong>、<strong>17</strong>章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。</li>
<li><strong>《iOS开发进阶》</strong>这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。</li>
<li><strong>《Objective-C高级编程》</strong>这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西<code>引用计数</code>，<code>Block</code>，<code>GCD</code>。<code>引用计数</code>这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；<code>Block</code>这块主要看的是clang rewrite 之后的代码；<code>GCD</code>是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS相关书籍…&lt;/p&gt;
    
    </summary>
    
      <category term="ReadBook" scheme="http://yoursite.com/categories/ReadBook/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex的简单使用</title>
    <link href="http://yoursite.com/2017/02/01/Weex_1/"/>
    <id>http://yoursite.com/2017/02/01/Weex_1/</id>
    <published>2017-02-01T08:33:44.000Z</published>
    <updated>2017-03-24T10:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解一下Weex的大概原理以及简单的使用</p>
<a id="more"></a>
<h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><ul>
<li>与RN相同原理，某些方面优于RN</li>
<li>js语法，比Native体验稍差，比hybrid app体验好太多</li>
<li>js一端代码，三端使用</li>
<li>iOS/Android脱离写UI的噩梦</li>
<li>文档不够完善</li>
</ul>
<h3 id="Weex原理"><a href="#Weex原理" class="headerlink" title="Weex原理"></a>Weex原理</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexTree.png" alt=""></p>
<h3 id="Weex使用"><a href="#Weex使用" class="headerlink" title="Weex使用"></a>Weex使用</h3><ul>
<li>首先，在<code>AppDelegate</code>中调用<code>[WXSDKEngine initSDKEnvironment]</code>进行注册</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line"></div><div class="line">    [WXSDKEngine initSDKEnvironment];    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其次，在需要使用的ViewController中定义一个<code>WXSDKInstance</code>实例和UI个<code>UIView</code>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) WXSDKInstance *instance;</div><div class="line">@property (nonatomic) UIView *weexView;</div></pre></td></tr></table></figure>
<ul>
<li>紧接着，初始化<code>WXSDKInstance</code>实例，设置它的viewController、frame属性，实现它的生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">_instance = [[WXSDKInstance alloc] init];</div><div class="line">_instance.viewController = self;</div><div class="line">_instance.frame = [UIScreen mainScreen].bounds;</div><div class="line">    </div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">_instance.onCreate = ^(UIView *view) &#123;</div><div class="line">    [weakSelf.weexView removeFromSuperview];</div><div class="line">    weakSelf.weexView = view;</div><div class="line">    [weakSelf.view addSubview:weakSelf.weexView];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onFailed = ^(NSError *error) &#123;</div><div class="line">    NSLog(@&quot;failed %@&quot;,error);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.renderFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;render finish&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onRenderProgress = ^(CGRect renderRect) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;renderProgress&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.updateFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;update Finish&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>最后，使用<code>WXSDKInstance</code>实例调用<code>renderWithURL:</code>方法即可。记得在<code>dealloc</code>中释放<code>WXSDKInstance</code>实例哦😯</li>
</ul>
<p><code>[self.instance renderWithURL:[NSURL URLWithString:renderURL]];</code></p>
<h3 id="Weex的自定义"><a href="#Weex的自定义" class="headerlink" title="Weex的自定义"></a>Weex的自定义</h3><ul>
<li>Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承<code>WXComponent</code>，滑动组件继承<code>WXScrollerComponent</code></li>
<li>handler: Native提供一个协议。weex官方定义了常用的部分，如<code>WXImgLoaderProtocol</code>图片下载。如果需要自定义，注意需遵守协议<code>WXModuleProtocol</code></li>
<li>module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议<code>WXModuleProtocol</code>，需要自定义Method，如果需要返回值使用<code>WXModuleCallback</code>返回</li>
<li>总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];</div><div class="line">[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];</div><div class="line">[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)];</div></pre></td></tr></table></figure>
<p>基本的Weex知识就是这些，具体使用方法请参照<a href="https://weex.apache.org/cn/" target="_blank" rel="external">官方文档</a>和demo<a href="https://github.com/alibaba/weex" target="_blank" rel="external">链接</a>。<br>下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲解一下Weex的大概原理以及简单的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
</feed>
