<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YownYang&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-07T10:07:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YownYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第一章</title>
    <link href="http://yoursite.com/2017/04/29/Accustoming%20Yourself%20to%20Objective-C/"/>
    <id>http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/</id>
    <published>2017-04-29T06:48:05.000Z</published>
    <updated>2017-05-07T10:07:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。</p>
<p>书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。</p>
<h3 id="了解Objective-C的本源"><a href="#了解Objective-C的本源" class="headerlink" title="了解Objective-C的本源"></a>了解Objective-C的本源</h3><p>Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 	Messaging (Objective-C)</div><div class="line">	Object *obj = [Object new];</div><div class="line">	[obj performWith:parameter1 and:parameter2];</div><div class="line">	</div><div class="line">// 	Function calling (C++)</div><div class="line">	Object *obj = new Object;</div><div class="line">	obj-&gt;perform(parameter1, parameter2);</div></pre></td></tr></table></figure>
<p>两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。</p>
<p>Objective-C在运行时做了更多的工作而不是编译时。<code>runtime</code>包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，<code>runtime</code>包含所有内存管理的方法。本质上，<code>runtime</code>是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当<code>runtime</code>更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。</p>
<p>Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure>
<p>这种语法大多来源于C，声明一个叫做<code>someString</code>的变量，类型是<code>NSString *</code>。它的意思是这是一个<code>NSString</code>类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	NSString stackString;</div><div class="line">//	error:interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p><code>someString</code>变量指向某个内存地址，在堆上初始化，包含一个<code>NSString</code>对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div><div class="line">NSString *anotherString = someString;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png" alt=""></p>
<p><strong>Figure 1.1</strong> 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它</p>
<p>这仅有一个<code>NSString</code>实例，但有两个变量指向同它。这两个变量的类型是<code>NSString *</code>，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：<code>NSString</code>实例的内存地址。</p>
<p>图1.1说明了这个结构。<code>NSString</code>实例存储了表示实际字符串所需要的字节。</p>
<p>在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。</p>
<p>Objective-C堆上的内存管理是已经抽象的。你不需要使用<code>malloc</code>和<code>free</code>去初始化和释放对象内存。Objective-C的<code>runtime</code>通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。</p>
<p>有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如<code>CGRect</code>，来源于<code>CoreGraphics</code>框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGRect frame;</div><div class="line">frame.origin.x = 0.0f;</div><div class="line">frame.origin.y = 10.0f;</div><div class="line">frame.size.width = 100.0f;</div><div class="line">frame.siez.height = 150.0f;</div></pre></td></tr></table></figure>
<p><code>CGRect</code>是一个C的结构体，定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGRect &#123;</div><div class="line">	CGRect origin;</div><div class="line">	CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CGRect CGRect;</div></pre></td></tr></table></figure>
<p>这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如<code>CGRect</code>。</p>
<p>在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Objective-C是C的超集，添加了面向对象的功能。<br>Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。Objective-C是运行时而不是编译时，通过消息决定代码如何运行。</p>
<p>了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。</p>
<h3 id="减少在头文件中使用import"><a href="#减少在头文件中使用import" class="headerlink" title="减少在头文件中使用import"></a>减少在头文件中使用import</h3><p>Objective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有<code>.h</code>的是头文件，带有<code>.m</code>的是实现文件。当你创建一个类时，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对所有类来说，导入<code>Foundation.h</code>是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建<code>UIViewController</code>的子类。这些类的头文件将会导入<code>UIKit.h</code>。</p>
<p>目前来讲，这个类的写法是没问题的。它导入了整个<code>Foundation</code>框架，但是并不需要在意。<code>EOCPerson</code>类继承自<code>Foundation</code>框架中的某一个类，它将会使用框架的一大部分功能。继承自<code>UIViewController</code>的类也是一样，它将会使用<code>UIKit</code>框架的一大部分功能。</p>
<p>随着时间的推移，你可能创建了一叫做<code>EOCEmployer</code>的新类。然后你决定一个<code>EOCPerson</code>实例持有一个<code>EOCEmployer</code>实例。所以你提前给它加了一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个问题出现了，当你编译时发现<code>EOCEmployer</code>是缺失的。这个时候编译器一定会提示你在<code>EOCPerson.h</code>中导入<code>EOCEmployer.h</code>。通常你是在<code>EOCPerson.h</code>顶部加入导入的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCEmployer.h&quot;</div></pre></td></tr></table></figure>
<p>这将使他正常编译，但这是一个坏的习惯。因为编译<code>EOCPerson</code>不需要知道<code>EOCEmployer</code>的详细信息。仅需要知道有一个叫做<code>EOCEmployer</code>的类存在即可。幸运的是，有一个办法可以告诉编译器这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@class EOCEmployer;</div></pre></td></tr></table></figure>
<p>这叫做向前声明这个类。这样<code>EOCPerson</code>的头文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCEmployer;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当你为了在实现文件中使用它时，你需要知道<code>EOCEmployer</code>的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line">#import &quot;EOCEmployer.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果<code>EOCEmployer.h</code>是在<code>EOCPerson.h</code>中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。</p>
<p>使用前向声明会缓解两个类互相引用的问题。考虑下当<code>EOCEmployer</code>有两个方法去添加和移除<code>EOCPerson</code>的实例会发生什么，在头文件像这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)addEmployee:(EOCPerson *)person;</div><div class="line">- (void)removeEmployee:(EOCPerson *)person;</div></pre></td></tr></table></figure>
<p>这时，在相反的情况下处于同样的原因，<code>EOCPerson</code>类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用<code>#import</code>而不是<code>#include</code>可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。</p>
<p>有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。</p>
<p>例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCRectangle.h</div><div class="line">#import &quot;EOCShape.h&quot;</div><div class="line">#import &quot;EOCDrawable.h&quot;</div><div class="line"></div><div class="line">@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;</div><div class="line"></div><div class="line">@property (nonatomic, assign) float width;</div><div class="line">@property (nonatomic, assign) float height;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果<code>EOCDrawable</code>协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。</p>
<p>即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即<code>.m</code>中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。</p>
<p>每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。</p>
<p>有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。</p>
<h3 id="多使用Literal-Syntax少使用与之等价的方法"><a href="#多使用Literal-Syntax少使用与之等价的方法" class="headerlink" title="多使用Literal Syntax少使用与之等价的方法"></a>多使用Literal Syntax少使用与之等价的方法</h3><hr>
<p>译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。</p>
<hr>
<p>当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用<code>Foundation</code>去书写Objective-C代码，你通常在练习中使用它们。这些类是<code>NSString、NSNumber、NSArray、NSDictionary</code>。它们的数据结构即是它们自身所代表的意思。</p>
<p>众所周知Objective-C拥有冗长的语法。这是真的。然而，自从<code>Objective-C 1.0</code>开始，有一个非常简单的办法去创建一个<code>NSString</code>对象。它被称为<strong>String Literal</strong>并且看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;Effective Objective-C 2.0&quot;;</div></pre></td></tr></table></figure>
<p>这种类型的语法是不存在的，通常创建一个<code>NSString</code>对象是需要调用<code>alloc</code>方法后，调用<code>init</code>方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括<code>NSNumber、NSArray、NSDictionary</code>的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。</p>
<h4 id="Literal-Numbers"><a href="#Literal-Numbers" class="headerlink" title="Literal Numbers"></a>Literal Numbers</h4><p>有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用<code>NSNumber</code>实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</div></pre></td></tr></table></figure>
<p>它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = @1;</div></pre></td></tr></table></figure>
<p>如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有<code>NSNumber</code>实例可以代表的数据类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSNumber *intNumber = @1;</div><div class="line">NSNumber *floatNumber = @2.5f;</div><div class="line">NSNumber *doubleNumber = @3.14159;</div><div class="line">NSNumber *boolNumber = @YES;</div><div class="line">NSNumber *charNumber = @&apos;a&apos;;</div></pre></td></tr></table></figure>
<p>这种Literal Syntax也适用于表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x = 5;</div><div class="line">float y = 6.32f;</div><div class="line">NSNumber *expressionNumber = @(x * y);</div></pre></td></tr></table></figure>
<p>使用Literal Syntax对于数值来说是非常有用的。这样做可以使<code>NSNumber</code>对象更简洁明了，因为声明的大部分是值而不是多余的语法。</p>
<h4 id="Literal-Arrays"><a href="#Literal-Arrays" class="headerlink" title="Literal Arrays"></a>Literal Arrays</h4><p>数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</div></pre></td></tr></table></figure>
<p>使用Literal Syntax之后，仅需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];</div></pre></td></tr></table></figure>
<p>这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用<code>objectAtIndex: method:</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = [animals objectAtIndex:1];</div></pre></td></tr></table></figure>
<p>而使用Literal Syntax，只需要像下面的做法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = animals[1];</div></pre></td></tr></table></figure>
<p>这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。</p>
<p>然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的<a href="https://www.zhihu.com/question/20651624?sort=created" target="_blank" rel="external">语法糖</a>。这个异常看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception </div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;*** </div><div class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to </div><div class="line">insert nil object from objects[0]&apos;</div></pre></td></tr></table></figure>
<p>这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id object1 = /*...*/;</div><div class="line">id object2 = /*...*/;</div><div class="line">id object3 = /*...*/;</div><div class="line">    </div><div class="line">NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];</div><div class="line">NSArray *arrayB = @[object1, object2, object3];</div></pre></td></tr></table></figure>
<p>现在考虑这样一个场景，当<strong>object1</strong>和<strong>object3</strong>指向一个有效的<code>Objective-C</code>对象，但是<strong>object2</strong>是空的。这literal array，<strong>arrayB</strong>，将会抛出一个异常。然而，<strong>arrayA</strong> 仍将会被创建但只包含<strong>object1</strong>对象。原因是<code>arrayWithObjects:</code>方法添加参数，遇到nil终止，这比预想的结束的早。</p>
<p>这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。</p>
<h4 id="Literal-Dictionaries"><a href="#Literal-Dictionaries" class="headerlink" title="Literal Dictionaries"></a>Literal Dictionaries</h4><p>字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是<code>Objective-C</code>代码中常用的。创建一个使用是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:</div><div class="line">		@&quot;Matt&quot;, @&quot;firstName&quot;, </div><div class="line">		@&quot;Galloway&quot;, @&quot;lastName&quot;, </div><div class="line">		[NSNumber numberWithInt:28], @&quot;age&quot;, </div><div class="line">		nil];</div></pre></td></tr></table></figure>
<p>这令人相当困惑，因为这顺序是<strong>object, key, object, key, …</strong>。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = </div><div class="line">	@&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, </div><div class="line">	  @&quot;lastName&quot; : @&quot;Galloway&quot;, </div><div class="line">	  @&quot;age&quot; : @28&#125;;</div></pre></td></tr></table></figure>
<p>这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是<code>Objective-C</code>对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个<code>NSNumber</code>实例中。但是Literal Syntax意味着它只是一个额外的字符。</p>
<p>就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于<code>dictionaryWithObjectsAndKeys:</code>方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。</p>
<p>另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = [personData objectForKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>与之等价的Literal Syntax是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = personData[@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。</p>
<h4 id="Mutable-Arrays-and-Dictionaries"><a href="#Mutable-Arrays-and-Dictionaries" class="headerlink" title="Mutable Arrays and Dictionaries"></a>Mutable Arrays and Dictionaries</h4><p>以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];</div><div class="line">[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>通过Literal Syntax设置时这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutableArray[1] = @&quot;dog&quot;;</div><div class="line">mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;;</div></pre></td></tr></table></figure>
<h4 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h4><p>使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于<code>NSArray、NSNumber、NSDictionary</code>是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用<code>NSString</code>类。</p>
<p>同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，<code>mutableCopy</code>必须被调用，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy];</div></pre></td></tr></table></figure>
<p>它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。</p>
<p>通过下标法访问数组或者字典。</p>
<p>使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>基本内容图解</title>
    <link href="http://yoursite.com/2017/04/17/BasePrinciple_Img/"/>
    <id>http://yoursite.com/2017/04/17/BasePrinciple_Img/</id>
    <published>2017-04-17T11:32:16.000Z</published>
    <updated>2017-04-17T11:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Some principle！！！</p>
<a id="more"></a>
<p>最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解:<img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E7%BC%96%E8%AF%91%E5%9E%8B:%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.jpeg" alt=""></p>
<p>就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后…<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpeg" alt=""></p>
<p>突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6.png" alt=""></p>
<p>对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Some principle！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://yoursite.com/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码解析</title>
    <link href="http://yoursite.com/2017/03/14/Weex_3/"/>
    <id>http://yoursite.com/2017/03/14/Weex_3/</id>
    <published>2017-03-14T11:26:52.000Z</published>
    <updated>2017-03-24T04:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0</p>
<a id="more"></a>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。</p>
<p>WeexDemo的入口是<code>[WXSDKEngine initSDKEnvironment];</code>。这个Method的主要代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];</div><div class="line">NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">[WXSDKEngine initSDKEnvironment:script];</div></pre></td></tr></table></figure>
<p>首先，读取一个叫做main.js的文件内容，然后将其内容作为<code>[WXSDKEngine initSDKEnvironment:script]</code>初始化的参数。<br>我们继续来看这个method的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!script || script.length &lt;= 0) &#123;</div><div class="line">        WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;);</div><div class="line">        return;</div><div class="line">&#125;</div><div class="line">[self registerDefaults];</div><div class="line">[[WXSDKManager bridgeMgr] executeJsFramework:script];</div></pre></td></tr></table></figure>
<h3 id="注册和执行"><a href="#注册和执行" class="headerlink" title="注册和执行"></a>注册和执行</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>首先，是对传递进来的js代码做判断，其次调用了一个<code>registerDefaults</code>的method，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    [self _registerDefaultComponents];</div><div class="line">    [self _registerDefaultModules];</div><div class="line">    [self _registerDefaultHandlers];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="Register-Componet"><a href="#Register-Componet" class="headerlink" title="Register Componet"></a>Register Componet</h5><p>这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz</div><div class="line">&#123;</div><div class="line">    [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties</div><div class="line">&#123;</div><div class="line">    if (!name || !clazz) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">    [WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</div><div class="line">    NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name];</div><div class="line">    dict[@&quot;type&quot;] = name;</div><div class="line">    if (properties) &#123;</div><div class="line">        NSMutableDictionary *props = [properties mutableCopy];</div><div class="line">        if ([dict[@&quot;methods&quot;] count]) &#123;</div><div class="line">            [props addEntriesFromDictionary:dict];</div><div class="line">        &#125;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[props]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。<code>@&quot;append&quot;:@&quot;tree&quot;</code>代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，<code>@&quot;append&quot;:@&quot;node&quot;</code>代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用<code>WXComponentFactory</code>进行注册，在这之前先讲几个相关类的功能，免得迷糊。</p>
<ul>
<li>WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承</li>
<li>WXComponentConfig: 继承<code>WXInvocationConfig</code>类，存储每个Component的method、name、classname</li>
<li>WXComponentFactory：单例类，通过字典存储<code>WXComponentConfig</code>对象，通过每个<code>WXComponentConfig</code>对象操作每个Component的method、name、classname。</li>
</ul>
<p>首先通过<code>WXComponentFactory</code>调用<code>- (void)registerComponent:(NSString 
*)name withClass:(Class)clazz withPros:(NSDictionary *)pros</code>方法注册。使用Assert判断，然后创建一个<code>WXComponentConfig</code>对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用<code>[config registerMethods];</code>将类中的method通过runtime存储在<code>WXComponentConfig</code>中，存取时加锁保证安全。其次调用<code>- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name</code>方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法<code>registerComponents</code>，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">export function registerComponents (newComponents) &#123;</div><div class="line">  if (Array.isArray(newComponents)) &#123;</div><div class="line">    newComponents.forEach(component =&gt; &#123;</div><div class="line">      if (!component) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      if (typeof component === &apos;string&apos;) &#123;</div><div class="line">        components[component] = true</div><div class="line">      &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123;</div><div class="line">        components[component.type] = component</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Register-Module"><a href="#Register-Module" class="headerlink" title="Register Module"></a>Register Module</h5><p>注册Module，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;);   </div><div class="line">NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];</div><div class="line">NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];</div><div class="line">[[WXSDKManager bridgeMgr] registerModules:dict];</div></pre></td></tr></table></figure>
<p>先介绍几个类：</p>
<ul>
<li>WXModuleConfig：继承<code>WXInvocationConfig</code>类，存储每个Component的method、name</li>
<li>WXModuleFactory：单例类，通过字典操作<code>WXModuleConfig</code>对象</li>
</ul>
<p>查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法<code>registerModules</code>。</p>
<h5 id="Register-Handler"><a href="#Register-Handler" class="headerlink" title="Register Handler"></a>Register Handler</h5><p>注册Handler，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">[WXHandlerFactory registerHandler:handler withProtocol:protocol];</div></pre></td></tr></table></figure>
<p>照例介绍几个类：</p>
<ul>
<li>WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储</li>
</ul>
<p>注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。</p>
<h4 id="ExecuteJs"><a href="#ExecuteJs" class="headerlink" title="ExecuteJs"></a>ExecuteJs</h4><p>最后调用<code>[[WXSDKManager bridgeMgr] executeJsFramework:script];</code>执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。</p>
<p>首先介绍几个类：</p>
<ul>
<li>WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能</li>
<li>WXSDKManager：单例类，通过一个字典存储所有<code>WXSDKInstance</code>实例，key是一个唯一值；一个<code>WXBridgeManager</code>实例</li>
<li>WXBridgeManager：单例类，注册，渲染功能都通过调用<code>WXBridgeContext</code>对象去跟JS交互</li>
<li>WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。</li>
<li>WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使<code>WXBridgeContext</code>调用</li>
</ul>
<p>现在可以从那句代码开始讲了，<code>[WXSDKManager bridgeMgr]</code>这个对象是一个单例，他在JS线程调用<code>executeJsFramework</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (!script) return;</div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">WXPerformBlockOnBridgeThread(^()&#123;</div><div class="line">    [weakSelf.bridgeCtx executeJsFramework:script];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>先是判空，其次weakSelf防止循环引用，然后在一个叫做<code>&quot;com.taobao.weex.bridge&quot;</code>的线程调用<code>executeJsFramework</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">WXAssertBridgeThread();</div><div class="line">WXAssertParam(script);</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_START(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">[self.jsBridge executeJSFramework:script];</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_END(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">if ([self.jsBridge exception]) &#123;</div><div class="line">    NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]];</div><div class="line">    WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);</div><div class="line">&#125; else &#123;</div><div class="line">    WX_MONITOR_SUCCESS(WXMTJSFramework);</div><div class="line">    //the JSFramework has been load successfully.</div><div class="line">    self.frameworkLoadFinished = YES;</div><div class="line">    </div><div class="line">    [self executeAllJsService];</div><div class="line">    </div><div class="line">    JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil];</div><div class="line">    if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123;</div><div class="line">        [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //execute methods which has been stored in methodQueue temporarily.</div><div class="line">    for (NSDictionary *method in _methodQueue) &#123;</div><div class="line">        [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [_methodQueue removeAllObjects];</div><div class="line">    </div><div class="line">    WX_MONITOR_PERF_END(WXPTInitalize);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先断言当前线程是否是<code>&quot;com.taobao.weex.bridge&quot;</code>线程，其次断言js代码，使用<code>WXBridgeProtocol</code>协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。</p>
<h3 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h3><h4 id="JavaScriptCore简介"><a href="#JavaScriptCore简介" class="headerlink" title="JavaScriptCore简介"></a>JavaScriptCore简介</h4><p>上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。</p>
<ul>
<li>JSVirtualMachine：为JavaScript提供运行资源</li>
<li>JSContext：为JavaScript提供运行环境</li>
<li>JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量</li>
</ul>
<h4 id="JavaScriptCore示例"><a href="#JavaScriptCore示例" class="headerlink" title="JavaScriptCore示例"></a>JavaScriptCore示例</h4><p>这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了：</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];</div><div class="line">NSLog(@&quot;%@&quot;, value); 输出5</div><div class="line">context[@&quot;sum&quot;] = @&quot;40&quot;;</div><div class="line">NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40</div></pre></td></tr></table></figure>
<p>首先初始化一个JSContext对象，可以使用<code>JSVirtualMachine</code>对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个<code>JSVirtualMachine</code>对象，所以这个js运行的资源，不可或缺。</p>
<p>第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。</p>
<p>第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。</p>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</div><div class="line">        context.exception = exception;</div><div class="line">        NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另一个要注意的点就是这里，JavaScriptCore会在<code>exceptionHandler</code>中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用<code>[JSContext currentContext]</code>获取当前的context。如果直接引用外部的context会造成循环饮用。</p>
<h5 id="invokeMethod"><a href="#invokeMethod" class="headerlink" title="invokeMethod"></a>invokeMethod</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;];    </div><div class="line">JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];</div><div class="line">NSLog(@&quot;%@&quot;, sum); 输出7</div></pre></td></tr></table></figure>
<p>初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexCallJS.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码文件夹的解释</title>
    <link href="http://yoursite.com/2017/03/14/Weex_2/"/>
    <id>http://yoursite.com/2017/03/14/Weex_2/</id>
    <published>2017-03-14T08:01:24.000Z</published>
    <updated>2017-03-15T03:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0</p>
<a id="more"></a>
<h3 id="Weex文件夹"><a href="#Weex文件夹" class="headerlink" title="Weex文件夹"></a>Weex文件夹</h3><pre><code>*最不重要的文件夹：Controller、Debug、Handler
*不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket
*稍微重要的文件夹：Component、Module、Protocol
*重要的文件夹：Display、Events、Layout、View
*最重要的文件夹：Bridge、Engine、Manager、Model
</code></pre><blockquote>
<p>Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油；</p>
<p>Debug：一个调试类，酱油；</p>
<p>Handler：两个类实现了两个Weex的Protocol，酱油；</p>
<p>Loader：一个类是Network的回调实现，一个类是WebSocket的回调。</p>
<p>Monitor：一个监测的类，输出一些信息。</p>
<p>Network:一个小型的网络请求库</p>
<p>Utility：一些常用方法的封装</p>
<p>WebSocket：对SRWebSocket的封装</p>
<p>Componet：对各种view的封装，如果需要扩展view就跟这个有关</p>
<p>Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method</p>
<p>Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。</p>
<p>Display：WXComponent的展示</p>
<p>Events：WXComponent的事件</p>
<p>Layout：WXComponent的布局</p>
<p>View：WXComponent的View</p>
<p>Bridge：Weex与NativeJS之间的桥接</p>
<p>Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等</p>
<p>Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。</p>
<p>Manager：Weex中各种管理的类</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Book</title>
    <link href="http://yoursite.com/2017/02/26/ReadBook_iOS/"/>
    <id>http://yoursite.com/2017/02/26/ReadBook_iOS/</id>
    <published>2017-02-26T11:03:08.000Z</published>
    <updated>2017-04-01T03:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS相关书籍…</p>
<a id="more"></a>
<ol>
<li><strong>《iOS7应用开发技术详解》</strong>在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如<strong>14.2</strong>手势事件、<strong>11.3.5</strong>的<code>UIViewAutoresizing</code>等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看<strong>16</strong>、<strong>17</strong>章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。</li>
<li><strong>《iOS开发进阶》</strong>这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。</li>
<li><strong>《Objective-C高级编程》</strong>这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西<code>引用计数</code>，<code>Block</code>，<code>GCD</code>。<code>引用计数</code>这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；<code>Block</code>这块主要看的是clang rewrite 之后的代码；<code>GCD</code>是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS相关书籍…&lt;/p&gt;
    
    </summary>
    
      <category term="ReadBook" scheme="http://yoursite.com/categories/ReadBook/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex的简单使用</title>
    <link href="http://yoursite.com/2017/02/01/Weex_1/"/>
    <id>http://yoursite.com/2017/02/01/Weex_1/</id>
    <published>2017-02-01T08:33:44.000Z</published>
    <updated>2017-03-24T10:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解一下Weex的大概原理以及简单的使用</p>
<a id="more"></a>
<h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><ul>
<li>与RN相同原理，某些方面优于RN</li>
<li>js语法，比Native体验稍差，比hybrid app体验好太多</li>
<li>js一端代码，三端使用</li>
<li>iOS/Android脱离写UI的噩梦</li>
<li>文档不够完善</li>
</ul>
<h3 id="Weex原理"><a href="#Weex原理" class="headerlink" title="Weex原理"></a>Weex原理</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexTree.png" alt=""></p>
<h3 id="Weex使用"><a href="#Weex使用" class="headerlink" title="Weex使用"></a>Weex使用</h3><ul>
<li>首先，在<code>AppDelegate</code>中调用<code>[WXSDKEngine initSDKEnvironment]</code>进行注册</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line"></div><div class="line">    [WXSDKEngine initSDKEnvironment];    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其次，在需要使用的ViewController中定义一个<code>WXSDKInstance</code>实例和UI个<code>UIView</code>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) WXSDKInstance *instance;</div><div class="line">@property (nonatomic) UIView *weexView;</div></pre></td></tr></table></figure>
<ul>
<li>紧接着，初始化<code>WXSDKInstance</code>实例，设置它的viewController、frame属性，实现它的生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">_instance = [[WXSDKInstance alloc] init];</div><div class="line">_instance.viewController = self;</div><div class="line">_instance.frame = [UIScreen mainScreen].bounds;</div><div class="line">    </div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">_instance.onCreate = ^(UIView *view) &#123;</div><div class="line">    [weakSelf.weexView removeFromSuperview];</div><div class="line">    weakSelf.weexView = view;</div><div class="line">    [weakSelf.view addSubview:weakSelf.weexView];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onFailed = ^(NSError *error) &#123;</div><div class="line">    NSLog(@&quot;failed %@&quot;,error);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.renderFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;render finish&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onRenderProgress = ^(CGRect renderRect) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;renderProgress&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.updateFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;update Finish&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>最后，使用<code>WXSDKInstance</code>实例调用<code>renderWithURL:</code>方法即可。记得在<code>dealloc</code>中释放<code>WXSDKInstance</code>实例哦😯</li>
</ul>
<p><code>[self.instance renderWithURL:[NSURL URLWithString:renderURL]];</code></p>
<h3 id="Weex的自定义"><a href="#Weex的自定义" class="headerlink" title="Weex的自定义"></a>Weex的自定义</h3><ul>
<li>Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承<code>WXComponent</code>，滑动组件继承<code>WXScrollerComponent</code></li>
<li>handler: Native提供一个协议。weex官方定义了常用的部分，如<code>WXImgLoaderProtocol</code>图片下载。如果需要自定义，注意需遵守协议<code>WXModuleProtocol</code></li>
<li>module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议<code>WXModuleProtocol</code>，需要自定义Method，如果需要返回值使用<code>WXModuleCallback</code>返回</li>
<li>总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];</div><div class="line">[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];</div><div class="line">[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)];</div></pre></td></tr></table></figure>
<p>基本的Weex知识就是这些，具体使用方法请参照<a href="https://weex.apache.org/cn/" target="_blank" rel="external">官方文档</a>和demo<a href="https://github.com/alibaba/weex" target="_blank" rel="external">链接</a>。<br>下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲解一下Weex的大概原理以及简单的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
</feed>
