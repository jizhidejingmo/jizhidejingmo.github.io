<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YownYang&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-18T10:55:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YownYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查找删除iOS项目中未使用的代码文件</title>
    <link href="http://yoursite.com/2018/08/18/Clean%20Project%20Tool/"/>
    <id>http://yoursite.com/2018/08/18/Clean Project Tool/</id>
    <published>2018-08-18T07:31:02.000Z</published>
    <updated>2018-08-18T10:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要是介绍构建一个Mac项目，用来对项目中未使用(冗余)的代码文件进行查找和删除。</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>5月份的时候入职了一家新公司，入职之后发现项目混乱，问题很多。开始的时候并未注意到项目中有很多随着版本迭代和设计者不合理设计遗留的文件，随着对项目逐渐深入发现项目中有很多冗余文件，决定写个工具进行查找删除。</p>
<h3 id="项目的组成"><a href="#项目的组成" class="headerlink" title="项目的组成"></a>项目的组成</h3><p>首先，我们需要了解一个项目中各种东西的概念。</p>
<h4 id="Xcode-project"><a href="#Xcode-project" class="headerlink" title="Xcode project"></a>Xcode project</h4><p>Xcode 中的project是指一个项目，它包含各种文件。它可以进行各种项目级别的配置，如debug和release，也可以配置多种target，项目本身是无法产生app或者mac应用的。</p>
<pre><code>* .h/.m/.mm/.c等源代码文件
* .a/framework等库文件
* image/bundle/plist等资源文件
* xib/storyboard等特殊资源文件
</code></pre><h4 id="Xcode-target"><a href="#Xcode-target" class="headerlink" title="Xcode target"></a>Xcode target</h4><p>target定义了构建一个app所需的文件和配置。target之间可以互相依赖，当它们在同一个workspace中时，Xcode会发现它们的隐性依赖关系。你也可以对它们进行设置，使其显性依赖。</p>
<h4 id="Xcode-workspace"><a href="#Xcode-workspace" class="headerlink" title="Xcode workspace"></a>Xcode workspace</h4><p><code>workspace</code>一般直译为工作空间，这个概念在苹果平台开发上面不是很明显，因为我们都是通过<code>xxx.xcodeproj</code>文件直接打开项目进行工作的(其实也是存在workspace的)，但如果你使用cocoapods进行第三方库的管理，你会发现你只有通过打开<code>xxx.xcworkspace</code>文件才能正常工作。</p>
<p>这是因为cocoapods产生了一个project用来存放各种第三方库产生的target，又将主项目的project和自己产生的project放在同一个workspace下进行依赖。</p>
<h4 id="Xcode-scheme"><a href="#Xcode-scheme" class="headerlink" title="Xcode scheme"></a>Xcode scheme</h4><p>既然说了这么多了，也不介意再提及下scheme这个东西。它可以包含多个target进行执行，但每次只能执行一个scheme。它可以存在project下，也可以存在workspace下。前者可以让包含了project的任意workspace使用，后者只能让那个workspace本身使用了。</p>
<h4 id="项目组成的总结"><a href="#项目组成的总结" class="headerlink" title="项目组成的总结"></a>项目组成的总结</h4><p>它们的关系大概可以这样总结:</p>
<pre><code>workspace &gt; project &gt; scheme &gt; target
</code></pre><p>或者:</p>
<pre><code>workspace &gt; scheme &gt; project &gt; target
</code></pre><h4 id="正常工作项目的分析"><a href="#正常工作项目的分析" class="headerlink" title="正常工作项目的分析"></a>正常工作项目的分析</h4><p>通过上面的说明，其实可以知道了，我们如果要找出一个项目中文件的组织关系，应该去project里面找。对于只存在一个project的项目，应该去xxx.xcodeproj中查找关系。对于使用了cocoapods的，如果要查找cocoapods项目的文件关系，可以去pod.xcodeproj中查找。不过一般没有必要，因为里面存的都是库，并且数量不会很多，不使用的话一般是整个库的移除。</p>
<h3 id="xxx-xcodeproj"><a href="#xxx-xcodeproj" class="headerlink" title="xxx.xcodeproj"></a>xxx.xcodeproj</h3><p>xxx.xcodeproj其实是一个文件夹，使用右键打开包内容，你会发现它包含了一个叫做<code>project.pbxproj</code>的文件，这个文件才是用来保存project中文件的组织关系的。</p>
<h4 id="project-pbxproj"><a href="#project-pbxproj" class="headerlink" title="project.pbxproj"></a>project.pbxproj</h4><p>它其实是一个老式的plist文件，它里面的每一个元素都是一个24位长度的十六进制标识符。这标识符似乎基于日期，序列和预定义值生成，所以保证了它的唯一性。(PS: 在看这个文件的时候建议使用TextMate，将格式指定为Property List(Old-Style))。</p>
<p>它最外层包含5个键值对，key分别是：<code>archiveVersion</code>、<code>classes</code>、<code>objectVersion</code>、<code>objects</code>、<code>rootObject</code>。我们只需要关心<code>objects</code>和<code>rootObject</code>就行了。</p>
<h4 id="解析objects和rootObject-附代码"><a href="#解析objects和rootObject-附代码" class="headerlink" title="解析objects和rootObject(附代码)"></a>解析objects和rootObject(附代码)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">//    1. 获取objects字典，fullDictionary是整个project.pbxproj的内容</div><div class="line">NSDictionary *objectDictionary = fullDictionary[@&quot;objects&quot;];</div><div class="line">//    2. 获取project的key</div><div class="line">NSString *rootObjectKey = fullDictionary[@&quot;rootObject&quot;];</div><div class="line">//    3. 根据key从objects字典中获取project的字典</div><div class="line">NSDictionary *projectDictionary = objectDictionary[rootObjectKey];</div><div class="line">//    4. 获取mainGroup的key</div><div class="line">NSString *mainGroupKey = projectDictionary[@&quot;mainGroup&quot;];</div><div class="line">//    5. 根据key从objects字典中获取mainGroup的字典</div><div class="line">NSDictionary *mainGroupDictionary = objectDictionary[mainGroupKey];</div><div class="line">//    6. 获取children数组，实际就是主target最外层的所有文件夹和文件</div><div class="line">NSArray *floderArray = mainGroupDictionary[@&quot;children&quot;];</div><div class="line">//    7. 以递归的方式获取项目中所有的h/m/mm/xib文件，将它们存储在一个字典套字典中。内层字典是每个文件自身的唯一标识做key，它们自身的完整路径做value。外层字典以每个不带后缀的文件名做key，以内层字典为value。</div><div class="line">- (void)searchAllClassWithArray:(NSArray *)keyArray objectDictionary:(NSDictionary *)objectDictionary path:(NSString *)path &#123;</div><div class="line">    </div><div class="line">    [keyArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">        @autoreleasepool &#123;</div><div class="line">            </div><div class="line">            NSDictionary *floderOrFileDictionary = objectDictionary[key];</div><div class="line">            NSString *type = floderOrFileDictionary[@&quot;isa&quot;];</div><div class="line">            NSString *onePath = floderOrFileDictionary[@&quot;path&quot;];</div><div class="line">            NSString *floderOrFilePath = [path stringByAppendingPathComponent:onePath];</div><div class="line">            if ([type isEqualToString:@&quot;PBXFileReference&quot;]) &#123;</div><div class="line">                </div><div class="line">                //                如果是非实体文件夹中的文件，会带有非实体文件夹的路径，所以要取最后一段</div><div class="line">                NSString *className = onePath.lastPathComponent;</div><div class="line">                NSString *classExtension = className.pathExtension;</div><div class="line">                if ([classExtension isEqualToString:@&quot;h&quot;] ||</div><div class="line">                    [classExtension isEqualToString:@&quot;m&quot;] ||</div><div class="line">                    [classExtension isEqualToString:@&quot;xib&quot;] ||</div><div class="line">                    [classExtension isEqualToString:@&quot;mm&quot;]) &#123;</div><div class="line">                    </div><div class="line">                    NSString *classNameWithoutExtension = className.stringByDeletingPathExtension;</div><div class="line">                    NSMutableDictionary *tempClassDictionary = [self.allClassDictionary objectForKey:classNameWithoutExtension];</div><div class="line">                    if (tempClassDictionary) &#123;</div><div class="line">                        </div><div class="line">                        [tempClassDictionary setObject:floderOrFilePath forKey:key];</div><div class="line">                    &#125; else &#123;</div><div class="line">                        </div><div class="line">                        tempClassDictionary = [NSMutableDictionary dictionary];</div><div class="line">                        [tempClassDictionary setObject:floderOrFilePath forKey:key];</div><div class="line">                        [self.allClassDictionary setObject:tempClassDictionary forKey:classNameWithoutExtension];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else if ([type isEqualToString:@&quot;PBXGroup&quot;]) &#123;</div><div class="line">                </div><div class="line">                NSArray *floderArray = floderOrFileDictionary[@&quot;children&quot;];</div><div class="line">                [self searchAllClassWithArray:floderArray objectDictionary:objectDictionary path:floderOrFilePath];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 8. 枚举所有的文件，从中匹配是否有导入其他的.h文件。如果有，则将那个文件簇标记为使用文件。</div><div class="line">- (void)searchUsedClass &#123;</div><div class="line">    </div><div class="line">    NSMutableDictionary *tempAllClassDictionary = [NSMutableDictionary dictionary];</div><div class="line">    [self.allClassDictionary.allValues enumerateObjectsUsingBlock:^(NSMutableDictionary *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">        @autoreleasepool &#123;</div><div class="line"></div><div class="line">            [tempAllClassDictionary addEntriesFromDictionary:obj];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [tempAllClassDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *classUUID, NSString *classPath1, BOOL * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">        @autoreleasepool &#123;</div><div class="line">            </div><div class="line">            NSString *classExtension = classPath1.pathExtension;</div><div class="line">            if ([classExtension isEqualToString:@&quot;h&quot;]) &#123;</div><div class="line">                </div><div class="line">                NSString *className1 = classPath1.lastPathComponent;</div><div class="line">                NSString *classNameWithoutExtension1 = className1.stringByDeletingPathExtension;</div><div class="line">                [tempAllClassDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *classUUID, NSString *classPath2, BOOL * _Nonnull stop) &#123;</div><div class="line">                   </div><div class="line">                    @autoreleasepool &#123;</div><div class="line">                        </div><div class="line">                        //  不能从自己的类中匹配</div><div class="line">                        NSString *className2 = classPath2.lastPathComponent;</div><div class="line">                        NSString *classNameWithoutExtension2 = className2.stringByDeletingPathExtension;</div><div class="line">                        if (![classNameWithoutExtension1 isEqualToString:classNameWithoutExtension2]) &#123;</div><div class="line">                            </div><div class="line">                            NSString *searchTypeOne = [NSString stringWithFormat:@&quot;#import \&quot;%@\&quot;&quot;, className1];</div><div class="line">                            NSString *searchTypeTwo = [NSString stringWithFormat:@&quot;\&quot;%@\&quot;&quot;, classNameWithoutExtension1];</div><div class="line">                            NSString *contents = [NSString stringWithContentsOfFile:classPath2 encoding:NSUTF8StringEncoding error:nil];</div><div class="line">                            BOOL isContainTypeOne = [contents containsString:searchTypeOne];</div><div class="line">                            BOOL isContainTypeTwo = [contents containsString:searchTypeTwo];</div><div class="line">                            if (isContainTypeOne || isContainTypeTwo) &#123;</div><div class="line">                                </div><div class="line">                                [self.usedClassDictionary setObject:classPath1 forKey:classNameWithoutExtension1];</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 9. 使用所有文件的数组去除掉使用文件，剩下的就是未使用文件了。也可以在这里做一些忽略过滤，过滤掉不想删除的文件。如main.m。</div><div class="line">- (void)searchUnusedClass &#123;</div><div class="line">    </div><div class="line">    self.unusedClassDictionary = [NSMutableDictionary dictionaryWithDictionary:self.allClassDictionary];</div><div class="line">    [self.unusedClassDictionary removeObjectsForKeys:self.usedClassDictionary.allKeys];</div><div class="line">    [self.unusedClassDictionary removeObjectForKey:@&quot;main&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>拉了这么长的篇幅，写了这么多代码，还是不如完整项目来的好。<br><a href="https://github.com/yownyang/Resource/tree/master/Project/Xcode/HZRCleanProjectTool" target="_blank" rel="external">仓库地址</a>     </p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://developer.apple.com/library/archive/featuredarticles/XcodeConcepts/Concept-Targets.html" target="_blank" rel="external">苹果官方文档</a></li>
<li><a href="http://www.monobjc.net/xcode-project-file-format.html" target="_blank" rel="external">project.pbxproj</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要是介绍构建一个Mac项目，用来对项目中未使用(冗余)的代码文件进行查找和删除。&lt;/p&gt;
    
    </summary>
    
      <category term="Xcode" scheme="http://yoursite.com/categories/Xcode/"/>
    
    
  </entry>
  
  <entry>
    <title>知识点杂记</title>
    <link href="http://yoursite.com/2018/06/23/Knowledge%20notes/"/>
    <id>http://yoursite.com/2018/06/23/Knowledge notes/</id>
    <published>2018-06-23T07:04:29.000Z</published>
    <updated>2018-06-23T07:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于技术知识点的整理汇总，在技术道路上，有许多知识点属于不常用但有用的知识，如果不加以记录，时间久了记忆就会模糊，不利于知识积累。我就是深受其害o(╥﹏╥)o</p>
<a id="more"></a>
<h3 id="编译原理相关"><a href="#编译原理相关" class="headerlink" title="编译原理相关"></a>编译原理相关</h3><p>Q: dSYM文件是什么，作用。</p>
<blockquote>
<p>A: 每次编译后都会产生的一个文件，本质是一个符号表，包含内存地址、函数名、文件名、行号。作用是可以查找到指定内存地址对应的函数位置。</p>
</blockquote>
<p>Q: 如何防止反编译</p>
<blockquote>
<p>A: 本地数据加密、URL加密、网络请求加密、代码混淆、代码逻辑混淆</p>
</blockquote>
<h3 id="App相关"><a href="#App相关" class="headerlink" title="App相关"></a>App相关</h3><p>Q: App启动过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. 加载dyld到内存</div><div class="line">2. 加载动态库(包括依赖的库)</div><div class="line">3. 加载rebase(重定位内存地址的，比如逻辑地址到物理地址)</div><div class="line">4. 加载bind(绑定真实的内存地址)</div><div class="line">5. 初始化Objective C Runtime</div><div class="line">6. 其它初始化(+load/C的__attribute__((constructor)))方法</div><div class="line">7. 执行main函数中的UIApplicationMain函数</div><div class="line">8. 创建该函数中第3和4个参数的实例对象</div><div class="line">9. 读取info.plst文件并设置一些属性</div><div class="line">10. 创建main runloop</div><div class="line">11. UIApplicationDelegate对象开始监听</div><div class="line">12. 执行`didFinishLaunchingWithOptions`函数，如果设置了启动的storyboard，则加载</div></pre></td></tr></table></figure>
<p>Q: App启动优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. 针对加载动态库步骤，减少私有动态库的数量，因为系统动态库有缓存。</div><div class="line">2. 针对Rebase和bind和Runtime可以减少category和合并功能类似的类，全局变量</div><div class="line">3. 对于其它初始化，使用initialize代替+load，减少使用__atribute__((constructor))方法。</div><div class="line">4. 针对main函数之后的优化，能延迟执行就延迟执行。不能延迟执行就放在后台执行。</div></pre></td></tr></table></figure>
<p>Q: App内存分布</p>
<blockquote>
<p>A: 内存地址由高到低，栈区，堆区，静态区，常量区，代码区</p>
</blockquote>
<p>Q: App框架层级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. Cocoa Touch  提供了UIKit等高级框架</div><div class="line">2. Media	提供了Core Graphics、Open GL、Core Animation等媒体框架</div><div class="line">3. Core Service 提供了Foundation、CF等基础框架</div><div class="line">4. Core OS 硬件和软件之间的桥梁</div></pre></td></tr></table></figure>
<p>Q: App性能优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1. ARC管理内存</div><div class="line">2. 缓存机制</div><div class="line">3. 延迟加载</div><div class="line">4. 保证图片大小与容器大小相同</div><div class="line">5. 避免复杂的XIB</div><div class="line">6. 权衡渲染方法</div><div class="line">7. 重用</div><div class="line">8. AutoreleasePool</div><div class="line">9. 苹果的Profile工具检测，进一步优化具体代码</div></pre></td></tr></table></figure>
<p>Q: tableView性能优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 高度缓存</div><div class="line">2. cell复用</div><div class="line">3. 图片按需加载</div><div class="line">4. 大的数据在其他线程操作</div><div class="line">5. cell中不需要交互的控件可以使用绘制</div></pre></td></tr></table></figure>
<h3 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h3><p>Q: 多线程是什么，作用，缺点</p>
<blockquote>
<p>A: 多线程是指多个线程并发执行的技术。作用是用来提升同一时间段内系统的处理效率，也就是作业量。缺点是消耗资源，容易造成数据竞争，死锁等问题。</p>
</blockquote>
<p>Q: 线程是什么，特点</p>
<blockquote>
<p>A: CPU执行的最小单元，由线程ID、指令指针、寄存器、堆栈组成，也常被称之为轻型进程。特点是无单独的内存空间，与同一进程下的其他线程共享进程的内存空间；线程crash会导致进程crash。</p>
</blockquote>
<p>Q: 单线程、并发、并行</p>
<blockquote>
<p>A: 一个CPU在一条线程上执行单一无分叉路径为单线程。一个CPU在多条线程切换执行称为并发，也叫伪.多线程。多个CPU同时执行多条线程称为并行，也叫真.多线程。</p>
</blockquote>
<p>Q: pthread、NSThread、NSOperation、GCD</p>
<blockquote>
<p>A: pthread和GCD都是一套C语言API，NSThread和NSOperation是一套OC语言的API。pthread和NSThread对线程直接操作，并且需要程序员去管理生命周期，很少使用。NSOperation和GCD不是直接面向线程操作，而是把要执行的方法提交到指定的block或者对象中，程序员无需管理线程的生命周期，也无需考虑当时CPU的使用情况以及消耗，系统会自动进行分配。NSOperation比GCD更易于管理，很简单就可以实现对执行任务的暂停取消等操作。而GCD功能更颗粒化，适合需求简单的多线程操作。</p>
</blockquote>
<p>Q: 如何避免多线程的常见问题</p>
<blockquote>
<p>A: 选择合适的多线程技术；尽量简化线程之间的关系；尽量指定相同优先级；写操作栅栏+串行，读操作并行。</p>
</blockquote>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>Q: SVN，Git</p>
<blockquote>
<p>A: SVN是一个集中式控制系统，管理集中在远程服务器。Git是一个分布式控制系统，每台使用git的电脑都拥有版本库，远程也有一个远程库，用来做数据交换。</p>
</blockquote>
<p>Q: SVN的缺点</p>
<blockquote>
<p>A: 第一，连接不到远程服务器基本无法工作；第二，每个分支每次提交都是整体的拷贝，占用存储空间。</p>
</blockquote>
<p>Q: Git的差异记录方式</p>
<blockquote>
<p>A: 整体文件做一个快照，文件有变化，产生一个新的快照；文件无变化，延用上一个快照。会使用文件内容或者目录结构生成一个40位的十六进制的哈希值。</p>
</blockquote>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>Q: 如何组件化</p>
<blockquote>
<p>A: 首先要明白组件化的实质就是把一个整体的耦合度高的项目给拆分成各种小的模块，拆成了模块之后，为了不让各模块耦合，需要一个中间层去进行模块间的通讯。对于一些基础功能模块和可以通用的模块，如网络请求，帮助类，公共UI库可以以cocoapods的方法去进行管理，便于多项目通用和版本管理。</p>
</blockquote>
<h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h3><blockquote>
<p>Q: runloop的运行顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1. 通知observer即将进入runloop</div><div class="line">2. 通知observer即将处理timer</div><div class="line">3. 通知observer即将处理source0</div><div class="line">4. 处理source0</div><div class="line">5. 存在source1，跳至第11步；不存在source1，跳至第6步。</div><div class="line">6. 无source1、timer，通知observer runloop即将休眠</div><div class="line">7. runloop休眠，等待唤醒</div><div class="line">8. 通知observer线程已经唤醒</div><div class="line">9. timer唤醒，处理timer；</div><div class="line">10. gcd主队列任务唤醒，处理主队列任务；</div><div class="line">11. 处理source1</div><div class="line">12. 是否满足退出条件，不满足跳回第2步</div><div class="line">13. 通知observer,runloop退出</div></pre></td></tr></table></figure>
<blockquote>
<p>Q: runloop概念</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. runloop是iOS中一个很基础很重要的东西，可以从字面理解为运行循环。一旦被创建，除非所在线程消亡，否则一直存在。主线程的runloop是在main函数中创建的，其余线程需要主动获取runloop才会创建。</div><div class="line">2. 每个runloop包含有不同的mode，用来让程序在某个mode下专注于对应的任务，一定程度上避免了资源抢占，例如程序初始化的mode，平时的默认mode，滚动时的mode。</div><div class="line">3. 每个mode包含不同的事件source、timer、observer</div><div class="line">4. source分为source0和source1两种类型。source0只包含一个回调指针，需要CFRunLoopSourceSignal(source)标记待处理，CFRunLoopWakeUp(runloop)唤醒runloop进行处理；source1比source0多了一个mach_port，它会主动唤醒runloop</div><div class="line">5. timer 计时器，当加入到runloop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调</div><div class="line">6. observer 每个Observer都包含了一个回调指针，当RunLoop的状态发生变化时，观察者就能通过回调接受到这个变化</div></pre></td></tr></table></figure>
<blockquote>
<p>Q: runloop处理的事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. 自动释放池的创建和销毁</div><div class="line">2. 识别硬件(source1)</div><div class="line">3. 识别手势(source0)</div><div class="line">4. 界面刷新</div></pre></td></tr></table></figure>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>Q: 什么是block</p>
<blockquote>
<p>A: 从表面看，block就是一段封装的代码，可以传递数据。从本质上看，它是闭包在iOS的具现化表现。按维基百科给出的解释，闭包就是一个封闭的作用域可以保存捕捉到的外部变量。从代码看，使用clang rewrite之后的block就是一个结构体，包含一个isa指针，捕捉的变量，实现的C函数，描述结构体。</p>
</blockquote>
<p>Q: 为什么添加__block后，变量可以被修改</p>
<blockquote>
<p>A: 因为添加之后，捕捉的变量就从一个普通的值引用变为了指针引用，用__block修饰的变量会生成一个结构体，结构体内部存储isa指针、变量、forwarding指针、释放函数、copy函数。</p>
</blockquote>
<h3 id="屏幕渲染"><a href="#屏幕渲染" class="headerlink" title="屏幕渲染"></a>屏幕渲染</h3><p>Q: 屏幕渲染大致流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 收到vsync信号</div><div class="line">2. CPU计算</div><div class="line">3. GPU渲染完成后将其放入帧缓冲区</div><div class="line">4. 视频控制器逐行读取帧缓冲区并显示</div><div class="line">5. 如果在一个vsync信号内，CPU或者GPU没有提交内容，那么就会丢弃那一帧，保持之前的状态，这就是卡顿的原因</div></pre></td></tr></table></figure>
<h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>Q: 什么是runtime</p>
<blockquote>
<p>runtime是一套底层的C语言API，是iOS的核心之一，平时写的代码，底层都是基于它实现的。</p>
</blockquote>
<p>Q: runtime的作用</p>
<blockquote>
<p>将一部分编译和链接时候做的工作，转移到运行时去做</p>
</blockquote>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>Q: Autorelease原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PS: 参阅NSObject.mm第628行-1191行</div><div class="line">1. AutoreleasePool本身并无结构，实质是AutoreleasePoolPage</div><div class="line">2. AutoreleasePoolPage以双向链表存在，当第一个表存满之后，就创建新表继续存储，每个表最大存储4096字节大小。</div><div class="line">3. 它有一些重要从参数和概念：next指向最新加进来的对象的下一个位置，判断是否存满也是靠这个参数的；thread，所在的线程；parent指向前一个page，child指向下一个page；holdPage最后page,coldPage首个page;每次objc_autoreleasePoolPush都会插入一个空的标志，用于在pop时使用，会直接pop到这个标志的位置。</div><div class="line">4. 明白了这些参数就很好理解了，你使用自动释放池时，就会创建一个poolpage，然后把池内对象加进来，next指向对象下一个位置；当满了，就创建新的page再加进来，设置两个page的parent和child指向。如果嵌套自动释放池，就嵌套poolpage，设置空标志。释放的时候，直接释放到空标志的地方。</div></pre></td></tr></table></figure>
<p>Q: Autorelease对返回值的优化</p>
<blockquote>
<p>依赖于TLS机制，这是一块某个线程专有的存储内存，以key-value进行读写。调用objc_autoreleaseReturnValue时将其存储进去，调用objc_retainAutoreleasedReturnValue时，去TLS中读取，如果读取到就不需要retain了。如果一方ARC，一方非ARC，那就需要依赖地址偏移量了。</p>
</blockquote>
<p>Q: 关联对象功能、基本内部参数(参考objc-refrences.mm文件)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">功能：为现有类添加属性</div><div class="line">1. AssociationsManager提供操作时候的spinlock锁</div><div class="line">2. AssociationsHashMap提供存储关联对象和ObjectAssociationMap的hash表</div><div class="line">3. ObjectAssociationMap用来存储key和ObjcAssociation</div><div class="line">4. ObjcAssociation一个C++的类用来存储关联引用的参数</div></pre></td></tr></table></figure>
<p>Q: objc_setAssociatedObject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 根据传入的value，以及策略，产生new_value</div><div class="line">2. 如果new_value为nil，根据对象地址找到ObjectAssociationMap，通过key找到关联引用，将其置为nil</div><div class="line">3. 如果new_value不为nil，根据对象地址找到ObjectAssociationMap，这个map不存在的话就自动创建。map存在的话，就根据key去找对应的ObjcAssociation，将新的关联引用存储，旧的关联引用释放。</div></pre></td></tr></table></figure>
<p>Q: objc_getAssociatedObject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 根据对象地址去查找ObjectAssociationMap</div><div class="line">2. 根据key在ObjectAssociationMap中查找对应的关联引用，存在就返回ObjcAssociation的value值，不存在返回nil。</div></pre></td></tr></table></figure>
<p>Q: objc_removeAssociatedObjects</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 根据对象地址去查找ObjectAssociationMap</div><div class="line">2. 将ObjectAssociationMap所有关联引用存储到vector中</div><div class="line">3. 释放所有存储对象</div></pre></td></tr></table></figure>
<h3 id="冷门小知识"><a href="#冷门小知识" class="headerlink" title="冷门小知识"></a>冷门小知识</h3><p>Q: ==，isEqual，各类衍生的isEqualXXX的区别</p>
<blockquote>
<p>==直接判断，判断基本类型时，判断值是否相等。判断对象时，判断所指向内存地址是否相同。</p>
<p>isEqualXXX，由isEqual衍生而来，当你知道两者类型相同时，使用这个比isEqual快。应该是省去了二者类型的比较和指向地址的比较，直接进行内容比较。</p>
<p>isEqual，NSObject提供的方法，正常来讲是跟==相同。但是iOS中的一些类对它进行了重写，我知道的有UIColor,NSArray,NSDictionary,NSSet,NSData.重写之后它们只进行类型判断和存储的数据判断，而不判断指向地址。不信的话，你可以初始化两个NSObject进行判断，再初始化两个NSArray进行判断，看下返回结果。</p>
<p>最后提一嘴，值相同的，hash值也相同，反之不一定。</p>
</blockquote>
<p>Q: App中使用了单独hash表的有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 引用计数 (对象地址为key，强引用为value)</div><div class="line">2. 弱引用 (对象地址为key，弱引用为value)</div><div class="line">3. 关联对象 (对象地址为key，关联引用为value)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇关于技术知识点的整理汇总，在技术道路上，有许多知识点属于不常用但有用的知识，如果不加以记录，时间久了记忆就会模糊，不利于知识积累。我就是深受其害o(╥﹏╥)o&lt;/p&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://yoursite.com/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>关于浮点型精度问题的一些理解</title>
    <link href="http://yoursite.com/2018/04/27/About%20float-point%20precision/"/>
    <id>http://yoursite.com/2018/04/27/About float-point precision/</id>
    <published>2018-04-27T03:43:37.000Z</published>
    <updated>2018-04-27T08:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于浮点型精度的文章，大致会从三个大的问题入手，去解析精度问题。</p>
<ol>
<li>字符串转浮点型出现精度丢失</li>
<li>浮点型和浮点型操作精度丢失</li>
<li>NSDecimalNumber如何解决精度丢失</li>
</ol>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>4月21号终于完成了4月份的自考，也有些时间来研究一些东西，写写博客了，刚好群里边有人问关于浮点型精度的问题，我去研究了一些资料，问了一些前辈和同行，总结如下，结尾处会有我参考资料的链接。(以下内容均是基于32位系统进行描述的)</p>
<h3 id="字符串在内存中的存储方式"><a href="#字符串在内存中的存储方式" class="headerlink" title="字符串在内存中的存储方式"></a>字符串在内存中的存储方式</h3><p>首先，我们了解一下字符串的存储方式，它是以ASCII码进行存储的，然后将对应的ASCII码转换成二进制存储在内存中。</p>
<p>例如：a对应的ASCII码是97，97对应的七位二进制表示是1100001，八位是01100001，这两者区别可以忽略掉，八位二进制可表示的字符范围更宽泛而已。因为是一个字符所以只需要1个字节，也就是8位，也就是1组二进制。</p>
<p>1.23作为一个字符串它由4个字符组成所以需要4个字节，也就是32位，需要4组二进制。它们分别对应的ASCII码是49、46、50、51，转换成二进制就分别是110001、101110、110010、110011。</p>
<h3 id="浮点型在内存中的存储方式"><a href="#浮点型在内存中的存储方式" class="headerlink" title="浮点型在内存中的存储方式"></a>浮点型在内存中的存储方式</h3><p>浮点型作为一种与整型不同的存储方式，它是遵循IEEE754标准的。浮点型在内存中的存储分为了3个部分，分别是1个符号位s，8个指数E，23个有效数字M。任意一个二进制数V都可以写成<code>sM*2^E</code>，s就是正号和负号，M就是有效数字，E就是指数。这个公式的意思是将M的小数点向右移E位。下面是IEEE754的一些规定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 当s=0，V为正数；当s=1，V为负数。</div><div class="line">2. M表示有效数字，大于等于1，小于2。</div><div class="line">3. 2^E表示指数位。</div><div class="line">4. E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127。</div><div class="line">5. 在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。</div></pre></td></tr></table></figure>
<p>例如浮点数10.0，转换成二进制是1010，在32位系统下你还要在前面补上28个0，这个二进制并不是在内存中的存储样式。套用上面的公式你可以写成+1.010*2^3，其中s是0，那么也就是+，M就是1.01，E就是3。这只是公式，并不是在内存中的真正存储形式。接下来看下下面的图，图中的数值不用看，跟本文无关，主要是看组成的三部分。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E7%BC%96%E7%A0%81%E7%A9%BA%E9%97%B4.png" alt=""></p>
<p>看过了上图，还是以+1.010*2^3为例，将其填入该32位的二进制中。</p>
<ol>
<li>首先是符号位S，也就是图中的sign，因为是正号，所以sign是0；</li>
<li>E是3，按第4条规则，E的真实值需要E+127，也就是130，将其转成二进制存储，也就是10000010；</li>
<li>M是1.010，按上述第5条规则，舍去1，也就是01000000000000000000000；</li>
<li>所以合在一起，浮点数10.0在内存中的表示就是01000001001000000000000000000000。</li>
</ol>
<h3 id="整型在内存中的存储方式"><a href="#整型在内存中的存储方式" class="headerlink" title="整型在内存中的存储方式"></a>整型在内存中的存储方式</h3><p>既然浮点型和字符串在内存中的存储方式都说了，顺道提下整型在内存中的存储方式。</p>
<p>这个很简单，它只需要考虑一个问题，就是正数和负数，它由两部分构成，第一个还是符号位，表示正负，后面31位都是实际存储的数字，所以它支持存储的数字范围是-2^31~~~2^31-1。只需要直接将整数转换成二进制就可以了。</p>
<p>比如100，在内存中的二进制表示就是00000000000000000000000001100100。</p>
<h3 id="字符串转浮点型出现精度丢失"><a href="#字符串转浮点型出现精度丢失" class="headerlink" title="字符串转浮点型出现精度丢失"></a>字符串转浮点型出现精度丢失</h3><p>前面说了字符串的存储方式和浮点型的存储方式，现在这个问题其实挺好解决的了。对了，还要说的一点是，你用的什么方法进行强转的，对于NSString类型的转成float，一般使用的是floatValue方法，那么可以看下官方文档对这个方法的解读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The floating-point value of the string as a float.</div><div class="line">This property doesn’t include whitespace at the beginning of the string. This property is HUGE_VAL or –HUGE_VAL on overflow, 0.0 on underflow. This property is 0.0 if the string doesn’t begin with a valid text representation of a floating-point number.</div><div class="line">This method uses formatting information stored in the non-localized value; use an NSScanner object for localized scanning of numeric values from a string.</div></pre></td></tr></table></figure>
<p>上文比较有用的信息就是这个方法是通过NSScanner对字符串进行逐个扫描，如果不是一个真正的浮点型，比如@”abv”这种，这个方法就是0.0；如果是@”1.23”这种，它就会转化成浮点型1.23。所以可以排除掉这个可能：浮点型和字符串在内存中的二进制表现形式不同而导致的。</p>
<p>那么，问题就很清楚了，肯定是浮点型自身存储成2进制的时候发生了精度丢失。这次举两个例子对比下：</p>
<ol>
<li>浮点数10.0，它的有效数字M是1.010，忽略掉整数位1，实际存储的也就3位是010，在32位情况下，M最多可以存储23位有效数，所以它是无损的。</li>
<li>浮点数1.2，它的有效数字是0011001100110011001100110011001100110011001100110011，这个长度大大超过了23位能存储的，所以它会被截取掉后面超出的部分，超出部分明显不全是0，所以会对它的精度造成损失。</li>
<li>总结：精度损失不损失需要看十进制的数据能否精确的转换为二进制。</li>
</ol>
<h3 id="浮点型和浮点型操作精度丢失"><a href="#浮点型和浮点型操作精度丢失" class="headerlink" title="浮点型和浮点型操作精度丢失"></a>浮点型和浮点型操作精度丢失</h3><p>关于这个问题，其实看懂了上面的内容，就知道这个问题出在哪里了。比如a=b+c;首先浮点型b和c自身存储就已经损失精度了，其次得到的结果a如果也是一个不能精确转为二进制的浮点型，那么必然造成精度的2次缺失，会跟你想象中的结果差距更大。</p>
<h3 id="NSDecimalNumber如何解决精度丢失"><a href="#NSDecimalNumber如何解决精度丢失" class="headerlink" title="NSDecimalNumber如何解决精度丢失"></a>NSDecimalNumber如何解决精度丢失</h3><p>找到了问题的产生原因，再来说说iOS提供的NSDecimalNumber这个类如何解决这个问题。我们先来看下系统文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSDecimalNumber, an immutable subclass of NSNumber, provides an object-oriented wrapper for doing base-10 arithmetic. An instance can represent any number that can be expressed as mantissa x 10^exponent where mantissa is a decimal integer up to 38 digits long, and exponent is an integer from –128 through 127.</div></pre></td></tr></table></figure>
<p>上述大概意思是NSDecimalNumber是NSNumber的一个子类，它提供了一个基于10进制面向对象的封装。它也有一个类似IEEE754的公式：<code>N*M*10^E</code></p>
<p>例如浮点型1.23，套用上面公式就是<code>1*123*10^(-2)</code>。它会将这个浮点型包装成一个NSDecimalNumber对象，N代表是正数还是负数，在本例中是1，M代表将浮点型转化为整数后的数，在本例中是123，E代表指数，在本例中是-2。</p>
<p>这样来看，系统的处理方式其实很明显了，这个类不存储浮点型，只存储整数，自然避免了IEEE754那种方式的精度损失，当然类在内存中肯定跟浮点型是不同的，但是M这个属性保存的是整数型，是同浮点型一样都是基础数据类型。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>其实还有一个整型强转浮点型的问题，这个问题跟字符串转浮点型的情况还是不同的，这个是因为两者对二进制的转化方式不同。整型存储在内存中是直接转化成二进制的，浮点型虽然也是转成二进制存储，但它需要符合IEEE754标准，所以你直接把整型的二进制取出来当浮点型使用，肯定会出现对应的问题。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII码</a></li>
<li><a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE754</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="external">阮一峰-浮点数二进制的表示</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsdecimalnumber?language=objc" target="_blank" rel="external">NSDecimalNumber文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇关于浮点型精度的文章，大致会从三个大的问题入手，去解析精度问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串转浮点型出现精度丢失&lt;/li&gt;
&lt;li&gt;浮点型和浮点型操作精度丢失&lt;/li&gt;
&lt;li&gt;NSDecimalNumber如何解决精度丢失&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://yoursite.com/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>如何适配iPhoneX</title>
    <link href="http://yoursite.com/2017/09/17/AdaptationiPhoneX/"/>
    <id>http://yoursite.com/2017/09/17/AdaptationiPhoneX/</id>
    <published>2017-09-17T02:01:42.000Z</published>
    <updated>2017-09-17T04:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何适配iPhone X</p>
<a id="more"></a>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><ul>
<li>它是一个3倍屏，也就是3x，通俗讲就是1个pt3个px</li>
<li>竖屏状态下，宽度是375pt，高度是812pt，分辨率是1125px × 2436px；横屏状态下，宽高相反</li>
<li>系统的UIKit会自动适配，例如<code>UINavigationBar</code>,<code>UITabbar</code>,<code>UITableView</code></li>
<li>如果你使用Auto Layout，特别是使用margin layout guides和safe area的话，布局会非常简单(这两个概念后面细说)</li>
</ul>
<h4 id="margin-layout-guides-和-safe-area"><a href="#margin-layout-guides-和-safe-area" class="headerlink" title="margin layout guides 和 safe area"></a>margin layout guides 和 safe area</h4><p>首先说明下margin layout guides，它是在iPhone X出来之前每一个控制器都有的两个属性，分别叫做<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>。这两者合起来组成了一个可以用于布局的标准高度，也就是你正常情况能用来放置控件的区域，因为竖屏状态左右是不会出现tabbar或者navigationBar的。</p>
<p><code>topLayoutGuide</code>无导航栏时，从y=状态栏高度开始。当然要说的一点是，iOS 7以及之后，状态栏都是透明的，所以在没有导航栏的时候，我们通常会将状态栏也视作可用范围，但一般只是填充颜色。当存在导航栏时，从y=状态栏高度+导航栏高度开始。这时导航栏会填充状态栏的背景色。</p>
<p><code>bottomLayoutGuide</code>正常情况下，位于视图的最底部，也就是y=屏幕高度的位置。当存在tabbar时，它位于y=屏幕高度-tabbar高度的位置。</p>
<p>safe area代表的就是中间可用于布局的区域。以竖屏iPhone X为例：</p>
<ul>
<li>它不考虑tabbar和navigationBar的translucent</li>
<li>状态栏高度44pt</li>
<li>导航栏高度44pt，对，导航栏高度一直是44，不要被视觉骗了</li>
<li>tabbar高度49pt</li>
<li>操作区，也就是以前的home键，高度是34pt，下文统一操作区称呼</li>
</ul>
<p>当导航栏状态栏存在时，safe area 的frame是(0, 0, 375, 812-44-44-49-34=641)。<br>当导航栏存在时，safe area 的frame是(0, 0, 375, 812-44-44-34=690)。<br>当tabbar存在时，safe area 的frame是(0, 0, 375, 812-44-49-34=685)。<br>当两者皆不存在时，safe area 的frame是(0, 0, 375, 812-44-34=734)。</p>
<p>这个safe area就是我们可以随意布局的地方，就像之前的layout guide一样，其实两者没什么区别。只不过safe area用矩形来表达，更加明确。</p>
<h4 id="屏幕的差异化"><a href="#屏幕的差异化" class="headerlink" title="屏幕的差异化"></a>屏幕的差异化</h4><p>明确了解两种iPhone屏幕的不同是适配的前提，如下图:<br><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Diff%20iPhone.png" alt=""></p>
<p>这是我在Xcode 9Beta版分别跑的iPhone 8和iPhone X的模拟器，大家可以很清楚的看到二者的区别。首先，这个项目只是加了一个自定义的白色的view，背景色是橘黄色。其次，是在storyBoard中使用AutoLayout进行布局，白色view的约束是上下左右都是0。</p>
<p>从图上也可以看出，safe area的区域所占据的屏幕边缘是正常的矩形，也就是说苹果已经把椭圆边角的区域处理掉了，这就大大降低了布局的难度。当然，如果状态栏也被隐藏就需要特殊的设计以及布局了，另外下面那个操作区是没办法隐藏的。当你只在安全区布局时，完全可以像以前一样，不需要考虑任何边角问题。</p>
<h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><ul>
<li>当我们选择storyboard和xib布局时，我们都是在safe area中布局的</li>
<li>当我们选择代码布局时，我们不能使用self.view.frame了，它会包含圆角区域</li>
<li>我们在viewDidAppear中获取self.view.safeAreaLayoutGuide.layoutFrame，这个时候可以得到准确的safe area的frame</li>
<li>而类似Mansory这种第三方布局框架，它们需要进行引入类似概念的升级了</li>
</ul>
<p><a href="https://github.com/yownyang/Resource/tree/master/Project/OC/AdaptationiPhonX" target="_blank" rel="external">项目地址</a></p>
<h4 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h4><ul>
<li>iOS 11带来了ARKit和Core ML这两大框架</li>
<li>iPhone X指纹的移除</li>
<li>系统的Push、Pop动画形式也发生了改变</li>
<li>Xcode中添加了更加利于重构的工具</li>
<li>还有很多别的东西，大家慢慢玩，我相信会被苹果玩死的</li>
</ul>
<h4 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h4><ul>
<li><a href="">https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何适配iPhone X&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Other-Book</title>
    <link href="http://yoursite.com/2017/09/13/ReadBook_Other/"/>
    <id>http://yoursite.com/2017/09/13/ReadBook_Other/</id>
    <published>2017-09-13T10:03:04.000Z</published>
    <updated>2017-10-10T07:06:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序员相关书籍，不要只做一个iOS码农，要成为一个真正的程序员。</p>
<a id="more"></a>
<ol>
<li><strong>《代码整洁之道》</strong> 这本书其实应该叫“通往专业程序员的道路”，本书讲述了作者很多的亲身经历，以及很多概念，例如流态、TDD、卡塔等。写的相当全面，写出了如何做一个专业的程序员，而不是混日子的码农，强烈推荐看这本思想层面的书。遗忘历史者，必重蹈覆辙。</li>
<li><strong>《重构》</strong> 这是一本非常经典的书，程序员必读。本书以示例的方式讲述了重构的尽可能多的情况，脱离了很多书的那种空洞感。重构这种偏思维的知识，跟设计模式一样，是需要在项目中切实使用，切身体会才能完全掌握的。随着项目的不断迭代，重构也需要持续进行。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序员相关书籍，不要只做一个iOS码农，要成为一个真正的程序员。&lt;/p&gt;
    
    </summary>
    
      <category term="ReadBook" scheme="http://yoursite.com/categories/ReadBook/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第七章</title>
    <link href="http://yoursite.com/2017/07/16/The%20System%20Frameworks/"/>
    <id>http://yoursite.com/2017/07/16/The System Frameworks/</id>
    <published>2017-07-16T09:59:09.000Z</published>
    <updated>2017-07-23T09:09:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第七章：系统框架。</p>
<p>这是这本书的最后一节了，翻译的有问题的地方看得人还请多多谅解。翻译完这本书就准备闭关，好好沉淀知识了。学习使我开心。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>你在使用<code>Objective-C</code>进行开发时，不使用框架是不可能的。即使是你使用的根类<code>NSObject</code>，它也是<code>Foundation</code>框架的一部分而不是语言本身的。如果你不想使用<code>Foundation</code>框架，你需要去写自己的根类，自己的集合类，自己的事件循环，和其他有用的类。而且，你也不能使用<code>Objective-C</code>为Mac OS X和iOS开发的其余框架。它们都是强大的，是开发者以年为单位进行优化的。因此，你可能会看到某些部分有感觉古老和笨拙的代码，但也会有意想不到的好东西在里面。</p>
<h3 id="熟悉你使用的系统框架"><a href="#熟悉你使用的系统框架" class="headerlink" title="熟悉你使用的系统框架"></a>熟悉你使用的系统框架</h3><p>当你使用<code>Objective-C</code>编写程序时，你肯定会用到系统框架，它们会提供许多常用类，例如集合，你只需要编写应用就可以了。如果你不知道这些系统框架提供的功能，你很可能会写一些已经实现的功能。当操作系统更新时，应用的使用者会获取最新的系统框架代码。所以如果你使用了这些框架，你能从中获得性能提高的收益，并且不需要更新你的应用程序。</p>
<p>一个框架其实是由代码集合打包成的动态库，并且将头文件作为接口。有时，第三方库的框架是一个静态库，因为iOS应用程序不允许使用动态库(PS:但是现在的第三方库还是有动态框架的，例如QQ登录)。它们不是真正的框架但是经常这样叫它们。但是，所有的iOS的系统框架都是使用的动态库。</p>
<p>如果你为Mac OS X或者iOS开发图形应用程序，你肯定会用到一个叫做<code>Cocoa</code>的层，它在iOS上被称为<code>Cocoa Touch</code>。<code>Cocoa</code>不是一个框架，它是那些在创建应用时常用框架的集合。</p>
<p>你主要会使用的框架叫做<code>Foundation</code>，它有<code>NSObject</code>、<code>NSArray</code>、 <code>NSDictionary</code>等类。这些类的前缀使用框架的<code>NS</code>前缀，因为它是在<code>NeXTSTEP</code>系统上使用<code>Objective-C</code>语言时确定的。<code>Foundation</code>框架是所有<code>Objective-C</code>应用程序的核心，如果没有它，本书讲的很多东西就是在瞎扯了。</p>
<p><code>Foundation</code>提供的功能不止集合这些，它也提供了例如字符串处理这种复杂功能。例如，<code>NSLinguisticTagger</code>提供了解析一个字符串并找到其中名词、动词、代词等的功能。简言之，<code>Foundation</code>提供的功能不只是基础。</p>
<p><code>Foundation</code>有一个叫做<code>CoreFoundation</code>的伴生类。尽管它不是一个<code>Objective-C</code>类，但它仍是一个重要框架，在你编写<code>Objective-C</code>程序时，它可以提供很多与<code>Foundation</code>框架等同功能的函数。<code>Foundation</code>和<code>CoreFoundation</code>不止名字相似，它们也有很多关联。一个众所周知的功能就是通过无缝桥接可以将一个<code>CoreFoundation</code>的<code>C</code>结构体转化为<code>Foundation</code>的<code>Objective-C</code>对象，反之亦然。例如，使用<code>Foundation</code>框架创建一个<code>NSString</code>类型的字符串，它等价于<code>CoreFoundation</code>的<code>CFString</code>。无缝桥接使运行时认为<code>CoreFoundation</code>对象是<code>Objective-C</code>对象。不幸的是，无缝桥接是非常复杂的，所以你自己不太可能手工实现它。这个功能开发时使用还是挺不错的，但是手动实现它，就需要考虑考虑了。</p>
<p>除了<code>Foundation</code>和<code>CoreFoundation</code>之外还有很多系统框架。包括但不限于下列框架：</p>
<blockquote>
<p>CFNetwork</p>
</blockquote>
<p>此框架基于BSD套接字进行封装，提供了C级别的易用的网络基础。<code>Foundation</code>将其包装为<code>Objective-C</code>接口，例如<code>NSURLConnection</code>从一个URL下载数据。 </p>
<blockquote>
<p>CoreAudio</p>
</blockquote>
<p>它提供了一个基于设备硬件的C级别的音频接口。这套框架很难使用，因为音频本身就很复杂。幸运的是，<code>Objective-C</code>抽象了一套更简单易用的API。</p>
<blockquote>
<p>AVFoundation</p>
</blockquote>
<p>它提供了<code>Objective-C</code>对象可以用来进行音视频的录制和播放功能，例如使用<code>UIView</code>视图去展示一个视频。</p>
<blockquote>
<p>CoreData</p>
</blockquote>
<p>它提供了<code>Objective-C</code>接口用于将对象存储在数据库中。它可以在Mac OS X 和 iOS上处理数据库数据获取和存储。</p>
<blockquote>
<p>CoreText</p>
</blockquote>
<p>它提供的C语言接口可以高效的进行文字排版和渲染。</p>
<p>当然还有别的框架，但是从列表就可以看出来，开发应用时，通常需要使用C级别的API。C级别的API绕过<code>Objective-C</code>的运行时可以带来速度的提升。当然，使用C级别的API更要小心内存管理问题，因为ARC仅适用于<code>Objective-C</code>对象。如果你使用这些框架，对它们进行了解是很重要的。</p>
<p>你可能还会编写使用UI框架的Mac OS X 和 iOS应用。它们的核心UI框架，分别被成为AppKit和UIKit，它们都提供了基于<code>Foundation</code>和<code>CoreFoundation</code>构建的<code>Objective-C</code>类。它们提供了UI元素，可以将多个UI元素粘合在一起构成应用程序。在这些主要的UI框架之下是<code>CoreAnimation</code>和<code>CoreGraphics</code>框架。</p>
<p><code>CoreAnimation</code>是用<code>Objective-C</code>写的，它提供了一些工具用于渲染图形和执行动画。你可能不需要使用这个级别的API，但知道它是很好的。<code>CoreAnimation</code>不是一个框架，但它是<code>QuartzCore</code>框架的一部分。但是在框架中，它仍算是一等公民。</p>
<p><code>CoreGraphics</code>是用C写的，它提供了数据结构和函数去进行2D渲染。例如，定义<code>CGPoint</code>、<code>CGSize</code>、<code>CGRect</code>的数据结构，而<code>UIKit</code>中的<code>UIView</code>类在定位位置时，这些结构都需要使用。</p>
<p>多数框架是基于UI框架搭建的，例如<code>MapKit</code>，它给iOS提供地图功能。比如<code>Social</code>框架，它给Mac OS X和iOS提供社交网络功能。开发者通常会将这些框架与核心框架结合使用。</p>
<p>总体来讲，许多框架都是直接存在于Mac OS X和iOS。所以，如果你需要写一个辅助类，首先搜索下有没有相应的系统框架吧。通常，它都是已经实现了的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>对开发者而言，许多系统框架都是可以直接用的。最重要的是<code>Foundation</code>和<code>CoreFoundation</code>，它们提供了整个应用程序的许多核心函数。</li>
<li>许多任务都可以使用已有的系统框架，例如音频、视频、网络通信、数据管理。</li>
<li>请记住纯粹用C代码写成的框架是一样重要的，如果你想成为一个好的<code>Objective-C</code>开发者，你应该理解C的核心概念。</li>
</ul>
<h3 id="相比for循环更喜欢用block枚举"><a href="#相比for循环更喜欢用block枚举" class="headerlink" title="相比for循环更喜欢用block枚举"></a>相比for循环更喜欢用block枚举</h3><p>在项目中，枚举一个集合是非常常见的任务，<code>Objective-C</code>也有很多方法可以做到，从C的标准for循环，到<code>Objective-C</code>1.0的<code>NSEnumerator</code>，到<code>Objective-C</code>2.0的快速枚举。block的出现给语言添加了一些开发者经常忽视的方法。这些方法允许你通过一个block去枚举集合，集合中的每个元素都会运行并且是易于使用的。</p>
<p>这些集合是通常会使用枚举的，如<code>NSArray</code>、<code>NSDictionary</code>、<code>NSSet</code>。另外，自定义的集合枚举也可以支持，但这不是我们这节要讲的内容。</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是以前常用的遍历数组的好办法，它来源于C语言。这个方法非常基础所以限制很大。通常是这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (int i = 0; i &lt; anArray.count; i++) &#123;</div><div class="line">    id object = anArray[i];</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是可以接受的，但当遍历字典或集合时它变得复杂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">NSArray *keys = [aDictionary allKeys];</div><div class="line">for (int i = 0; i &lt; keys.count; i++) &#123;</div><div class="line">    id key = keys[i];</div><div class="line">    id value = aDictionary[key];</div><div class="line">    // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">NSArray *objects = [aSet allObjects];</div><div class="line">for (int i = 0; i &lt; objects.count; i++) &#123;</div><div class="line">    id object = objects[i];</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为字典和集合是无序的，所以没有办法直接通过确定的整数值去获取数据。因此，你需要将字典的所有键或者集合的所有对象，将其组成一个有序的数组，然后通过枚举访问每个值。创建这个数组是一个额外的工作，并导致有额外对象持有集合中的对象。当然，这些对象会在数组释放时释放的，但这个方法不是必须调用的。从技术上讲，使用for循环，其他所有对象枚举时都需要创建一个额外的数组。</p>
<p>使用for循环也可以向后枚举，开始数值是集合对象的最大个数，每次循环建议，当数值为0时，停止循环。这也是非常简单的。</p>
<h4 id="Objective-C-1-0使用NSEnumerator进行枚举"><a href="#Objective-C-1-0使用NSEnumerator进行枚举" class="headerlink" title="Objective-C 1.0使用NSEnumerator进行枚举"></a>Objective-C 1.0使用NSEnumerator进行枚举</h4><p><code>NSEnumerator</code>是一个抽象基类，它仅定义了两个方法用于让子类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSArray*)allObjects</div><div class="line">- (id)nextObject</div></pre></td></tr></table></figure>
<p>关键方法是<code>nextObject</code>，它返回枚举中的下一个对象。每次这个方法被调用，内部的数据结构都会返回下一个对象。这样枚举中的所有对象都会返回，当枚举到最后一个时，返回nil。</p>
<p><code>Foundation</code>框架中的集合类都实现了这个方法。例如，枚举数组是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">NSEnumerator *enumerator = [anArray objectEnumerator];</div><div class="line">id object;</div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这根for循环很相似，但也有额外的工作。它的唯一好处大概就是所有的集合枚举都是使用相似的语法。例如，考虑下面的字典和集合的枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">NSEnumerator *enumerator = [aDictionary keyEnumerator];</div><div class="line">idkey;</div><div class="line">while ((key = [enumerator nextObject]) != nil) &#123;</div><div class="line">    id value = aDictionary[key];</div><div class="line">    // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">NSEnumerator *enumerator = [aSet objectEnumerator];</div><div class="line">id object;</div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字典的枚举是稍有不同的，因为字典有键和值，所以需要根据键去获取字典中的值。使用<code>NSEnumerator</code>还有个好处就是可以使用不同种类的枚举器。例如，一个数组，可以使用逆向枚举。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">NSEnumerator *enumerator = [anArray reverseObjectEnumerator];</div><div class="line">id object;</div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样是比for循环语法更易阅读的。</p>
<h4 id="快速枚举"><a href="#快速枚举" class="headerlink" title="快速枚举"></a>快速枚举</h4><p>快速枚举产生于<code>Objective-C</code>2.0。快速枚举和<code>NSEnumerator</code>是非常相似的，不过语法是非常简洁的，它为for循环添加了in关键字。使用关键字的语法是非常简洁的，例如数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (id object in anArray) &#123;</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样是非常简单的！如果一个类的对象想进行枚举，它只要遵循<code>NSFastEnumeration</code>协议。这个协议只定义了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState*)state</div><div class="line">                                  objects:(id*)stackbuffer</div><div class="line">                                    count:(NSUInteger)length</div></pre></td></tr></table></figure>
<p>这个方法的原理不是本节所讲述的内容。但是，网上是有关于它们的优秀教程的。需要注意的是它可以同时返回多个对象，这样使得枚举循环更高效。</p>
<p>字典和集合的枚举如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">for (id key in aDictionary) &#123;</div><div class="line">    id value = aDictionary[key];</div><div class="line">    // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">for (id object in aSet) &#123;</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逆向枚举也可以通过<code>NSEnumerator</code>实现，因为它也实现了<code>NSFastEnumeration</code>。所以如果要逆向一个数组，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (id object in [anArray reverseObjectEnumerator]) &#123;</div><div class="line">    // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的语法是最简单和高效的，但是如果你需要在遍历字典时，使用字典的键和值，你仍然需要额外的步骤。另外，这个循环不像传统for循环，它无法很容易的获取下标值。在许多场景中，下标都是非常有用的。</p>
<h4 id="基于block的枚举"><a href="#基于block的枚举" class="headerlink" title="基于block的枚举"></a>基于block的枚举</h4><p>在当前的<code>Objective-C</code>语言中，最新的一种做法是基于block来遍历。例如数组的基本枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block</div></pre></td></tr></table></figure>
<p>这个方法的系列中还可以传入一系列的参数，我们将在稍后讨论它们。</p>
<p>对于数组和集合，block每次执行时都会带有一个当前对象和当前下标以及一个bool值的指针。前两个参数与正常循环一样。第三个参数提供了停止枚举的一种机制。</p>
<p>例如，你可以使用这个方法枚举一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;object&apos;</div><div class="line">     if (shouldStop) &#123;</div><div class="line">         *stop = YES;</div><div class="line">     &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这个语法比快速枚举稍微复杂点，但它很清楚，并且你可以得的对象和下标两个值。如果你想暂停循环，你可以通过<code>stop</code>参数终止循环，尽管你使用<code>break</code>也可以达到同样的目的。</p>
<p>不仅仅数组可以通过这种方式枚举。同样的block枚举方法也存在<code>NSSet</code>和<code>NSDictionary</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id object, BOOL *stop))block</div></pre></td></tr></table></figure>
<p>因此，枚举字典和集合就像刚才那样简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;key&apos; and &apos;object&apos;</div><div class="line">    if (shouldStop) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">[aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;object&apos;</div><div class="line">     if (shouldStop) &#123;</div><div class="line">         *stop = YES;</div><div class="line">     &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这种方法比别的好很多的原因是你在block中可以直接获得很多信息。在数组那个例子中，你可以从枚举中得到下标。遍历有序set时也是一样的。在字典中，你不需要任何额外的操作就可以得到键和值，因此不需要通过指定键获取值。这种方式也是很快的，因为在字典内部的数据结构中，它们是在一起存储的。</p>
<p>另一个好处是，你可以修改block的方法签名，限制为需要的类型；实际上，你将类型转换交给了block方法签名来做。考虑使用快速枚举对字典进行枚举。如果字典中的对象是一个字符串，你可能这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (NSString *key in aDictionary) &#123;</div><div class="line">    NSString *object = (NSString*)aDictionary[key];</div><div class="line">    // Do something with &apos;key&apos; and &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而使用block枚举，你可以这样修改block枚举的方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">[aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL *stop)&#123;</div><div class="line">    // Do something with &apos;key&apos; and &apos;obj&apos;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>可以这样做的原因是，<code>id</code>类型是非常特殊的，它可以代表任何类型。如果本来的block方法签名定义为<code>NSObject*</code>，这样写就会出问题了。这技巧看上去不起眼，实际非常有用。指定对象的类型后，如果你调用了这个对象不相应的方法，编译器会抛出一个错误。如果你知道集合中对象的类型，使用这种方法指明类型是很重要的。</p>
<p>它也可以进行逆向枚举。数组，字典，集合都实现了前面方法的变体，允许你传入一个选项掩码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)options</div><div class="line">                         usingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block</div><div class="line">- (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)options</div><div class="line">                                usingBlock:(void(^)(id key, id obj, BOOL *stop))block</div></pre></td></tr></table></figure>
<p><code>NSEnumerationOptions</code>类型是<code>enum</code>，你可以使用按位或来连接它的值用以表达枚举行为。例如，你可以请求以并发形式迭代，意思是，如果系统资源允许，每次迭代的block都可以并行执行。使用<code>NSEnumerationConcurrent</code>选项开启此功能。如果使用这个选型，会使用GCD去处理并发执行，就像之前讲的<code>dispatch groups</code>一样。但是，本节不会讲具体实现。使用<code>NSEnumerationReverse</code>可以进行逆向枚举。注意这只适用于数组和有序集合这些情况。</p>
<p>最重要的是，block枚举有所有其他方法的收益组合，或者更多。它比快速枚举稍微复杂。但是与快速枚举相比，它能提供所有的下标，遍历字典时提供键与值，还能使用并发迭代功能，所以多点代码还是值得的。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>枚举集合有四种方法。最基本的是for循环，其次是<code>NSEnumerator</code>和快速循环。最新最先进的是使用block枚举法。</li>
<li>block枚举通过使用GCD，来允许你并发迭代，不需要任何额外代码。别的枚举方法都不能很容易的达到这个效果。</li>
<li>如果你知道枚举的对象的类型，你可以修改block枚举方法的方法签名。</li>
</ul>
<h3 id="对自定义内存管理语义的集合使用无缝桥接"><a href="#对自定义内存管理语义的集合使用无缝桥接" class="headerlink" title="对自定义内存管理语义的集合使用无缝桥接"></a>对自定义内存管理语义的集合使用无缝桥接</h3><p><code>Objective-C</code>系统框架中集合类是非常多的：数组、字典、set。<code>Foundation</code>框架定义了这些集合的<code>Objective-C</code>类。相似的，<code>CoreFoundation</code>框架也定义了C API，用于操作C类型数据结构的数据集合。例如，<code>NSArray</code>用于操作<code>Objective-C</code>语言的数组，<code>CFArray</code>则用于操作C语言的数组。这两种方法创造出来的数组看起来差距很大，但通过一个强大的被称作无缝桥接的功能，你可以在这两者之间随意转换。</p>
<p>无缝桥接技术允许你将定义在<code>Foundation</code>中的<code>Objective-C</code>对象转化为定义在<code>CoreFoundation</code>中的C数据结构，反之亦然。我之所以称C级别API为数据结构而不是类或对象是因为它与<code>Objective-C</code>的类或对象并不相同。例如，<code>CFArray</code>通过<code>CFArrayRef</code>引用，并且它是指向<code>__CFArray</code>的指针。这个结构体的操作是通过使用这样的函数，例如获取数组大小使用的<code>CFArrayGetCount</code>函数。这和<code>Objective-C</code>中的对应类差别很大，在<code>Objective-C</code>中你可以创建一个<code>NSArray</code>对象，然后调用一个叫做<code>count</code>的方法，去获取这个数组对象的大小。</p>
<p>一个简单的无缝桥接例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *anNSArray = @[@1, @2, @3, @4, @5];</div><div class="line">CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;</div><div class="line">NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(aCFArray));</div><div class="line">// Output: Size of array = 5</div></pre></td></tr></table></figure>
<p><code>__bridge</code>告诉ARC如何处理相关的<code>Objective-C</code>对象。<code>__bridge</code>意味着ARC仍然拥有<code>Objective-C</code>对象的所有权。<code>__bridge_retained</code>意味着ARC不再拥有<code>Objective-C</code>对象的所有权。如果我们在上面的例子中使用了它，那么我们需要在C数组不再使用时添加<code>CFRelease(aCFArray)</code>。相似的，反向转换使用<code>__bridge_transfer</code>完成。例如，将<code>CFArrayRef</code>转化为<code>NSArray*</code>，并且想讲所有权交给ARC，那么使用这个转换。这三种转换方式被称为桥式转换。</p>
<p>但是，你可能会这样想，为什么你会在一个纯粹的<code>Objective-C</code>应用中使用这个功能?这是因为<code>Foundation</code>中的<code>Objective-C</code>类可以做到<code>CoreFoundation</code>中C数据结构无法做到的事，反之亦然。例如，关于<code>Foundation</code>中的字典就有一个问题，它的键是拷贝，值是保留。如果你不使用无缝桥接，这种语义无法修改。</p>
<p><code>CoreFoundation</code>中的字典叫做<code>CFDictionary</code>。对应的可变部分叫做<code>CFMutableDictionary</code>。当创建<code>CFMutableDictionary</code>时，你可以使用下面的方法自定义键和值的内存管理语义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFMutableDictionaryRef CFDictionaryCreateMutable (</div><div class="line">    CFAllocatorRef allocator,</div><div class="line">    CFIndex capacity,</div><div class="line">    const CFDictionaryKeyCallBacks *keyCallBacks,</div><div class="line">    const CFDictionaryValueCallBacks *valueCallBacks</div><div class="line">)</div></pre></td></tr></table></figure>
<p>第一个参数是内存分配器。如果你大部分的时间都是在写<code>Objective-C</code>，那么你对<code>CoreFoundation</code>的这部分感觉陌生。内存分配器对于<code>CoreFoundation</code>对象是必须的，因为数据结构需要占用内存，内存分配器负责初始化和释放。通常，你会将这个值设置为NULL去使用默认内存分配器。</p>
<p>第二个参数指明字典初始化时的大小。它不是用来限制字典的最大尺寸，只是提示内存分配器在开始时要分配多少空间。如果你知道你将要创建的字典有十个键值对，你可以设为10。</p>
<p>最后两个参数都挺有意思的。当键和值存进字典时，它们会调用对应情况的回调。这两个参数都是结构体的指针，它们看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct CFDictionaryKeyCallBacks &#123;</div><div class="line">    CFIndex version;</div><div class="line">    CFDictionaryRetainCallBack retain;</div><div class="line">    CFDictionaryReleaseCallBack release;</div><div class="line">    CFDictionaryCopyDescriptionCallBack copyDescription;</div><div class="line">    CFDictionaryEqualCallBack equal;</div><div class="line">    CFDictionaryHashCallBack hash;</div><div class="line">&#125;;</div><div class="line">struct CFDictionaryValueCallBacks &#123;</div><div class="line">    CFIndex version;</div><div class="line">    CFDictionaryRetainCallBack retain;</div><div class="line">    CFDictionaryReleaseCallBack release;</div><div class="line">    CFDictionaryCopyDescriptionCallBack copyDescription;</div><div class="line">    CFDictionaryEqualCallBack equal;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在这个<code>version</code>参数应该是0。它已经成为当前管理，但是如果苹果公司决定修改机构体，那么它可能会发生变化。这个参数用作检测新版和旧版是否兼容。结构体里面其余部分都是指针，当没一个任务发生时，函数应该如何运行。例如，当每个键和值添加进字典时，会调用<code>retain</code>函数。这个参数类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef const void* (*CFDictionaryRetainCallBack) (</div><div class="line">    CFAllocatorRef allocator,</div><div class="line">    const void *value</div><div class="line">);</div></pre></td></tr></table></figure>
<p>由此可见它是一个函数指针，接受<code>CFAllocatorRef</code>类型和<code>const void*</code>类型的参数。传入的<code>value</code>参数代表添加给字典的是键或值。而返回的<code>void*</code>则代表要添加进字典的值。你可以这样定义你自己的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const void* CustomCallback(CFAllocatorRef allocator, const void *value)</div><div class="line">&#123;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个简单返回的值是未做改变的。所以，如果使用<code>retain</code>回调创建一个字典，键和值都没有被保留。加上无缝桥接，你就可以创建一个特殊的<code>NSDictionary</code>对象，它的行为不同于<code>Objective-C</code>中直接创建的字典。</p>
<p>下面是一个完整的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;CoreFoundation/CoreFoundation.h&gt;</div><div class="line"></div><div class="line">const void* EOCRetainCallback(CFAllocatorRef allocator, const void *value)</div><div class="line">&#123;</div><div class="line">    return CFRetain(value);</div><div class="line">&#125;</div><div class="line">void EOCReleaseCallback(CFAllocatorRef allocator, const void *value)</div><div class="line">&#123;</div><div class="line">    CFRelease(value);</div><div class="line">&#125;</div><div class="line">CFDictionaryKeyCallBacks keyCallbacks = &#123;</div><div class="line">    0,</div><div class="line">    EOCRetainCallback,</div><div class="line">    EOCReleaseCallback,</div><div class="line">    NULL,</div><div class="line">    CFEqual,</div><div class="line">    CFHash</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CFDictionaryValueCallBacks valueCallbacks = &#123;</div><div class="line">    0,</div><div class="line">    EOCRetainCallback,</div><div class="line">    EOCReleaseCallback,</div><div class="line">    NULL,</div><div class="line">    CFEqual</div><div class="line">&#125;;</div><div class="line">CFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL,</div><div class="line">                                                                 0,</div><div class="line">                                                                 &amp;keyCallbacks,</div><div class="line">                                                                 &amp;valueCallbacks);</div><div class="line">NSMutableDictionary *anNSDictionary = (__bridge_transfer NSMutableDictionary*)aCFDictionary;</div></pre></td></tr></table></figure>
<p>在设置回调函数时，<code>copyDescription</code>使用NULL值，因为它的默认已经很好了。<code>equal</code>和<code>hash</code>则分别使用<code>CFEqual</code>和<code>CFHash</code>，因为<code>NSMutableDictionary</code>使用了同样的方法。<code>CFEqual</code>最终会调用<code>NSObject</code>的<code>isEqual:</code>方法，<code>CFHash</code>最终会调用<code>NSObject</code>的<code>hash</code>方法。这就是无缝桥接的强大之处。</p>
<p>无论是键还是值的<code>retain</code>和<code>release</code>回调都分别设置的<code>EOCRetainCallback</code>和<code>EOCReleaseCallback</code>函数。为什么要这样做？会想一下前面所说的，<code>NSMutableDictionary</code>的键会被拷贝，值会被保留。如果你没设置<code>copy</code>回调，那会发生什么？在这种情况下，你不能在<code>NSMutableDictionary</code>中使用它，因为它会在运行时抛出一个这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception</div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;-[EOCClass</div><div class="line">copyWithZone:]:unrecognized selector sent to instance</div><div class="line">0x7fd069c080b0&apos;</div></pre></td></tr></table></figure>
<p>这个错误的意思是这个类不支持<code>NSCopying</code>协议，因为没实现<code>copyWithZone:</code>方法。通过使用<code>CoreFoundation</code>层创建字典，你可以修改键的内存管理语义为保留而非拷贝。</p>
<p>使用类似的方法也可以创建出不保留对象的数组。这个方法可能是有用的，因为如果数组保留元素，可能会导致循环引用，但是请注意，这种情况有更好的办法解决。一个数组不保留对象是非常危险的，如果数组中的某个元素释放了，但它仍在数组中，如果访问这个对象，应用程序将发生崩溃。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>无缝桥接允许你将<code>Foundation</code>框架的<code>Objective-C</code>对象和<code>CoreFoundation</code>框架C数据结构互相转换。</li>
<li>使用<code>CoreFoundation</code>创建集合允许你指定多种回调情况，这些回调情况代表你如何处理集合中的元素。如果配合上无缝桥接，你可以将其转化为特殊内存管理语义的<code>Objective-C</code>集合。</li>
</ul>
<h3 id="使用NSCache替代NSDictionary进行缓存"><a href="#使用NSCache替代NSDictionary进行缓存" class="headerlink" title="使用NSCache替代NSDictionary进行缓存"></a>使用NSCache替代NSDictionary进行缓存</h3><p>当你开发Mac OS X或者iOS应用时，你通常会遇到这样的问题，即从网络上下载的图片如何缓存它们。第一个好的办法是将其存储在字典中，这样后面再使用时就不需要下载了。有些开发者可能直接就会使用<code>NSDictionary</code>了或者是<code>NSMutableDictionary</code>了，因为这是一个常用的类。但是有一个更好的类，它叫做<code>NSCache</code>，它是<code>Foundation</code>框架的一部分，并且它就是为了这种任务设计的。</p>
<p><code>NSCache</code>的收益是大于<code>NSDictionary</code>的，当系统资源快要耗尽时，它会自动清除一部分缓存。当使用字典时，你需要对系统进行hook，在系统低内存时，接受通知进行清理。但是，<code>NSCache</code>是自动的；因为它是<code>Foundation</code>框架的一部分，它可以很轻松的hook在系统的深层次。<code>NSCache</code>会优先删除最长时间未使用的对象，但是开发者使用字典实现这个方法却很复杂。</p>
<p>另外，<code>NSCache</code>不拷贝键而是保留它。如果使用<code>NSDictionary</code>也可以办到，但需要更复杂的代码。缓存通常不希望拷贝键，因为键对象可能不支持拷贝。因为<code>NSCache</code>默认不拷贝键，所以它更适合这种需求。另外，<code>NSCache</code>是线程安全的。<code>NSDictionary</code>线程是不安全的<code>NSDictionary</code>，这意味着你可以在多线程中随时进行存取，而不需要加任何锁。这是非常有用的，因为你通常会在某个线程读取它，如果键不存在，则去下载这个键对应的数据。下载的回调很可能处在其他线程，所以你需要在另外一个线程添加缓存了。</p>
<p>你可以控制缓存合适删除内容。有两个对象分别限制存储的对象个数和存储对象花费的大小。当给缓存添加对象时，你可以选择控制它的大小。当对象总数超出了限制或者对象总花费超出了限制，缓存就会像在系统资源不足时做的一样，进行缓存清除。需要注意的是，可能会删除某对象并不代表一定会删除它。这要取决于具体的实现。这意味着，试图通过控制花费大小去优先删减某对象不是一个好主意。</p>
<p>这个花费限制应该仅在添加对象时能很容易计算出它的大小时添加。如果计算它的代价比较大，那么就不要设置这个值了，因为每次向缓存中添加对象还要计算它的大小会导致速度变慢。重要的是，缓存本身就是为了帮助应用更快的响应。例如，如果需要从磁盘或者数据库获得存储对象的大小，这不是一个好主意。但是，如果你存储的是<code>NSData</code>对象；这种情况下，你可以将数据大小指为花费大小。这是因为<code>NSData</code>对象大小是已知的，获取它的大小不过时调用了一个属性。</p>
<p>下面是一个使用<code>NSCache</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">// Network fetcher class</div><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);</div><div class="line"></div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// Class that uses the network fetcher and caches results</div><div class="line">@interface EOCClass : NSObject</div><div class="line">@end</div><div class="line">@implementation EOCClass &#123;</div><div class="line">    </div><div class="line">    NSCache *_cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)init &#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _cache = [NSCache new];</div><div class="line">        // Cache a maximum of 100 URLs</div><div class="line">        _cache.countLimit = 100;</div><div class="line">        /**</div><div class="line">         * The size in bytes of data is used as the cost, * so this sets a cost limit of 5MB.</div><div class="line">         */</div><div class="line">        _cache.totalCostLimit = 5 * 1024 * 1024;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)downloadDataForURL:(NSURL*)url &#123;</div><div class="line">    NSData *cachedData = [_cache objectForKey:url];</div><div class="line">    if (cachedData) &#123;</div><div class="line">        // Cache hit</div><div class="line">        [self useData:cachedData];</div><div class="line">    &#125; else &#123;</div><div class="line">        // Cache miss</div><div class="line">        EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">        [fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">            [_cache setObject:data forKey:url cost:data.length];</div><div class="line">            [self useData:data];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个例子中，是将下载的URL作为缓存的键。当找不到键对应的数据时，就去下载数据然后将其添加进缓存。这个花费是计算的数据长度。在创建缓存时，将缓存的总数设为100，将总花费设为5M，不过因为总花费单位是字节所以要进行换算。</p>
<p>还有一个类叫做<code>NSPurgeableData</code>，它是<code>NSMutableData</code>的子类，它实现了<code>NSDiscardableContent</code>协议，将它和<code>NSCache</code>配合使用会更强大。如果有对象的内存可以根据需要释放，那么就可以使用它。这意味着当系统资源变少时，可以释放<code>NSPurgeableData</code>数据。<code>NSDiscardableContent</code>协议还定义了一个叫做<code>isContentDiscarded</code>的方法，它可以返回对象内存是否被释放。</p>
<p>如果<code>NSPurgeableData</code>对象需要被访问，你可以调用<code>beginContentAccess</code>方法告诉它这期间不能被释放。当你使用完毕，你可以调用<code>endContentAccess</code>去告诉它可以根据需要释放了。这些调用可以嵌套，所以你可以像引用计数那样成对。仅当引用计数为0，对象才可以丢弃。</p>
<p>如果<code>NSPurgeableData</code>对象添加进<code>NSCache</code>，<code>NSPurgeableData</code>对象会自动从缓存中移除。可以通过设置缓存的<code>evictsObjectsWithDiscardedContent</code>属性去控制开启或者关闭。</p>
<p>使用<code>NSPurgeableData</code>对象对上面示例进行更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)downloadDataForURL:(NSURL*)url &#123;</div><div class="line">    NSPurgeableData *cachedData = [_cache objectForKey:url];</div><div class="line">    if (cachedData) &#123;</div><div class="line">        // Stop the data being purged</div><div class="line">        [cacheData beginContentAccess]; // Use the cached data</div><div class="line">        [self useData:cachedData];</div><div class="line">        // Mark that the data may be purged again</div><div class="line">        [cacheData endContentAccess];</div><div class="line">    &#125; else &#123;</div><div class="line">        // Cache miss</div><div class="line">        EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">        [fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">        NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];</div><div class="line">        [_cache setObject:purgeableData forKey:url cost:purgeableData.length];</div><div class="line">        // Don&apos;t need to beginContentAccess as it begins // with access already marked</div><div class="line">        // Use the retrieved data</div><div class="line">        [self useData:data];</div><div class="line">        // Mark that the data may be purged now</div><div class="line">        [purgeableData endContentAccess]; &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意当创建了一个<code>NSPurgeableData</code>对象时，它会自动加1“引用计数”，所以不需要特地调用<code>beginContentAccess</code>方法，但你必须在使用之后调用<code>endContentAccess</code>方法平衡计数。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用<code>NSCache</code>替代<code>NSDictionary</code>缓存对象，<code>NSCache</code>提供了对象自动清理行为，线程安全，并且不会像字典一样拷贝键。</li>
<li>使用数量限制和花费限制去定义删除缓存中内容的时机。但它们不是硬限制，它们只是一种指导。</li>
<li>使用<code>NSPurgeableData</code>和<code>NSCache</code>，可实现自动清除功能，当缓存清除时，数据对象也会被清除。</li>
<li>如果你正确使用缓存，会使你的应用程序更快的相应。缓存应该仅存储难以获得的数据，例如需要从网络或者磁盘读取的数据。</li>
</ul>
<h3 id="精简initialize和load实现方法"><a href="#精简initialize和load实现方法" class="headerlink" title="精简initialize和load实现方法"></a>精简initialize和load实现方法</h3><p>有时一些类需要先初始化执行一些任务，那么可以使用<code>initialization</code>方法。在<code>Objective-C</code>中，大多数类都继承自<code>NSObject</code>根类，它有两个方法用于执行这种任务。</p>
<p>第一个方法叫做<code>load</code>，它原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)load</div></pre></td></tr></table></figure>
<p>它只会调用一次不论是类还是类别，它是在运行时添加的方法。当类库包含了类或者类别时，这个方法会被调用，通常是在应用启动的时候，如果是iOS程序，那肯定会在这里运行。Mac OS X则更自由一些，它可以在程序启动之后，使用类似动态加载的方式加载类库。如果类和类别中都定义了<code>load</code>方法，那么类中先调用，类别后调用。</p>
<p>使用<code>load</code>方法有个问题，那就是运行时在此时是脆弱的。任何类的父类的<code>load</code>方法都会先于类运行；而且，如果，这段代码依赖别的类库，那么就需要别的类库中的<code>load</code>方法运行完。但是，根据给定的类库，你无法判断出它们的<code>load</code>顺序呢。因此，<code>load</code>方法是不安全的。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;EOCClassA.h&quot; //&lt; From the same library</div><div class="line"></div><div class="line">@interface EOCClassB : NSObject</div><div class="line">@end</div><div class="line">@implementation EOCClassB</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Loading EOCClassB&quot;);</div><div class="line">    EOCClassA *object = [EOCClassA new];</div><div class="line">    // Use &apos;object&apos;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>NSLog</code>那句代码输出是安全的，因为我们知道<code>Foundation</code>框架已经加载过<code>load</code>方法了。但是，在<code>EOCClassB</code>的<code>load</code>方法中是用<code>EOCClassA</code>类是不安全的，因为你不能确定它是否在<code>EOCClassB</code>之前运行了<code>load</code>方法。如你所见，你无法知道<code>EOCClassA</code>类是否在其<code>load</code>方法中做了什么重要操作，使其运行之后才能正常初始化实例。</p>
<p><code>load</code>方法有一个重要的地方是，它不遵守正常的方法继承规则。如果类本身没有实现<code>load</code>方法，那么无论它的父类是否实现了这个方法，都不会调用。另外，<code>load</code>方法可以出现在类别和类之中。这两种实现都会被调用，但类的永远早于类别的。</p>
<p>另外，你也应该确保你的<code>load</code>方法非常精简，因为在读取这个地方代码时，整个程序都处于被阻塞状态。如果某个<code>load</code>方法做了非常多的事情，那么应用程序将会在一段时间内无响应。你不应该在这里执行任何锁操作或者回调操作。本质上，可以放在别处的事情就不要在这里做。实际上，任何想在类使用之前执行的任务，在这里都不会取得太好的效果。它应该仅仅用于调试，比如判断某个分类是否已经被加载。或许这方法以前很有用，但以目前的<code>Objective-C</code>代码来看，完全不需要用到它。</p>
<p>另一个执行与类初始化有关的方法是覆写下面方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)initialize</div></pre></td></tr></table></figure>
<p>这个方法每个类只会调用一次，在类被使用之前。这个方法在运行时被调用，并且永远不需要手动调用它。它跟<code>load</code>方法很相似，但是在某些重要的地方有轻微差别。首先，它是懒调用，这意味着它只会在类第一次使用之前调用。因此，如果这个类永远没有使用，那么这个方法也永远不会被调用。这样做不会像<code>load</code>方法一样导致程序会阻塞一段时间，只有所有<code>load</code>方法运行完毕，程序才会继续运行。</p>
<p>第二个不同于<code>load</code>方法的是，这时的运行时处于正常状态，因此从运行时完整性来讲，此时调用任何方法都是正常。另外，运行时会确保<code>initialize</code>方法执行在线程安全的环境，这意味着它只会执行在那个操作<code>initialize</code>方法的线程。这时其余线程会阻塞，知道<code>initialize</code>方法完成。</p>
<p>最后一个区别是，<code>initialize</code>就像其余的消息一样；如果一个类没有实现它， 但它的父类实现了它，那么将会运行父类的实现。这听起来并不奇怪，但经常被开发者忽略。考虑下面两个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCBaseClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCBaseClass</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;%@ initialize&quot;, self);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCSubClass : EOCBaseClass</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCSubClass</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>即使它不实现<code>initialize</code>方法，<code>EOCSubClass</code>仍会发送这条消息。所有的父类实现都会在第一次被调用。所以，如果第一次调用<code>EOCSubClass</code>，你可能会看到下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCBaseClass initialize</div><div class="line">EOCSubClass initialize</div></pre></td></tr></table></figure>
<p>你可能认为有点奇怪，但它是正常的。正常的继承规则允许<code>initialize</code>方法像其余方法一样(除了load方法)，所以当运行<code>EOCBaseClass</code>时，会将该方法运行一遍，当运行<code>EOCSubClass</code>时，由于它没有实现自己的<code>initialize</code>方法，所以还会调用父类的实现。这就是为什么通常<code>initialize</code>方法会这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (void)initialize &#123;</div><div class="line">    if (self == [EOCBaseClass class]) &#123;</div><div class="line">        NSLog(@&quot;%@ initialized&quot;, self);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个地方加上检查类型，使这个方法只会在本身的类加入系统时才会执行初始化操作。如果将它应用在前面的例子中，那么就只会输出一句话了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCBaseClass initialize</div></pre></td></tr></table></figure>
<p>所有这一切说明<code>load</code>和<code>initialize</code>两个方法应该尽可能的简洁。它们应该被限制只做一些对类初始化有用的事情，而不应该做任何加锁或者和锁有关的。<code>load</code>方法不这样做的理由前面已经说了；<code>initialize</code>方法跟<code>load</code>方法类似。首先，没有开发者愿意应用挂起。类在第一次初始化的时候，<code>initialize</code>方法可以运行在任何线程。如果它运行在UI线程，将会在整个执行<code>initialize</code>方法期间阻塞UI线程，导致应用无响应。限制它在某个线程运行第一次是麻烦的，并且假定它在某个线程执行这个方法也不是一个好主意。</p>
<p>其次，你不能控制一个类什么时候会初始化。这个方法会在类第一次使用时运行，但依赖这个时间点是非常危险的。因为运行时可能在将来更新后发生一些轻微改变，这样的话，你如果假定类在某时一定会初始化就不成立了。</p>
<p>最后，如果你的实现非常复杂，你可能间接或直接调用了其他的类。如果这些类还没有运行<code>initialized</code>，它们将会先运行这个方法。但是，第一个类的<code>initialized</code>方法这时还没有运行完毕。如果别的类依赖第一个类初始化后的某些确定数据，这可能会导致这些数据还没初始化完成。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">static id EOCClassAInternalData;</div><div class="line">@interface EOCClassA : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">static id EOCClassBInternalData;</div><div class="line">@interface EOCClassB : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClassA</div><div class="line">+ (void)initialize &#123;</div><div class="line">    if (self == [EOCClassA class]) &#123;</div><div class="line">        [EOCClassB doSomethingThatUsesItsInternalData];</div><div class="line">        EOCClassAInternalData = [self setupInternalData];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClassB</div><div class="line">+ (void)initialize &#123;</div><div class="line">    if (self == [EOCClassB class]) &#123;</div><div class="line">        [EOCClassA doSomethingThatUsesItsInternalData];</div><div class="line">        EOCClassBInternalData = [self setupInternalData];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果<code>EOCClassA</code>首先运行，那么在<code>EOCClassB</code>中的<code>initialize</code>方法中，它会调用<code>EOCClassA</code>的<code>doSomethingThatUsesItsInternalData</code>方法，但这时还没有设置任何内部数据。事实上，这个问题不会这么明显，它可能牵涉更多的类。因此当代码出现问题时是很难找出错误的。</p>
<p>所以说，<code>initialize</code>方法只应该用于设置内部数据。你不应该调用其它方法，即使是这个类本身的。如果你添加了方法调用，你可能会遇到之前那个问题。使用<code>initialize</code>方法去设置无法再编译时设置的状态是最好的。下面的例子展示了这点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCClass.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCClass.m</div><div class="line">#import &quot;EOCClass.h&quot;</div><div class="line">static const int kInterval = 10;</div><div class="line">static NSMutableArray *kSomeObjects;</div><div class="line">@implementation EOCClass</div><div class="line">+ (void)initialize &#123;</div><div class="line">    if (self == [EOCClass class]) &#123;</div><div class="line">        kSomeObjects = [NSMutableArray new];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>整数值可以在编译期定义，但是可变数组不行，因为它是<code>Objective-C</code>对象，因为它需要先激活运行期才可以创建实例变量。注意一些<code>Objective-C</code>对象是可以在编译器创建的，例如<code>NSString</code>实例。如果你尝试这样做，编译器会抛出一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static NSMutableArray *kSomeObjects = [NSMutableArray new];</div></pre></td></tr></table></figure>
<p>如果你在写<code>load</code>或者<code>initialize</code>方法时，一定要考虑清楚。保持它们实现的简单性可以减少调试的时间。如果你想在这里做除了初始化全变变量之外的事情，你可以考虑创建一个方法去执行它们，然后确保使用者在使用类之前一定执行它们。例如，单例类就可以在第一次的时候执行一些其他的操作。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果类中实现了<code>load</code>方法，那么会在加载类之前运行它。如果分类中也中<code>load</code>方法，那么会在类中的<code>load</code>方法运行后再运行它。不像其余的方法，<code>load</code>方法不支持覆写。</li>
<li>类第一次运行之前会执行一个方法，它就是<code>initialize</code>方法。这个方法可以覆写，所以通常会判断当前是哪个类在执行初始化。</li>
<li><code>load</code>和<code>initialize</code>方法都应该保持代码简单，这可以减少应用程序的相应时间，也可以减少依赖环的几率。</li>
<li>在<code>initialize</code>方法初始化不能在编译器设置的状态。</li>
</ul>
<h3 id="记住NSTimer会保留它的目标"><a href="#记住NSTimer会保留它的目标" class="headerlink" title="记住NSTimer会保留它的目标"></a>记住NSTimer会保留它的目标</h3><p>计时器是一种很有用的对象。<code>Foundation</code>框架有一个叫做<code>NSTimer</code>的类，它可以执行绝对时间来执行，也可以指定相对时间来执行。计时器也可以重复执行，它有一个间隔值去定义多久触发一次。例如，你可以每5秒触发一次资源。</p>
<p>计时器和运行循环关联，运行循环会在指定时间触发任务。创建计时器时，你可以将其直接放入当前循环中，也可以由你自己控制。无论哪种方式，计时器都只会在运行循环中触发。例如，下面的方法可以创建一个预先放置在运行循环中的计时器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds</div><div class="line">                                     target:(id)target</div><div class="line">                                   selector:(SEL)selector</div><div class="line">                                   userInfo:(id)userInfo</div><div class="line">                                    repeats:(BOOL)repeats;</div></pre></td></tr></table></figure>
<p>这个方法可以用于创建一个计时器，并在指定的时间间隔后触发。另外，它还可以重复触发，知道手动停止它。<code>target</code>和<code>selector</code>参数是特别的，<code>selector</code>在计时器触发时调用。计时器会保留这个<code>target</code>，并在计时器无效时释放它。一个不会重复的计时器在触发时就无效了，一个会重复的计时器，则需要手动调用<code>invalidate</code>方法，它才会无效。</p>
<p>由于计时器保留了目标对象，应用中重复的计时器通常会导致一些问题的发生。这意味着使用重复计时器时你会得到一个循环引用的情况。考虑下面的例子，看看为什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line">- (void)startPolling;</div><div class="line">- (void)stopPolling;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass &#123;</div><div class="line">    NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)init &#123;</div><div class="line">    return [super init];</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line">- (void)stopPolling &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line">- (void)startPolling &#123;</div><div class="line">	_pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0];</div><div class="line">	[NSTimer scheduledTimerWithTimeInterval:5.0</div><div class="line">                                     target:self</div><div class="line">                                   selector:@selector(p_doPoll)</div><div class="line">                                   userInfo:nil</div><div class="line">                                    repeats:YES];</div><div class="line">&#125;</div><div class="line">- (void)p_doPoll &#123;</div><div class="line">    // Poll the resource</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你可以看出问题吗？考虑一下，如果这个类创建一个实例变量然后开始计时会发生什么。会创建一个计时器，然后计时器会保留实例，因为它的目标对象是<code>self</code>。但是，计时器也会一直被保留，因为它是一个实例变量。这形成了一个循环引用，如果在某时打破这个循环是不会有什么问题的。唯一打破循环引用的办法是，将计时器变量清空，或者使计时器无效。所以要么调用<code>stopPolling</code>，要么使计时器无效。你不能确保有人一定会调用<code>stopPolling</code>，除非你能控制整个类的代码。而且，这种调用方法去避免循环引用的办法也不是好的办法。而且，如果你想在系统释放本类的时候，使计时器无效也是不可能的。因为实例没有被释放，所以当计时器有效时，它的引用计数不为0。而且，除非计时器无效，否则它会一直存活。图7.1展示了这个情况。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%207.1.png" alt=""><br><strong>Figure 7.1</strong> 由于计时器保留了目标对象，目标对象保留了计时器，所以循环引用了。</p>
<p>一旦<code>EOCClass</code>实例的最后一个引用被移除，由于计时器的保留，它仍然存活。计时器也不会被释放，因为<code>EOCClass</code>实例也一直持有着它。更坏的是，这个实例永远丢失了，因为没有别的任何引用了，除了计时器。而除了这个实例外也没有任何引用指向计时器了。那么泄露就发生了。这是一个特别坏的泄露，因为它会一直轮循任务。如果轮训的任务是下载网络数据，那么它就会一直下载网络数据了，这又可能导致其它的内存泄露。</p>
<p>单一通过计时器很难解决这个问题。你可以手动的在其余对象释放之前手动调用<code>stopPolling</code>方法。但是，这种情况没办法检测，并且如果你这个类是作为公共API的一部分，暴露给其余开发者使用，你不能确保它们会调用它。</p>
<p>不过你可以使用block去解决这个问题。即使计时器当前不直接支持block，你可以添加一个这样的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                       repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                       repeats:(BOOL)repeats &#123;</div><div class="line">    return [self scheduledTimerWithTimeInterval:interval</div><div class="line">                                         target:self</div><div class="line">                                       selector:@selector(eoc_blockInvoke:)</div><div class="line">                                       userInfo:[block copy] repeats:repeats];</div><div class="line">&#125;</div><div class="line">+ (void)eoc_blockInvoke:(NSTimer*)timer &#123;</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样做为什么可以解决这个问题。当计时器触发时，会运行block。当计时器有效时，就会保留这个不透明值。block调用copy是因为要确保它是一个堆block(看第37节)；另外，它也有可能会在稍后执行时变得无效。计时器的目标对象现在是<code>NSTimer</code>类对象了，它是一个单例，因此不需要担心它被计时器保留。这也会产生一个循环引用，但因为类对象不会释放，所以也不需要担心。</p>
<p>这个方案并不能解决这个问题，但它提供了解决问题的工具。考虑修改上面的代码，改为使用类别中的方法初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)startPolling &#123;</div><div class="line">    _pollTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0</div><div class="line">                                                       block:^&#123;</div><div class="line">                                                           [self p_doPoll];</div><div class="line">                                                       &#125;</div><div class="line">                                                     repeats:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你仔细观察，你会发现这里仍有一个循环引用。block保留了当前的<code>self</code>实例。最后计时器本身通过<code>userInfo</code>参数保留了block。最后实例本身还保留了计时器变量。但是，这个循环引用可以通过弱引用去打破：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)startPolling &#123;</div><div class="line">    __weak EOCClass *weakSelf = self;</div><div class="line">    _pollTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0</div><div class="line">                                                       block:^&#123;</div><div class="line">                                                           EOCClass *strongSelf = weakSelf;</div><div class="line">                                                           [strongSelf p_doPoll];</div><div class="line">                                                       &#125;</div><div class="line">                                                     repeats:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这套代码使用了一种有用的方法，它定义了一个弱引用的<code>self</code>变量，取代被block捕捉的正常<code>self</code>变量。这意味着<code>self</code>不会被保留。但是，当block执行时，立即生成一个强引用，这样就可以确保稍后block执行时，<code>self</code>变量的存活。</p>
<p>使用这种方法，如果<code>EOCClass</code>的实例最后一个引用被释放，它也将释放。然后释放方法中使计时器无效，这样可以确保计时器不会再运行。使用弱引用确保它是更安全的；如果使用者忘记在释放方法中将计时器设为无效，再次运行计时器时，<code>weakSelf</code>会变为nil。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>一个<code>NSTimer</code>对象会保留它的目标对象，除非计时器无效。要想使计时器无效可以调用<code>invalidate</code>方法，或者一次计时器触发时间后会自动无效。</li>
<li>使用重复计时器很容易导致循环引用，特别是计时器的目标对象，同时持有计时器的时候。这种关系可能是直接发生也可能是通过对象图里的其他对象。</li>
<li>使用block扩展<code>NSTimer</code>可以打破循环引用。除非<code>NSTimer</code>接口中添加这部分方法，否则一定要将其实现代码添加在类别中。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第七章：系统框架。&lt;/p&gt;
&lt;p&gt;这是这本书的最后一节了，翻译的有问题的地方看得人还请多多谅解。翻译完这本书就准备闭关，好好沉淀知识了。学习使我开心。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第六章</title>
    <link href="http://yoursite.com/2017/07/08/Blocks%20and%20Grand%20Central%20Dispatch/"/>
    <id>http://yoursite.com/2017/07/08/Blocks and Grand Central Dispatch/</id>
    <published>2017-07-08T07:50:24.000Z</published>
    <updated>2017-07-16T09:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第六章：Block和GCD</p>
<a id="more"></a>
<hr>
<p>PS：不使用中文名字进行翻译</p>
<p>block ： block/Block</p>
<p>GCD : Grand Central Dispatch</p>
<hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>多线程开发是每个开发者都会遇到并需要考虑的情况。即使你不认为你的程序是多线程的，但其实它是，因为系统框架通常会在主线程之外做一些事情。最坏的情况就是UI线程被阻塞，应用程序挂起。在Mac OS X上，会有一个彩球一直转；在iOS上，如果阻塞过久，你的程序可能会终止。</p>
<p>幸运的是，苹果已经解决多线程的问题了。现代多线程的核心功能是block和GCD。从技术上讲，它们明显没什么关系，但它们是一起引入的。block提供了词法闭包，这对C、C++、Objective-C都是非常有用的，主要是提供了一种机制，让代码像对象一样传递，并运行在不同的环境下。重要的是，block可以使用它定义范围内的任何事物。</p>
<p>GCD是block的关联技术，基于派发队列概念提供线程的抽象。block可以被排进队列，GCD可以处理所有的事务。GCD会根据系统资源的情况，对每个队列进行创建，暂停，销毁等操作。而且，GCD可以提供很多易于使用的常见功能，例如单一线程代码安全执行，基于系统资源的并发。</p>
<p>现在的<code>Objective-C</code>项目中，block和GCD是主要部分之一。因此，你需要理解它们的功能以及工作原理。</p>
<h3 id="理解Block"><a href="#理解Block" class="headerlink" title="理解Block"></a>理解Block</h3><p>block提供闭包。这项语言特性是作为GCC编译器的扩展，因此适用于所有的现在Clang版本(Clang是开发Mac OS X和iOS的编译器)。而运行期组件则需要Mac OS X 10.4和iOS 4.0之后才能支持block。语言功能是C级别的功能，因此只要运行期组件支持C、C++、Objective-C、Objective-C++的代码都可以使用block。</p>
<h4 id="block的基础"><a href="#block的基础" class="headerlink" title="block的基础"></a>block的基础</h4><p>block跟函数很相似，但它定义在另一个函数的内部，和另一个函数更享作用域。block使用<code>^</code>符号作为标示，后面跟随一个作用域，作用域包含block的实现。例如，一个简单的block如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^&#123;</div><div class="line">	// Block implementation here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>block就是一个值，它也有自己的类型。就像<code>int、float</code>或者<code>Objective-C</code>对象，也可以把block赋值给一个变量，然后就像使用其他变量那样使用它。这种block类型语法跟函数指针很像。下面是一个简单block的例子，它没有参数和返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void(^someBlock)() = ^&#123;</div><div class="line">	// Block implementation here</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个block定义了一个叫做<code>someBlock</code>的变量。它可能看起来是奇怪的，因为它的变量名写在中间，但是一旦你理解了它的语法，它是非常易读的。block的结构语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return_type (^block_name)(parameters)</div></pre></td></tr></table></figure>
<p>定义一个block，它有两个int类型参数，返回值也是int类型，你会使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int (^addBlock)(int a, int b) = ^(int a, int b) &#123;</div><div class="line"></div><div class="line">	return a+b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>block的使用就像函数一样。例如，<code>addBlock</code>可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int add = addBlock(2, 5); //&lt;add = 7</div></pre></td></tr></table></figure>
<p>block还有一个强力的功能，就是允许访问它定义区域的变量。意思是任何适用于block定义范围的变量都适用于block内部。例如，你可以定义一个block然后使用另一个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int additional = 5;</div><div class="line">int (^addBlock)(int a, int b) = ^(int a, int b)&#123;</div><div class="line"></div><div class="line">	return a+b+additional;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int add = addBlock(2, 5); //&lt;add = 12</div></pre></td></tr></table></figure>
<p>默认情况下，被block捕捉的变量不能在block中修改。在上面的例子中，如果在block内部对<code>additional</code>变量进行修改，编译器将会编译错误。但是，可以在声明变量时使用特定字符<code>__block</code>修饰，这样就可以修改了。例如，block可以使用数组枚举去确定数组中多少元素小于2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@0, @1, @2, @3, @4, @5];</div><div class="line">__block NSInteger count = 0;</div><div class="line">[array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">    if ([number compare:@2] == NSOrderedAscending) &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">// count = 2</div></pre></td></tr></table></figure>
<p>这个例子也展示了如何使用内连block。这个block通过<code>enumerateObjectsUsingBlock:</code>方法声明为一个内连block，直接调用，并未赋值给一个本地变量。这种常用的代码模式展示了为什么block是非常有用的。在block成为语言的一部分之前，枚举方法只能调用函数指针或者选择器名字。状态不得不通过手动处理，通常使用不透明指针，因此需要额外的代码，并将它们分散在别的地方。声明一个内连block则可以使代码逻辑集中在一个地方。</p>
<p>当block捕捉一个对象类型的变量，它会偷偷的保留它。当block自身被释放时，这个变量才会释放。这就引出一个关于block的重大问题。一个block可以被看做一个对象。实际上，block可以像其他<code>Objective-C</code>对象一样响应许多选择器。重要的是block自身就像其他对象一样，它也有引用计数。当block最后的应用被移除时，block就会被销毁。因此，block捕捉的对象会在这时进行释放，以平衡捕捉时增加的引用计数。</p>
<p>如果block作为一个实例变量定义在一个<code>Objective-C</code>类中，那么可以使用<code>self</code>变量以及类的所有变量。使用实例变量时也永远不需要加上<code>__block</code>前缀。如果一个实例变量被block通过读或者写的方法捕获，它也会捕获<code>self</code>变量，因为实例变量与<code>self</code>持有的实例变量相关联。例如，一个叫做<code>EOCClass</code>的类里面有一个方法，方法里面使用一个block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass</div><div class="line"></div><div class="line">- (void)anInstanceMethod &#123;</div><div class="line">    // ...</div><div class="line">    void (^someBlock)() = ^&#123;</div><div class="line">        _anInstanceVariable = @&quot;Something&quot;;</div><div class="line">        NSLog(@&quot;_anInstanceVariable = %@&quot;, _anInstanceVariable);</div><div class="line">    &#125;;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个<code>EOCClass</code>的实例变量有一个叫做<code>anInstanceMethod</code>的方法，这个方法运行时会使用到<code>self</code>变量。你会非常容易忘记<code>self</code>变量被block捕捉了，因为代码中没有显示调用<code>self</code>。但是，访问实例变量与下面语法相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self-&gt;_anInstanceVariable = @&quot;Something&quot;;</div></pre></td></tr></table></figure>
<p>这就是为什么<code>self</code>变量会被捕捉。通常情况下，使用属性访问实例变量，在这种情况下，就要使用<code>self</code>变量了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.aProperty = @&quot;Something&quot;;</div></pre></td></tr></table></figure>
<p>但是，记着<code>self</code>是一个对象，当block捕捉了<code>self</code>，它会被保留。如果<code>self</code>也持有block，这种情况很容易造成循环引用。更多信息看第40节。</p>
<h4 id="block的内部结构"><a href="#block的内部结构" class="headerlink" title="block的内部结构"></a>block的内部结构</h4><p>在<code>Objective-C</code>中，每一个对象都有一块固定的内存区域。每个对象的内存区域大小是不一样的，这取决于实例变量的个数和关联的数据。一个block也是一个对象，因此它内存区域的第一个变量是一个指向类的指针，叫做isa指针(看第14节)。block的其余内存里面包含各种它正常运行的信息。图6.1展示了block的细节。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%206.1.png" alt=""><br><strong>Figure 6.1</strong> 一个block对象的内存分布。</p>
<p>在这个布局里面最重要的是那个叫做<code>invoke</code>的变量，它是一个函数指针，指向block的实现。函数原型至少有一个<code>void*</code>，它代表块本身。之前说过，block仅是替代函数指针的，之前使用函数指针时，通过使用不透明指针传递状态。而使用block之后，则可把C语言特性改为简单易用的接口。</p>
<p><code>descriptor</code>变量是每一个block都会有的结构体的指针，声明了block对象的大小，函数指针的拷贝和释放方法。当block的拷贝和释放呗调用时就会运行这些方法，例如，将捕获的对象保留或者释放。</p>
<p>最后，block包含它所捕获的变量的拷贝。这些拷贝存储在<code>descriptor</code>变量后面，捕获多少变量就占用多少空间。请注意，拷贝的并不是这些对象本身，而是指向这些对象的指针变量。当block运行时，被捕捉的变量从内存中被读取，这就是为什么block需要通过参数传递进<code>invoke</code>函数。</p>
<h4 id="全局block、堆block、栈block"><a href="#全局block、堆block、栈block" class="headerlink" title="全局block、堆block、栈block"></a>全局block、堆block、栈block</h4><hr>
<p>PS : 经我本人验证，下面的block并不会像书中一样，出了if或者else的区域就被释放，ARC/MRC我都试过。所以各位看书的时候，请自行实验。但是除了例子举的有问题外，别的并无问题。个人看法，欢迎讨论。</p>
<hr>
<p>当定义block时，它初始化的内存地址是在栈上。这意味着该block仅在它定义的范围内有效。例如，下面的代码是有风险的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void (^block)();</div><div class="line">if ( /* some condition */ ) &#123;</div><div class="line">    block = ^&#123;</div><div class="line">        NSLog(@&quot;Block A&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125; else &#123;</div><div class="line">    block = ^&#123;</div><div class="line">        NSLog(@&quot;Block B&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>两个block定义在<code>if</code>和<code>else</code>判断里面，初始化在栈内存上。当每个block初始化栈内存后，编译器都会在内存作用域的最后对它们进行释放。所以每个block仅在它们所在的判断语句内是有效的。这段代码没有任何编译错误，但是在运行时可能出现函数错误。如果被释放的内存没有被重写，代码不会有错误，但是如果重写了，程序将会崩溃。</p>
<p>为了解决这个问题，可以在对block进行拷贝。这样做的原因是可以将block从栈区拷贝到堆区。一旦将其拷贝到堆区，block就可以在它定义区域外使用了。而且，一旦将它拷贝到堆区，block也拥有引用计数了。后续的拷贝操作都不会再真的拷贝只是增加block的引用计数。当一个堆block不再被持有，它需要被释放，如果使用ARC，它会自己释放，如果使用MRC，就手动调用<code>release</code>。当它的引用计数为0时，堆block就像对象一样被释放。栈block不需要手动释放，因为栈的内存是由系统自动释放的，刚才那段代码之所以会有问题就是因为这个原因。</p>
<p>现在，你可以简单的对其使用<code>copy</code>方法使其代码安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void (^block)();</div><div class="line">if ( /* some condition */ ) &#123;</div><div class="line">    block = [^&#123; NSLog(@&quot;Block A&quot;);&#125; copy];</div><div class="line">&#125; else &#123;</div><div class="line">    block = [^&#123; NSLog(@&quot;Block B&quot;);&#125; copy];</div><div class="line">&#125;    </div><div class="line">block();</div></pre></td></tr></table></figure>
<p>现在代码是安全的了。如果使用了MRC，需要在最后释放block。</p>
<p>全局block是另一个概念，它不同于堆block和栈block。全局block不捕捉任何状态，例如外围的变量，运行时也不需要状态参与。它的内存地址是在编译时就可以确定的；所以全局block是声明在全局内存中的而不是每次使用都从栈中创建。另外，对全局block使用拷贝也是无效的，因为一个全局block不会被释放。所以这样的block实际上就是一个单例。下面是一个全局block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;This is a block&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>全局block的所有信息都必须在编译时就确定。这是一种优化技术；如果简单的block还需要在栈上和堆上做拷贝或释放，等于多做一些无用的操作。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>block是一种适用于C、C++、Objective-C的语义闭包。</li>
<li>block参数和返回值都是可选的。</li>
<li>block可以在栈上、堆上、全局初始化。一个栈block可以拷贝到堆上面，这样它就会像其余的<code>Objective-C</code>对象一样，拥有自己的引用计数。</li>
</ul>
<h3 id="使用typedefs创建通用block"><a href="#使用typedefs创建通用block" class="headerlink" title="使用typedefs创建通用block"></a>使用typedefs创建通用block</h3><p>block具有固有类型；因而，可将其赋给适当的类型变量。block的类型由参数和返回值组成。例如，下面的block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">^(BOOL flag, int value)&#123;</div><div class="line">    if (flag) &#123;</div><div class="line">        return value * 5;</div><div class="line">    &#125; else &#123;</div><div class="line">        return value * 10;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个block有两个参数，分别是<code>Bool</code>型和<code>int</code>型，以及一个<code>int</code>型的返回值。如果要将其赋给一个变量，这个block需要适当的类型。赋值变量的类型是像这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int (^variableName)(BOOL flag, int value) = ^(BOOL flag, int value) &#123;</div><div class="line">    // Implementation</div><div class="line">    return someInt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个看起来跟正常类型由很大差别，但如果你使用函数指针，你会感觉到熟悉。这个类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return_type (^block_name)(parameters)</div></pre></td></tr></table></figure>
<p>block变量的定义与普通类型是不同的，它的变量名在中间而不是在右边。这造成它的语法难以记忆和阅读。因此，有一个好办法是为通用block定义类型，特别是你给别人提供API时。你可以起个好读的名字表示block的用途并将它的类型隐藏在后面。</p>
<p>为了隐藏block的复杂类型，你可以使用C语言的一个功能去定义类型。这个功能的关键字是<code>typedef</code>，使用它可以定义一个易于阅读的名字，使它成为类型别名。例如，使用类型定义给一个block定义新的类型，这个block接受一个<code>int</code>参数和一个<code>Bool</code>参数并返回一个<code>int</code>值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef int(^EOCSomeBlock)(BOOL flag, int value);</div></pre></td></tr></table></figure>
<p>就像之前block变量的命名一样名字在<code>^</code>符号右边，新的类型名字也是这样。这条语句向系统增加了一个叫做<code>EOCSomeBlock</code>的类型。所以当你再次创建同类型变量时，你可以使用这个新类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EOCSomeBlock block = ^(BOOL flag, int value)&#123;</div><div class="line">    // Implementation</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在这代码就易于阅读了，它就像你平时使用的变量一样定义，类型在左，变量名在右。</p>
<p>使用这个功能可以把API中的block做的更为易用。类里面有些方法可能需要使用一个block参数，例如，一个异步任务完成时的回调，使用这个功能可以使得代码易于阅读。考虑一个情况，一个类有一个叫做<code>start</code>的方法，它有一个在任务结束时调用的block参数。如果没有使用类型定义，这个方法可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)startWithCompletionHandler:(void(^)(NSData *data, NSError *error))completion;</div></pre></td></tr></table></figure>
<p>注意，在方法中的block参数和block变量的语法是不同的。如果方法中block参数可以是一个单词，那么就易读多了。所以你可以定义一个类型信息并且代替它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef void(^EOCCompletionHandler)(NSData *data, NSError *error);</div><div class="line">- (void)startWithCompletionHandler:(EOCCompletionHandler)completion;</div></pre></td></tr></table></figure>
<p>这样的参数是容易阅读和理解的。更好的是，现在的IDE都是自动支持这种类型定义的，这使得它更易于使用。</p>
<p>如果你想重新构建block的函数时，使用类型定义也是非常有用的。例如，如果你现在想给block添加一个参数，你只需要简单修改类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void(^EOCCompletionHandler)(NSData *data, NSTimeInterval duration, NSError *error);</div></pre></td></tr></table></figure>
<p>任何使用了这个类型定义的地方，例如方法签名，都会编译失败，然后你可以逐个修复。如果没有类型定义，你需要逐个找到你需要修改的代码。这很容易遗忘一两处，导致难以排查的bug。</p>
<p>通常在使用block类型定义的类中定义它们。也会给类型block添加类名作为前缀。这使得block的用途非常清楚。还可以使用<code>typedef</code>定义更多的别名。这是多多益善的。</p>
<p>在Mac OS X和iOS中的Account框架是有这种例子的。在框架中可以找到下面两个类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef void(^ACAccountStoreSaveCompletionHandler) (BOOL success, NSError *error);</div><div class="line">typedef void(^ACAccountStoreRequestAccessCompletionHandler) (BOOL granted, NSError *error);</div></pre></td></tr></table></figure>
<p>这两个block都相同的签名，但使用在不同的场景。签名中的类型名字和参数名字可以让开发者很容易理解这个block怎么使用。也可以将这两个block定义为一个单一类型定义，可能统称<code>ACAccountStoreBooleanCompletionHandler</code>，在两个地方都适用它。但是，这样做会使得block的用途不是那么清楚了。</p>
<p>相似的，如果你有几个类都执行相似但不同的异步任务，并且无法放在一个继承中，那么每个类都应该有它自己的block类型定义。可能每一个block的签名都是相同的，但那也好过让每个类都适用同一个block。另一方面，如果这些类可以从一个基类继承，你可以将block类型定义放在基类中，然后让每个子类使用它。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用类型定义可以使得block变量更易于使用。</li>
<li>定义block名字时务必遵守当前规则，使其不与其他类型冲突。</li>
<li>给相同签名block定义多个别名。当你想重构的代码使用了其中某个别名，只需修改相应<code>typedef</code>中的签名，无须改动其他别名。</li>
</ul>
<h3 id="使用block去减少代码分离"><a href="#使用block去减少代码分离" class="headerlink" title="使用block去减少代码分离"></a>使用block去减少代码分离</h3><p>在编写项目时，有一个常用的范例是用户接口需要去执行异步任务。这样当执行长时间的任务时，不会阻塞用户界面的显示和触摸所用的线程，例如文件I/O或者网络请求。这个线程就是我们提到的主线程。如果执行任务的线程是同步的，当任务执行时，用户界面的任何操作都无法响应。在某些情况下，如果应用停止响应一段时间，它将会被自动终结。这是真实存在于iOS应用的；如果主线程长时间被阻断，系统监视器会终结应用。</p>
<p>异步方法需要用过某种方式去通知相关代码任务执行完毕。这有很多实现办法。通用的一个办法就是设计一个协议，让某个对象遵守它。这个对象成为被委托者后就可以在结束时得到通知了，例如一个异步任务的完成。</p>
<p>考虑下面这个从URL获取数据的类。使用委托模式，这个类大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCNetworkFetcher;</div><div class="line">@protocol EOCNetworkFetcherDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher</div><div class="line">     didFinishWithData:(NSData*)data;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) id &lt;EOCNetworkFetcherDelegate&gt; delegate;</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)start;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>某各类可能会这样使用这种API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)fetchFooData &#123;</div><div class="line">    </div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;];</div><div class="line">    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    fetcher.delegate = self;</div><div class="line">    [fetcher start];</div><div class="line">&#125;</div><div class="line">// ...</div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(NSData*)data &#123;</div><div class="line">    </div><div class="line">    _fetchedFooData = data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法也不是有问题。但是，block可以使得代码非常清晰。block可以使API变得更加紧凑，并且让使用者更容易使用。这需要定义一个block类型，将其作为完成handler，然后作为参数直接传给<code>start</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);</div><div class="line"></div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这种做法跟使用委托协议是很像的，但是它在<code>start</code>方法中直接加入了内联block，这可以提升代码的阅读性。例如，考虑使用block风格的API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)fetchFooData &#123;</div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;];</div><div class="line">    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">        _fetchedFooData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比委托和block两种方式的代码会发现block这种代码更简洁。异步执行完毕后的逻辑代码和开始任务的代码都在一起。而且，由于block定义在网络获取器的范围内，你可以访问这个范围内的所有变量。在这个简单的例子中，优势不是很明显，但在复杂场景下，就可以看到优势了。</p>
<p>委托模式有一个缺点，就是如果一个类使用了多个网络请求去下载不同的数据，它需要在委托方法中根据不同的网络下载器去处理不同情况。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)fetchFooData &#123;</div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;];</div><div class="line">    _fooFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    _fooFetcher.delegate = self;</div><div class="line">    [_fooFetcher start];</div><div class="line">&#125;</div><div class="line">- (void)fetchBarData &#123;</div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/bar.dat&quot;];</div><div class="line">    _barFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    _barFetcher.delegate = self;</div><div class="line">    [_barFetcher start];</div><div class="line">&#125;</div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(NSData*)data &#123;</div><div class="line">    if (networkFetcher == _fooFetcher) &#123;</div><div class="line">        _fetchedFooData = data;</div><div class="line">        _fooFetcher = nil;</div><div class="line">    &#125; else if (networkFetcher == _barFetcher) &#123;</div><div class="line">        _fetchedBarData = data;</div><div class="line">        _barFetcher = nil;</div><div class="line">    &#125;</div><div class="line">    // etc.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做法会使得委托方法的回调代码变长，网络下载器必须存储为一个实例变量。这样做可能是因为别的原因，例如稍后取消下载，但是它终究会使得类的代码激增。这就是block的优势了，它不需要存储网络获取器，也不需要去做切换。每个回调block的逻辑是定义在每个网络获取器那里的，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)fetchFooData &#123;</div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;];</div><div class="line">    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">        _fetchedFooData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line">- (void)fetchBarData &#123;</div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/bar.dat&quot;];</div><div class="line">    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">        _fetchedBarData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法还可以进行扩展，许多现在的基于block的API还有一个用于处理错误的block。有两个方法可以做到这点。第一个是将成功的block与失败的block分开实现。第二个是将两种情况写在一个block里面。使用分开情况大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@class EOCNetworkFetcher;</div><div class="line"></div><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);</div><div class="line">typedef void(^EOCNetworkFetcherErrorHandler)(NSError *error);</div><div class="line"></div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion failureHandler:(EOCNetworkFetcherErrorHandler)failure;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用这种风格的API是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">[fetcher startWithCompletionHander:^(NSData *data)&#123;</div><div class="line">    </div><div class="line">    // Handle success</div><div class="line">&#125; failureHandle:^(NSError *error) &#123;</div><div class="line"></div><div class="line">    // Handle failure</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这种格式非常好，因为分割了成功和失败两种情况，这意味着使用者可以将成功和失败的逻辑分开。而且，如果需要忽略成功或失败的情况，也是非常容易的。</p>
<p>另一种类型，是将成功情况和失败情况放进同一个block，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@class EOCNetworkFetcher;</div><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data, NSError *error);</div><div class="line"></div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用这种风格的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">[fetcher startWithCompletionHander: ^(NSData *data, NSError *error)&#123;</div><div class="line">    if (error) &#123;</div><div class="line">        // Handle failure</div><div class="line">    &#125; else &#123;</div><div class="line">        // Handle success</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这种方法需要判断错误变量并需要将所有逻辑放在一个地方。它有一个坏处，因为所有的逻辑都在一个地方，这会使得这个block变得庞大和复杂。但是，这种单一block是非常灵活的。例如，传入错误的同时也能传入数据。考虑这种情况，数据下载到一半发生错误了。这种情况下，可以把数据和相关错误回传给block。这样的话，就可以处理这个问题并可能利用这些成功的数据做一些事情。</p>
<p>把成功和失败情况放入同一个block的另一个原因是当处理成功数据时，使用者发现了一个错误。例如，返回数据太短。这种情况可能需要按网络获取器发生错误时处理一致。如果成功和失败情况分开写在两个block里面，那这就没办法共享一份代码了，如果将方法放在别处处理，那又违反我们使用block将逻辑放在一起的概念了。</p>
<p>总体来说，我建议将错误情况和成功情况放在同一个block内，苹果公司似乎也是使用的这种思路。例如，<code>Twitter</code>框架中的<code>TWRequest</code>和<code>MapKit</code>框架中的<code>MKLocalSearch</code>，它们都使用了单一block处理。</p>
<p>有时需要在某些时间点进行回调。例如，一个网络获取器的使用者可能想在每个下载进度变化时获得回调。委托也可以做到这个。不过继续使用block，你可添加一个进度处理类型的block和一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler) (float progress);</div><div class="line">@property (nonatomic, copy) EOCNetworkFetcherProgressHandler progressHandler;</div></pre></td></tr></table></figure>
<p>这种模式很好，它将所有的逻辑放在了同一个地方：网络获取器的创建和进度block的定义。</p>
<p>当写处理API时，某些代码需要运行在一个确定的线程。例如，任何<code>Cocoa</code>和<code>Cocoa Touch</code>的UI工作都必须发生在主线程。这相当于GCD中的主队列。因此，最好由API的使用者来决定它在哪条线程上运行。有这样一个API就是<code>NSNotificationCenter</code>，它有一个方法可以让注册者注册某个通知，等到收到通知时，就会在指定的线程执行注册好的那个block。可以给回调block指定一个线程，但不是必须的。如果没有指定线程，它就会运行在发送时的线程上。这个添加观察者的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)addObserverForName:(NSString*)name</div><div class="line">                  object:(id)object</div><div class="line">                   queue:(NSOperationQueue*)queue</div><div class="line">              usingBlock:(void(^)(NSNotification*))block;</div></pre></td></tr></table></figure>
<p>这里有一个参数是使用<code>NSOperationQueue</code>对象指定在哪个线程上运行的。这是操作队列而不是更深层次的GCD队列，但是语义是相同的(第43节详细讲述了GCD队列与其他的区别)。</p>
<p>你也可以根据自己的业务去设计API，根据所需的实现细节去选择使用操作队列或者GCD队列。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>当创建对象时，可以将逻辑以内联block的方法一并声明。</li>
<li>当有多个网络获取器实例时，block是比委托模式更具有优势的。</li>
<li>当设计API时如果用到了处理block，可以考虑让使用者通过一个参数去指定回调的线程。</li>
</ul>
<h3 id="避免block引用对象时产生循环引用"><a href="#避免block引用对象时产生循环引用" class="headerlink" title="避免block引用对象时产生循环引用"></a>避免block引用对象时产生循环引用</h3><p>如果没有考虑清楚，block很容易产生循环引用。例如，下面的类提供一个接口，用于下载某个URL的资源。当获取器开始使用时可以设置一个回调block，当下载结束时调用block。为了在下载结束时调用block，需要将其存储在一个实例变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCNetworkFetcher.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);</div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) NSURL *url;</div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCNetworkFetcher.m</div><div class="line">#import &quot;EOCNetworkFetcher.h&quot;</div><div class="line">@interface EOCNetworkFetcher ()</div><div class="line"></div><div class="line">@property (nonatomic, strong, readwrite) NSURL *url;</div><div class="line">@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;</div><div class="line">@property (nonatomic, strong) NSData *downloadedData;</div><div class="line"></div><div class="line">@end</div><div class="line">@implementation EOCNetworkFetcher</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL*)url &#123;</div><div class="line"></div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _url = url;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)startWithCompletionHandler: (EOCNetworkFetcherCompletionHandler)completion &#123;</div><div class="line">    self.completionHandler = completion;</div><div class="line">    // Start the request</div><div class="line">    // Request sets downloadedData property</div><div class="line">    // When request is finished, p_requestCompleted is called</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_requestCompleted &#123;</div><div class="line">    if (_completionHandler) &#123;</div><div class="line">        _completionHandler(_downloadedData);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>另一个使用的类可能创建一个网络获取器，使用它去下载一个URL的数据，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation EOCClass &#123;</div><div class="line"></div><div class="line">    EOCNetworkFetcher *_networkFetcher;</div><div class="line">    NSData *_fetchedData;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)downloadData &#123;</div><div class="line">    </div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;];</div><div class="line">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [_networkFetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url);</div><div class="line">        _fetchedData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这段代码看起来非常正常。但你可能没发现里面有一个循环引用。即完成处理block引用了self，因为它使用了<code>_fetchedData</code>实例变量。<code>EOCClass</code>的实例创建并持有了网络获取器。网络获取器持有了这个<code>block</code>。图6.2说明了这个循环引用。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%206.2.png" alt=""><br><strong>Figure 6.2</strong> 网络获取器和类实例的循环引用。</p>
<p>这个循环引用可以很轻松的打破，通过令类不再引用<code>_networkFetcher</code>实例变量或者网络获取器类不再引用<code>completionHandler</code>。在这个例子中，这种破坏需要在<code>completionHandler</code>结束时进行，所以网络获取器是一直活跃的直到它释放。例如，<code>completionHandler</code>block可以这样修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[_networkFetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;Request for URL %@ finished&quot;, _networkFetcher.url);</div><div class="line">    _fetchedData = data;</div><div class="line">    _networkFetcher = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环引用这种问题在使用完成block的API中是很常见的，所以理解它就很重要。通常，可以通过在合适时机将一方释放解决问题；但是，不是总有这种机会的。在这个例子中，是因为<code>completionHandler</code>运行了，循环引用才被打破。如果<code>completionHandler</code>永远没运行，那么循环引用永远不会打破，就会造成内存泄露。</p>
<p>使用<code>completionHandler</code>block还有另一种循环引用的情况。那就是当<code>completionHandler</code>block引用的对象也引用了block本身就会发生循环引用。例如，将前面的例子稍作扩展，不在运行期间保留网络获取器的引用，而是使用别的机制另其存货。那么可能会将其加入一个全局的集合，比如set集合，开始时加入其中，结束时将其移除。那么使用者可能会这样修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)downloadData &#123;</div><div class="line">    </div><div class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;];</div><div class="line">    EOCNetworkFetcher *networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [networkFetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;Request URL %@ finished&quot;, networkFetcher.url);</div><div class="line">        _fetchedData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多数的网络库使用这种方法，因为令使用者自己保持这个对象是麻烦的。有一个例子是<code>Twitter</code>框架中的<code>TWRequest</code>类。但是，以<code>EOCNetworkFetcher</code>的代码来看，还是会产生循环引用。这比之前更难以发现，<code>completionHandler</code>block会使用网络获取器的url，而网络获取器又会通过<code>completionHandler</code>属性持有block。幸运的是，这是很容易解决的。之所以保存<code>completionHandler</code>属性是因为要在稍后使用它。一旦使用完毕，就不再需要持有这个block了。所以可以这样简单的解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)p_requestCompleted &#123;</div><div class="line">    if (_completionHandler) &#123;</div><div class="line">        _completionHandler(_downloadedData);</div><div class="line">    &#125;</div><div class="line">    self.completionHandler = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦请求执行完毕，就可以解除循环引用了，然后获取器对象也会在需要的时候释放掉。注意将<code>completionHandler</code>放在<code>start</code>方法中是很好的主意。因为如果将<code>completionHandler</code>暴漏为一个公共属性，你不能在请求结束时将其清空，因为跟你将其设为公共属性的语义不符。这种情况下，只有一种方法可以打破循环引用，那就是使用者自己清空<code>completionHandler</code>属性。但这不是很合理，因为你不能假定一个使用者一定会去做这件事，然后它们会反过来责怪你没处理好内存泄露。</p>
<p>这两种循环引用的情况都很常见。当使用block时很容易产生bug。当然，如果你小心谨慎，它们也是很容易解决的。关键就是考虑清楚block会捕捉哪些对象。如果这些对象中的任意一个对象持有了block，不论是直接持有还是间接持有，都要考虑清楚如何在一个恰当时机打破循环引用。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>当block捕捉的对象也捕捉了block时，小心循环引用这种问题。</li>
<li>考虑一个打破循环引用的合适时机，但不要依赖API的使用者自己去打破。</li>
</ul>
<h3 id="多用Dispatch-Queue少用同步锁"><a href="#多用Dispatch-Queue少用同步锁" class="headerlink" title="多用Dispatch Queue少用同步锁"></a>多用Dispatch Queue少用同步锁</h3><p>在<code>Objective-C</code>中，如果你多个线程执行同一份代码可能会遇到一些问题。通常使用锁来解决这个问题。在GCD之前，有两个办法可以解决这个问题，第一个就是构建一个同步block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)synchronizedMethod &#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        // Safe</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构会自动创建一个基于给定对象的锁，并且直到block里面的代码执行完毕才会解锁。在block代码的最后，锁会自动解除。在这个例子中，同步行为的对象是self。这通常是一个好的选择，因为它能确保对象的每个实例可以同步的运行其同步方法。但是<code>@synchronized(self)</code>的过度使用会带来性能问题，使用相同同步锁的block会按顺序执行。如果你对self进行了大量的同步锁，你不得不等待一些无关紧要的代码的结束。</p>
<p>另一种做法是直接使用<code>NSLock</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_lock = [[NSLock alloc] init];</div><div class="line">- (void)synchronizedMethod &#123;</div><div class="line">    [_lock lock];</div><div class="line">    // Safe</div><div class="line">    [_lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以使用<code>NSRecursiveLock</code>这种递归锁，它允许线程多次持有它，并且不会导致死锁。</p>
<p>这两种方法都是好的，但也有它们的缺点。例如，同步block会在极端情况下会导致死锁并且会影响性能。当发生死锁时，直接使用锁会非常麻烦。</p>
<p>对它们可以使用GCD进行替代，它可以提供一套高效和易于管理的锁。属性由于其特性经常会被开发者做成同步的，这时会将其特质设为<code>atomic</code>。使用<code>atomic</code>属性特质可以达到这个效果。或者，如果是手动书写，下面的代码是常用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (NSString*)someString &#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        return _someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重申如果滥用<code>@synchronized(self)</code>是危险的，因为所有这样的block都会抢夺同一个锁。如果多个属性都这样做，每个block都要等它之前的运行完，这肯定不是你想要的。我们只是想令每个属性独立的同步。</p>
<p>顺便说下，你应该知道这只是在某种程度上确保了线程安全，它不能确保绝对安全。当然，访问的属性肯定是原子性的。当你使用属性时，你想确保得到有效的结果，但是当你多次从同一个线程获取值时，可能每次获取的结果不一样。另外的线程可能在访问时对属性进行了修改。</p>
<p>一个简单高效的替代同步block或者锁对象的方法是使用一个连续的同步队列。不论是读还是写都在同一个同步队列中。这样做大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_queue_create(&quot;com.effectiveobjectivec.syncQueue&quot;, NULL);</div><div class="line"></div><div class="line">- (NSString*)someString &#123;</div><div class="line">    </div><div class="line">    __block NSString *localSomeString;</div><div class="line"></div><div class="line">    dispatch_sync(_syncQueue, ^&#123;</div><div class="line">    </div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return localSomeString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">    </div><div class="line">    dispatch_sync(_syncQueue, ^&#123;</div><div class="line">    </div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个模式的思路是所有访问属性的操作都是同步的，因为GCD队列可以确保<code>setter</code>和<code>getter</code>方法运行在一个连续队列上。<code>getter</code>中的<code>__block</code>语法部分，是用于允许block可以设置本地变量，这种方法是更整洁的。所有的加锁都是在GCD中处理的，GCD是一个是现在非常底层的功能，所以它有很多优化。因此，你不需要担心别的事情，只需要聚焦在你的访问器代码上即可。</p>
<p>但是，我们还可以尽一步优化。<code>setter</code>方法不一定需要是同步的。设置实例变量的block不需要返回任何内容。这个意思是你可以这样修改<code>setter</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">    dispatch_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个简单的变化是从同步派发变为异步派发，从调用者的角度看，它可以使得<code>setter</code>方法执行的更快，而读和写操作仍然会按序执行。如果你测试了性能，你可能发现它是更慢的；因为异步派发需要拷贝block。如果拷贝block的时间大于执行block的时间，那么它是慢的。所以在我们简单的例子中，它是变慢了的。但是这种方法仍是一个好的候选方法，如果block中执行的是非常重的任务。</p>
<p>利用<code>getter</code>方法可以同时发生，<code>getter</code>跟<code>setter</code>需要顺序执行这一点可以进行优化。此时正体现出GCD方法的好处。使用同步block或者锁是没办法轻易做到这个的。不使用连续队列，考虑当使用并发队列时会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">- (NSString*)someString &#123;</div><div class="line">    __block NSString *localSomeString;</div><div class="line">    dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">    return localSomeString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">    dispatch_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照目前的情况来看，上述代码不是同步执行的。所有的读和写操作执行在同一条队列上，但是队列是并发的，读和写可以在同时发生。我们恰恰想阻止这一点。但是，GCD有一个简单的叫做栅栏的功能，是适用于这种情况的。这个功能是一个队列栅栏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</div><div class="line">void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>栅栏必须单独执行不能跟其他队列并行。它是只作用于并发队列的，因为所有的串行队列都是按顺序执行的。当一个队列发现下一个执行的是栅栏block，队列会等所有的当前block执行完毕再去执行栅栏block。当栅栏block执行完毕，队列再向下正常执行。</p>
<p>栅栏可以用在例子中的<code>setter</code>方法内。如果<code>setter</code>方法使用了栅栏，属性读取将同时发生，但是写只能单独执行。图6.3展示了许多读和单一写的队列。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%206.3.png" alt=""><br><strong>Figure 6.3</strong> 并发队列中正常block的读和栅栏block的写。读并发执行；写单一执行，如同栅栏。</p>
<p>实现代码很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">- (NSString*)someString &#123;</div><div class="line">    </div><div class="line">    __block NSString *localSomeString;</div><div class="line">    dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return localSomeString;</div><div class="line">&#125;</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">    </div><div class="line">    dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你进行性能测试，你肯定会发现它是比使用串行队列快的。你可以在<code>setter</code>中使用同步栅栏，它可能会更高效，原因如之前所说的一样。每一种性能优化的方法和选择都要基于你的使用场景。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>派发队列可以用来提供同步场景，可以用来替代<code>@synchronized</code>block和<code>NSLock</code>对象。</li>
<li>将同步与异步派发结合起来一样可以提供同步行为，并且也不会造成线程阻塞。</li>
<li>并发队列和栅栏block使用同步行为更高效。</li>
</ul>
<h3 id="多使用GCD，少使用performSelector及其相关方法"><a href="#多使用GCD，少使用performSelector及其相关方法" class="headerlink" title="多使用GCD，少使用performSelector及其相关方法"></a>多使用GCD，少使用performSelector及其相关方法</h3><p>由于<code>Objective-C</code>的动态派发，<code>NSObject</code>中有几个定义的方法，允许你调用任何方法。它们允许延迟执行方法或者指定在某个线程执行。它们是非常有用的功能；但是现在，GCD和block的出现使得它们的重要性大大减少。尽管你经常看到使用它们的代码，但我建议你清理掉它们。</p>
<p>这一系列方法中最基础的那个是<code>performSelector:</code>。它只有单一一个参数，那就是需要执行的选择器，下面是方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)selector</div></pre></td></tr></table></figure>
<p>它等价于直接调用这个方法。所以下面两行代码等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object performSelector:@selector(selectorName)];[object selectorName];</div></pre></td></tr></table></figure>
<p>它看起来好像是多余的。如果它只能这样用那当然是。但是它真是的强大是可以在运行时决定运行哪个选择器。这样的动态绑定机制意味着你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line"></div><div class="line">if ( /* some condition */ ) &#123;</div><div class="line">    </div><div class="line">    selector = @selector(foo);</div><div class="line">&#125; else if ( /* some other condition */ ) &#123;</div><div class="line">    </div><div class="line">    selector = @selector(bar);</div><div class="line">&#125; else &#123;</div><div class="line">    selector = @selector(baz);</div><div class="line">&#125;</div><div class="line">[object performSelector:selector];</div></pre></td></tr></table></figure>
<p>这种代码非常灵活并且可以简化复杂的代码。另外也可以存储一个选择器，在之后的某个时候执行它。在这种情况下，不到运行时编译器无法知道它要执行哪个选择器。但是使用它的代价是，如果你在ARC环境下，编译器将会发出警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">warning: performSelector may cause a leak because its selector</div><div class="line">is unknown [-Warc-performSelector-leaks]</div></pre></td></tr></table></figure>
<p>你可能没料到这点！如果你知道，你可能会理解为什么使用这些方法要小心了。这个警告信息看起来非常奇怪，为什么会担心可能发生内存泄露。最重要的是，你只不过简单的尝试去调用一个方法。这个原因是编译器不知道什么选择器会被调用，因此无法知道方法签名，返回类型甚至会不会有返回值。由于编译器无法知道方法名因此无法通过ARC的内存规则去确定返回值是否该释放。因此，ARC出于谨慎的做法就不会给他添加释放。但是，如果返回的值是一个已经被保留，这样的结果可能会导致内存泄露，。</p>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line">if ( /* some condition */ ) &#123;</div><div class="line">    selector = @selector(newObject);</div><div class="line">&#125; else if ( /* some other condition */ ) &#123;</div><div class="line">    selector = @selector(copy);</div><div class="line">&#125; else &#123;</div><div class="line">    selector = @selector(someProperty);</div><div class="line">&#125;</div><div class="line">id ret = [object performSelector:selector];</div></pre></td></tr></table></figure>
<p>在上面的例子中有轻微的差别用于展示这个问题。在前两个选择器重，<code>ret</code>对象需要通过代码释放；第三个选择器则不需要。不仅在ARC下应该这样做，在MRC也应该这样做，这样才严格遵守了方法命名规范。不使用ARC(因此没有编译警告)，如果第一个或第二个条件为真，<code>ret</code>对象需要被释放，其余不需要。这是很容易被忽略的，就算使用静态分析器也很难找到内存泄露的地方。这就是为什么要弃用<code>performSelector</code>相关方法的原因。</p>
<p>另一个原因是，这些方法只能返回对象或者void。尽管执行的选择器可能返回类型是void，但是<code>performSelector</code>方法返回的类型是id。如果想要返回整数或者浮点数，那么就需要复杂的类型转化，这是不安全的。由于id类型代表的是任意<code>Objective-C</code>对象，从技术上讲，只要返回值大小和指针大小相同即可，在32位架构下，任何类型都是32位，在64位架构下，任何类型读时64位的。如果返回值是一个C的结构体，<code>performSelector</code>方法就不能使用了。</p>
<p><code>performSelector</code>还有不同的变体，可以在发送消息时传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)selector withObject:(id)object</div><div class="line">- (id)performSelector:(SEL)selector withObject:(id)objectA withObject:(id)objectB</div></pre></td></tr></table></figure>
<p>例如，这个变体可以设置对象中名为value的属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id object = /* an object with a property called &apos;value&apos; */;</div><div class="line">id newValue = /* new value for the property */;</div><div class="line">[object performSelector:@selector(setValue:) withObject:newValue];</div></pre></td></tr></table></figure>
<p>这个方法看起来是有用的，但它也有一个严重的限制。由于参数是id，所以传递的参数必须是一个对象。如果是整形或者浮点型，这些方法就不能用了。另外，使用这个方法的某个变体最多可以传递两个参数，即<code>performSelector:withObject:withObject:</code>。它没有办法执行参数多于两个的选择器。</p>
<p><code>performSelector</code>的系统方法中另外一些方法还可以延时执行或者在另一个线程执行。这些方法中比较通用的如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)selector</div><div class="line">             withObject:(id)argument</div><div class="line">             afterDelay:(NSTimeInterval)delay</div><div class="line"></div><div class="line">- (void)performSelector:(SEL)selector</div><div class="line">               onThread:(NSThread*)thread</div><div class="line">             withObject:(id)argument</div><div class="line">          waitUntilDone:(BOOL)wait</div><div class="line"></div><div class="line">- (void)performSelectorOnMainThread:(SEL)selector</div><div class="line">                         withObject:(id)argument</div><div class="line">                      waitUntilDone:(BOOL)wait</div></pre></td></tr></table></figure>
<p>但是，这些方法有更多的限制。例如，延后执行的方法不可以执行带有两个参数的选择器。在指定线程执行的方法也出于同样的理由限制很大。如果想使用这些方法就需要将这些参数打包在一个字典中然后再方法中将其一个一个取出来，这会增加消耗并可能带来潜在的bug。</p>
<p>所有的这些限制都可以通过使用其他方法解决。主要就是使用block(看第37节)。而且，<code>performSelector</code>系列方法带来的效果都可以使用GCD达到。延后执行可以使用<code>dispatch_after</code>，在另一个线程执行可以使用<code>dispatch_sync</code>和<code>dispatch_async</code>。</p>
<p>例如，去延后执行一个任务，你应该使用后面的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Using performSelector:withObject:afterDelay:</div><div class="line">[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];</div><div class="line"></div><div class="line">// Using dispatch_after</div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</div><div class="line"></div><div class="line">    [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在主线程执行任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Using performSelectorOnMainThread:withObject:waitUntilDone:</div><div class="line">[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];</div><div class="line"></div><div class="line">// Using dispatch_async</div><div class="line">// (or if waitUntilDone is YES, then dispatch_sync)</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用<code>performSelector</code>系列方法有潜在的内存管理问题。如果没办法确定要执行哪个选择器，ARC编译器无法插入恰当的内存管理代码。</li>
<li>使用<code>performSelector</code>系列方法限制非常大，例如返回类型和数字参数都无法使用。</li>
<li>想让方法在某个线程上执行，最好使用GCD来实现。</li>
</ul>
<h3 id="掌握GCD和操作对象的使用时机"><a href="#掌握GCD和操作对象的使用时机" class="headerlink" title="掌握GCD和操作对象的使用时机"></a>掌握GCD和操作对象的使用时机</h3><p>GCD是一种非常棒的技术，不过有时使用系统标准库会有更好的效果。要知道所使用的每个库的使用时机，如果使用了不合适的库，会使代码难以管理。</p>
<p>能与GCD的功能机制相媲美的很少。对于那种只执行一次的代码，使用<code>dispatch_once</code>(看第45节)是最好的选择。但是，对于在后台执行任务，使用GCD并不是最好的选择。一种与GCD不同但有关系的技术，叫做<code>NSOperationQueue</code>，允许你去将操作以<code>NSOperation</code>的子类的形式放入队列中，它也可以进行并发操作。它与GCD的相似不是一个巧合。操作队列出现在GCD之前，GCD是基于某些操作队列流行的理念设计的。实际上，从iOS 4和Mac OS X 10.6之后，操作队列的底层都是使用GCD实现的。</p>
<p>两者的第一个不同点是GCD是一个纯C的API，操作队列是一个<code>Objective-C</code>对象。在GCD中任务用block表示，block是一个轻量级的数据结构。另一方面，操作对象是一个<code>Objective-C</code>对象，因此它是更重的。这也就是说，GCD并不总是最好的选择。有时，使用对象带来的好处是远远大于它的消耗的。</p>
<p>使用<code>NSBlockOperation</code>和<code>NSOperationQueue</code>的<code>addOperationWithBlock:</code>方法，操作队列的语法和GCD非常相似。这里列举了一些使用<code>NSOperation</code>和<code>NSOperationQueue</code>的优点：</p>
<blockquote>
<p><strong>取消操作队列</strong></p>
</blockquote>
<p>使用操作队列是非常简单的。在运行任务之前，可以在<code>NSOperation</code>上调用<code>cancel</code>方法，该方法会设置一个内部标示符去告诉队列这个任务不需要运行了，但是它不能取消已经开始的操作队列了。另一方面，GCD没有办法取消未开始的操作队列。GCD那套架构是加入队列之后就不管了。你也可以在应用层实现取消功能，但那需要大量的代码，而操作队列已经实现了这个功能。</p>
<blockquote>
<p><strong>操作队列依赖</strong></p>
</blockquote>
<p>一个操作队列可以依赖其他多个操作队列。这样可以创建一个操作队列继承机制，即某个确定的操作队列可以在别的操作队列完成之后再执行。例如，你想从服务器下载一个文件，但是首先需要先下载一个清单文件。依赖可以让其余的下载操作队列在下载完清单文件之后再进行。如果操作队列被设置为并发执行，后续的下载可以同时执行，但是需要清单文件下载完毕。</p>
<blockquote>
<p><strong>操作队列属性的KVO</strong> </p>
</blockquote>
<p>操作队列会有许多可以使用KVO观测的值，例如<code>isCancelled</code>去确定是否取消操作队列，<code>isFinished</code>去确定操作队列是否完成。如果像知道一个任务的状态或者比GCD更详细的观测，使用KVO是非常有用的。</p>
<blockquote>
<p><strong>操作队列的优先级</strong> </p>
</blockquote>
<p>在一条队列中，每个操作队列都有它自己的优先级。高优先级的操作队列是要早于低优先级的。这个操作队列算法虽然是不透明的，但肯定经过认真思考。GCD没有办法直接做到类似事情。它没有任务优先级，但它可以给整条队列队列设置优先级而不是单个block。而令你自己在GCD上写调度算法，又是你所不愿意的。因此，操作队列提供的优先级设置功能是比GCD更适合的。</p>
<p><code>NSOperations</code>也有自己的线程优先级，它决定了操作队列运行在哪条线程上。你在GCD上也可以做，但操作队列使用属性去控制是更简单的。</p>
<blockquote>
<p><strong>操作队列的重用</strong> </p>
</blockquote>
<p>除非你使用系统构建的<code>NSOperation</code>的子类，例如<code>NSBlockOperation</code>，否则你必须自己创建子类。这个类可以生成正常的<code>Objective-C</code>对象，也可以存储你想存储的信息。对象在运行时可以使用存储的信息，也可以调用类中任意的方法。这使得它比派发队列中单一的block更强大。这些<code>NSOperation</code>类可以重复使用，它遵循软件开发中的不重复原则。</p>
<p>如你所见，有许多原因去使用操作队列而不是派发队列。操作队列提供了大多数你在开发时会用到的功能。不需要你自己去实现复杂功能，例如取消队列和队列优先级，这些操作队列都已经处理好了。</p>
<p>另一个API使用了操作队列而不是派发队列的是<code>NSNotificationCenter</code>，它有一个方法可以让注册者通过一个block而不是选择器去监听通知。这个方法原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)addObserverForName:(NSString*)name</div><div class="line">                  object:(id)object</div><div class="line">                   queue:(NSOperationQueue*)queue</div><div class="line">              usingBlock:(void(^)(NSNotification*))block</div></pre></td></tr></table></figure>
<p>相比于操作队列，这个方法也能通过派发队列去实现。但它并没有这样做，这个设计者只使用了高层的<code>Objective-C</code>API。在这个情况下，两者并无性能的差别。设计者可能不想使用派发队列，因为那需要使用GCD；注意block不是GCD，block并不需要依赖GCD。也可能是设计者只想保持所用的都是<code>Objective-C</code>功能。</p>
<p>你可能经常听到你应该使用高层API，仅在需要时使用底层API这种说法。我认为它说的没问题，但我并不盲从。某些功能确实高层的<code>Objective-C</code>API可以实现，但底层并不一定比他差。最好的办法还是由性能来决定。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在解决多线程和任务管理时，GCD并不是唯一选择。</li>
<li><code>Objective-C</code>提供了一种高层次的API，它叫做操作队列，它可以实现大多数GCD能做到的事情。操作队列还做了一些复杂的操作，GCD也可以做到这些复杂操作，但是需要额外的代码。</li>
</ul>
<h3 id="通过dispatch-group机制，根据系统资源状况来执行任务"><a href="#通过dispatch-group机制，根据系统资源状况来执行任务" class="headerlink" title="通过dispatch group机制，根据系统资源状况来执行任务"></a>通过dispatch group机制，根据系统资源状况来执行任务</h3><p><code>dispatch group</code>是一个GCD功能，它可以让你很轻易的将任务分组。你可以将任务放在一个集合中，当集合中任务执行完毕，你会收到一个回调。这个功能是非常有用的，首先是当你想执行多个并发任务，并想在它们都结束之后做些什么。例如，可以把压缩一系列文件的任务放在一个任务组中。使用下面的函数创建<code>dispatch group</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t dispatch_group_create();</div></pre></td></tr></table></figure>
<p><code>dispatch group</code>是一个简单的数据结构，结构之间没有什么不同，它不像派发队列，派发队列是有标示符的。你有两种办法可以将任务加入组内。第一种是使用下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>这是正常<code>dispatch_async</code>函数的一个变种，它多了一个派发组参数，它将block任务关联进组内执行。第二个将方法关联进组内的办法是下面这对函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void dispatch_group_enter(dispatch_group_t group);</div><div class="line">void dispatch_group_leave(dispatch_group_t group);</div></pre></td></tr></table></figure>
<p>第一个函数会让派发组中正要执行的任务数增加；第二个与之相反。因此，每次调用<code>dispatch_group_enter</code>，也必须调用<code>dispatch_group_leave</code>。这与引用计数(看第29节)类似，引用计数的<code>retain</code>和<code>release</code>必须成对出现避免内存泄露。在派发组这个例子中，如果调用了一次enter而没有调用leave，那么组将永远不会结束。</p>
<p>下面这个函数可用来等待<code>dispatch group</code>执行完毕：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</div></pre></td></tr></table></figure>
<p>这个函数有两个参数，一个是派发组，一个是超时值。这个超时值指定乐这个函数会等任务组执行多久。如果任务组在超时前结束，那么会返回0；否则，就会返回非0。这个值可以使用<code>DISPATCH_TIME_FOREVER</code>，这样会一直等待组任务执行完毕，也永远不会超时。</p>
<p>下面的函数可以替代上面函数的，它一样可以阻塞当前线程直到任务组执行完毕：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>它们些微不同在于，这个函数可以 让你指定一个block，当组任务结束时，可以运行在某个特定的线程上。如果你不希望当前线程被阻塞，又想知道任务组什么时候结束，这是非常有用的。例如，在Mac OS X和iOS尚，你永远不该阻塞主线程，因为它是绘制UI和事件相应的线程。</p>
<p>如果想让数组中每个对象都执行一个任务，并等待它们执行完毕，可以使用GCD的这个功能。下面代码做到了这点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class="line">for (id object in collection) &#123;</div><div class="line">    dispatch_group_async(dispatchGroup,</div><div class="line">                         queue,</div><div class="line">                         ^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line">dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);</div><div class="line">// Continue processing after completing tasks</div></pre></td></tr></table></figure>
<p>如果当前线程不该被阻塞，你应该使用通知函数替代等待函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t notifyQueue = dispatch_get_main_queue();</div><div class="line">dispatch_group_notify(dispatchGroup,</div><div class="line">                        notifyQueue,</div><div class="line">                        ^&#123;</div><div class="line">                            // Continue processing after completing tasks</div><div class="line">                        &#125;);</div></pre></td></tr></table></figure>
<p>这个回调所执行的线程应该取决于情况。这里，我使用了主队列，它是一个常用的做法。你也可以使用任意串行队列或者全局并发队列。</p>
<p>在这个例子中，所有任务都派发到同一个队列上。但这样做并不是必须的。你可能想将一些任务放置在高优先级但是仍是在任务结束收到通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class="line">dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class="line">for (id object in lowPriorityObjects) &#123;</div><div class="line">    dispatch_group_async(dispatchGroup,</div><div class="line">                        lowPriorityQueue,</div><div class="line">                        ^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line">for (id object in highPriorityObjects) &#123;</div><div class="line">    dispatch_group_async(dispatchGroup,</div><div class="line">                        highPriorityQueue,</div><div class="line">                        ^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line">dispatch_queue_t notifyQueue = dispatch_get_main_queue();</div><div class="line">dispatch_group_notify(dispatchGroup,</div><div class="line">                      notifyQueue,</div><div class="line">                      ^&#123;</div><div class="line">                          // Continue processing after completing tasks</div><div class="line">                      &#125;);</div></pre></td></tr></table></figure>
<p>除了上面例子中的提交到并发队列，也可以将其提交到串行队列中。但是如果所有的任务都在痛一个串行队列，那任务组就没什么用了。因为所有的任务都是顺序执行，你只需要在最后添加一个block，它就等价于任务组的通知了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.effectiveobjectivec.queue&quot;, NULL);</div><div class="line">for (id object in collection) &#123;</div><div class="line">    dispatch_async(queue, ^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    // Continue processing after completing tasks</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码展示了有些情况你不需要使用任务组。有时采用单个串行队列，以及异步派发也是可以达到同样效果的。</p>
<p>为什么我提到执行任务要基于系统资源呢？当如，如果你往后看刚才的那个并发队列的例子，它是非常清楚的。GCD会自动创建新的线程或者复用旧的线程。在并发队列中，它可以有多个线程，这意味着多个任务block并发执行。并发线程的数量取决于很多因素，但最多的是取决于系统资源。如果CPU是多核的，队列中有许多人物等待执行，那么就会产生很多线程去执行任务。通过<code>dispatch group</code>提供的功能可以很容易的执行多个并发任务，并在结束时收到通知。通过GCD的原生并发队列，执行并发任务将会基于系统可用资源去分配。这样开发者只需要关注商业逻辑不需要去关注处理并发任务的复杂逻辑。</p>
<p>上面集合循环的例子，然后每个元素执行一个任务也能通过一个GCD函数功能达到，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void dispatch_apply(size_t iterations, dispatch_queue_t queue, void(^block)(size_t));</div></pre></td></tr></table></figure>
<p>这个函数执行给定次数的block，每次执行都会增加传给block的数值，这个值是从0到iterations - 1。它是这样使用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.effectiveobjectivec.queue&quot;, NULL);</div><div class="line">dispatch_apply(10, queue, ^(size_t i)&#123;</div><div class="line">    // Perform task</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>实际上，它等价于一个0-9的for循环，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">    // Perform task</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是<code>dispatch_apply</code>也可以使用并发队列。如果是这样，block将会根据系统资源同时执行，就像刚才那个组任务。如果刚才例子中的集合是一个数组，它也可以使用<code>dispatch_apply</code>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i)&#123;</div><div class="line">    id object = array[i];</div><div class="line">    [object performTask];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个例子又一次展示了<code>dispatch group</code>不是必须的。但是<code>dispatch_apply</code>会持续阻塞，直到所有任务执行完毕。因此，如果你尝试在并发队列上运行block(或者高于当前队列的一个串行队列)，就会造成死锁。如果你想在后台执行任务，那么还是使用<code>dispatch group</code>吧。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch group</code>用来执行集合中的所有任务。当所有任务执行完毕时，你可以选择获得通知。</li>
<li><code>dispatch group</code>可以通过并发队列执行多个并发任务。在这种情况下，GCD会基于系统资源去同时处理多个任务。如果你自己实现这个功能需要大量代码。</li>
</ul>
<h3 id="使用dispatch-once执行只执行一次的线程代码"><a href="#使用dispatch-once执行只执行一次的线程代码" class="headerlink" title="使用dispatch_once执行只执行一次的线程代码"></a>使用dispatch_once执行只执行一次的线程代码</h3><p>单例模式是<code>Objective-C</code>中常用到的一种模式，一般通过叫做<code>sharedInstance</code>的类方法，它会返回一个单一实例，而不是每次都返回新实例。<code>sharedInstance</code>方法的通常实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@implementation EOCClass</div><div class="line"></div><div class="line">+ (id)sharedInstance &#123;</div><div class="line">    static EOCClass *sharedInstance = nil;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (!sharedInstance) &#123;</div><div class="line">            sharedInstance = [[self alloc] init];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sharedInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我发现单例模式很容易产生激烈辩论，特别是<code>Objective-C</code>。线程安全是辩论的主要问题。上面的代码使用同步锁使创建的单例线程安全。无论好坏，这种代码很简单，所以随处可见。</p>
<p>但是，GCD的一个功能使单例模式更容易实现。这个函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void dispatch_once(dispatch_once_t *token, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>这个函数接受一个特殊的<code>dispatch_once_t</code>类型参数，我将其称为标记，此外还有一个block。这个函数确保给予一个标记，这个block会执行一次也仅仅执行一次。这个block金辉在第一次调用时执行，最重要的是，它是线程安全的。注意，每次传入的标记必须完全一致，只有这样它才会只执行一次。因此开发者经常将其声明为静态或者全局变量。</p>
<p>使用这个函数重写单例模式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (id)sharedInstance &#123;</div><div class="line">    static EOCClass *sharedInstance = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedInstance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>dispatch_once</code>简化了代码，也是的线程安全，所以你不需要考虑加锁或者同步锁的问题。所有都在GCD底层处理了。那个标记被声明为<code>static</code>，因为它需要每次都是同一个值。将其定义在<code>static</code>区域意味着编译器会确保每次执行<code>sharedInstance</code>方法时都复用旧值而不是创建新的变量。</p>
<p>而且，<code>dispatch_once</code>是非常高效的。它没有使用重量级的同步机制，否则每次运行都要加锁，它使用了原子性去访问标记，用以指示代码是否已经运行。在Mac OS X10.8.2系统64位的电脑上，使用<code>@synchronized</code>访问<code>sharedInstance</code>方法比使用<code>dispatch_once</code>花费的时间要多两倍。</p>
<h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul>
<li>单一线程安全是常见的任务。GCD提供了一种易于使用的工具去达成这个目的，它就是<code>dispatch_once</code>函数。</li>
<li>标记应该声明在<code>static</code>或者<code>global</code>区域中，这样每次执行时得到的标记都是相同的。</li>
</ul>
<h3 id="避免使用dispatch-get-current-queue"><a href="#避免使用dispatch-get-current-queue" class="headerlink" title="避免使用dispatch_get_current_queue"></a>避免使用dispatch_get_current_queue</h3><p>当你在使用GCD时，特别是当你派发了任务给不同的队列时，通常都会想确定当前是哪个线程在执行。例如，UI工作一直需要在Mac OS X和iOS的主线程工作，它等价于GCD的主队列。有时，看起来可能需要去确定当前代码是否执行在主线程上。通过阅读文档，你发现可以通过下面的函数获取当前线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dispatch_get_current_queue()</div></pre></td></tr></table></figure>
<p>它会返回当前哪个队列在执行。确实是这样，不过使用的时候需要小心。实际上，它在iOS6.0之后就被废弃了，但在Mac OS X 10.8并未废弃。尽管如此，你也应该避免在Mac OS X上使用它。</p>
<p>该函数有一个典型的反面教材，就是去检测当前队列是否是指定队列，用以试图避免同步时的死锁。考虑下面的代码，它使用一个同步队列去访问一个实例变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (NSString*)someString &#123;</div><div class="line">   </div><div class="line">    __block NSString *localSomeString;</div><div class="line">    dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">    return localSomeString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">    </div><div class="line">    dispatch_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>getter</code>方法中可能会产生一个问题，如果调用<code>getter</code>方法的队列是与<code>getter</code>方法内部是相同队列，由于<code>dispatch_sync</code>只会在block执行完毕时返回。但是如果目标队列是当前队列，那么block将永远不会得到执行机会，因为应该执行block的目标队列是当前队列，而当前队列又一直阻塞。像这个例子中的<code>getter</code>方法就是不可重入的。</p>
<p>看了<code>dispatch_get_current_queue</code>的文档后，你可能觉得可以通过检测当前队列的方法使得<code>getter</code>方法可以重入，如果这样，直接执行block就行了，不需要执行派发了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (NSString*)someString &#123;</div><div class="line">    __block NSString *localSomeString;</div><div class="line">    dispatch_block_t accessorBlock = ^&#123;</div><div class="line">        </div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    if (dispatch_get_current_queue() == _syncQueue) &#123;</div><div class="line">    </div><div class="line">        accessorBlock();</div><div class="line">    &#125; else &#123;</div><div class="line">        </div><div class="line">        dispatch_sync(_syncQueue, accessorBlock);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return localSomeString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子在简单环境下可以工作。但是，它仍旧是危险且容易导致死锁的。为什么？考虑下面场景的两条串行队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queueA = dispatch_queue_create(&quot;com.effectiveobjectivec.queueA&quot;, NULL);</div><div class="line">dispatch_queue_t queueB = dispatch_queue_create(&quot;com.effectiveobjectivec.queueB&quot;, NULL);</div><div class="line">dispatch_sync(queueA, ^&#123; </div><div class="line">    dispatch_sync(queueB, ^&#123;</div><div class="line">        dispatch_sync(queueA, ^&#123;</div><div class="line">            // Deadlock</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在最内部的队列A一样会造成死锁，因为它要等待最外层的<code>dispatch_sync</code>完成，而最外层的又不可能完成，因为它要等最内层的执行完成，这样就死锁了。现在考虑使用<code>dispatch_get_current_queue</code>放入相同的检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(queueA, ^&#123;</div><div class="line">    dispatch_sync(queueB, ^&#123;</div><div class="line">        dispatch_block_t block = ^&#123; /* ... */ &#125;;</div><div class="line">        if (dispatch_get_current_queue() == queueA) &#123;</div><div class="line">            block();</div><div class="line">        &#125; else &#123;</div><div class="line">            dispatch_sync(queueA, block);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是这一样会导致死锁啊，因为<code>dispatch_get_current_queue</code>返回的是当前队列，在上面的例子中将会返回队列B。所以仍将同步执行最内层的队列A，结果就会像之前那样死锁喽。</p>
<p>在这个例子中，正确的解决办法是使其不可重入。而是应该确保同步队列绝不会访问属性，即不会调用<code>someString</code>方法。这个队列应该只用来同步属性。派发队列是非常轻的，为了使每个属性都有自己的同步队列，我们可以为其创建多个队列。</p>
<p>上边的例子看起来有点做死，但是还是会有别的情况导致这个问题的。队里是可以被安排进层级中的，这意味着block会在其上级队列中执行。队列的最外层是一个全局并发队列。<br>图6.4展示了简单的队列结构。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%206.4.png" alt=""><br><strong>Figure 6.4</strong> 派发队列层级。</p>
<p>队列B或者队列C的block会在队列A后面执行。所以队列A、队列B、队列C的block总会分开执行。但是队列D就可能与队列A或者队列B或者队列C同时执行了，因为队列A和队列D是放在全局并发队列里面了。如果需要执行并发任务，就会依据系统资源来进行分配了，例如GCD的核数。</p>
<p>由于队列有层级关系，所以去检测当前队列是哪个也并没有太大作用了。例如，你确定当前block执行在队列C上面，所以你认为在队列A上面同步执行任务就是安全的。实际上，这仍然会导致死锁。</p>
<p>如果一个API允许你指定回调时的block的运行队列，但是它的内部使用了一个同步串行队里，如果你的目标也是这个队列，依然会造成死锁。使用API的开发者可能以为<code>dispatch_get_current_queue</code>返回的是调用API那个，但其实是它内部使用的那个。</p>
<p>为了解决这个问题，最好的办法是使用GCD提供的队列特有数据，它允许你去将任何数据以键值对的形式添加进队列中。最重要的是，如果根据指定的键找不到数据，它会沿着队列层次一直寻找，直到根队列位置。这么说可能明白怎么使用，所以看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queueA = dispatch_queue_create(&quot;com.effectiveobjectivec.queueA&quot;, NULL);</div><div class="line">dispatch_queue_t queueB = dispatch_queue_create(&quot;com.effectiveobjectivec.queueB&quot;, NULL);</div><div class="line">dispatch_set_target_queue(queueB, queueA);</div><div class="line">static int kQueueSpecific;</div><div class="line">CFStringRef queueSpecificValue = CFSTR(&quot;queueA&quot;);</div><div class="line"></div><div class="line">dispatch_queue_set_specific(queueA,</div><div class="line">                            &amp;kQueueSpecific,</div><div class="line">                            (void*)queueSpecificValue,</div><div class="line">                            (dispatch_function_t)CFRelease);</div><div class="line">dispatch_sync(queueB, ^&#123;</div><div class="line">    dispatch_block_t block = ^&#123; NSLog(@&quot;No deadlock!&quot;); &#125;;</div><div class="line">    CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);</div><div class="line">    if (retrievedValue) &#123;</div><div class="line">        block();</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_sync(queueA, block);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个例子中，创建了两个队列。将队列B的目标队列设为队列A，而队列A的目标队里仍旧是默认的全局并发队列。然后给队列A设置一个队列特有值，使用下面这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void dispatch_queue_set_specific(dispatch_queue_t queue,</div><div class="line">                                 const void *key,</div><div class="line">                                 void *context,</div><div class="line">                                 dispatch_function_t destructor);</div></pre></td></tr></table></figure>
<p>第一个参数是设置数据的目标队列，后面两个是参数和值。参数和值都是不透明的void指针。对于键来说，函数是按照指针来做比较的，而不是内容。所以，队列特有数据的行为是不同于<code>NSDictionary</code>对象的，字典对面是对比键的内容。队列特有数据的行为更像是关联对象。值也是不透明的void指针，所以你可以放置任何值。但是，你必须去管理这个对象的内存。这使得ARC很难去自动管理这个对象的内存。在这个例子中，这个value值是一个<code>CoreFoundation</code>字符串，而ARC不关心任何<code>CoreFoundation</code>对面的内存管理。这样的对象更适合做队列特有数据，因为它可以使用免费桥与<code>Objective-C</code>相关类进行转换。</p>
<p>最后的参数是这个函数的析构函数，当对象持有的键被移除时，它就会运行。因为那时肯定是队列被释放或者有新的键值对被设置。<code>dispatch_function_t</code>的类型是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void (*dispatch_function_t)(void*)</div></pre></td></tr></table></figure>
<p>析构函数必须只能带有一个单一指针并且返回值一定是void。在这个例子中，使用了<code>CFRelease</code>，它就是这样一个函数，不过你也可以自己定义一个函数，在其中调用<code>CFRelease</code>，并对其它需要清理的内容进行清理。</p>
<p>队列特有数据提供的这套简单易用的功能避免了使用<code>dispatch_get_current_queue</code>所带来的坑。另外还可能在调试时使用<code>dispatch_get_current_queue</code>。在这种情况下，它是可以安全使用的，只要你不讲代码编译进发布版本。如果对访问当前队列有特殊需要，而当前函数又无法完成，那么最好的解决办法还是去找苹果公司吧。</p>
<h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_get_current_queue</code>函数可能不会像你想象的那么有用。它已经被废弃并且现在只应在调试时使用它。</li>
<li>派发队列是有层级结构的；因此，单个队列无法描述当前队列。</li>
<li>队列特有数据可以解决使用<code>dispatch_get_current_queue</code>遇到的常见问题，它可以避免因为无法重入导致的代码死锁。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第六章：Block和GCD&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第五章</title>
    <link href="http://yoursite.com/2017/07/01/Memory%20Management/"/>
    <id>http://yoursite.com/2017/07/01/Memory Management/</id>
    <published>2017-07-01T09:55:58.000Z</published>
    <updated>2017-07-08T07:48:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第五章：内存管理</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>无论任何面向对象语言，内存管理都是重要的一部分，例如<code>Objective-C</code>。想写出高效无bug的语言，对其语言的内存管理模型一定要了解。</p>
<p>如果你理解了类似规则，你会发现<code>Objective-C</code>的内存管理貌似也不是很复杂，特别当你使用ARC时。ARC将所有的内存管理都交给了编译器，可以让开发者专注业务逻辑。</p>
<h3 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h3><p><code>Objective-C</code>使用引用计数去管理内存，这意味着每个对象都有一个计数器用于增加和减少引用计数。当你想使用某个对象时就增加引用计数，当你不再使用某个对象时，就减少引用计数。当对象引用计数为0，这个对象不再有任何使用者，这时他就会被释放。上面所述是主要概念，如果你想写出优秀的代码，即使你使用ARC(看第30节)机制，你也需要理解上述概念。</p>
<p>在Mac上，垃圾回收机制在10.8之后被废弃，在iOS上更是从来都不能使用。所以理解引用计数就至关重要了，因为你不能在iOS和Mac上使用垃圾回收了。</p>
<p>如果你已经使用了ARC，那你应该知道所有与引用计数相关的方法都无法调用了，暂且忘掉这些吧。在ARC中，这是真的。但是这是讲述引用计数必须的一部分，并且ARC也是一种引用计数机制，所以还是要讲述这些在ARC下无法使用的方法。</p>
<h4 id="引用计数如何工作"><a href="#引用计数如何工作" class="headerlink" title="引用计数如何工作"></a>引用计数如何工作</h4><p>在引用计数机制下，计数器是代表每个对象有多少事物想令此对象继续存在。这涉及到了一个叫做保留计数的东西，但是他也被称作引用计数。下面三个<code>NSObject</code>的协议方法可以操作引用计数的增加和减少：</p>
<ul>
<li><strong>retain</strong> 增加引用计数</li>
<li><strong>release</strong> 减少引用计数</li>
<li><strong>autorelease</strong> 稍后减少引用计数，当自动释放池释放时减少(我们将在第34节第150页讨论自动释放池)</li>
</ul>
<p>其中有一个叫做<code>retainCount</code>的方法，但是它不是很准确，即使在调试环境下也是。所以我跟苹果都不推荐你使用它。具体信息看第36节。</p>
<p>每个对象创建时引用计数最少为1。如果想要对象存活，就调用<code>retain</code>方法。当某部分代码不再需要这个对象时就调用<code>release</code>或者<code>autorelease</code>。当引用计数为0时，对象被释放，这意味着这块内存被标为可复用。一旦对象被释放，那么该对象的任何引用都是无效的。</p>
<p>图5.1展示了一个对象的创建，持有和两次释放。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.1.png" alt=""><br><strong>Figure 5.1</strong> 一个对象的整个生命周期内它的引用计数的增加和减少</p>
<p>在一个应用的生命周期内，有许多对象被创建。这些对象往往跟另一个对象有所关联。例如，有一个代表人的对象，它会对一个用字符串表示的人名进行引用，也可能有别的引用，例如一个代表它朋友的结合，这些构成了一个对象表。如果一个对象对另一个对象持有一个强引用，那么前者持有后者。这个意思是当某个对象对其余对象有使用的意图时，就可以通过持有的方式保证后者被释放。当它不在需要后者时，再对后者进行释放。</p>
<p>图5.2的对象表中，<code>ObjectA</code>同时被<code>ObjectB</code>和<code>ObjectC</code>持有。当<code>ObjectB</code>和<code>ObjectC</code>不在持有<code>ObjectA</code>并且<code>ObjectA</code>引用计数为0时，<code>ObjectA</code>会被释放。<code>ObjectB</code>和<code>ObjectC</code>被其余对象持有，而其余对象又被别的对象持有。如果你查找整个对象表，你会发现一个根对象。在Mac中，根对象是<code>NSApplication</code>；在iOS中，根对象是<code>UIApplication</code>。这两个对象都是程序启动时创建的一个单例对象。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.2.png" alt=""><br><strong>Figure 5.2</strong> 对象表展示一个对象被释放之前它的引用的释放</p>
<p>下面的代码将帮助你理解上图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</div><div class="line">[array addObject:number];</div><div class="line">[number release];</div><div class="line">// do something with &apos;array&apos;</div><div class="line">[array release];</div></pre></td></tr></table></figure>
<p>如前面展示的一样，上述代码在ARC下无法编译通过。因为显式调用了<code>release</code>方法。在<code>Objective-C</code>中，调用<code>alloc</code>方法返回的对象由调用者持有。也就是说，调用者通过 <code>alloc</code>方法表达了想让对象存在的想法。但是有一点需要注意，这时它的引用计数并不一定是1。它有可能比1大，因为<code>alloc</code>或者<code>initWithInt:</code>的实现里面有别的对象对他有引用。这样，这个对象的引用计数就最少为1了。你应该这样理解引用计数这个概念。你不应该认为引用计数是几，只应该说清楚引用计数增加或者减少。</p>
<p>然后<code>number</code>对象被添加进数组。数组通过<code>addObject:</code>方法一直保持<code>number</code>的引用。<br>这时，<code>number</code>对象的引用计数最少是2。然后，这段代码不再需要<code>number</code>变量，所以释放它。这时引用计数最少是1。这时，<code>number</code>变量不再可以安全的使用。它调用<code>release</code>的意思是不再能保证所指对象是否存活了。当然，在这个例子中，我们很明显可以知道它在调用了<code>release</code>之后仍然是存活的，因为数组还在引用它。但是不要假定一个对象存活，就是不要像下面这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</div><div class="line">[array addObject:number];</div><div class="line">[number release];</div><div class="line">NSLog(@&quot;number = %@&quot;, number);</div></pre></td></tr></table></figure>
<p>这样的代码即使在这个环境下可以运行，它也不是好的做法。不论出现任何原因导致<code>number</code>对象的引用计数为0，然后被释放，那么当你调用<code>NSLog</code>的时候，程序就可能会崩溃掉了。这里为什么说是可能呢？因为对象释放之后，只是将内存放回可用内存池。如果在你调用<code>NSLog</code>时，内存还没有被覆盖，那么该对象仍然存在，就不会发生崩溃。因此，过早释放对象会造成难以调试的问题。</p>
<p>为了减少这种对象已经被释放的潜在风险，你经常能看到在<code>release</code>之后将对象设为nil的代码。这能确保不会通过指针调用一个无效的对象，这种指针被称为悬垂指针。例如，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</div><div class="line">[array addObject:number];</div><div class="line">[number release];</div><div class="line">number = nil;</div></pre></td></tr></table></figure>
<h4 id="属性存取器的内存管理"><a href="#属性存取器的内存管理" class="headerlink" title="属性存取器的内存管理"></a>属性存取器的内存管理</h4><p>正像前面说的那样，对象链接在一起构成了对象表。上面例子中的数组通过对对象进行<code>retain</code>操作持有它们。同样，其它对象也可以使用属性持有其它对象，并通过存取方法去获得或者设置实例变量。如果属性是一个强引用，则设置的属性值会被保留。一个叫做<code>foo</code>的属性的，它有一个叫做<code>_foo</code>的实例变量，它的<code>setter</code>方法像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setFoo:(id)foo &#123;  </div><div class="line">    [foo retain];</div><div class="line">    [_foo release];</div><div class="line">    _foo = foo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>保存新值，释放旧值。然后更新实例变量指向新的值。这个命令是重要的。如果旧值在新值保留前释放并且这两个值是相同的，这意味着这个对象可能会被过早的释放。后面的<code>retain</code>操作也无法使这个对象存活，然后这个实例变量将会变成一个悬垂指针。</p>
<h4 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h4><p>在<code>Objective-C</code>的引用计数中有一个重要结构，那就是自动释放池。调用<code>release</code>的会直接减少引用计数(可能导致对象直接释放)，你也可以使用<code>autorelease</code>，它会在之后执行释放操作，通常是在下一次循环事件时递减，不过也可能更早(具体看第34节)。</p>
<p>这个功能是非常有用的，特别是当一个方法返回一个对象时。在这种情况下，我们并不想另调用者手动保存其值。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSString*)stringValue &#123;</div><div class="line">    </div><div class="line">    NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self];</div><div class="line">    return str;</div><div class="line">&#125;</div><div class="line">```在这个例子中，`str`的引用计数最少为1，因为调用`alloc`方法会使引用计数加1，并且也没有对应的释放。引用计数加1意味着你作为调用者，必须在某个时刻将其释放，即引用计数减1。但是这并不意味着它的引用计数是1。它可能是更多，因为你不知道`initWithFormat:`的实现细节。你要考虑的是如何处理这一次的保留操作。 </div><div class="line">但是你不能在这个方法里面释放它，因为它需要返回后才能释放。所以这里应该使用`autorelease`去保证对象可以正常返回，然后进行释放。也就是说，这个方法可以保证对象跨越方法调用边界之后仍然存活。实际上，这个释放会在当前自动释放池释放时(看第34节)发生，除非你创建了自己的自动释放池，否则它会在当前线程的下次事件时释放。对这个字符串对象使用这个方法如下：</div></pre></td></tr></table></figure>
<ul>
<li><p>(NSString*)stringValue {</p>
<p>  NSString *str = [[NSString alloc] initWithFormat:@”I am this: %@”, self];<br>  return [str autorelease];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在这个方法返回时，对象一定存活。所以这个对象可以这样使用了：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NSString *str = [self stringValue];<br>NSLog(@”The string is: %@”, str);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里不再需要更多的内存管理了，因为`str`对象已经自动释放，达到引用计数平衡了。因为自动释放池要到下一次事件循环才会释放，所以在使用`NSLog`时，不需要再进行保留了。但是，如果对象需要被持有，例如一个实例变量，对象需要`retain`并在稍后使用`release`：</div></pre></td></tr></table></figure></p>
<p>_instanceVariable = [[self stringValue] retain];<br>// …<br>[_instanceVariable release];<br>```</p>
<p>所以<code>autorelease</code>可以延长对象的生命周期，使其跨越方法调用边界之后仍然存在。</p>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>使用引用计数时常遇到的一个场景是循环应用，它发生在多个对象相互引用的时候。它会导致内存泄露，因为没有办法调用到这些循环引用的对象，并将其引用计数设为0。在循环引用中，每个对象都会被最少一个对象持有。在图5.3中，每一个对象都有另外两个对象的引用。在这个循环中，所有对象的引用计数都是1。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.3.png" alt=""><br><strong>Figure 5.3</strong> 一个循环引用的对象表</p>
<p>在垃圾回收中，这种情况会被标记为孤岛。这种情况下，垃圾回收器会将三个对象都释放掉。很遗憾在<code>Objective-C</code>的引用计数中不存在这种做法。这个问题的常用做法是使用弱引用(看第33节)或者将这些对象中的某一个放弃持有其它对象。上述的两种做法都可以打破循环引用，这样内存泄露就不存在了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>以引用计数方式进行内存管理是基于计数器进行增加和减少的。一个对象创建后，它的引用计数最少为1。如果引用计数为正，则对象存活。如果引用计数为0，则对象被释放。</li>
<li>在对象的整个生命周期中，一个对象通过引用来保留和释放其他对象。保留和释放会增加和减少引用计数。</li>
</ul>
<h3 id="ARC使引用计数更加简单"><a href="#ARC使引用计数更加简单" class="headerlink" title="ARC使引用计数更加简单"></a>ARC使引用计数更加简单</h3><p>理解引用计数概念是很简单的(看第29节)，但是<code>retain</code>和<code>release</code>出现的场景很是频繁。所以<code>Clang</code>编译器搞了一个静态解析器，用于指出引用计数出现问题的地方。例如，考虑下面代码片段的引用计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ([self shouldLogMessage]) &#123;</div><div class="line">        </div><div class="line">    NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self];</div><div class="line">    NSLog(@&quot;message = %@&quot;, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码有一个内存泄露，因为在判断语句的结尾，<code>message</code>对象没有释放。因为出了条件语句后，就没办法引用它了，对象就泄露了。判断内存泄露的规则很简单。它调用了<code>NSString</code>的<code>alloc</code>方法生成了一个对象，使其引用计数最少为1。但是它没有释放。这些规则很容易表达，电脑可以轻易使用这些规则并告诉我们哪个对象发生了泄露。这就是静态编译器要做的事情。</p>
<p>静态分析还有更深层次的用途。因为它可以告诉你哪个地方发生了内存泄露，所以它也可以在需要的地方添加<code>retain</code>或者<code>release</code>，是吧？ARC就是由这个概念诞生的。ARC的就像它名字说的那样：使引用计数自动化。所以上面的代码会在判断语句结束的地方自动加上<code>release</code>操作，自动添加后的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ([self shouldLogMessage]) &#123;</div><div class="line">        </div><div class="line">    NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self];</div><div class="line">    NSLog(@&quot;message = %@&quot;, message);</div><div class="line">    [message release]; ///&lt; Added by ARC</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要记住的是即使使用了ARC，引用计数仍是在执行的。只不过添加<code>retain</code>或者<code>release</code>的操作是ARC做的。除了为方法返回的对象处理内存管理语义ARC还做了更多的事，稍后你将看到。不过这些功能，都是基于核心内存管理语义构建的，这套标准适用于整个<code>Objective-C</code>。</p>
<p>由于ARC会自动的调用<code>retains, releases, autoreleases</code>，所以你在ARC下直接调用内存管理方法是不合法的。尤其是，你不能调用下面这些方法：</p>
<ul>
<li>retain</li>
<li>release</li>
<li>autorelease</li>
<li>dealloc</li>
</ul>
<p>在ARC下，你直接调用上述方法的任意一个都会导致编译错误，因为你这样做会导致ARC无法正常工作。你必须相信ARC可以处理好这些，这会使某些开发者不是很放心。</p>
<p>实际上，ARC并没有通过正常的<code>Objective-C</code>派发机制去调用这些方法，它直接调用了底层的C函数。这是一种优化，因为<code>retain</code>和<code>release</code>方法调用的是很频繁的，并且也可以减少CPU的工作量。例如，<code>retain</code>是等价于<code>objc_retain</code>的。这就是为什么覆写<code>retain, release, autorelease</code>这些方法是非法的，因为它们并不是直接调用的。对于本章节的其余部分，我仍将讲述与底层C函数等价的<code>Objective-C</code>方法。这对那些使用过手动管理引用计数的人更友好。</p>
<h4 id="ARC中的方法命名规则"><a href="#ARC中的方法命名规则" class="headerlink" title="ARC中的方法命名规则"></a>ARC中的方法命名规则</h4><p>在<code>Objective-C</code>中，将内存管理语义通过方法名表现出来是惯例，而ARC则将其确定为硬性规则。规则是很简单的并且跟方法名有关联的。一个返回对象的方法，如果方法以下列名词开头，它的所有权归属调用者：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>归属调用者的意思是调用那四种方法的调用者需要管理返回值的释放。这是说，返回对象有一个正的引用计数，调用者需要去平衡这一次引用计数。如果有别的对象对其进行了保存或者进行了<code>autorelease</code>，那么它的引用计数会大于1，这就是为什么说<code>retainCount</code>方法没有什么用的原因(看第36节)。</p>
<p>任意别的方法名都代表返回对象的所有权不归属于调用者。这种情况下，对象将自动调用<code>autorelease</code>，这样返回对象的值就可以在跨越边界调用后仍旧有效。如果想确保对象仍然存活，可以调用<code>retain</code>保留它。</p>
<p>ARC自动处理所有需要操作的内存管理规则，包括代码返回值的<code>autorelease</code>，就像下面代码展示的那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">+ (EOCPerson*)newPerson &#123;</div><div class="line">    EOCPerson *person = [[EOCPerson alloc] init];</div><div class="line">    return person;</div><div class="line">    /**</div><div class="line">     * The method name begins with &apos;new&apos;, and since &apos;person&apos; * already has an unbalanced +1 retain count from the</div><div class="line">     * &apos;alloc&apos;, no retains, releases, or autoreleases are</div><div class="line">     * required when returning.</div><div class="line">     */</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (EOCPerson*)somePerson &#123;</div><div class="line">    </div><div class="line">    EOCPerson *person = [[EOCPerson alloc] init];</div><div class="line">    return person;</div><div class="line">    /**</div><div class="line">     * The method name does not begin with one of the &quot;owning&quot;</div><div class="line">     * prefixes, therefore ARC will add an autorelease when</div><div class="line">     * returning &apos;person&apos;.</div><div class="line">     * The equivalent manual reference counting statement is:</div><div class="line">     * return [person autorelease];</div><div class="line">     */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doSomething &#123;</div><div class="line">    </div><div class="line">    EOCPerson *personOne = [EOCPerson newPerson];</div><div class="line">    // ...</div><div class="line">    EOCPerson *personTwo = [EOCPerson somePerson];</div><div class="line">    // ...</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * At this point, &apos;personOne&apos; and &apos;personTwo&apos; go out of</div><div class="line">     * scope, therefore ARC needs to clean them up as required.</div><div class="line">     * - &apos;personOne&apos; was returned as owned by this block of</div><div class="line">     * code, so it needs to be released.</div><div class="line">     * - &apos;personTwo&apos; was returned not owned by this block of</div><div class="line">     *  code, so it does not need to be released.</div><div class="line">     * The equivalent manual reference counting cleanup code</div><div class="line">     * is:</div><div class="line">     * [personOne release]; */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ARC通过名称来约定内存管理的规则，新手往往感觉不可思议。很少有其他语言像<code>Objective-C</code>一样把命名看的这么重要。适应这种模式对于成为一个好的<code>Objective-C</code>开发者是重要的。在这个过程中，ARC帮助你做了大量的工作。</p>
<p>ARC除了为你添加<code>retain、release</code>这些方法，还有一些其他好处。它也会做一些手动难以完成或者不能完成的操作。例如，ARC能互相抵消<code>retain、release、autorelease</code>的互相操作。如果某个对象多次进行<code>retain</code>和<code>release</code>，ARC可以成对的移除它们。</p>
<p>ARC也包含有运行期组件。这些优化发生在运行时，这些就是我们为什么应该在ARC下进行开发。前面提到某个对象需要在返回时进行<code>autorelease</code>。但是调用者需要代码存活就会对它进行<code>retain</code>操作，就像下面这个情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// From a class where _myPerson is a strong instance variable</div><div class="line">_myPerson = [EOCPerson personWithName:@&quot;Bob Smith&quot;];</div></pre></td></tr></table></figure>
<p>调用<code>personWithName:</code>返回了一个自动释放的<code>EOCPerson</code>对象。但是编译器也需要去给那个实例变量添加<code>retain</code>操作，因为它是一个强引用。因此上面的代码等价于下面的手动代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCPerson *tmp = [EOCPerson personWithName:@&quot;Bob Smith&quot;];</div><div class="line">_myPerson = [tmp retain];</div></pre></td></tr></table></figure>
<p>你会发现这里的<code>autorelease</code>和<code>retain</code>都是多余的。去除它们两个可以获得更好的性能收益。但是在ARC下的代码需要考虑向后兼容性，即需要去兼容非ARC的代码。ARC可以移除<code>autorelease</code>这个概念，并且指定所有的方法返回的对象的引用计数都加1。但是，它需要向后兼容。</p>
<p>但是ARC可以在运行时检测到这种多余的行为，即<code>autorelease</code>操作后面跟<code>retain</code>。当一个对象自动释放时，它会调用一个特殊函数，而不是对象的<code>autorelease</code>方法，它叫做<code>objc_autoreleaseReturnValue</code>。这个函数会检查当前函数返回后的那段代码。如果它发现在返回对象后会对对象进行<code>retain</code>操作，它会设置全局数据结构(取决于处理器)中的一个标志，而不执行<code>release</code>操作。同样，对一个自动释放对象进行<code>retain</code>的代码，也不会调用<code>retain</code>，而是执行一个叫做<code>objc_retainAutoreleasedReturnValue</code>的方法。这个方法会检查标志是否存在，如果存在，就不执行<code>retain</code>。对标志进行设置和检查是快过使用<code>autorelease</code>和<code>retain</code>的。</p>
<p>下面的代码展示了ARC是如何使用特殊函数进行优化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Within EOCPerson class</div><div class="line">+ (EOCPerson*)personWithName:(NSString*)name &#123;</div><div class="line">    EOCPerson *person = [[EOCPerson alloc] init];</div><div class="line">    person.name = name;</div><div class="line">    objc_autoreleaseReturnValue(person);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Code using EOCPerson class</div><div class="line">EOCPerson *tmp = [EOCPerson personWithName:@&quot;Matt Galloway&quot;];</div><div class="line">_myPerson = objc_retainAutoreleasedReturnValue(tmp);</div></pre></td></tr></table></figure>
<p>为了求得最佳优化，特殊函数在不同处理器都有不同表现。下面的伪代码展示了大概流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">id objc_autoreleaseReturnValue(id object) &#123;</div><div class="line">    if ( /* caller will retain object */ ) &#123;</div><div class="line">        set_flag(object);</div><div class="line">        return object; ///&lt; No autorelease</div><div class="line">    &#125; else &#123;</div><div class="line">        return [object autorelease];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">id objc_retainAutoreleasedReturnValue(id object) &#123;</div><div class="line">    if (get_flag(object)) &#123;</div><div class="line">        clear_flag(object);</div><div class="line">        return object; ///&lt; No retain</div><div class="line">    &#125; else &#123;</div><div class="line">        return [object retain];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_autoreleaseReturnValue</code>函数如何检测需要保留对象呢。这取决于处理器。只有编译器的作者知道怎么实现它的，因为它需要使用检查机器码。除了编译器的作者谁知道调用的方法是怎么实现的。</p>
<p>这只是编译器在运行期的一种优化。所以使用ARC是一个好的建议。编译器和运行时日渐成熟，我相信会有更多的优化技术的出现。</p>
<h4 id="变量的内存管理语义"><a href="#变量的内存管理语义" class="headerlink" title="变量的内存管理语义"></a>变量的内存管理语义</h4><p>ARC也可以处理本地变量和实例变量的内存管理。通常每个变量都对对象持有强引用。这点是非常重要的，特别是实例变量，因为对象相同的代码，在手动引用计数和自动引用计数都是不一样的。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line">    </div><div class="line">    id _object;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line"></div><div class="line">- (void)setup &#123;</div><div class="line"></div><div class="line">    _object = [EOCOtherClass new];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在手动管理引用计数下，<code>_object</code>实例变量不会自动保留这个值，但是在ARC下会。因此，在ARC下编译这个代码，方法会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setup &#123;</div><div class="line">    id tmp = [EOCOtherClass new];</div><div class="line">    _object = [tmp retain];</div><div class="line">    [tmp release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，这种情况下，<code>retain</code>和<code>release</code>都可以取消掉。所以ARC这样做了，就像转换前的代码一样。但是当它发生在设置<code>setter</code>方法时。如果不使用ARC，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(id)object &#123;</div><div class="line">    [_object release];</div><div class="line">    _object = [object retain];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这样做有一个问题。那就是如果设置的新值和已有的值相同会发生什么？如果这个对象仅有一个引用，那么<code>release</code>会导致这个对象的引用计数变为0并且释放这个对象。后面的<code>retain</code>操作将会导致应用程序崩溃。使用ARC则不可能发生这种错误。ARC下等价的<code>setter</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(id)object &#123;</div><div class="line">    </div><div class="line">    _object = object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ARC执行一种安全的设置变量的方法，先保存新值，然后释放旧值，最后设置实例变量的值。你可能在MRC下已经明白这个问题了并且能正确编写，但是在ARC下你无需考虑这种类似的边界情况。</p>
<p>本地和实例变量可以通过下面这些修饰符进行语义改变：</p>
<ul>
<li>__strong 默认修饰符，这种情况下，变量会被保存。</li>
<li>__unsafe_unretained 这个值不会被保留，这样是不安全的，因为你再次使用它时，可能它已经被释放了。</li>
<li>__weak 这个值也不会被保留，但它是安全的，因为它会在变量为空时，自动设置为nil。</li>
<li>__autoreleasing 把对象按引用传递时始终它，当返回时它会被释放。</li>
</ul>
<p>例如，想令变量与不使用ARC时一样，可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line">    </div><div class="line">    id __weak _weakObject;</div><div class="line">    id __unsafe_unretained _unsafeUnretainedObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这种情况下，当设置实例变量时，对象不会被保留。只有在使用新版运行时库(Mac OS X 10.7、iOS 5.0)的时候，<code>weak</code>修饰符才会自动将实例变量置为nil，因为它需要依赖依稀新的特性。</p>
<p>当我们在块(看第40节)中使用本地变量时，通常使用标示符去打破循环引用。块自动的引用所有它捕获的对象，这样加入那些对象中的某一个也保留有块，就会造成循环引用。使用<code>__weak</code>修饰变量可以打破循环应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:@&quot;http://www.example.com/&quot;];</div><div class="line">EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">EOCNetworkFetcher * __weak weakFetcher = fetcher;</div><div class="line">[fetcher startWithCompletion:^(BOOL success)&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;Finished fetching from %@&quot;, weakFetcher.url);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="ARC清理实例变量"><a href="#ARC清理实例变量" class="headerlink" title="ARC清理实例变量"></a>ARC清理实例变量</h4><p>就像上面展示的一样，ARC会处理实例变量的内存管理。如果要这样做，ARC就需要在释放时期生成清理的代码。凡是使用强引用的变量，ARC都会在<code>dealloc</code>方法中释放它。而在MRC下，需要你自己实现<code>dealloc</code>方法就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    [_foo release];</div><div class="line">    [_bar release];</div><div class="line">    [super dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用了ARC，<code>dealloc</code>方法就不需要这样写了；因为ARC会借用<code>Objective-C++</code>的一项功能来实现清理。在释放时，<code>Objective-C++</code>对象会调用所有C++对象的析构函数。当编译器发现对象包含<code>C++</code>对象时，它会生成一个叫做<code>.cxx_destruct</code>的方法。ARC借助此方法生成清理内存所有的代码。</p>
<p>但是，如果有不是<code>Objective-C</code>的对象，你仍然需要去手动清理，例如<code>CoreFoundation</code>对象，或者是<code>malloc()</code>分配的堆内存。但是你不需要像之前那样去调用父类的<code>dealloc</code>方法。在ARC下不能直接调用<code>dealloc</code>方法。所以ARC会自动在<code>.cxx_destruct</code>中生成并运行代码，也会在生成的代码中自动调用父类的<code>dealloc</code>方法。在ARC下，一个<code>dealloc</code>方法大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    CFRelease(_coreFoundationObject);</div><div class="line">    free(_heapAllocatedMemoryBlob);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于ARC会生成这个方法，所以一般不需要实现<code>dealloc</code>方法。这可以减少项目源码的大小，并减少模板代码。</p>
<h4 id="覆写内存管理方法"><a href="#覆写内存管理方法" class="headerlink" title="覆写内存管理方法"></a>覆写内存管理方法</h4><p>在非ARC时代，是可以覆写内存管理方法的。例如，一个单例类通常会覆写<code>release</code>方法，使其什么也不做，因为单例类不需要释放啊。在ARC就不能这样，因为这会影响ARC对对象声明周期的分析。而且，由于不能调用和覆写这些方法，所以ARC就可以不使用<code>Objective-C</code>的消息派发系统从而对<code>retain, release, autorelease</code>方法进行优化。相应的，可以直接调用运行期的C函数。ARC可以对这些进行优化例如刚才说的对一个返回对象进行<code>autorelease</code>操作，然后接着又进行<code>retain</code>操作。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>ARC使开发者不用担心内存管理。使用ARC也可以减少类的模板代码。</li>
<li>ARC管理对象生命周期的办法就是在合适地方插入<code>retain</code>或者<code>release</code>。ARC下变量可以通过修饰符去改变内存管理语义，MRC下只能手动进行<code>retain</code>或者<code>release</code>。</li>
<li>方法名字已经指出了返回对象的内存管理语义。ARC将这些规则确定为必须遵守的规则。</li>
<li>ARC仅能处理<code>Objective-C</code>对象。特别是不能处理<code>CoreFoundation</code>的对象，它们必须使用<code>CFRetain/CFRelease</code>去处理。</li>
</ul>
<h3 id="在deaclloc中释放引用并清除监听状态"><a href="#在deaclloc中释放引用并清除监听状态" class="headerlink" title="在deaclloc中释放引用并清除监听状态"></a>在deaclloc中释放引用并清除监听状态</h3><p>一个对象走完生命周期后会被释放，那个释放的入口就是<code>dealloc</code>方法。在对象的整个生命周期中，释放只会被调用一次，当对象的引用计数为0时。不过什么时候调用就不知道了。也就是说，你可能通过你手动调用<code>retain</code>或<code>release</code>大概推测出它什么时候调用，但其实这是由系统决定的，它会在你不知道的时候进行释放。你永远不该调用<code>dealloc</code>本身。系统会在运行时在正确时间调用它。而且<code>dealloc</code>被调用后，对象都不再有效，后面的方法也是无效的。</p>
<p>那么你应该在<code>dealloc</code>中做什么呢？主要要做的应该是释放对象的所有持有。这个意思是释放所有的<code>Objective-C</code>对象，ARC会自动帮你添加进<code>dealloc</code>方法，通过自动生成<code>.cxx_destrucr</code>(看第30节)方法。任何非<code>Objective-C</code>也应该在这里释放。例如，<code>CoreFoundation</code>的对象需要释放，因为它是纯C的API。</p>
<p>另一个需要在<code>dealloc</code>中做的事情是清除所有的观察者行为。如果有对象注册了通知者，那么这里是一个移除通知的好地方。这样就不会向这个对象发送通知了，否则会导致应用程序崩溃。</p>
<p>一个<code>dealloc</code>方法大概像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">   </div><div class="line">    CFRelease(coreFoundationObject);</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意当你使用MRC而不是ARC时，你应该在这些方法后面调用<code>[super dealloc]</code>。ARC会自动在后面调用，这也是一个ARC比MRC安全简单的原因。并且使用MRC，你不得不讲每个需要释放的<code>Objective-C</code>对象添加进来。</p>
<p>即便如此，你不应该在这里释放开销较大或者系统的稀缺资源。例如文件描述符，套接字，大块内存。你不应该依赖<code>dealloc</code>方法去释放这些对象，因为有时候别的东西也会持有这些对象。这样会造成你不需要某个系统稀缺资源，但是却还在持有它，这是不合理的。通常的做法是当程序不再使用它时，实现别的办法进行释放。这样资源的声明周期就是明确的了。</p>
<p>比如一个管理套接字链接的对象，它需要有清理的方法。或许是一个数据库链接。这样类的接口大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCServerConnection : NSObject</div><div class="line"></div><div class="line">- (void)open:(NSString*)address;</div><div class="line">- (void)close;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当需要使用时，可以调用<code>open</code>方法打开链接；当链接结束时，可以调用<code>close</code>方法。<code>close</code>方法一定要在链接对象释放前调用；否则，会被认为是一个项目错误，就像你不得不使用<code>retain</code>和<code>release</code>去平衡引用计数一样。</p>
<p>另一个在别的清理方法释放资源的理由是实际上对象的<code>dealloc</code>方法不一定会被调用。边界情况下，当程序意外退出时，对象可能仍然存在。这些对象没有接收到释放信息。相应的，当系统终止后，它们占用的资源也会返回给系统。所以不调用<code>dealloc</code>方法也是一种优化。这也说明不是每个对象都会调用释放方法的。在Mac OS X和iOS中都有一个应用的协议方法，当程序结束时会调用。这个方法可以被用来清理某些必须要清理的对象。</p>
<p>在Mac OS X中，程序结束会调用的协议方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillTerminate:(NSNotification *)notification;</div></pre></td></tr></table></figure>
<p>在iOS中，程序结束会调用的协议方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillTerminate:(UIApplication *)application;</div></pre></td></tr></table></figure>
<p>如果对象管理着某些资源，那么在<code>dealloc</code>中也应该调用它们的清理方法，以减少意外情况。如果有意外情况发生，那么有一个好办法是，输出一句信息去指明程序发生了一个错误。这是一个编程错误，因为这个关闭方法需要在对象释放前调用；否则，这个方法就不会有效果了。输出信息会警告开发者改正这个问题。在<code>dealloc</code>中去关闭资源依然是一个避免内存泄漏的好习惯。下面有一个这样的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)close &#123;</div><div class="line">    </div><div class="line">    /* clean up resources */</div><div class="line">    _closed = YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    if (!_closed) &#123;</div><div class="line">       </div><div class="line">        NSLog(@&quot;ERROR: close was not called before dealloc!&quot;);</div><div class="line">        [self close];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果关闭方法没有调用，那么相比输出一个错误，你应该去抛出一个异常指出程序发生了一个严重的错误。另外就是要避免在<code>dealloc</code>方法中调用别的对象。在上面的例子中，在<code>dealloc</code>中调用了一个方法。但那是一个特殊情况：去查明程序错误。无论在这里调用什么方法都不太合适，因为这里的对象已经接近尾声了。如果别的方法还会异步执行任务或者调用它们自己的方法，等到对象执行完任务，对象早被释放了。这会导致很多问题并且可能导致程序崩溃，因为它们会回调告诉对象任务执行完了。如果对象早已被释放，那么就会发生错误。</p>
<p>另外，调用释放方法的线程会进行最终释放，使所有对象的引用计数为0。有些方法需要运行在特定的线程，例如主线程。如果在<code>dealloc</code>中调用它们，无法保证它们运行在正确的线程。没有什么常规代码可以保证它们安全的运行在正确的线程，因为对象已经处于释放状态了，并且运行时已经对内部的数据结构进行释放标示了。</p>
<p>也应该避免在<code>dealloc</code>中调用属性存取器，因为它们可以被覆盖并且去执行一些在释放期不安全的操作。比如，某个对象可能通过KVO监听属性，并且监听者想去做一些事情，例如试图保留对象，或使用这个将被回收的对象。这样做会导致在运行期出现一些莫名错误，并可能导致程序崩溃。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dealloc</code>方法里面只应该被用来释放对象以及取消注册，例如KVO或者NSNotificationCenter通知。</li>
<li>如果一个对象持有系统资源，例如文件标示符，那么应该有一个方法去释放资源。当资源使用结束时，类的使用者应该调用关闭方法。</li>
<li>避免在<code>dealloc</code>方法中调用执行异步操作的方法或者只能正常状态执行的方法。</li>
</ul>
<h3 id="小心异常安全代码的内存管理"><a href="#小心异常安全代码的内存管理" class="headerlink" title="小心异常安全代码的内存管理"></a>小心异常安全代码的内存管理</h3><p>现代语言中，异常是一个常见的语言功能。C中不存在异常，但<code>C++</code>和<code>Objective-C</code>中存在异常。实际上，在当前的运行时系统中，<code>C++</code>和<code>Objective-C</code>的异常都是通用的，这意味着一个语言抛出的异常可以被另一个语言捕获。</p>
<p><code>Objective-C</code>的错误模型表示只有发生致命错误时才应该使用异常，你可能仍需要错误代码去捕获并处理异常。比如使用<code>Objective-C++</code>或者不受你控制的第三方库代码时，应该捕获异常。而且，有些系统库仍在使用异常，仿佛回到了异常频繁使用的年代。例如，如果你想去取消一个尚未注册的观察者，那么KVO就会抛出一个异常。</p>
<p>当异常发生时会带来一个内存管理问题。在<code>try</code>块里面，如果保留了一个对象，然后再对象释放前抛出了异常，那么对象将会发生泄漏除非在<code>catch</code>块中进行处理。C++的析构函数由<code>Objective-C</code>的异常处理来运行。这对于C++是非常重要的，因为这会缩短对象的声明周期，所以抛出异常时要调用析构函数；否则，对象内存将会泄露，特别是别的系统资源，例如文件权柄，是更容易泄露的。</p>
<p>异常处理机制会自动销毁对象，不过在MRC环境下处理对象销毁有些麻烦。考虑下面的<code>Objective-C</code>代码，它是在MRC下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">    EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">    [object release];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>乍看起来，它似乎是正确的。但是如果<code>doSomethingThatMayThrow</code>方法抛出异常呢？下面一行的释放代码将不会运行，因为异常会直接跳入<code>catch</code>块。所以当抛出异常时，这个对象将会泄露。这不是一个好主意。使用<code>@finally</code>块可以解决这个问题，不论是否抛出异常，<code>@finally</code>块一定会运行也只会运行一次。例如，代码将会转换成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">EOCSomeClass *object;</div><div class="line">@try &#123;</div><div class="line">    object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div><div class="line">@finally &#123;</div><div class="line">    [object release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对象是在<code>@try</code>块之外声明的，因为需要在<code>@finally</code>块中使用它。如果所有的对象都需要释放那是非常单调的。而且，如果这里的逻辑更加复杂，<code>@try</code>块内状态更多，那么是非常容易忽略释放的，从而导致潜在的泄露风险。如果一个稀缺资源的对象泄露，例如文件标示符或者数据库连接，那么这个泄露就是灾难性的，因为最后应用程序占用的所有的系统资源都不会释放。</p>
<p>在ARC下，这种情况会更加严重。下面是与之等价的ARC环境下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">    EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在问题更严重了；你不能将释放放在<code>@finally</code>的块内了，因为不能调用<code>release</code>了。你可能会认为ARC已经处理了这种情况。默认情况下并没有做；因为这样做需要给对象添加大量模板代码，当有异常抛出时追踪对象清理。当抛出异常时，这段代码会严重影响性能。这段额外的代码也会增加应用程序的大小。总之这不是一个好的建议。</p>
<p>虽然默认状态下未开启，但是ARC支持这种异常安全机制。你可以在编译器中使用<code>-fobjc-arc-exceptions</code>开启。其默认不开启的原因是<code>Objective-C</code>定义异常应该只在该异常会导致应用重大错误时抛出(看第21节)。因此，如果应用程序将要终结，那么潜在的内存泄露就无所谓了。所以在应用程序将要终结时添加安全代码是没有什么意义的。</p>
<p>当编译器处于<code>Objective-C++</code>模式时，会自动打开这个<code>-fobjc-arc-exceptions</code>标示。因为C++的异常处理代码在ARC下与<code>Objective-C</code>的额外异常安全代码类似，所以在ARC下自动开启这些代码对性能影响并不大。而且，C++代码用的太多，<code>Objective-C</code>开发者可能也想使用异常处理。</p>
<p>如果你在MRC下开发并且一定要捕捉异常，那么一定记得正确的清理你的代码。如果你在ARC下开发并且一定要捕捉异常，那么你需要开启<code>-fobjc-arc-exceptions</code>标示符。但最重要的是，如果你发现你使用了大量的异常捕捉，那么考虑使用<code>NSError-style</code>重构代替，如第21节展示的一样。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果捕捉了异常，一定要将在<code>@try</code>块中的代码处理干净。</li>
<li>默认情况下，在异常发生时ARC并不会处理干净代码。你可以通过一个编译器标示符开启它，但这会使得代码包变大和运行时花费变大。</li>
</ul>
<h3 id="使用弱引用避免循环引用"><a href="#使用弱引用避免循环引用" class="headerlink" title="使用弱引用避免循环引用"></a>使用弱引用避免循环引用</h3><p>在对象表中会有一种典型的情况，那就是每个对象都持有对方的引用。当它发生在引用计数模型下时，例如<code>Objective-C</code>的内存管理模型，那么某个地方肯定会发生内存泄露，因为最后没有对象持有循环的对象的引用。因此，没有对象可以访问循环引用，循环引用中的对象也不会被释放，因为它们相互持有保证对方的存活。</p>
<p>在最简单的循环引用中，两个对象互相持有。图5.4展示了一个例子。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.4.png" alt=""><br><strong>Figure 5.4</strong> 两个互相持有强引用的对象构成了循环引用。</p>
<p>循环引用是非常容易理解的并且也可以通过看代码找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCClassA;</div><div class="line">@class EOCClassB;</div><div class="line"></div><div class="line">@interface EOCClassA : NSObject</div><div class="line">@property (nonatomic, strong) EOCClassB *other;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCClassB : NSObject</div><div class="line">@property (nonatomic, strong) EOCClassA *other;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>从代码可以轻易的看出来这个潜在的循环引用；如果将<code>EOCClassA</code>中属性设置为<code>EOCClassB</code>的实例变量，将<code>EOCClassB</code>的属性设置为<code>EOCClassA</code>的实例变量，那么就会发生像图5.4那样的循环引用。</p>
<p>循环引用的结果肯定是内存泄露。当对循环引用中对象的最后一个引用移除时，就会发生内存泄露。这意味着没有对象可以访问它们。在图5.5当<code>ObjectB</code>对象的最后一个引用被移除时，一个涉及四个对象的复杂循环引用就产生了。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.5.png" alt=""><br><strong>Figure 5.5</strong> 当对象表中的循环引用的对象的最后引用被移除，循环引用就会发生内存泄露</p>
<p>在MAC OS X上有个选项可以使用垃圾回收机制，垃圾回收机制会找到循环引用的地方并且清理掉没有任何引用的循环引用。但是垃圾回收机制在MAC OS X 10.8被废弃了，在iOS上更是没存在过。因此，在写代码时，需要注意这个循环引用问题并确保它不会发生。</p>
<p>最好的避免循环引用的办法是使用弱引用。这样引用的一方总是非持有关系。通过<code>unsafe_unretained</code>特质也能达到这个效果。下面的例子中使用了这个特质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCClassA;</div><div class="line">@class EOCClassB;</div><div class="line"></div><div class="line">@interface EOCClassA : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) EOCClassB *other;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCClassB : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, unsafe_unretained) EOCClassA *other;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这里，<code>EOCClassB</code>的<code>other</code>属性不会持有<code>EOCClassA</code>实例变量。这个叫做<code>unsafe_unretained</code>的特质指明属性是不安全的并且不会保留对象。如果设置的对象已经被释放了，那么调用它会导致程序崩溃。因为该属性不会保留对象，所以对象有可能被释放。</p>
<p><code>unsafe_unretained</code>特质与<code>assign</code>特质语义相同。但是，<code>assign</code>通常用在基础类型(int, float, structs, etc.)，<code>unsafe_unretained</code>用于对象类型。这个特质本身就表明对象可能无法安全使用。</p>
<p>不过ARC给<code>Objective-C</code>打来了一项功能那就是可以使用安全的弱引用：一个叫做<code>weak</code>的属性特质，它的作用跟<code>unsafe_unretained</code>相同。但是当对象释放时，它会自动将属性设置为nil。在上面的例子中，可以这样修改<code>EOCClassB</code>的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) EOCClassA *other;</div></pre></td></tr></table></figure>
<p>图5.6展示了<code>unsafe_unretained</code>和<code>weak</code>的不同之处。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.6.png" alt=""><br><strong>Figure 5.6</strong> 当属性指向的对象释放时，<code>unsafe_unretained</code>和<code>weak</code>的不同之处</p>
<p>当使用<code>unsafe_unretained</code>时，<code>EOCClassB</code>的<code>other</code>属性仍然指向一个已经释放的对象；当使用<code>weak</code>时，<code>EOCClassB</code>的<code>other</code>属性将会指向nil。</p>
<p>但是，使用<code>weak</code>特质不应成为你偷懒的借口。在上面的例子中，当<code>EOCClassA</code>的对象释放后，如果<code>EOCClassB</code>属性仍然指向它，那是一个编程错误。如果发生了这种事情，那就是一个bug。你应该确保这种情况不会发生。但是使用<code>weak</code>特质比使用<code>unsafe_unretained</code>特质安全是肯定的。相对比应用崩溃，应用可能更能接受展示错误的数据。这么做无疑对终端用户更好。但是，在所指对象销毁后，仍使用弱引用，那仍是一个bug。例如有一个用户界面，它有一个属性持有数据源对象，用户界面需要展示数据。假如这样一个属性是弱引用。如果数据源在元素展示之前被释放，那么弱引用意味着虽然不会崩溃但用户界面不会显示任何数据。</p>
<p>通常的规则是如果你不持有一个对象，那么就不要保留它。但是有个例外，那就是集合，集合类虽然不直接持有内容，但它要它所属的对象来保留这些元素。有一个例子，对象的引用会指向自己并不拥有的对象，比如委托模式。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>可以通过使用<code>weak</code>避免循环引用。</li>
<li>弱引用可能会也可能不会自动清空。自动清空是由ARC带来的一个在运行期实现的新功能。自动清空的弱引用是安全的，它永远不会引用一个已经释放的对象。</li>
</ul>
<h3 id="使用自动释放池降低高峰内存值"><a href="#使用自动释放池降低高峰内存值" class="headerlink" title="使用自动释放池降低高峰内存值"></a>使用自动释放池降低高峰内存值</h3><p><code>Objective-C</code>对象的存活是受到引用计数(看第29节)控制的。<code>Objective-C</code>的引用计数体系中的一个功能被称作自动释放吃。释放一个对象要么通过调用<code>releas</code>直接减少引用计数，要么通过调用<code>autorelease</code>添加一个自动释放池。一个自动释放池实际上是一个集合对象，它会在将来某个时刻进行释放。当一个自动释放池释放时，自动释放池内所有的对象立即发送<code>release</code>消息。</p>
<p>创建一个自动释放池的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这里没有自动自释放池，当对象发送<code>autorelease</code>消息时，你将会看下类似下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Object 0xabcd0123 of class __NSCFString autoreleased</div><div class="line">with no pool in place - just leaking - break on objc_</div><div class="line">autoreleaseNoPool() to debug</div></pre></td></tr></table></figure>
<p>但是你通常不需要担心这个事。因为一个运行在Mac OS X或者iOS上的应用程序，它们都是处于Cocoa(或者Cocoa Touch)环境。系统都会给你创建一些线程，例如主线程或者GCD机制中的线程，每个线程都会有一个自动释放池，每次事件循环它们都会被清空。因此，你不需要创建自动释放池块。通常，你在应用程序的入口，即<code>main</code>函数那里会看到一个自动释放池包裹了整个应用程序。例如，一个iOS应用的<code>main</code>函数通常是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从技术上讲，这个自动释放池不是必须的。只有在程序中止的时候，整个操作系统才需要释放所有的内存。但是没有它，<code>UIApplicationMain</code>自动释放的对象就没有自动释放池可以放置了，然后会输出一个警告信息。所以这个自动释放池就是最外围用来捕捉自动释放对象的池。</p>
<p>大括号定义了自动释放池的作用范围。在第一个大括号创建自动释放池，在超出作用域后自动释放。因此任何在这个池中的对象都会在最后发送<code>release</code>消息。自动释放池可以嵌套。当一个对象是自动释放时，它会自动添加进最近的自动释放池。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">	NSString *string = [NSString stringWithFormat:@&quot;1 = %i&quot;, 1]; </div><div class="line">	@autoreleasepool &#123;</div><div class="line">		NSNumber *number = [NSNumber numberWithInt:1]; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在前面那个例子中，有两个使用工厂方法创建的对象，它们会自动释放(看第30节)。那个字符串对象将会被加入外层的自动释放池，数值对象将会被加入内层的释放池。嵌套自动释放池可以带来优势，那就是可以控制应用程序的峰值内存不会过高。</p>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; 100000; i++) &#123; </div><div class="line">	[self doSomethingWithInt:i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>doSomethingWithInt:</code>方法创建了很多临时对象，它们将会加入自动释放池。例如，那些对象可能是字符串。即使你不在后面使用它们，这些对象仍旧存活，因为它们在自动释放池内，准备释放并回收。但是自动释放池不到下一次事件循环不会释放。这意味着在这次事件循环中，会有越来越多的对象被创建并加入自动释放池。直到最后，事件循环结束，它才会被释放。但是这样在事件循环期间，应用程序的内存肯定会暴增并在最后释放的时候内存暴减。</p>
<p>这种情况是不好的，特别是如果这个事件循环的长度不固定，取决于用户输入。例如，下面从数据库获取集合对象。代码可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *databaseRecords = /* ... */; </div><div class="line">NSMutableArray *people = [NSMutableArray new]; </div><div class="line">for (NSDictionary *record in databaseRecords) &#123;</div><div class="line">	EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class="line">	[people addObject:person]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>EOCPerson</code>类可能会创建非常多的临时对象，就像刚才那个例子。如果数据库记录是庞大的，那么就会有大量的临时对象一直存活，而它们本应被早收回的。可以在这里增加一个自动释放池帮助提前回收。如果在循环内部包裹一个自动释放池块，那么任何自动释放的对象都是在超出这个池作用域时释放而不是主线程的自动释放池。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *databaseRecords = /* ... */; </div><div class="line">NSMutableArray *people = [NSMutableArray new]; </div><div class="line">for (NSDictionary *record in databaseRecords) &#123;</div><div class="line">	@autoreleasepool &#123; </div><div class="line">		EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; </div><div class="line">		[people addObject:person];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加了新的自动释放池后，应用程序的内存峰值会一直持续在稳定的水平。内存峰值是指应用程序某个时间段内的最大使用内存。添加自动释放池可以降低这个峰值，因为它会在块结束时释放某些对象。这些临时对象就是需要释放的一部分。</p>
<p>可以把自动释放池比喻成栈。当一个自动释放池被创建，它被推入栈；当它释放时，它从栈中弹出。当一个对象是自动释放时，它自动被放入栈顶的自动释放池。</p>
<p>是否添加自动释放池优化取决于你的应用程序。首先监视内存的峰值然后再决定是否需要使用自动释放池。虽然自动释放池消耗不大，但还是有消耗的，所以如果不需要使用，就避免创建自动释放池。</p>
<p>如果你是一个在ARC出现之前的<code>Objective-C</code>程序员，那么你还记得老式的语法，即使用一个叫做<code>NSAutoreleasePool</code>的对象。这是一个特殊对象，它不同于正常对象，它设计出来就是代表自动释放池的，就像新的块语法一样。这个不是每次for循环都会释放的，它是一个稍重的自动释放池，它通常用在偶尔需要释放的内容上，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSArray *databaseRecords = /* ... */; </div><div class="line">NSMutableArray *people = [NSMutableArray new]; </div><div class="line">int i = 0;</div><div class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; </div><div class="line">for (NSDictionary *record in databaseRecords) &#123;</div><div class="line">	EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class="line">	[people addObject:person];</div><div class="line">	// Drain the pool only every 10 cycles</div><div class="line">	if (++i == 10) &#123; </div><div class="line">		[pool drain];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// Also drain at the end in case the loop is not a multiple of 10</div><div class="line">[pool drain];</div></pre></td></tr></table></figure>
<p>不过这种代码风格不再需要了。使用新的语法，ARC带来的更轻量级的自动释放池。所以如果你有代码需要在循环内部释放，你可以使用自动释放池块去包括那部分代码，这样每次循环都会自动创建并清空自动释放池。</p>
<p><code>@autoreleasepool</code>语法还有一个好处就是它有自己的作用域，这样可以帮助你避免使用那些已经被自动释放的对象。例如，考虑下面的代码风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; </div><div class="line">id object = [self createObject];</div><div class="line">[pool drain];</div><div class="line">[self useObject:object];</div></pre></td></tr></table></figure>
<p>这略微夸大了问题，但是它确实存在。<code>useObject:</code>可能会调用一个释放过的对象。但是，相同点在新样式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">	id object = [self createObject];</div><div class="line">&#125;</div><div class="line">[self useObject:object];</div></pre></td></tr></table></figure>
<p>这样的代码是无法通过编译的，因为对象变量在作用域外是无效的，所以<code>useObject:</code>不能使用它。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>自动释放池排在栈中，当对象发送<code>autorelease</code>消息时，自动将他加入栈顶层的自动释放池。</li>
<li>正确的使用自动释放池可以帮助降低应用程序的内存峰值。</li>
<li>现在的自动释放池使用新的<code>@autoreleasepool</code>语法。</li>
</ul>
<h3 id="使用僵尸对象调试内存管理问题"><a href="#使用僵尸对象调试内存管理问题" class="headerlink" title="使用僵尸对象调试内存管理问题"></a>使用僵尸对象调试内存管理问题</h3><p>一直以来，调式内存问题都是麻烦的。向一个已经释放的对象发送消息是不安全的，这点跟我们所想是一样的。但是有时候它会正常工作，有时候它不会。这取决于那块内存是否已经被覆写了。这块内存是否被用来做其它事情呢，又无法确定，所以偶尔会发生崩溃。有时，那块内存仅有一部分被覆写，所以还有部分二进制有效。还有一种可能，就是覆写这块内存区域的是一个有效对象。这时，运行时会把消息传递给新对象，它能或者不能响应这个消息。如果能响应消息，应用不会崩溃，但是你会想为什么收到消息的不是想象中的那个呢？如果它不能响应消息，那么应用依旧会崩溃。</p>
<p>幸运的是，Cocoa的僵尸对象功能可以处理这些情况。当在调试功能打开时，运行时会将所有被销毁实例转换成一个特殊的僵尸对象而不是销毁它们。这种对象的内存不会被回收，因为也就不会被覆写。当僵尸对象收到消息时，它会抛出一个异常，并说明发送消息的对象以及转换僵尸对象前的对象。使用僵尸对象是调式内存管理问题的最佳办法。</p>
<p>这项功能是通过设置<code>NSZombieEnabled</code>环境变量为YES使用的。例如，如果你使用脚本并且在Mac OS X上运行它，你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NSZombieEnabled=&quot;YES&quot; </div><div class="line">./app</div></pre></td></tr></table></figure>
<p>当给僵尸对象发送消息时，将会在控制台输出一条消息，并且应用程序会终止。这条消息看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** -[CFString respondsToSelector:]: message sent to </div><div class="line">deallocated instance 0x7ff9e9c080e0</div></pre></td></tr></table></figure>
<p>你也可以在Xcode中设置这个环境变量，当你从Xcode运行时，它会自动读取。为了这样做，你需要编译应用程序的<code>scheme</code>，选择<code>Run</code>配置，然后点击<code>Diagnostics</code>标签，最后打开<code>Enable Zombie Objects</code>。图5.7展示了Xcode的设置界面，以及打开僵尸对象的选项。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%205.7.png" alt=""><br><strong>Figure 5.7</strong> 在Xcode的scheme编辑器中打开僵尸对象</p>
<p>那么僵尸对象是如何工作的呢？它实现在<code>Objective-C</code>运行期、<code>Foundation</code>、<code>CoreFoundation</code>框架的底层。当一个对象被释放时，如果这个功能开启了，就会多一步操作。多出来的一步就是将对象转化为一个僵尸对象而不是直接释放。</p>
<p>去看多出来的一步做了什么，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt; </div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line">@end</div><div class="line"></div><div class="line">void PrintClassInfo(id obj) &#123;</div><div class="line"> </div><div class="line">    Class cls = object_getClass(obj);</div><div class="line">    Class superCls = class_getSuperclass(cls);</div><div class="line">    NSLog(@&quot;=== %s : %s ===&quot;, class_getName(cls), class_getName(superCls));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">    </div><div class="line">    EOCClass *obj = [[EOCClass alloc] init];</div><div class="line">    NSLog(@&quot;Before release:&quot;);</div><div class="line">    PrintClassInfo(obj);</div><div class="line">    [obj release];</div><div class="line">    NSLog(@&quot;After release:&quot;);</div><div class="line">    PrintClassInfo(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码使用MRC是的更容易看清对象如何转化为僵尸对象。ARC会使<code>obj</code>对象尽可能的长时间存活，意味着这个简单的例子不会转化为僵尸对象。这意思不是说在ARC下对象不会转化为僵尸对象。使用ARC这个内存bug依然存在，只不过需要更复杂的代码才能表现出来。</p>
<p>上述例子中有一个函数用来输出给定对象的类和父类的名字。代码使用了<code>object_getClass()</code>方法，这是一个运行时函数，而不是给类发送<code>Objective-C</code>消息。如果那个对象是一个僵尸对象，发送任何<code>Objective-C</code>消息都会导致打印错误信息，并使得应用崩溃。上述代码的输出像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Before release:</div><div class="line">=== EOCClass : NSObject === </div><div class="line">After release:</div><div class="line">=== _NSZombie_EOCClass : nil ===</div></pre></td></tr></table></figure>
<p>对象的类从<code>EOCClass</code>变为<code>_NSZombie_EOCClass</code>了。但是这个类从哪里来的呢？代码里面没有定义这个类啊。而且，在启用僵尸对象功能后，编译器给每个类创建一个额外的类那效率也太低了。这个类是在运行时第一个<code>EOCClass</code>对象转变为僵尸对象时生成的。它使用了运行时函数，用来操作类列表。</p>
<p>僵尸类是从一个叫做<code>_NSZombie_</code>的模板类复制的。僵尸类并不做太多的事请，它仅仅是作为一个标记。你将会看到它如何做为一个标记的。首先看下面的伪代码，它展示了如何如何根据需要创建僵尸类并将对象转化为僵尸对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// Obtain the class of the object being deallocated</div><div class="line">Class cls = object_getClass(self); </div><div class="line"></div><div class="line">// Get the class&apos;s name</div><div class="line">const char *clsName = class_getName(cls); </div><div class="line"></div><div class="line">// Prepend _NSZombie_ to the class name</div><div class="line">const char *zombieClsName = &quot;_NSZombie_&quot; + clsName; </div><div class="line"></div><div class="line">// See if the specific zombie class exists</div><div class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</div><div class="line"></div><div class="line">// If the specific zombie class doesn&apos;t exist, </div><div class="line">// then it needs to be created</div><div class="line">if (!zombieCls) &#123;</div><div class="line">	// Obtain the template zombie class called _NSZombie_</div><div class="line">	Class baseZombieCls = objc_lookUpClass(&quot;_NSZombie_&quot;);</div><div class="line">	</div><div class="line">	// Duplicate the base zombie class, where the new class&apos;s </div><div class="line">	// name is the prepended string from above</div><div class="line">	zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0);</div><div class="line">	// Perform normal destruction of the object being deallocated</div><div class="line">&#125;</div><div class="line"></div><div class="line">objc_destructInstance(self);</div><div class="line"></div><div class="line">// Set the class of the object being deallocated </div><div class="line">// to the zombie class</div><div class="line">objc_setClass(self, zombieCls);</div><div class="line">// The class of &apos;self&apos; is now _NSZombie_OriginalClass</div></pre></td></tr></table></figure>
<p>这个过程发生在<code>NSObject</code>对象的<code>dealloc</code>方法中。当<code>NSZombieEnabled</code>环境开启时，运行时会交换(看第13节)<code>dealloc</code>方法的实现和前面的代码实现。在这个过程的最后，对象的类已经变为<code>_NSZombie_OriginalClass</code>类了，其中<code>OriginalClass</code>是它本来类的类名。</p>
<p>重要的是，这个对象的内存并没有被释放。因此，这块内存不会被再次使用。尽管它发生了内存泄露，但它是一个调试工具并且不会将其发布在正式包中，所以不要在意这个。</p>
<p>但是系统为什么会为每一个僵尸对象创建一个新类呢？这样做是因为当给僵尸对象发送消息时，可以确定它原来的类是什么。如果所有对象的类都是<code>_NSZombie_</code>，那么原来类的名字就不知道了。通过运行时的<code>objc_duplicateClass()</code>函数创建一个新类，拷贝整个僵尸类然后给一个新的名字。它的父类，实例变量，方法都跟原来一模一样。另一个方法是通过继承<code>_NSZombie_</code>类创建一个新类而不是拷贝它。但是使用相应函数时，它的效率没有直接拷贝的高。</p>
<p>僵尸类的作用体现在消息转发机制(看第12节)中。<code>_NSZombie_</code>类不实现任何方法。它也不需要任何父类，因此它自身就是一个根类，就像<code>NSObject</code>一样，只有一个叫做isa的实例变量，它是所有<code>Objective-C</code>根类都要有的。这个轻量级的类不实现任何方法，所以所有发送给它的消息都会走完整的消息转发机制。</p>
<p>消息转发机制的核心是<code>___forwarding___</code>，你可能在调式的时候通过栈回溯看到过它。它要做的第一件事就是检查接受消息的类的名字。如果名字前缀是<code>_NSZombie_</code>，那么就肯定它是一个僵尸对象，那么就会特殊处理。应用程序会在这里终止，然后打印一条消息指出接受消息的类的类型。这时就可以看出来在僵尸类命中加入原类名的好处了。将<code>_NSZombie_</code>从僵尸类名中移除就是原来类的名字了。下面的伪代码展示了发生的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Obtain the object&apos;s class</div><div class="line">Class cls = object_getClass(self); </div><div class="line">// Get the class&apos;s name</div><div class="line">const char *clsName = class_getName(cls);</div><div class="line">// Check if the class is prefixed with _NSZombie_</div><div class="line">if (string_has_prefix(clsName, &quot;_NSZombie_&quot;) &#123;</div><div class="line">	 // If so, this object is a zombie</div><div class="line">	// Get the original class name by skipping past the</div><div class="line">	// _NSZombie_, i.e. taking the substring from character 10 </div><div class="line">	const char *originalClsName = substring_from(clsName, 10);</div><div class="line">	// Get the selector name of the message</div><div class="line">	const char *selectorName = sel_getName(_cmd);</div><div class="line">	// Log a message to indicate which selector is</div><div class="line">	// being sent to which zombie</div><div class="line">	Log(&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;, originalClsName, selectorName, self);</div><div class="line">	// Kill the application</div><div class="line">	abort(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尝试给开头的那个例子进行扩展，给将是对象发送消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EOCClass *obj = [[EOCClass alloc] init]; </div><div class="line">NSLog(@&quot;Before release:&quot;); </div><div class="line">PrintClassInfo(obj);</div><div class="line">[obj release]; </div><div class="line">NSLog(@&quot;After release:&quot;); </div><div class="line">PrintClassInfo(obj);</div><div class="line">NSString *desc = [obj description];</div></pre></td></tr></table></figure>
<p>如果僵尸对象开启了，你将会看到下面的输出信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Before release:</div><div class="line">=== EOCClass : NSObject ===</div><div class="line">After release:</div><div class="line">=== _NSZombie_EOCClass : nil ===</div><div class="line">*** -[EOCClass description]: message sent to deallocated instance 0x7fc821c02a00</div></pre></td></tr></table></figure>
<p>如你所见，上面的信息清楚的展示了选择器已经对象的原来类，也指出了已释放的消息接受对象的指针值。如果你在做功能调试，这个信息是非常有用的，如果与合适的工具配合使用，例如Instruments，那会有更好的效果。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>当一个对象释放时，它可以转化为一个僵尸对象而不用释放。这个功能仅能通过<code>NSZombieEnabled</code>环境变量开启。</li>
<li>对象转换为僵尸对象是通过更改它的isa指针值去指向特殊僵尸类。僵尸类可以响应所有发给僵尸对象的消息，然后会打印一条信息，程序终止。</li>
</ul>
<h3 id="避免使用retainCount"><a href="#避免使用retainCount" class="headerlink" title="避免使用retainCount"></a>避免使用retainCount</h3><p><code>Objective-C</code>使用引用技术去管理内存(看第29节)。每个对象都有一个计数器去确定有多少别的事物希望它保持存活。当一个对象呗创建，它的引用计数一样大于0。<code>retain</code>和<code>release</code>会使引用计数增加或减少。当引用计数为0时，对象被释放销毁。</p>
<p><code>NSObject</code>的协议定义了一个方法允许你获取某个对象当前的引用计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)retainCount</div></pre></td></tr></table></figure>
<p>但是，ARC已经废弃了这个方法。实际上，在ARC下，如果你试图调用它，编译器将会抛出一个错误，就像<code>retain、release、autorelease</code>这些方法一样。即使官方已经废弃了它，但还是有人无解它，并且应该避免使用它。如果你不使用ARC，你仍然可以使用它，并且没有编译器错误。所以理解为什么要避免使用这个方法是非常重要的。</p>
<p>这个方法看起来很有用的。因为它返回了引用计数，毕竟这个属性对每个对象都是很重要的。但个问题就在于，引用计数通常与开发者所应关注的没什么关系。即使你只是在调试环境下使用，它也不是有帮助的。</p>
<p>避免使用的主要原因是这个方法返回的值引用计数是在某个时间的值。因为这个值不包含将要减去的引用计数，例如在一个自动释放池中，这个值并不能真的代表引用计数。因此，下面的代码是有问题的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while ([object retainCount]) &#123; </div><div class="line">	[object release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这代码的第一个错误点在于它没有考虑可能有自动释放的情况，只是一直减少引用计数直到释放为止。如果对象处于一个自动释放池，这时自动释放池释放了，那么这个对象也会释放，那么肯定会崩溃了。</p>
<p>其次，这代码是危险的，因为<code>retainCount</code>永远不会返回0；因为有时系统会对对象释放行为进行优化，意思是当它释放时，如果它的引用计数是1，会直接执行销毁。否则，才会减少引用计数并销毁。因此，引用计数永远不会是1。不幸的是，即使这种代码有时能正常运行，那也是运气大于判断。当对象回收后，如果while循环还在运行，那么现代运行时很可能直接让其崩溃。</p>
<p>这样的代码不该使用。这样的代码实现的应该交由内存管理去处理。当你想让某个对象释放时，你应该确保它在该处已经达到引用计数平衡了。如果没有释放，应该查明是否有引用计数未平衡并且查明为什么没释放。</p>
<p>你可能尝试使用<code>retainCount</code>并且疑惑为什么返回值有时候非常巨大。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;Some string&quot;;</div><div class="line">NSLog(@&quot;string retainCount = %lu&quot;, [string retainCount]);</div><div class="line">NSNumber *numberI = @1;</div><div class="line">NSLog(@&quot;numberI retainCount = %lu&quot;, [number retainCount]);</div><div class="line">NSNumber *numberF = @3.141f;</div><div class="line">NSLog(@&quot;numberF retainCount = %lu&quot;, [numberFloat retainCount]);</div></pre></td></tr></table></figure>
<p>在64位Mac OS X 10.8.2，使用Clang 4.1编译，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string retainCount = 18446744073709551615 </div><div class="line">numberI retainCount = 9223372036854775807 </div><div class="line">numberF retainCount = 1</div></pre></td></tr></table></figure>
<p>第一个值是2^64 - 1，第二个值是2^63 - 1。对象的引用计数为什么这么大，因为它们代表了单一对象。如果可以，系统会将字符串实现为单一对象的。如果像本例一样，字符串是一个编译期常量。在这种情况下，编译器会制作一个特殊的对象，代替<code>NSString</code>对象在二进制文件中的位置，并在运行时使用常量代替它。在这种设计下，<code>NSNumber</code>也是类似的对象；指针包含了所有的数字信息。运行时系统会在消息转发时发现这个标签，并对其做相应操作，使其行为和一个真正的<code>NSNumber</code>对象一样。这种优化仅使用这种特定的值，比如例子中的浮点数值就没有做这种优化，它的引用计数就是1。</p>
<p>另外，这种单一对象的引用计数永远不会发生改变。保留和释放都是空操作。即使两个单一对象，它们的引用计数值也不一样，系统借此指出，不要考虑使用引用计数作什么。如果你更改<code>NSNumber</code>对象的引用计数，当它是一个标签指针时，那么代码就会发生错误。</p>
<p>那么，你只想用<code>retainCount</code>去调试呢？即使这样，它也没什么用。这个值可能没你想的那么精确，就像它处于自动释放池中。而且，其他库也可能去释放或者保留对象。如果你检查引用计数，你可能以为自己错了，因为可能有其余库修改了它的引用计数啊。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id object = [self createObject];</div><div class="line">[opaqueObject doSomethingWithObject:object];</div><div class="line">NSLog(@&quot;retainCount = %lu&quot;, [object retainCount]);</div></pre></td></tr></table></figure>
<p>它的引用计数是多少？可以是任何值吧。<code>doSomethingWithObject:</code>方法里面集合可能添加了这个对象，增加引用计数。或者可能多次保留对象并自动释放它，其中的某些自动释放池可能稍后才会清空。所以这引用计数没你想的那样有用。</p>
<p>你什么时候可以使用引用计数？最好的答案是：永远不用，尤其是苹果在引入ARC后已经将其废弃。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul>
<li>引用计数看似有用，实则无用，因为任何时间点，绝对引用计数都无法代表对象的完整生命面貌。</li>
<li>当在ARC环境下时，<code>retainCount</code>方法被废弃，如果使用它还会导致编译器报错。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第五章：内存管理&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第四章</title>
    <link href="http://yoursite.com/2017/06/19/Protocols%20and%20Categories/"/>
    <id>http://yoursite.com/2017/06/19/Protocols and Categories/</id>
    <published>2017-06-19T10:08:12.000Z</published>
    <updated>2017-07-01T09:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第四章：协议和分类</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>协议是<code>Objective-C</code>语言的一个功能，类似Java的接口。<code>Objective-C</code>没有多重继承，因此我们把某个类应该实现的方法定义在协议中。协议最多的用法是实现委托模式(看第23节)，<br>但是它也有别的用法。了解并使用它们可以使代码更易于维护，因为这是记录代码接口的好方法。</p>
<p>分类也是<code>Objective-C</code>语言的一个重要功能。它提供了一种给类添加方法而不需要添加子类的机制，而在其他方法中则不行。由于运行时的高度动态性，这一特性成为可能，但它也有一些缺陷，你应该在使用之前了解这些缺陷。</p>
<h3 id="通过委托与数据源协议进行对象间通信"><a href="#通过委托与数据源协议进行对象间通信" class="headerlink" title="通过委托与数据源协议进行对象间通信"></a>通过委托与数据源协议进行对象间通信</h3><p>对象之间经常需要通信。<code>Objective-C</code>开发者都知道一种叫做委托协议的设计模式。它的本质是定义一个接口，使任何遵循这个接口的类成为另一个类的委托(PS:为了便于理解，定义接口的类是委托类，遵循接口的类是被委托类)。当事件发生时，委托类就可以获取一些信息或者告知被委托类。</p>
<p>使用这种模式可以使得数据解耦。例如，一个展示数据列表的类应该只处理数据展示的逻辑，而不需要知道数据的类型或者数据之间的逻辑。这个视图对象应该有某个属性去处理数据和事件。它们各自被称为数据源和委托。</p>
<p>在<code>Objective-C</code>中，实现这种模式的常用方法是使用协议这种语言特性，它被用于整个<code>Cocoa</code>框架。如果你使用了这种功能，你会发现你的代码非常健壮。</p>
<p>例如，有一个类是从网络获取数据的。这个类从远端服务器获得数据。服务器可能需要花费很多时间才会相应，如果一直处在等待中，这是一种坏的体验。所以，通常会使用委托模式，这个网络类会有一个协议对象，并且当数据返回时，回调这个对象。图4.1展示了这个概念；<code>EOCDataModel</code>对象是被委托类，<code>EOCNetworkFetcher</code>是委托类。<code>EOCDataModel</code>让<code>EOCNetworkFetcher</code>执行一个异步任务，当任务执行完毕时，<code>EOCNetworkFetcher</code>调用这个委托。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%204.1.png" alt=""></p>
<p><strong>Figure 4.1</strong> 一次委托回调的流程。注意委托对象并不需要一定是<code>EOCDataModel</code>实例，也可以是另外的实例。</p>
<p>使用<code>Objective-C</code>的协议可以很容易的实现这个模式。像图4.1这种情况，这个协议可能是这样定义的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol EOCNetworkFetcherDelegate</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">        didReceiveData:(NSData*)data;</div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">      didFailWithError:(NSError*)error;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个委托协议的命名通常是类名后面追加<code>delegate</code>，整个名字使用骆驼命名法。给你的委托协议使用这种命名法可以使任何使用者都感到熟悉。</p>
<p>类会使用协议声明一个属性用于存放被委托者。在我们的例子中， 定义属性的类就是<code>EOCNetworkFetcher</code>类。因此，这个类的接口是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line">@property (nonatomic, weak) id &lt;EOCNetworkFetcherDelegate&gt; delegate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>确保这个属性定义为<code>weak</code>而不是<code>strong</code>是非常重要的，因为它必须是非拥有关系。通常情况下，被委托者对象也会持有本对象。例如，一个对象想使用<code>EOCNetworkFetcher</code>，它将会持有<code>EOCNetworkFetcher</code>对象直到用完为止。如果属性使用<code>strong</code>特质持有被委托者对象，那么就会形成循环引用。因此，这个协议属性需要定义成<code>weak</code>或者<code>unsafe_unretained</code>，如果需要在释放时自动情况值，那么需要使用<code>weak</code>，如果不需要释放，那么就使用<code>unsafe_unretained</code>。它们的持有关系如图4.2。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%204.2.png" alt=""></p>
<p><strong>Figure 4.2</strong> 持有关系图展示了不保留<code>delegate</code>属性，可以避免循环引用。</p>
<p>实现委托的办法是声明某个类遵循协议，然后实现任何你想使用的协议方法。你可以在接口文件中声明类遵循的协议，也可以在类扩展(看第27节)中实现。如果你想告诉别人你事先了某个协议那么在接口中实现；但是像委托这种情况，一般都是在类的内部使用。所以它通常像这样被声明在类扩展中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@interface EOCDataModel () &lt;EOCNetworkFetcherDelegate&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCDataModel</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">        didReceiveData:(NSData*)data &#123;</div><div class="line">    /* Handle data */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">      didFailWithError:(NSError*)error &#123;</div><div class="line">    /* Handle error */</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>通常，协议中的方法是可以选择实现的，因为被委托对象可能并不关心所有的方法。在这个例子中，<code>DataModel</code>类可能不关心错误的方法，所以它可能不会实现<code>networkFetcher:didFailWithError:</code>这个方法。为了指明可选方法，通过使用<code>@optional</code>关键字标注大部分或者所有的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@protocol EOCNetworkFetcherDelegate</div><div class="line"></div><div class="line">@optional</div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">        didReceiveData:(NSData*)data;</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">      didFailWithError:(NSError*)error;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果要在通过被委托对象调用可选方法，那么就要判断被委托对象是否能响应这个方法。在<code>EOCNetworkFetcher</code>这个例子中，它可能是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSData *data = /* data obtained from network */;</div><div class="line">if ([_delegate respondsToSelector:</div><div class="line">		@selector(networkFetcher:didReceiveData:)]) &#123;</div><div class="line">    </div><div class="line">    [_delegate networkFetcher:self didReceiveData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>respondsToSelector:</code>这个方法用于确认被委托者是否实现了某个方法。如果实现了，就调用它；如果没实现，什么也不做。这样的话，协议方法就是可选的了，并且不会因为没有实现某个方法而出问题。即使没有设置被委托对象，也是没有问题的，因为给空发送消息将会使得<code>if</code>语句的值为<code>false</code>。</p>
<p>协议中的方法名也是很重要的。方法名应该准确描述当前发生了什么，以及为什么要处理此事件。在这个例子中，协议方法读起来非常清楚，一个存在的<code>EOCNetworkFetcher</code>对象刚刚接收到了一些数据。你应该通过协议方法将被委托对象传递出去，就像上面的例子一样，这样当有特殊情况时可以根据被委托实例进行区分。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data &#123;</div><div class="line">    </div><div class="line">    if (fetcher == _myFetcherA) &#123;</div><div class="line">        /* Handle data */</div><div class="line">    &#125; else if (fetcher == _myFetcherB) &#123;</div><div class="line">        /* Handle data */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个被委托实例，所以要区分到底哪个实例接受了数据。如果没有传入被委托实例，那么同一时间只能处理一个网络请求，这样不是很好。</p>
<p>协议方法也可以用来从被委托者中获取消息。例如，<code>EOCNetworkFetcher</code>类可能想提供这样一个机制，当获取数据发生重定向时，那么将向被委托对象询问是否允许发生重定向。这个协议方法看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)networkFetcher:(EOCNetworkFetcher*)fetcher shouldFollowRedirectToURL:(NSURL*)url;</div></pre></td></tr></table></figure>
<p>这个例子解释了为什么这种模式叫做委托模式，因为是一个对象委托另一个对象去处理一些行为。</p>
<p>协议也可以提供一套接口给需要获取数据的类使用。这种委托模式被称为数据源模式，因为它的作用是给委托者提供数据。数据源模式中，信息从被委托者流向委托者；而正常的委托模式，信息是从委托者流向被委托者。图4.3展示了这个流程。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%204.3.png" alt=""></p>
<p><strong>Figure 4.3</strong> 数据源模式中，信息从被委托者流向委托者；而在普通的委托模式，信息是从委托者流向被委托者。</p>
<p>例如，用户界面的列表对象使用数据源协议获取数据用于展示在列表中。列表视图还有一个委托协议用来处理用户操作。通过分隔数据源和委托协议，提供了一个清晰的接口，因为它们的逻辑也被分离了。另外，你可以使用一个对象处理数据源，另一个对象处理委托。然而，一般情况下，两者都是同一个对象。</p>
<p>如果数据源的方法和委托的方法大多数可选的，那么你将会写大量类似这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ([_delegate respondsToSelector:@selector(someClassDidSomething:)]) &#123;</div><div class="line">        </div><div class="line">        [_delegate someClassDidSomething];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查被委托者是否实现了一个确定的方法是非常迅速的，但是如果一直这样做，那么除了第一次之外其余的是多余的。如果被委托对象本身没有发生变化，那么不太可能会突然开始响应或停止响应某个方法。因此，可以将被委托者是否能响应方法的结果缓存在协议中。例如，<code>EOCNetworkFetcher</code>类有一个被委托对象，它用于表示获取进度的回调方法，每当进度发生变化，就会调用被委托对象实现的协议方法。那么在这个生命周期中，这个方法将会被多次调用，并且每次都会检查是否相应这个方法。</p>
<p>将刚才说的方法加进协议中，目前协议中的定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@protocol EOCNetworkFetcherDelegate</div><div class="line"></div><div class="line">@optional</div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">        didReceiveData:(NSData*)data;</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">      didFailWithError:(NSError*)error;</div><div class="line"></div><div class="line">- (void)networkFetcher:(EOCNetworkFetcher*)fetcher</div><div class="line">   didUpdateProgressTo:(float)progress;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里新增了一个叫做<code>networkFetcher:didUpdateProgressTo:</code>的方法。缓存这个相应结果的最好办法是使用位段数据结构。这是一项很少使用的C语言特性，但在这里确实很合适的。它允许你定义一个确定的结构体位段，并且设置特定的值。看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct data &#123;</div><div class="line">    unsigned int fieldA : 8;</div><div class="line">    unsigned int fieldB : 4;</div><div class="line">    unsigned int fieldC : 2;</div><div class="line">    unsigned int fieldD : 1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这个结构体中，<code>fieldA</code>使用8个二进制位，<code>fieldB</code>使用4个二进制位，<code>fieldC</code>使用2个二进制位，<code>fieldD</code>使用1个二进制位。所以<code>fieldA</code>可以表示0-255的数字，<code>fieldD</code>可以表示0或者1。如果创建的结构体中只有大小为1的位段，那么就能把许多布尔值塞入数据中了。以<code>EOCNetworkFetcher</code>类为例，你可以设置一个包含有位段的结构体为实例变量，结构体中的没一个变量代表一个协议方法。这个结构体是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface EOCNetworkFetcher () &#123;</div><div class="line">    </div><div class="line">    struct &#123;</div><div class="line">        </div><div class="line">        unsigned int didReciveData       : 1;</div><div class="line">        unsigned int didFailWithError    : 1;</div><div class="line">        unsigned int didUpdateProgressTo : 1;</div><div class="line">    &#125; _delegateFlags;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里，我使用了类扩展去添加实例变量，具体描述在第27节；这个实例变量是一个结构体包含三个位段，每个位段代表一个协议方法。在<code>EOCNetworkFetcher</code>类中，可以像下面这样查询并设置结构体中的位段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Set flag</div><div class="line">_delegateFlags.didReceiveData = 1;</div><div class="line">// Check flag</div><div class="line">if (_delegateFlags.didReceiveData) &#123;</div><div class="line">    // Yes, flag set</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构体用来魂村被委托对象是否能相应某个指定方法的结果。实现缓存功能的代码可以写在<code>delegate</code>属性的<code>setter</code>方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setDelegate:(id&lt;EOCNetworkFetcher&gt;)delegate &#123;</div><div class="line">    </div><div class="line">    _delegate = delegate;</div><div class="line">    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];</div><div class="line">    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)];</div><div class="line">    _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector (networkFetcher:didUpdateProgressTo:)] ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样每次调用<code>delegate</code>的相关方法时，就不需要检测被委托对象是否能响应指定的方法了，可以直接查询结构体中的标志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (_delegateFlags.didUpdateProgressTo) &#123;</div><div class="line">        </div><div class="line">    [_delegate networkFetcher:self didUpdateProgressTo:currentProgress];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果多次调用判断方法，那么这个优化是有价值的。是否优化需要取决你的代码。你应该使用性能检测工具检测你的代码是否遇到性能瓶颈，如果需要优化可以使用类似技巧。如果频繁从数据源获取数据，那么该优化技术极大可能提高程序效率。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>委托模式为对象提供了一套接口，使其可将相关事件告诉其他对象。</li>
<li>在协议中把可能需要处理的事件定义成方法。</li>
<li>当一个对象需要从别的对象获取数据时，使用委托模式。在这种情况下，该模式被称为数据源模式。</li>
<li>如果需要，可以实现包含位段的结构体，用于缓存被委托者相应指定方法的结果。</li>
</ul>
<h3 id="使用便于管理的分类分散类的实现代码"><a href="#使用便于管理的分类分散类的实现代码" class="headerlink" title="使用便于管理的分类分散类的实现代码"></a>使用便于管理的分类分散类的实现代码</h3><p>随着许多方法放置在实现文件中，一个类很容易变得臃肿。有时候，这样是没问题的，即使你对它们进行了重构也并不能变得更好。在这种情况下，可以使用<code>Objective-C</code>的类别功能，将其分封在几个区域中，这对开发和调试都有好处。</p>
<p>比如有一个模型类代表人的信息。那么这个类就会有一些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">/* Friendship methods */</div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">/* Work methods */</div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">/* Play methods */</div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个类的实现会包含长长的方法列表。如果有更多方法加进这个类，这个类会随着时间越来越难以管理。所以分隔这个类是常用的办法。例如，使用类别功能，上面的类可能这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Work)</div><div class="line"></div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Play)</div><div class="line"></div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>现在，类的每个不同部分都被划分到不同的类别中了。毫不奇怪，这项语言的特性被称作类别。在这个例子中，类的基础部分包括属性和初始化方法，所以声明在主实现中。附加的那些方法，根据不同功能，分封在不同的类别中。</p>
<p>你仍然可以将所有的声明和实现放在一个类中，但随着类别的增长，单一的实现文件也很容易变得难以管理。在这个例子中，类别也可以拥有它们自己的实现文件。例如，<code>EOCPerson</code>可以这样分隔实现：</p>
<ul>
<li>EOCPerson+Friendship(.h/.m)</li>
<li>EOCPerson+Work(.h/.m)</li>
<li>EOCPerson+Play(.h/.m)</li>
</ul>
<p>例如，<code>Friendship</code>分类可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// EOCPerson+Friendship.h</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson+Friendship.m</div><div class="line">#import &quot;EOCPerson+Friendship.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line">- (void)removeFriend:(EOCPerson*)person &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个类已经被分隔成多个易于管理的代码块，并且利于单独检查。使用分类机制之后，如果要使用分类方法，要记得将有关的类别头导入<code>EOCPerson</code>的头文件。虽然稍微有点麻烦，但这是使代码易于管理的好办法。</p>
<p>即使类不是很大，也可以通过分类机制将不同模块的代码放入不同的功能域。在<code>Cocoa</code>框架中有一个这样的例子，那就是<code>NSURLRequest</code>和它的可变版本<code>NSMutableURLRequest</code>。这个类经常使用<code>HTTP</code>请求获取网络数据，但是它也能使用别的协议。然而，与标准的URL相比，<code>HTTP</code>请求需要额外的附加信息，例如<code>HTTP</code>方法(Get、Post等)和<code>HTTP</code>头。</p>
<p>但是<code>NSURLRequest</code>不是易于子类化的，因为它包含了一套操作<code>CFURLRequest</code>结构体的C函数，以及所有的<code>HTTP</code>方法。所以给<code>NSURLRequest</code>添加了一个叫做<code>NSHTTPURLRequest</code>的类别，用于放置<code>HTTP</code>相关方法，还添加了一个叫做<code>NSMutableHTTPURLRequest</code>的类别，用于放置可变版本的方法。这样所有的<code>CFURLRequest</code>的方法都封装在同一个类里面了，但是仍要将<code>HTTP</code>方法单独拆分，不然使用者可能会想，为什么<code>FTP</code>协议的请求可以设置<code>HTTP</code>方法？</p>
<p>另一个使用类别的原因是便于调试：对于某个分类中的所有办法来说，分类名称会出现在其符号中。例如，<code>addFriend:</code>输出的符号名是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[EOCPerson(Friendship) addFriend:]</div></pre></td></tr></table></figure>
<p>当它在调试器的回溯中出现时，通常是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame #2: 0x00001c50 Test&apos;-[EOCPerson(Friendship) addFriend:] + 32 at main.m:46</div></pre></td></tr></table></figure>
<p>在回溯中的类别名称可以很容易的区分类方法属于哪个功能区，对私有方法特别有用。在这种情况下，可能会创建一个叫做<code>private</code>的类别包含这些私有方法。这种类别的方法通常只用在类或者框架的内部。如果使用者通过回溯看到了这个信息，就知道不该直接调用这个私有方法。这算是一种自我描述式代码的办法。</p>
<p>当你决定创建一个库给别人使用时，私有的类别是非常有用的。通常，有一些方法不应该暴漏在外部，但是却适合在类库内部使用。在这种情况下，创建一个私有分类是非常有用的，因为可以在任何需要使用的内部导入它的头文件。如果类别头文件不随着类库一并公开，那么类库的使用者是不会知道这些私有类别的。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用类别分隔某个类，使其易于管理。</li>
<li>创建一个私有类别用于隐藏那些不该暴漏的方法。</li>
</ul>
<h3 id="总是为第三方类的分类名称加前缀"><a href="#总是为第三方类的分类名称加前缀" class="headerlink" title="总是为第三方类的分类名称加前缀"></a>总是为第三方类的分类名称加前缀</h3><p>类别通常被用做给已存在的但无源码的类添加功能。这是一个非常有用的功能，但是这样做也很容易出问题。产生问题的原因是如果类本身有某个方法，而分类又实现了这个方法，那么类本身的方法将会被覆盖。在运行时会将分类中的每个方法加入到类的方法列表中。如果类中有这个方法，而分类又实现一次，那么分类中的方法就会覆盖类中的。实际上这个问题可能会发生不止一次，因为某个类别覆盖了类的本身实现，别的类别覆盖了上个类别。那么调用时将会调用最后一个覆盖的方法。</p>
<p>例如，你创建一个<code>NSString</code>的类别，并提供一些用于处理<code>HTTP URL</code>的方法。你可能会这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface NSString (HTTP)</div><div class="line">// Encode a string with URL encoding</div><div class="line">- (NSString*)urlEncodedString;</div><div class="line">// Decode a URL encoded string</div><div class="line">- (NSString*)urlDecodedString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这看起来非常好啊，但是考虑一下如果另一个类别也给<code>NSString</code>添加了同样的方法。第二个类别也添加了一个叫做<code>urlEncodedString</code>的方法，但是实现却与你的类别有些微差异。如果那个类别在你的类别之后加载，那么调用方法时将会调用第二个类别的。这会导致你的代码不能正确的工作，并且会得到意料之外的结果。这种问题是难以排查的，因为你不知道实际上你的方法并没有运行。</p>
<p>解决这种问题，一般的做法是使用命名空间区分类别和类别中的方法。而<code>Obejective-C</code>中命名空间的做法是给相关名称加上前缀。就像之前给类添加前缀一样，给分类选择前缀也要选择恰当才行。通常，前缀名与你的应用名或者库名相同。因此，<code>NSString</code>类别加上<code>ABC</code>前缀之后大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface NSString (ABC_HTTP)</div><div class="line"></div><div class="line">// Encode a string with URL encoding</div><div class="line">- (NSString*)abc_urlEncodedString;</div><div class="line">// Decode a URL encoded string</div><div class="line">- (NSString*)abc_urlDecodedString;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>从技术上讲，并不一定需要把类别名称加前缀。两个同名类别不会出现问题。但是这是不好的，因为编译器会发出这样的编译警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">warning: duplicate definition of category &apos;HTTP&apos; on interface &apos;NSString&apos;</div></pre></td></tr></table></figure>
<p>即使这样也可能会有别的类别覆盖你的方法，但是这样做可以大大减少这种情况，因为别的类和你使用相同的前缀名是不太可能的。这样做也能避免类的开发者以后更新类的时候覆盖你的方法。例如，如果苹果给<code>NSString</code>添加了<code>urlEncodedString</code>方法，而你的方法又没有增加前缀，那么你将覆盖苹果的方法。这是不合适的，因为别的<code>NSString</code>类的使用者想得到的结果是苹果的代码输出，而非你的返回结果。或者苹果实现的方法带有一些别的效果，你的方法如果覆盖了苹果的方法并且没有响应的效果，那么就会产生难以排查的问题。</p>
<p>此外要记住的是你使用分类给某个类添加的方法，该类的每一个实例都可以调用。如果你给系统提供的类添加功能，例如<code>NSString、NSArra、NSNumber</code>，那么即使这些类的实例不是由你的代码初始化出来的，它们也可以调用你添加的方法。如果你无意中把自己类别中的方法起的和其他分类或者第三方库一样，那么将会产生难以预料的问题，因为你以为执行的是自己的方法，但是实际上却不是。同样的，使用类别故意覆盖方法也是不好的，尤其是当你的方法是以类库形式提供给别人使用时，而他们又要依赖系统中的功能。如果其他开发者覆盖相同的方法，那么就更不能确定到底运行的是哪个类别的方法了。这又一次说明了给类别方法使用命名空间的重要性。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>向第三方类中添加分类时，总应给你的分类加上相应的前缀。</li>
<li>向第三方类中添加分类时，总应给你分类中的方法加上相应的前缀。</li>
</ul>
<h3 id="避免在类别中使用属性"><a href="#避免在类别中使用属性" class="headerlink" title="避免在类别中使用属性"></a>避免在类别中使用属性</h3><p>属性是用来封装数据的(看第6节)。从技术上讲你可以在类别中声明属性，但你不应该这样做。理由是，除了类扩展(看第27节)这种特殊类别会产生实例变量并加入类中，普通类别中的属性并不会产生实例变量。</p>
<p>在阅读了第24节之后，你决定将一个代表人的类的实现分隔进不同的类别中。你可能会创建一个朋友的类别用来存放所有操作朋友属性的方法。如果你不知道“应该避免在类别中使用属性这个问题”，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line">            andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Methods</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSArray *friends;</div><div class="line"></div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson (Friendship)</div><div class="line">// Methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你就这样编译它，那么你会得到两个编译警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">warning: property &apos;friends&apos; requires method &apos;friends&apos; to be</div><div class="line">defined - use @dynamic or provide a method implementation in</div><div class="line">this category [-Wobjc-property-implementation]</div><div class="line">    </div><div class="line">warning: property &apos;friends&apos; requires method &apos;setFriends:&apos; to be</div><div class="line">defined - use @dynamic or provide a method implementation in</div><div class="line">this category [-Wobjc-property-implementation]</div></pre></td></tr></table></figure>
<p>这个警告的意思是属性不能自动合成变量，所以需要提供存取方法去实现属性。或者，你可以使用<code>@dynamic</code>声明属性，告诉编译器你会在运行时添加，而不是编译时。如果你在运行时使用消息转发机制(看第12节)拦截消息，并且提供实现这也是个办法。</p>
<p>关于为什么类别不能生成变量，你可以去看关联对象(对，去看第10节)。例如，在类别中，你可能需要这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">static const char *kFriendsPropertyKey = &quot;kFriendsPropertyKey&quot;;</div><div class="line"></div><div class="line">@implementation EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (NSArray*)friends &#123;</div><div class="line">    </div><div class="line">    return objc_getAssociatedObject(self, kFriendsPropertyKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setFriends:(NSArray*)friends &#123;</div><div class="line">    </div><div class="line">    objc_setAssociatedObject(self,</div><div class="line">                             kFriendsPropertyKey,</div><div class="line">                             friends,</div><div class="line">                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样做也可以使代码正常工作，但这不是一个好主意。这是一个重复且容易在内存管理上出错的做法，因为你很容易忘记属性的实现。例如，你修改了它关联属性的内存管理语义，那么你总是需要记着修改<code>setter</code>方法中的内存管理语义。尽管这不是坏的解决办法，但我也不推荐这样做。</p>
<p>并且，你可能想让返回的<code>friends</code>数组是可变的。你可以对传入的数组使用<code>mutableCopy</code>，但这样又会产生另一个编程问题。综上所述，在主文件中定义属性是比在类别中更清楚易懂的。</p>
<p>在这个例子中，正确的做法是将所有的属性定义在主文件中。所有的数据封装都应该定义在主文件，那里是唯一可以定义变量的地方。因为属性其实只是实例变量以及存取方法的语法糖。类别的唯一用途就是给类添加额外的方法而不是存储数据。</p>
<p>话虽如此，有时也可以在类别中使用只读属性。例如，你可能想创建一个<code>NSCalendar</code>的分类，并且返回一个包含所有月份字符串的数组。因此这个方法不需要访问任何属性也不需要产生实例变量，你可以像下面这样定义它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface NSCalendar (EOC_Additions)</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) NSArray *eoc_allMonths;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSCalendar (EOC_Additions)</div><div class="line"></div><div class="line">- (NSArray*)eoc_allMonths &#123;</div><div class="line">    </div><div class="line">    if ([self.calendarIdentifier isEqualToString:NSGregorianCalendar]) &#123;</div><div class="line">        </div><div class="line">        return @[@&quot;January&quot;, @&quot;February&quot;,</div><div class="line">                 @&quot;March&quot;, @&quot;April&quot;,</div><div class="line">                 @&quot;May&quot;, @&quot;June&quot;,</div><div class="line">                 @&quot;July&quot;, @&quot;August&quot;, @&quot;September&quot;, @&quot;October&quot;, @&quot;November&quot;, @&quot;December&quot;];</div><div class="line">    &#125; else if ( /* other calendar identifiers */ ) &#123;</div><div class="line">        </div><div class="line">        /* return months for other calendars */</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样属性就无需生成实例变量了，因为所有需要的方法(仅仅在属性是只读的情况下)都已经实现。因此，编译器也不会有任何警告。即使在这种情况下，也最好避免使用属性。属性要表达的意思是它持有某些数据。属性是用来封装数据的。在这个例子中，你应该声明一个方法去替代属性的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface NSCalendar (EOC_Additions)</div><div class="line"></div><div class="line">- (NSArray*)eoc_allMonths;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>保持所有属性都声明在主文件中。</li>
<li>除非是类扩展这种特殊类别，否则类别中尽量不要定义属性，但可以定义存取方法。</li>
</ul>
<h3 id="使用类扩展隐藏类实现细节"><a href="#使用类扩展隐藏类实现细节" class="headerlink" title="使用类扩展隐藏类实现细节"></a>使用类扩展隐藏类实现细节</h3><p>通常，你的类里面的很多方法和实例变量是只想给内部使用的。你可以表面上暴漏它们但将它们标记为私有的，那么使用者就不会使用这些了。最重要的是，在<code>Objective-C</code>中是没有私有变量或私有方法的，这完全因为<code>Objective-C</code>的动态消息派发系统(看第11节)。然而，只暴漏需要暴漏的公共方法才是正确的原则，但是我们应该在哪里声明不该暴漏的属性和方法呢？这时就需要特殊的类别，即类扩展了。</p>
<p>类扩展不像普通的类别，它必须定义在类的实现文件中。重要的是，它是仅有的允许声明实例变量的类别。而且，这个类别不需要特殊的实现。任何定义在这里的方法和属性都能正常的出现在类的使用中。不像其他类别，这个特殊的类别也没有名字。一个<code>EOCPerson</code>类的类扩展大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson ()</div><div class="line">// Methods here</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>为什么这个类别有用？它有用是因为这里可以定义实例变量和方法。这种可能性来源于稳定的ABI(看第6节)，这意味着不需要知道对象的大小也可以使用它。因此，内部使用的实例变量不需要定义在公共接口中，这样类的使用者也不会知道类的内存布局。因此，使用类扩展给类添加实例变量等同于在类实现中添加变量。为了这样做，你只需要在类扩展右侧加上大括号，并将变量放置在那里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson () &#123;</div><div class="line">    </div><div class="line">    NSString *_anInstanceVariable;</div><div class="line">&#125;</div><div class="line">// Method declarations here</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson &#123;</div><div class="line">    </div><div class="line">    int _anotherInstanceVariable;</div><div class="line">&#125;</div><div class="line">// Method implementations here</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样做有什么意义吗？你可以在公共接口中定义实例变量啊。但是这样做可以将实现细节隐藏在类扩展或者实现块中，使其仅为本类使用。即使你在公共接口中将其标位<code>private</code>，但依然泄露了实现细节。例如，你不想别人知道你在类的内部使用了某个秘密的类。假如你在类中使用了秘密的类并且将其定义在公共接口中，那么看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@class EOCSuperSecretClass;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line"></div><div class="line">@private</div><div class="line">    EOCSuperSecretClass *_secretInstance;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个叫做<code>EOCSuperSecretClass</code>的类已经泄露了。你可以不将其类型信息表现出来并使用<code>id</code>代替。但这样做是不好的，因为你在内部使用时，无法获得编译器的任何帮助。仅仅因为不想暴漏类型就要失去编译器的帮助？类扩展可以很好的达成这个目标。现在它的定义像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCClass.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCClass.m</div><div class="line">#import &quot;EOCClass.h&quot;</div><div class="line">#import &quot;EOCSuperSecretClass.h&quot;</div><div class="line"></div><div class="line">@interface EOCClass () &#123;</div><div class="line">    </div><div class="line">    EOCSuperSecretClass *_secretInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line">// Methods here</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>同样的，实例变量也可以定义在类实现块中，在语义上它跟定义在类扩展中是一样的。我更推荐将其添加在类扩展中，因为它可以保持定义地方的一致性。你可能已经将属性定义在这里了，所以这是一个好的添加额外变量的地方。这些变量并不是真正意义上的私有，在运行时通过某些方法依然可以得到它们，但在我们的目的上，它们是私有的。而且，如果它们没有声明在公共头文件中，如果你的代码是某个库的一部分，那它们会隐藏的更深。</p>
<p>另一个使用类扩展的地方是在你混写<code>Objetive-C</code>和<code>C++</code>代码时。在混写环境下，你所写的代码两种语言都可以使用。游戏通常出于性能和移植性的考虑，一般会使用<code>C++</code>。有时，你可能需要使用<code>C++</code>，因为你使用了一个第三方库并且那个库是用<code>C++</code>写的。这种情况下，类别同样可以处理。假设在你使用类别之前，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt; </div><div class="line">#include &quot;SomeCppClass.h&quot;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line"></div><div class="line">@private</div><div class="line">    SomeCppClass _cppClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个类的实现文件应该叫做<code>EOCClass.mm</code>，这个<code>.mm</code>告诉编译器应该允许混编，没有这个符号，就无法导入<code>SomeCppClass.h</code>了。然而这样会把整个<code>SomeCppClass</code>类导入进来，因为编译器需要知道<code>_cppClass</code>的全部信息。所以任何包含了<code>EOCClass.h</code>的类也需要能进行混合编译，因为它也包含了<code>SomeCppClass.h</code>。这很容易导致失去控制使得整个项目都需要进行混合编译。这么做完全可以，但是我不推荐这种做法，特别是当你的代码以第三方库的形式给别人使用时，这会让使用者需要给所有的文件重新命名并加上<code>.mm</code>后缀。</p>
<p>你可能会使用前向声明的方法导入这个<code>C++</code>类，并将其实例变量声明为一个指针，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">class SomeCppClass;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject &#123;</div><div class="line"></div><div class="line">@private</div><div class="line">    SomeCppClass *_cppClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个实例变量现在需要声明为一个指针，如果它不是指针，编译器无法得知它的大小，这将会产生一个错误。指针的大小是固定的，所以需要告诉编译器它是一个指针。这时问题又出现了，别的导入了<code>EOCClass</code>的类，当它们发现<code>class</code>这个关键字时，这是一个<code>C++</code>关键字，它们也需要能进行混编才能编译通过。这是没有必要的，因为这是一个私有变量，别的类根本不关心它的存在。这时，类扩展又一次派上用场了。像下面这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCClass.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCClass.mm</div><div class="line">#import &quot;EOCClass.h&quot; </div><div class="line">#include &quot;SomeCppClass.h&quot;</div><div class="line"></div><div class="line">@interface EOCClass () &#123;</div><div class="line">    </div><div class="line">    SomeCppClass _cppClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>现在头文件从<code>C++</code>中脱离出来了，而使用了这个头文件的其他类也无需担心<code>C++</code>了，现在<code>C++</code>的使用是秘密了。在系统的一些类库中也使用了这种模式，例如<code>WebKit</code>，这是一个网页浏览器框架，它同样是使用<code>C++</code>写的并且提供了只有<code>Objective-C</code>语言的接口。这个模式在<code>CoreAnimation</code>中也有用到，内部都是使用<code>C++</code>书写，给外部使用的接口都是<code>Objective-C</code>。</p>
<p>类别的另一个用途是在公共接口中提供只读属性在内部对属性进行修改。通常你会调用属性的<code>setter</code>方法而不是直接调用实例变量，是因为你不知道是否有其他对象监听了你的属性，而直接调用实例变量不会触发<code>KVO</code>。出现在类扩展或者类别中的属性，必须与主文件中的属性特质一致，但是只读特质可以改变为读写特质。例如，下面类的公共文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>通常类扩展中会修改这两个属性的读写特质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson ()</div><div class="line"></div><div class="line">@property (nonatomic, copy, readwrite) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readwrite) NSString *lastName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一切准备妥当了。现在<code>EOCPerson</code>的实现文件可以通过<code>setFirstName:</code>和<code>setLastName:</code>方法或者点语法自由的设置数据了。这样做也可以保证外部是不可变的，内部仍可根据需要修改。这样封装的数据就由类本身的实例进行控制，外部就无法控制了。第18节有更多关于这个话题的信息。请注意，现在有一个潜在的问题，如果观察者正在读取这个值，而内部则正在对这个值进行修改，则有可能引发竞争条件。合理的使用同步(看第41节)机制将减少问题的发生。</p>
<p>另一个使用类扩展的地方是在其中声明私有方法，即只在类内部使用的方法。因为它表示这些方法都是在内部使用的。看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson ()</div><div class="line"></div><div class="line">- (void)p_privateMethod;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个地方使用前缀的原因是第20节讲述了使用前缀标示私有方法。在最新的编译器版本，不需要严格遵守这条约定。但是，在类似的类扩展中将方法标示出来仍然是一个好主意。我经常像这样先把方法原型写出来。然后再去考虑实现这些方法。这是一个提高类可读性的办法。</p>
<p>最后，类扩展也是一个遵循协议私有化的好地方。通常，你不需要在公共接口中泄露你遵守了哪些确定的协议，可能因为那个协议是私有API的一部分。例如，<code>EOCPerson</code>类遵循一个叫做<code>EOCSecretDelegate</code>的协议。如果在公共接口中声明，它大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt; </div><div class="line">#import &quot;EOCSecretDelegate.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject &lt;EOCSecretDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你可能认为你可以仅仅前向声明这个协议而不是导入它(或者在头文件定义它)。你使用前向声明代替导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@protocol EOCSecretDelegate;</div></pre></td></tr></table></figure>
<p>然而任何一个导入了这个头文件的地方，编译器都会有下面的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">warning: cannot find protocol definition for &apos;EOCSecretDelegate&apos;</div></pre></td></tr></table></figure>
<p>这个警告是因为编译器知道不会有机会知道协议中到底定义了什么方法。但是它是一个私有的内部协议，你甚至没必要泄露它的名字。类扩展再次救场！替代<code>EOCPerson</code>在公共接口中遵循<code>EOCSecretDelegate</code>协议，你可以在类扩展中这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line">#import &quot;EOCSecretDelegate.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson () &lt;EOCSecretDelegate&gt;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">/* ... */</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>公共接口对协议的遵循被移除。私有协议不在暴漏，使用者如果不深入查找也不知道它的存在。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用类扩展给类添加实例变量。</li>
<li>如果在公共接口中声明的属性需要在内部进行修改，使用类扩展修改它的读写特质。</li>
<li>在类扩展中声明私有方法。</li>
<li>使用类扩展去遵循你想私有的协议。</li>
</ul>
<h3 id="通过协议提供匿名对象"><a href="#通过协议提供匿名对象" class="headerlink" title="通过协议提供匿名对象"></a>通过协议提供匿名对象</h3><p>协议定义了一系列遵循对象应该实现或者必须实现的方法。因此我们可以通过协议隐藏自己所写的API细节，将返回的对象设计为遵从此协议的<code>id</code>类型。这样就不会泄露API中特定类的名字了。当你想有许多不同类的行为时这是非常有用的，并且也不需要指定特定的类。例如，许多类并不能以标准的继承方式实现时，因此它们没有共同的基类。</p>
<p>这个概念被称为匿名对象，它并不像别的语言中的匿名对象。别的语言的匿名对象是指通过一个类的内联函数创建的没有名字的对象。在<code>Objective-C</code>中，它并不是这个意思。在第23节，委托和数据源已经展示了匿名对象的使用。例如，委托的属性可能这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate;</div></pre></td></tr></table></figure>
<p>这个属性的类型是<code>id&lt;EOCDelegate&gt;</code>，因此这个类的对象可以是任何东西；即使它不继承自<code>NSObject</code>也行。只要它遵循<code>EOCDelegate</code>协议。对具有此属性的类，这个就是匿名对象。如果你想知道匿名对象的类型信息也是可以的，只要在运行时检查对象的类型就可以了。但是这样做不是个好习惯，因为既然选择了这种属性类型就是不需要关心类型信息。</p>
<p><code>NSDictionary</code>是这个概念的另一个例子。字典的<code>key</code>的内存管理语义是当设置值时拷贝它。因此，在一个可变数组中，设置一组键值对的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key</div></pre></td></tr></table></figure>
<p><code>key</code>参数的类型是<code>id&lt;NSCopying&gt;</code>，因为它只需要任何遵循<code>NSCopying</code>协议的对象，只要能成功接收拷贝的消息就可以当做<code>key</code>。这个<code>key</code>参数也可以是匿名的。就像刚才的委托属性，字典也不关心<code>key</code>的类并且它也不需要。它只需要知道<code>key</code>这个参数可以接收拷贝信息即可。</p>
<p>使用匿名对象的另一个例子是当一个对象是从一个库返回时，这个库是用于处理数据库连接的。你可能不想泄露处理数据库的类，因为它可能不是同一个数据库。这些方法不是来自一个同样的基类，你只能强制它们返回<code>id</code>类型。但是，你可以创建一个协议并且声明通用的方法，让所有的处理数据库连接的类声明并遵循它。这个协议看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol EOCDatabaseConnection</div><div class="line"></div><div class="line">- (void)connect;</div><div class="line">- (void)disconnect;</div><div class="line">- (BOOL)isConnected;</div><div class="line">- (NSArray*)performQuery:(NSString*)query;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后你创建一个处理数据库的单例类，用以提供数据库连接。它的接口大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol EOCDatabaseConnection;</div><div class="line"></div><div class="line">@interface EOCDatabaseManager : NSObject</div><div class="line"></div><div class="line">+ (id)sharedInstance;</div><div class="line"></div><div class="line">- (id&lt;EOCDatabaseConnection&gt;)connectionWithIdentifier: (NSString*)identifier;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样，这个类就可以处理数据库连接而不暴漏来自不同的框架不同的类并且都返回同样的方法。所有使用这个API的人只要关心这个对象可以执行连接和断开连接就可以了。这一点很重要。在这个例子中，后端代码去处理数据库连接可以使用不同的第三方库去连接不同的数据库。(例如，MySQL, PostgreSQL)。由于这些类来自不同的第三方库，让它们继承同一个基类是不可能的事情。所以可以把这些第三方类简单的包装起来，使匿名对象成为其子类，并遵循<code>EOCDatabaseConnection</code>协议。然后可以通过<code>connectionWithIdentifier:</code>方法返回这些类对象。在开发后续呢版本时，无需改变公共API即可切换后端的实现类。</p>
<p>当你想表达的对象类型是不重要的时候，你也可以选择匿名类型，但更重要的是对象有没有实现某些方法。即使你实现中的某个类型总是确定的，你可能仍想使用匿名类型来表达它类型是不重要的。在<code>CoreData</code>框架中有一个这种用法的例子。这个类叫做<code>NSFetchedResultsController</code>，它用来处理查询<code>CoreData</code>数据库的结果，如果有需要，处理时还会把数据分区。在负责查询结果的控制器上有一个叫做<code>sections</code>的字段用来处理分区。它是一个遵循<code>NSFetchedResultsSectionInfo</code>协议的对象数组而不是一个具体类型的数组。使用控制器去获取分段信息就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSFetchedResultsController *controller = /* some controller */;</div><div class="line">NSUInteger section = /* section index to query */;</div><div class="line">NSArray *sections = controller.sections;</div><div class="line">id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = sections[section];</div><div class="line">NSUInteger numberOfObjects = sectionInfo.numberOfObjects;</div></pre></td></tr></table></figure>
<p><code>sectionInfo</code>是一个匿名对象。在制作API时要把通过对象获取分段信息这个功能清晰的展示出来。在代码内部，这个对象可能是结果控制器通过内部状态创建出来的。也没必要把这个状态暴漏在公共接口总，因为这个控制器的使用者并不关心数据段是如何存储的。它们需要的只是能通过这个控制器去查询数据。<code>sections</code>数组中返回的内部状态对象就是遵循了某个协议的匿名对象。使用者只要知道它实现了一些方法就可以了，这样也隐藏了对象的其余实现细节。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>协议可以在某种程度上提供匿名对象。对象的类型可以降低为遵循了某协议并实现了某些方法的<code>id</code>类型。</li>
<li>当类型信息应该被隐藏时，使用匿名对象。</li>
<li>当类型信息不重要时，并且对象实现了该实现的方法(某个协议定义的)，那么可匿名对象表示。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第四章：协议和分类&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第三章</title>
    <link href="http://yoursite.com/2017/06/08/Interface%20and%20API%20Design/"/>
    <id>http://yoursite.com/2017/06/08/Interface and API Design/</id>
    <published>2017-06-08T07:42:59.000Z</published>
    <updated>2017-06-19T10:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第三章：接口和API设计</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一旦你构建过一个应用程序，那么你可能会想在将来的项目中重用部分代码。你甚至可能想要发布一些代码给他人使用。即使你认为你不会这样做，你也可能在别的地方用到。当你阅读过本节，它将帮你写出合适的接口声明。这意味着你需要理解各种缺陷，才能写出标准模板一样的<code>Objective-C</code>代码。</p>
<p>近年来，随着iOS的问世，带来了大量的开源社区和流行的组件，你经常会在自己的项目里使用别人的代码。相似的，别人也可能会使用你的代码，所以写出清晰的代码可以使别人更快、更容易的整合你的代码。并且谁也不知道，你写下的某个库会不会被成千上万的应用使用呢！</p>
<h3 id="使用前缀名去避免命名空间冲突"><a href="#使用前缀名去避免命名空间冲突" class="headerlink" title="使用前缀名去避免命名空间冲突"></a>使用前缀名去避免命名空间冲突</h3><p>不像别的语言，<code>Objective-C</code>没有命名空间功能。由于这个原因，如果没有采取措施去避免，命名冲突是非常容易出现的。由于符号重复编译错误，命名冲突对应用的影响是可能导致项目无法链接，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _OBJC_METACLASS_$_EOCTheClass in:</div><div class="line">	build/something.o</div><div class="line">	build/something_else.o</div><div class="line">duplicate symbol _OBJC_CLASS_$_EOCTheClass in:</div><div class="line">	build/something.o</div><div class="line">	build/something_else.o</div></pre></td></tr></table></figure>
<p>这个错误结果是因为某个符号在<code>EOCTheClass</code>类和其元类(看第14节)的符号表定义了两次。在应用程序的两部分代码中，同时存在<code>EOCTheClass</code>类的两个实现，那个符号也就自然会定义两次。</p>
<p>更糟糕的是，如果在链接时没有发现某个库包含了一份重复的代码，而是在运行时加载。在这种情况下，动态加载器将会遭遇重复符号错误并且导致应用程序崩溃。</p>
<p>仅有一种办法去避免这个问题就是去使用一个粗糙的命名空间：给所有的名字加上一个确定的前缀。这个前缀应该选择你公司名字或者应用名字或者两者结合。例如，如果你的公司名字叫做Effective Widgets，你可能决定在应用中使用<code>EWS</code>前缀，如果是<code>EWB</code>前缀，仅仅因为你的应用叫做Effective Browser。即使你加上了前缀也不会没有名称冲突，但是会减少发生的次数。</p>
<p>如果你使用<code>Cocoa</code>创建应用程序，需要注意苹果已经表明可能会使用任意两个字母作为前缀，所以在这种情况下，你应该选择三个字母做前缀。例如，如果你不遵守这项约定并使用了<code>TW</code>作为前缀，那么将会产生问题。当<code>iOS 5.0</code>的SDK发布时，它带来了<code>Twitter</code>框架，并且选择<code>TW</code>作为前缀，有一个叫做<code>TWRequest</code>的类用于支持<code>Twitter API</code>的<code>HTTP</code>请求。如果你的公司叫做Tiny Widgets，并且有你自己用的<code>API</code>，那么你很大可能会有一个叫做<code>TWRequest</code>的类。</p>
<p>在你的应用中，前缀不该带有类名但应该适用于所有的类。第25节讲述了如果类别基于存在的类，类别名字和方法名字前缀的重要性。另一个常被忽视的问题是与C函数的冲突或者你在类的实现文件中使用的全局变量。通常很容易忘记全局变量在编译后的目标文件中是作为顶级符号出现的。例如，在<code>iOS SDK</code>中的<code>AudioToolbox</code>框架，它有一个函数用于播放一个声音文件。你可以给它一个回调从而在它结束时调用它。你可能会去写一个类，当声音文件播放结束时，去调用它，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">//  EOCSoundPlayer.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCSoundPlayer;</div><div class="line">@protocol EOCSoundPlayerDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)soundPlayerDidFinish:(EOCSoundPlayer*)player;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCSoundPlayer : NSObject</div><div class="line">@property (nonatomic, weak) id &lt;EOCSoundPlayerDelegate&gt; delegate;</div><div class="line">- (id)initWithURL:(NSURL *)url;</div><div class="line">- (void)playSound;</div><div class="line">@end</div><div class="line"></div><div class="line">//  EOCSoundPlayer.m</div><div class="line">#import &quot;EOCSoundPlayer.h&quot;</div><div class="line">#import &lt;AudioToolbox/AudioToolbox.h&gt;</div><div class="line"></div><div class="line">void completion(SystemSoundID ssID, void *clientData) &#123;</div><div class="line">    </div><div class="line">    EOCSoundPlayer *player = (__bridge EOCSoundPlayer*)clientData;</div><div class="line">    </div><div class="line">    if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) &#123;</div><div class="line">        </div><div class="line">        [player.delegate soundPlayerDidFinish:player];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@implementation EOCSoundPlayer &#123;</div><div class="line">    SystemSoundID _systemSoundID;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL *)url &#123;</div><div class="line">    </div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        </div><div class="line">        AudioServicesCreateSystemSoundID((__bridge CFURLRef)url,</div><div class="line">                                         &amp;_systemSoundID);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    AudioServicesDisposeSystemSoundID(_systemSoundID);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)playSound &#123;</div><div class="line">    </div><div class="line">    AudioServicesAddSystemSoundCompletion(</div><div class="line">                                          _systemSoundID,</div><div class="line">                                          NULL,</div><div class="line">                                          NULL,</div><div class="line">                                          completion,</div><div class="line">                                          (__bridge void*)self);</div><div class="line">    AudioServicesPlaySystemSound(_systemSoundID);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这看起来没什么问题，但是从这个目标文件的符号表中发现了一点不同，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">00000230 t -[EOCSoundPlayer .cxx_destruct]</div><div class="line">0000014c t -[EOCSoundPlayer dealloc]</div><div class="line">000001e0 t -[EOCSoundPlayer delegate]</div><div class="line">0000009c t -[EOCSoundPlayer initWithURL:]</div><div class="line">00000198 t -[EOCSoundPlayer playSound]</div><div class="line">00000208 t -[EOCSoundPlayer setDelegate:]</div><div class="line">00000b88 S _OBJC_CLASS_$_EOCSoundPlayer</div><div class="line">00000bb8 S _OBJC_IVAR_$_EOCSoundPlayer._delegate</div><div class="line">00000bb4 S _OBJC_IVAR_$_EOCSoundPlayer._systemSoundID</div><div class="line">00000b9c S _OBJC_METACLASS_$_EOCSoundPlayer</div><div class="line">00000000 T _completion</div><div class="line">00000bf8 s l_OBJC_$_INSTANCE_METHODS_EOCSoundPlayer</div><div class="line">00000c48 s l_OBJC_$_INSTANCE_VARIABLES_EOCSoundPlayer</div><div class="line">00000c78 s l_OBJC_$_PROP_LIST_EOCSoundPlayer</div><div class="line">00000c88 s l_OBJC_CLASS_RO_$_EOCSoundPlayer</div><div class="line">00000bd0 s l_OBJC_METACLASS_RO_$_EOCSoundPlayer</div></pre></td></tr></table></figure>
<p>注意符号表的中间部分，有一个符号叫做_completion。它是<code>completion</code>函数创建的用于在声音播放结束时做一些事情。即使它是在实现文件实现的，并且没有在头文件声明它，它依然作为顶级符号出现在这里。因此，如果某处创建的函数也叫做<code>completion</code>，那么将会出现一个错误，像下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _completion in: </div><div class="line">	build/EOCSoundPlayer.o </div><div class="line">	build/EOCAnotherClass.o</div></pre></td></tr></table></figure>
<p>更糟糕的是如果你把库给别人用，他们在自己的应用中使用它。如果你暴漏了一个类似<code>_completion</code>的符号，任何使用你这个库的人都可能会创建一个叫做<code>_completion</code>的函数，这是非常不幸的。</p>
<p>所以你应该给它加上类似于C函数的前缀。例如，在之前的例子中，你可以将<code>completion</code>命名为<code>EOCSoundPlayerCompletion</code>。如果符号曾在回溯堆栈时出现，即使出现问题，也是异域排查的。</p>
<p>当你使用第三方库或者将你的代码制作成库给别人使用时，你要特别小心重复符号的问题。当你在你的应用程序中使用了第三方库时，重复符号错误是容易发生的。在这种情况下，通常会使用自己的前缀去给所有的第三方库加上前缀。例如，如果你的库叫做<code>EOCLibrary</code>并且你添加了一个叫做<code>XYZLibrary</code>的库，你将给<code>XYZLibrary</code>添加<code>EOC</code>前缀。然后应用程序使用<code>XYZLibrary</code>时，就没有命名冲突的机会了，如图3.1。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%203.1.png" alt=""></p>
<p><strong>Figure 3.1</strong> 避免第三方库两次编译：一次应用程序本身另一次是库本身</p>
<p>仔细检查并更改所有的名字，看起来是件乏味的事情，但如果你想避免命名冲突，那是很有用的。你可能会问为什么需要这样做，并且为什么应用程序不能简单的包含<code>XYZLibrary</code>库本身并且使用它的实现。这也是可以的，但你考虑下面这个场景，你的应用程序包含另一个第三方库，叫做<code>ABCLibrary</code>，并且它也使用了<code>XYZLibrary</code>。在这种情况下，如果你和<code>ABCLibrary</code>库的作者都没有前缀，那么应用程序仍将发生重复符号的错误。或者你使用<code>XYZLibrary</code>的X版本，但是应用需要的功能是Y版本，那么它将会自动拷贝。如果你在开发的时候使用流行的第三方库，你将经常看到这种类型的前缀。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>选择一个适合的前缀，可以是公司名，应用名，或者都可以。并且一直使用这个前缀。</li>
<li>当你使用的第三方库依赖你自己的库，考虑给它的名字加上你的前缀。</li>
</ul>
<h3 id="提供指定的初始化器"><a href="#提供指定的初始化器" class="headerlink" title="提供指定的初始化器"></a>提供指定的初始化器</h3><p>所有的对象都需要初始化。当你初始化一个对象时，有时你不需要给他任何信息，有时需要。这种情况通常出现在没有信息就不能执行相应的方法的情况。例如，<code>iOS</code>的<code>UIKit</code>框架中的<code>UITableViewCell</code>，组中不同类型的cell需要不同的类型和标示符，这样可以使用cell对象的复用功能，而不需要一直去创建。在初始化时，赋予对象执行任务所需的信息，在术语上称为指定初始化器。</p>
<p>一个类中有多种方法去创建实例，那么这个类可能会有多个初始化方法。这是很好的，但是应该其余方法调用指定的初始化方法。一个例子是<code>NSDate</code>，像下面这样的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)init</div><div class="line">- (id)initWithString:(NSString*)string</div><div class="line">- (id)initWithTimeIntervalSinceNow:(NSTimeInterval)seconds</div><div class="line">- (id)initWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate*)refDate</div><div class="line">- (id)initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds</div><div class="line">- (id)initWithTimeIntervalSince1970:(NSTimeInterval)seconds</div></pre></td></tr></table></figure>
<p>上述情况中的指定初始化器是<code>- (id)initWithTimeIntervalSinceReferenceDate:</code>，类中的文档说明了这一点。它的意思是别的初始化方法其实都是调用了这个初始化方法。因此，指定的初始化器是存储内部数据的唯一地方。如果需要改变数据存储，那么仅需要改变这个方法就可以了。</p>
<p>例如，考虑一个代表范围的类。它的接口应该像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCRectangle : NSObject</div><div class="line">@property (nonatomic, assign, readonly) float width;</div><div class="line">@property (nonatomic, assign, readonly) float height;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意上述属性是只读(看第18节)的。这意味着矩形对象不能在外部修改它的属性。所以你可能创建一个这样的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width</div><div class="line">			andHeight:(float)height</div><div class="line">&#123;</div><div class="line">	if ((self = [super init])) &#123;</div><div class="line">		_width = width;</div><div class="line">		_height = height;</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果某些调用使用<code>[[EOCRectangle alloc] init]</code>去创建实例呢？这样做是合法的，因为<code>EOCRectangle</code>的父类是<code>NSObject</code>，<code>NSObject</code>实现了一个叫做<code>init</code>的方法，它将所有的对象设置为0(或者是等价于0的数据类型)。如果这个方法被调用，那么<code>EOCRectangle</code>实例的宽和高都将为0。虽然这可能是你想要的，但是你可能更喜欢设置一个默认值，或者通过抛出异常告诉调用者，必须使用你的指定的初始化方法。在<code>EOCRectangle</code>这种情况下，它可能会这样覆盖<code>init</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Using default values</div><div class="line">- (id)init &#123;</div><div class="line">	return [self initWithWidth:5.0f andHeight:10.0f];</div><div class="line">&#125;</div><div class="line">        </div><div class="line">// Throwing an exception</div><div class="line">- (id)init &#123;</div><div class="line">    @throw [NSException</div><div class="line">              exceptionWithName:NSInternalInconsistencyException</div><div class="line">              reason:@&quot;Must use initWithWidth:andHeight: instead.&quot;</div><div class="line">              userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意设置默认值的版本如何调用初始化方法的。它也可以通过直接设置<code>_width</code>和<code>_height</code>两个实例变量。然而，如果类的存储发生了一些变化。例如，通过一个结构体去存储宽和高的值的集合，你将会需要修改两个方法的逻辑。在这个简单例子中，这还不算坏，但是想象下一个复杂的类有很多初始化方法和复杂的数据。那么将会很容易忘记修改其中的一个，从而导致冲突。</p>
<p>想象下，你现在想去给<code>EOCRectangle</code>创建一个叫做<code>EOCSquare</code>的子类。这种使用场景很常见，但是初始化器该怎么办？很明显，应该强制宽和高相等，因为它是一个正方形！所以你可能决定这样创建初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCRectangle.h&quot;</div><div class="line"></div><div class="line">@interface EOCSquare : EOCRectangle</div><div class="line">- (id)initWithDimension:(float)dimension;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCSquare</div><div class="line"></div><div class="line">- (id)initWithDimension:(float)dimension &#123;</div><div class="line">    return [super initWithWidth:dimension andHeight:dimension];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>它将变成<code>EOCSquare</code>的初始化器。注意它如何调用父类的指定初始化器。如果你往回看了<code>EOCRectangle</code>的指定初始化器，你将会看到它也调用了父类的指定初始化器。指定初始化器链条是重要的。然而，它仍然可能调用<code>initWithWidth:andHeight:</code>或者<code>init</code>方法去创建对象。你当然不想这样喽，因为有人可能会创建一个宽高不一致的正方形。这是一个重要的点在你子类化某个类时。在子类中如果你有一个不同名字的指定初始化器，你应该总是覆盖指定初始化器。在<code>EOCSquare</code>这种情况下，你可以覆盖<code>EOCRectangle</code>的指定初始化器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</div><div class="line">    float dimension = MAX(width, height);</div><div class="line">    return [self initWithDimension:dimension];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意<code>EOCSquare</code>的指定初始化器是如何调用的。在这种实现情况下，如果调用者调用<code>init</code>方法，仍将产生神奇的事情。回想下<code>EOCRectangle</code>类，<code>init</code>方法的实现是去调用自身的指定初始化器，并且设置默认值。它仍然工作，但是因为<code>initWithWidth:andHeight:</code>方法已经被覆盖，所以它会调用<code>EOCSquare</code>的实现，它会依次调用初始化方法。这样一切正常，并不会创建一个宽高不等的正方形。</p>
<p>有时，你并不想去覆盖父类的指定初始化器，因为没有意义。例如，你可能会觉得一个<code>EOCSquare</code>对象使用<code>initWithWidth:andHeight:</code>方法创建很奇怪。你可能会认为它是一个使用错误。这种情况下，通常的做法是覆盖这个方法并且抛出一个异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</div><div class="line">    @throw [NSException</div><div class="line">           	 exceptionWithName:NSInternalInconsistencyException</div><div class="line">            	 reason:@&quot;Must use initWithDimension: instead.&quot;</div><div class="line">              userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这看起来有点过于严格，但有时是必要的，这样可以保持内部数据的一致性。在<code>EOCRectangle</code>和<code>EOCSquare</code>这种情况下，这意味着如果调用<code>init</code>方法会抛出错误，因为<code>init</code>方法会调用<code>initWithWidth:andHeight:</code>。这时，你可能会去重写<code>init</code>方法，并让其调用<code>initWithDimension:</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)init &#123;</div><div class="line">    return [self initWithDimension:5.0f];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，在<code>Objective-C</code>中，抛出异常代表这是一个致命错误(看21节)，如果不能初始化实例，抛出异常应该是最后的选择。</p>
<p>在一些情况下，你可能需要多个指定初始化器。当对象可以以两种不同方式去初始化，那么就需要不止一个指定初始化器了。一个例子是<code>NSCoding</code>的协议，这是一种序列化机制，允许对象进行编码和解码。这种机制在<code>Appkit</code>和<code>UIKit</code>中也是使用广泛的，这两个UI框架分别源于<code>Mac OS X</code>和<code>iOS</code>，并且给对象提供用XML序列化NIB的能力，视图控制器控制解压缩。</p>
<p><code>NSCoding</code>协议定义了序列化时应该实现下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithCoder:(NSCoder*)decoder;</div></pre></td></tr></table></figure>
<p>这种方法通常不是你的主要的指定初始化器，因为它还需要解码器去解码它。例外，如果父类也实现了<code>NSCoding</code>协议，那也需要调用父类的<code>initWithCoder:</code>方法。严格来说，你有两个指定初始化器，因为不止一个初始化方法调用父类的初始化方法。</p>
<p>应用到<code>EOCRectangle</code>类是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCRectangle : NSObject &lt;NSCoding&gt;</div><div class="line">@property (nonatomic, assign, readonly) float width;</div><div class="line">@property (nonatomic, assign, readonly) float height;</div><div class="line">- (id)initWithWidth:(float)width</div><div class="line">          andHeight:(float)height;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCRectangle</div><div class="line">// Designated initializer</div><div class="line">- (id)initWithWidth:(float)width</div><div class="line">          andHeight:(float)height</div><div class="line">&#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _width = width;</div><div class="line">        _height = height;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Superclass&apos;s designated initializer</div><div class="line">- (id)init &#123;</div><div class="line">    return [self initWithWidth:5.0f andHeight:10.0f];</div><div class="line">&#125;</div><div class="line">// Initializer from NSCoding</div><div class="line">- (id)initWithCoder:(NSCoder*)decoder &#123;</div><div class="line">    // Call through to super&apos;s designated initializer</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _width = [decoder decodeFloatForKey:@&quot;width&quot;];</div><div class="line">        _height = [decoder decodeFloatForKey:@&quot;height&quot;];</div><div class="line">    &#125;</div><div class="line">    return self; </div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意<code>NSCoding</code>的初始化方法，它调用了父类的初始化而不是它自己的初始化。然而，如果父类也实现了<code>NSCoding</code>，它将调用<code>NSCoding</code>自身的指定初始化器。例如下面的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCRectangle.h&quot;</div><div class="line"></div><div class="line">@interface EOCSquare : EOCRectangle</div><div class="line">- (id)initWithDimension:(float)dimension;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCSquare</div><div class="line">// Designated initializer</div><div class="line">- (id)initWithDimension:(float)dimension &#123;</div><div class="line">    return [super initWithWidth:dimension andHeight:dimension];</div><div class="line">&#125;</div><div class="line">// Superclass designated initializer</div><div class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</div><div class="line">    float dimension = MAX(width, height);</div><div class="line">    return [self initWithDimension:dimension];</div><div class="line">&#125;</div><div class="line">// NSCoding designated initializer</div><div class="line">- (id)initWithCoder:(NSCoder*)decoder &#123;</div><div class="line">    if ((self = [super initWithCoder:decoder])) &#123;</div><div class="line">        // EOCSquare&apos;s specific initializer</div><div class="line">    &#125;</div><div class="line">    return self; </div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>所有的初始化方法都调用到父类的实现，即<code>initWithCoder:</code>。子类在初始化的任何事情之前调用它，先完成父类的初始化。这样，<code>EOCSquare</code>也可以完全兼容<code>NSCoding</code>协议。如果你是调用你自己的初始化方法或者别的父类的初始化方法，对于<code>EOCSquare</code>的实例来说，<code>EOCRectangle</code>的<code>initWithCoder:</code>方法永远不会被调用，并且宽高两个实例变量永远不会被解码。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在你的类中指定初始化器，并且用文档标明它。所有的别的初始化器都应该调用它。</li>
<li>如果子类的初始化器不同于父类的初始化器，确保你覆写了父类的初始化器。</li>
<li>当子类覆写了父类的初始化器，不应该抛出异常。</li>
</ul>
<h3 id="实现description方法"><a href="#实现description方法" class="headerlink" title="实现description方法"></a>实现description方法</h3><p>在调试的时候，你经常会输出一个对象来获得有用的信息。其中一个办法是输出对象的所有属性，通常像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;object = %@&quot;, object);</div></pre></td></tr></table></figure>
<p>当你以字符串方式输出对象时，这时对象将调用<code>description</code>方法并且替代<code>%@</code>符号。所以，如果输出对象是一个数组，大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *object = @[@&quot;A string&quot;, @(123)];</div><div class="line">NSLog(@&quot;object = %@&quot;, object);</div></pre></td></tr></table></figure>
<p>它的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">object = (</div><div class="line">          &quot;A string&quot;,</div><div class="line">          123</div><div class="line">          )</div></pre></td></tr></table></figure>
<p>但是如果你尝试输出一个自己的类，你经常看到这样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object = &lt;EOCPerson: 0x7fd9a1600600&gt;</div></pre></td></tr></table></figure>
<p>这样的输出是没有数组的输出有帮助的。除非你在你的类中覆写了<code>description</code>方法，否则只会调用<code>NSObject</code>的默认实现。这个方法定义在<code>NSObject</code>协议中，但是<code>NSObject</code>类实现了它。<code>NSObject</code>协议有许多方法，它这样做的原因是<code>NSObject</code>并不是唯一根类。例如<code>NSProxy</code>是另一个根类，它遵循<code>NSObject</code>协议。因为其余根类的子类也可能需要实现协议中的某些方法。如你所见，默认实现并没有太大用。它仅仅展示了对象的类名以及内存地址。如果你仅仅想知道两个对象是不是相同，那它是有用的。然而你可能更想知道它更多的信息。</p>
<p>为了输出有用的东西，你需要去覆写<code>description</code>方法并且返回你想知道的信息。例如，考虑下面的类的描述方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line">               lastName:(NSString*)lastName;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line">               lastName:(NSString*)lastName &#123;</div><div class="line">    </div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        </div><div class="line">        _firstName = [firstName copy];</div><div class="line">        _lastName = [lastName copy];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个典型的<code>description</code>方法实现是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSString *)description &#123;</div><div class="line">    </div><div class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@\&quot;&gt;&quot;, </div><div class="line">    					[self class], self, _firstName, _lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你像这样调用它，它将输出这些信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&quot;Bob&quot;</div><div class="line">                                                lastName:@&quot;Smith&quot;];</div><div class="line">NSLog(@&quot;person = %@&quot;, person);</div><div class="line">// Output:</div><div class="line">// person = &lt;EOCPerson: 0x7fb249c030f0, &quot;Bob Smith&quot;&gt;</div></pre></td></tr></table></figure>
<p>这样的输出很清晰，并且输出了很多有用的信息。我建议应该像默认实现那样，展示类名和指针地址，因为它有时候是有用的。尽管之前的<code>NSArray</code>并没有输出这些，并且也没有明文规定。不过你在<code>description</code>方法中输出的应该是所用到的。</p>
<p>有一个简单的办法去实现包含大量信息的<code>description</code>方法，那就是在返回中包含字典。它的返回值大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    key: value;</div><div class="line">    foo: bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过在自己的<code>description</code>方法中形成一个字典并返回包含此词典的字符串。例如，下面的类描述一个位置对象包含一个标题和经纬度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCLocation : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *title;</div><div class="line">@property (nonatomic, assign, readonly) float latitude;</div><div class="line">@property (nonatomic, assign, readonly) float longitude;</div><div class="line"></div><div class="line">- (id)initWithTitle:(NSString*)title</div><div class="line">           latitude:(float)latitude</div><div class="line">          longitude:(float)longitude;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCLocation</div><div class="line"></div><div class="line">- (id)initWithTitle:(NSString*)title</div><div class="line">           latitude:(float)latitude</div><div class="line">          longitude:(float)longitude &#123;</div><div class="line">    </div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _title = [title copy];</div><div class="line">        _latitude = latitude;</div><div class="line">        _longitude = longitude;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果<code>description</code>方法能同时输出标题和经纬度就非常好了。如果使用字典，那么<code>description</code>方法可能像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (NSString *)description &#123;</div><div class="line">    </div><div class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;,</div><div class="line">            [self class],</div><div class="line">            self,</div><div class="line">            @&#123;@&quot;title&quot;:_title,</div><div class="line">              @&quot;latitude&quot;:@(_latitude),</div><div class="line">              @&quot;longitude&quot;:@(_longitude)&#125;</div><div class="line">            ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的输出是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location = &lt;EOCLocation: 0x7f98f2e01d20, &#123;</div><div class="line">    latitude = &quot;51.506&quot;;</div><div class="line">    longitude = 0;</div><div class="line">    title = London;</div><div class="line">&#125;&gt;</div></pre></td></tr></table></figure>
<p>这比刚才仅有指针和类名是有用多的，并且对象的所有属性都很好的展示了出来。你可以总是使用字符串去描述每个变量，但是当更多的属性被加入这个类，字典这种方法更易于操作。</p>
<p><code>NSObject</code>协议中另一个与之类似的方法叫做<code>debugDescription</code>。它们的不同在于<code>debugDescription</code>是在调式器中输出对象时调用的。<code>NSObject</code>类默认实现就是调用<code>description</code>方法。例如，以<code>EOCPerson</code>类为例，在调试器中运行应用程序，并且断点在输出对象之后，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&quot;Bob&quot;</div><div class="line">												lastName:@&quot;Smith&quot;];</div><div class="line">NSLog(@&quot;person = %@&quot;, person);</div><div class="line">// Breakpoint here</div></pre></td></tr></table></figure>
<p>当断点触发时，控制台准备接收输出。在LLDB调试器中，使用po命令输出对象，像下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EOCTest[640:c07] person = &lt;EOCPerson: 0x712a4d0, &quot;Bob Smith&quot;&gt;</div><div class="line">(lldb) po person</div><div class="line">(EOCPerson *) $1 = 0x0712a4d0 &lt;EOCPerson: 0x712a4d0, &quot;Bob Smith&quot;&gt;</div></pre></td></tr></table></figure>
<p>注意，调试器中加上了一些额外的信息<code>(EOCPerson *) $1 = 0x0712a4d0</code>。后面的部分来源于<code>debugDescription</code>方法。</p>
<p>你可能只想在<code>description</code>方法中展示正常的人名，在<code>debugDescription</code>方法展示更深入的信息。这种情况下，这两个方法看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSString*)description &#123;</div><div class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,</div><div class="line">            _firstName, _lastName];</div><div class="line">&#125;</div><div class="line">- (NSString*)debugDescription &#123;</div><div class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@\&quot;&gt;&quot;,</div><div class="line">             [self class], self, _firstName, _lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次运行相同的代码，并且打印对象，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EOCTest[640:c07] person = Bob Smith</div><div class="line">(lldb) po person</div><div class="line">(EOCPerson *) $1 = 0x07117fb0 &lt;EOCPerson: 0x7117fb0, &quot;Bob Smith&quot;&gt;</div></pre></td></tr></table></figure>
<p>这种做法是当你在正常调试时不需要看到类名、对象地址等额外信息，在调试器的环境下仍能轻松访问完整信息时使用。<code>Foundation</code>框架中的<code>NSArray</code>类就是一个很好的例子。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;Effective Objective-C 2.0&quot;, @(123), @(YES)];</div><div class="line">NSLog(@&quot;array = %@&quot;, array);</div><div class="line">// Breakpoint here</div></pre></td></tr></table></figure>
<p>这时，运行程序，在断点处停止，并且输出数组对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">EOCTest[713:c07] array = (</div><div class="line">    &quot;Effective Objective-C 2.0&quot;,</div><div class="line">    123,</div><div class="line">    1</div><div class="line">)</div><div class="line">(lldb) po array</div><div class="line">(NSArray *) $1 = 0x071275b0 &lt;__NSArrayI 0x71275b0&gt;(</div><div class="line">   Effective Objective-C 2.0,</div><div class="line">   123,</div><div class="line">   1</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>覆写<code>description</code>方法以提供实例的字符串描述。</li>
<li>如果想要对象在调试器中做更多事，那么覆写<code>debugDescription</code>方法。</li>
</ul>
<h3 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h3><p>在设计一个类时，理想情况下，考虑使用属性(看第6节)去存储数据。当使用属性时，你可以限制属性是只读的。默认情况下，属性是可读写的，这使你所有类都是可变的。然而，通常读取到数据之后是不需要改变的。例如，对象存储的数据来自只读的web service，如地图上的兴趣点列表，那么没有情况需要对象可变。如果这样的对象发生了改变，数据将不会被发送给服务器。如第8节所述，如果可变对象存储在集合中，则集合的内部数据结构很容易变得不一致。因此，我建议只在对象需要改变时，使用可变对象。</p>
<p>实际上，这意味着将外部属性设为只读，并且只暴漏需要暴漏的数据。例如，考虑一个类来处理地图上的兴趣点，这些数据来自web service。你可以像下面这样从某个类开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPointOfInterest : NSObject</div><div class="line">@property (nonatomic, copy) NSString *identifier;</div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, assign) float latitude;</div><div class="line">@property (nonatomic, assign) float longitude;</div><div class="line"></div><div class="line">- (id)initWithIdentifier:(NSString*)identifier</div><div class="line">                   title:(NSString*)title</div><div class="line">                latitude:(float)latitude</div><div class="line">               longitude:(float)longitude;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>所有的数据都来自web service，标示符是服务端给一个兴趣点的标记。一旦兴趣点被创建，并且从服务端拿到数据之后，就不应该在任何场景下去修改。在别的语言中，你可能会创建一个私有变量，并且仅有一个<code>getter</code>方法。然而，在<code>Objective-C</code>中，当你使用属性时，这是非常容易的并且不需要考虑私有变量。</p>
<p>为了使<code>EOCPointOfInterest</code>类不可变，你可以给所有的属性添加只读特质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPointOfInterest : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *identifier;</div><div class="line">@property (nonatomic, copy, readonly) NSString *title;</div><div class="line">@property (nonatomic, assign, readonly) float latitude;</div><div class="line">@property (nonatomic, assign, readonly) float longitude;</div><div class="line"></div><div class="line">- (id)initWithIdentifier:(NSString*)identifier</div><div class="line">                   title:(NSString*)title</div><div class="line">                latitude:(float)latitude</div><div class="line">               longitude:(float)longitude;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这确保任何人试图修改某个属性值，编译时都会报错。这些属性的值还可以正常读取，但不能改变，所以<code>EOCPointOfInterest</code>数据不会产生不同。因此，任何人使用这个对象的人都可以确信数据不会被修改的。对象自身的数据结构也不会变的不一致。这种情况下，地图上显示的<code>EOCPointOfInterest</code>对象兴趣点的经纬度都不用担心被修改。</p>
<p>你可能会想为什么会有内存管理语义，因为它是只读的，是没有<code>setter</code>方法的。好吧，你可以简化上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly) NSString *identifier;</div><div class="line">@property (nonatomic, readonly) NSString *title;</div><div class="line">@property (nonatomic, readonly) float latitude;</div><div class="line">@property (nonatomic, readonly) float longitude;</div></pre></td></tr></table></figure>
<p>但是，使用内存管理语义是有用的，对你之后将属性特质设置为读写也是容易的。</p>
<p>你可能希望在对象内部对数据进行修改，而不是外部。在这种情况下，通常的做法是重新声明它为读写特质。当然，当属性特质是非原子性时，多个线程同时读写会造成权限的竞争。这是可能的，在一个观察者读取的同时，在内部修改这个属性。这种情况应该被杜绝，所有的访问无论是内部的还是外部的，或者是不同的队列(看第41节)，都应该是同步的。</p>
<p>通过使用分类功能在类的内部将属性重新声明为读写特质。你可以像写在头文件一样重新声明它，只要拥有相同的特质和扩展的读写状态。在<code>EOCPointOfInterest</code>的例子中，类别中的声明可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCPointOfInterest.h&quot;</div><div class="line"></div><div class="line">@interface EOCPointOfInterest ()</div><div class="line"></div><div class="line">@property (nonatomic, copy, readwrite) NSString *identifier;</div><div class="line">@property (nonatomic, copy, readwrite) NSString *title;</div><div class="line">@property (nonatomic, assign, readwrite) float latitude;</div><div class="line">@property (nonatomic, assign, readwrite) float longitude;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPointOfInterest</div><div class="line">/* ... */</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>现在，这属性可以在<code>EOCPointOfInterest</code>类的实现内部进行修改了。更准确的说，通过使用KVC这种方法，在外部也可以对对象进行修改，例如下面这种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[pointOfInterest setValue:@&quot;abc&quot; forKey:@&quot;identifier&quot;];</div></pre></td></tr></table></figure>
<p>这是因为KVC是直接调用的<code>identifier</code>的<code>setter</code>方法，即使你这个方法并没有暴漏在头文件。然而，这样做被视为对类API的非法入侵，如果有什么问题，还是需要开发者自身去解决。</p>
<p>一个不讲道理的开发者可以通过在类上使用内省来确定类对象的内存布局中属性的实例变量的偏移量而不是<code>setter</code>方法。开发者可以通过这种办法去设置实例变量，但这种行为被视为对类API的非法入侵。但从技术上来说，围绕缺失了头文件的<code>setter</code>方法这种可能性，你不应该忽略使你的对象是不可变的。</p>
<p>在定义类的公共API时，要记住的另一点是集合类属性是否是可变的或不可变的。例如，你有一个代表人的类，并且可以存储这个人的朋友列表，你可能想使用一个属性去存储这个人的朋友列表。如果这个人的朋友会添加和删除，那么这个属性应该设置为可变的。在这种情况下，应该暴漏一个只读特质并且不可变的集合，但它其实是拷贝了内部的可变集合。例如，像下面类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSSet *friends;</div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson ()</div><div class="line"></div><div class="line">@property (nonatomic, copy, readwrite) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readwrite) NSString *lastName;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson &#123;</div><div class="line"></div><div class="line">    NSMutableSet *_internalFriends;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSSet*)friends &#123;</div><div class="line">    </div><div class="line">    return [_internalFriends copy];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (void)addFriend:(EOCPerson*)person &#123;</div><div class="line">    </div><div class="line">    [_internalFriends addObject:person];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">- (void)removeFriend:(EOCPerson*)person &#123;</div><div class="line">    </div><div class="line">    [_internalFriends removeObject:person];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _firstName = firstName;</div><div class="line">        _lastName = lastName;</div><div class="line">        _internalFriends = [NSMutableSet new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你也可以直接将<code>friends</code>属性设置为可变集合并通过直接操作集合去删除和增加朋友，而不是通过<code>addFriend:</code>和<code>removeFriend:</code>方法。但是这样数据就能随意修改，容易产生bug。如果<code>EOCPerson</code>类中的朋友集合可以被外部改变，这可能会造成一些问题。例如，当添加朋友或者删除朋友时，这个对象想做一些别的事情，这时，这个对象就会变得不一致。</p>
<p>在这点上，同样重要的是不要给你反回的对象做内省，去判断它是否是可变的。例如，你可能使用一个包含<code>EOCPerson</code>类的库。库的开发者可能没有返回一个内部可变集合的拷贝，而是直接返回了可变集合本身。如果这个集合非常大，这是合法合理的，因为拷贝的代价太大。它返回一个<code>NSMutableSet</code>是合法的，因为它是<code>NSSet</code>的子类，在这种情况下，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EOCPerson *person = /* ... */;</div><div class="line">NSSet *friends = person.friends;</div><div class="line">if ([friends isKindOfClass:[NSMutableSet class]]) &#123;</div><div class="line">    NSMutableSet *mutableFriends = (NSMutableSet*)friends;</div><div class="line">    /* mutate the set */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论如何，你应该避免这种写法。你并没有跟<code>EOCPerson</code>类预定什么，所以你不应该在此处使用内省。重点是，这个对象可能没办法处理你要的操作。因此，你不应该假设它可以。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>尽量创建不可变对象。</li>
<li>如果属性需要在内部设置，那么暴露给外部的应该设置为只读，在类别中设置为读写。</li>
<li>通过方法去操作可变集合，而不是直接暴漏可变集合本身。</li>
</ul>
<h3 id="使用清晰而协调的命名方式"><a href="#使用清晰而协调的命名方式" class="headerlink" title="使用清晰而协调的命名方式"></a>使用清晰而协调的命名方式</h3><p>在<code>Objective-C</code>中，类的命名，方法的命名，变量的命名等等都是重要的因素。新手总是说语言冗长，因为使用的语法结构可以像自然语言一样阅读。命名的时候常常包括一些介词(in、for、with等等)，而别的语言经常忽略这些。例如，考虑下面的代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *text = @&quot;The quick brown fox jumped over the lazy dog&quot;;</div><div class="line">NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;fox&quot; withString:@&quot;cat&quot;];</div></pre></td></tr></table></figure>
<p>上述代码经常被认为是把一个简单的表达式复杂成了一句啰嗦的话。毕竟，执行的替换方法长达48个字符。但是它读起来像一句话：“使用<code>cat</code>字符串替换<code>text</code>字符串中的<code>fox</code>字符串并且赋值给一个新的字符串。”</p>
<p>这句话完美的表达了正在发生的事情。在不冗长的语言中，大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string text = &quot;The quick brown fox jumped over the lazy dog&quot;;</div><div class="line">string newText = text.replace(&quot;fox&quot;, &quot;cat&quot;);</div></pre></td></tr></table></figure>
<p>但是上面的命令中，<code>text.replace</code>的参数是什么意思？<code>fox</code>字符串替代<code>cat</code>，还是相反？而且，替换函数替换所有字符还是第一个？这非常不清晰。虽然<code>Objective-C</code>的语法更长，但是却非常清晰。</p>
<p>你还会注意到不论是变量名还是方法名，使用的都是首字母小写的骆驼式命名法。另外，类名是以大写字母开头并且带有两个或者三个字符的前缀（看第15节）。这个风格遍布整个<code>Objective-C</code>代码。如果你愿意你可以使用你自己的风格，但是在<code>Objective-C</code>中骆驼风格将确保你命名的健壮。</p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>如果你之前学过别的语言，例如<code>C++</code>或者<code>Java</code>，你习惯于函数命名的简洁，并且必须查看函数原型以确定参数做什么。然而，这使得代码难以阅读，因为你经常需要返回原型来记住函数的作用。例如，考虑一个代表范围的类。在<code>C++</code>中，你可能这样定义它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">public:</div><div class="line">    Rectangle(float width, float height);</div><div class="line">    float getWidth();</div><div class="line">    float getHeight();</div><div class="line">private:</div><div class="line">    float width;</div><div class="line">    float height;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你不熟悉<code>C++</code>，那也没关系。你只需要意识到有一个叫做<code>Rectangle</code>的类，里面有两个实例变量，宽和高。它也有一个接受宽和高的方法用于创建类的实例，叫做构造器。它也有宽高的访问方法。当使用这个类时，你会这样创建实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rectangle *aRectangle = new Rectangle(5.0f, 10.0f);</div></pre></td></tr></table></figure>
<p>当你回头看这些代码时，你不能清楚的知道<code>5.0f</code>和<code>10.0f</code>代表什么。你大概可以猜到它是构成矩形的宽高，但你知道第一个参数是宽还是高？你需要回头去看看定义的构造方法。</p>
<p><code>Objective-C</code>通过更长的方法命名解决了这个问题。与上述<code>C++</code>代码等价的<code>Objective-C</code>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCRectangle : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign, readonly) float width;</div><div class="line">@property (nonatomic, assign, readonly) float height;</div><div class="line"></div><div class="line">- (id)initWithSize:(float)width :(float)height;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样的写法可以轻松的知道等价的构造器方法和方法名叫做<code>initWithSize:</code>。你可能认为它很奇怪或者在第二个参数的冒号前面没有字符是语法错误的。实际上，语法是非常合理的，但它犯了和<code>C++</code>函数命名一样的毛病。如果你使用这个类，你会在相同的位置看到这个问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCRectangle *aRectangle = </div><div class="line">	[[EOCRectangle alloc] initWithSize:5.0f :10.0f];</div></pre></td></tr></table></figure>
<p>一个更好的写法是像下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWidth:(float)width andHeight:(float)height;</div></pre></td></tr></table></figure>
<p>这是冗长的，但对于使用时，每个变量的意思都是清晰的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCRectangle *aRectangle =	[[EOCRectangle alloc] initWithWidth:5.0f andHeight:10.0f];</div></pre></td></tr></table></figure>
<p>新手往往很难使用<code>Objective-C</code>冗长的命名，尽管冗长的命名可以增加代码的可读性。不要害怕使用长的方法名。确保方法名是他们需要表达的，但不是让你使用极长的命名。你的方法名应该统一和清晰。</p>
<p>以<code>EOCRectangle</code>类为例子。好的方法命名像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (EOCRectangle*)unionRectangle:(EOCRectangle*)rectangle</div><div class="line">- (float)area</div></pre></td></tr></table></figure>
<p>不好的的方法命名像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (EOCRectangle*)union:(EOCRectangle*)rectangle // Unclear</div><div class="line">- (float)calculateTheArea // Too verbose</div></pre></td></tr></table></figure>
<p>清楚地方法命名就像读一篇文章一样，从左到右阅读。遵循方法命名规则并不是强制的，但这样做将会确保你的代码易于维护和被其他人阅读。</p>
<p><code>NSString</code>类是一个好的命名示例，它遵循了良好的命名规则。这有一些它的方法以及为什么这样命名的解释：</p>
<p><strong>+ string</strong></p>
<p>这是一个工厂方法，用于创建一个新的空字符串。通过方法名表示返回值。</p>
<p><strong>+ stringWithString:</strong> </p>
<p>这是一个工厂方法，使用另一个字符串创建一个新的字符串。同创建空的字符串的工厂方法一样，它通过方法名的第一个单词表示返回值。</p>
<p><strong>+ localizedStringWithFormat:</strong></p>
<p>这是一个工厂方法，使用指定的格式去创建一个本地化的字符串。它的返回值是方法名的第二个单词，这是因为对返回类型进行修饰是合理的。尽管它返回的仍然是字符串，但它是一种更具体的字符串，因为它已经本地化了。</p>
<p><strong>- lowercaseString</strong></p>
<p>将一个字符的所有字符转化为小写。它创建了一个新的字符串而不是转化者本身，因此它遵循返回类型作为方法名的一部分的规则。不过修饰符仍应在类型之前。</p>
<p><strong>- intValue</strong></p>
<p>将字符串解析为整数。因为它的返回类型是<code>int</code>，所以它的第一个单词是<code>int</code>。通常你不会缩写类型。例如<code>string</code>不会缩写成<code>str</code>。<code>int</code>是类型名字，所以方法名的后缀带有<code>value</code>而不是单一单词。单一单词通常用在属性上面。因为<code>int</code>不是属性，所以添加<code>value</code>限制它。</p>
<p><strong>- length</strong></p>
<p>获取字符串的长度。这是一个单独的短语，因为它实际上是一个字符串的属性。对于这个方法有一个不好的名字，叫做<code>stringLength</code>。<code>string</code>这个单词是多余的，因为这个方法的接收者本身就是个字符串。</p>
<p><strong>- lengthOfBytesUsingEncoding:</strong></p>
<p>获取使用给定编码方式编码的字节数组长度。这与<code>length</code>方法类似，所以可以用同样的理由解释。另外，这个方法需要一个参数。方法名称在描述其类型的名词之后立即放置参数。</p>
<p><strong>- getCharacters:range:</strong></p>
<p>在字符串的给定范围内获取单个字符。这是一个例子，因为这不是一个访问方法，所以添加<code>get</code>前缀，不像一些其他的语言。这里使用的原因是字符是通过作为第一个参数传入的数组返回的。完整的方法签名如下：</p>
<p><strong>- (void)getCharacters:(unichar*)buffer range:(NSRange)aRange</strong></p>
<p>第一个参数，缓冲区，应该是指向足够容纳所请求范围内字符的数组的指针。该方法通过一个参数（通常称为<code>out-parameter</code>）返回，而不是通过返回值，因为它从内存管理角度更有意义。该方法的调用者处理所有内存管理，而不是由方法执行创建，并要求调用方释放它。第二个参数是以名词描述其类型，就像正常参数一样。有时，这些参数名前面都有一个介词；例如，这个方法可以叫做<code>getCharacters:inRange:</code>。如果参数超过其他参数需要额外的意义，通常是这样做的。</p>
<p><strong>- hasPrefix:</strong></p>
<p>确定字符串前缀是否是给定字符。它的返回值是一个Bool值，所以通常这样使用它，像读句子一样。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[@&quot;Effective Objective-C&quot; hasPrefix:@&quot;Effective&quot;] == YES</div></pre></td></tr></table></figure>
<p>如果方法名是<code>prefix:</code>，它不容易理解的。相似的，如果是<code>isPrefixedWith:</code>，它是太长的并且听起来也过于笨拙。</p>
<p><strong>- isEqualToString:</strong></p>
<p>确定两个字符串是否相等。它的返回值是一个Bool值，就像上面的<code>hasPrefix:</code>方法一样，方法的名称确保该方法像句子一样阅读。另一个使用<code>is</code>前缀的地方是Bool属性。如果属性名是<code>enabled</code>，例如它的访问方法是<code>setEnabled:</code>和<code>isEnabled</code>。总之，遵循一些规则将帮助你给方法命名。</p>
<ul>
<li>如果方法返回一个新值，那么方法的第一个单词应该是它的类型，除非它需要一个修饰词，例如<code>localizedString</code>方法。这个规则不适用于属性访问器，因为他们在逻辑上没有创建一个新的对象。即使它们可能会返回一个拷贝的内部对象。这些访问器方法代表属性本身。</li>
<li>一个参数应该紧挨着一个描述它类型的名词。</li>
<li>如果一个对象需要参数来执行操作，那么导致对象上发生动作的方法应该包含一个动词，然后是一个名词（或多个名词）。</li>
<li>不要使用缩写，例如<code>str</code>，使用全名，例如<code>string</code>。</li>
<li>Bool属性的前缀应该使用<code>is</code>。方法返回一个Bool值但不应该直接返回属性应该带有<code>has</code>或者<code>is</code>前缀，这取决于你使用的场景。</li>
<li>使用前缀<code>get</code>的方法，返回值应该是某个输出参数，例如填充C风格的数组。</li>
</ul>
<h4 id="类名和协议名"><a href="#类名和协议名" class="headerlink" title="类名和协议名"></a>类名和协议名</h4><p>应该给类和协议提供前缀以避免命名空间冲突（看第15节）并且应该结构化，使它们从左到右阅读，就像方法一样。例如，<code>NSArray</code>类和它的对应可变类<code>NSMutableArray</code>，<code>mutable</code>应该在<code>array</code>之前，因为它描述了一个指定的类型。</p>
<p>为了说明命名惯例，考虑下面<code>UIKit</code>中的类：</p>
<p><strong>UIView (class)</strong></p>
<p>所有的视图都继承自这个类。它们是用户界面的构建块，执行按钮、文本字段和表的绘制。类的名字是对它的解释以及整个<code>UIKit</code>框架的<code>UI</code>前缀。</p>
<p><strong>UIViewController (class)</strong></p>
<p>一个视图处理绘画视图但不负责控制在视图中显示。这就是这个类的工作：一个“视图控制器”。它以这样的方式命名，它保持左到右可读性。</p>
<p><strong>UITableView (class)</strong></p>
<p>这是一个特定的视图，用于显示列表数据。所以给父类名字添加特定前缀来区别视图的种类。在命名管理中，使用给父类加前缀是常见的。它可以被命名为<code>UITable</code>，但这样不能清除的指出它是一个视图。你需要查找接口声明以确定它是什么。如果你要创建一个表格视图用于显示图像，你可以创建一个子类叫做<code>EOCImageTableView</code>。例如，你总是使用自己的前缀，而不是父类的前缀。原因是你没有权利向另一个框架的命名空间添加一些东西，而另一个框架可能决定在将来创建一个同名的类。</p>
<p><strong>UITableViewController (class)</strong></p>
<p>正如表格是一种特定的视图，这是一种特殊的视图控制器专门设计用来控制表格视图。因此，它以类似的方式命名。</p>
<p><strong>UITableViewDelegate (protocol)</strong></p>
<p>该协议定义了一个接口，通过该接口，表格视图可以与另一个对象通信，并以它定义委托接口的类命名，从而保证了正确的可读性。（关于委托模式的更多信息，请参阅项目23）。</p>
<p>最重要的是，你应该使你的命名保持一致。另外，如果你的类在另一个框架，确保遵守命名约定。例如，你创建一个视图的子类，那么类名的后缀应该加上<code>view</code>。类似地，如果创建了自己的委托协议，则应该将它命名为它代表的类，带有<code>Delegate</code>后缀。坚持这种命名结构将确保当你或其他人稍后使用它时，你的代码是易懂的。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>创建接口时，遵循<code>Objective-C</code>的命名规则，接口将会是健壮的。</li>
<li>确保方法名称简洁而精确，并使其使用像阅读句子一样从左向右。</li>
<li>在方法命中避免使用类型缩写。</li>
<li>最重要的是，确保你自己的代码中方法名的一致性。</li>
</ul>
<h3 id="为私有方法名加前缀"><a href="#为私有方法名加前缀" class="headerlink" title="为私有方法名加前缀"></a>为私有方法名加前缀</h3><p>一个类做的事情远比外部调用多的多。编写类实现时，通常会编写一些给类内部使用的方法。对于这样的方法，我建议给它们的名称加上前缀。通过将公共方法与私有方法区分开来，有助于调试。</p>
<p>给私有方法加标记的另一个原因是在修改方法名时易于区分。如果一个方法是公开的，那么修改它时应该加倍小心，因为可能对外部造成影响。因此，这个类的使用者也需要进行修改。但是，如果该方法是内部方法，则只有类自己的代码需要更改，对公开的API没有影响。对私有方法进行标记意味着在进行这种更改时很容易看出区别。</p>
<p>要使用什么样的前缀看你个人喜好，但我有一个好的选择是前缀包含一个字母<code>p</code>和<code>_</code>。因为<code>p</code>代表<code>private</code>，<code>_</code>在方法名开始之前有了视觉的差距。方法名仍继续使用骆驼命名法，即第一个字母小写。例如，一个叫做<code>EOCObject</code>的类，它的私有方法可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCObject : NSObject</div><div class="line"></div><div class="line">- (void)publicMethod;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCObject</div><div class="line"></div><div class="line">- (void)publicMethod &#123; /* ... */</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_privateMethod &#123; /* ... */</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>与公共方法不同，私有方法不会出现在接口定义中。有时，您希望在类扩展中声明私有方法（看第27节）；然而，最近的编译器修改意味着在使用方法之前不需要声明它。通常，私有方法只能在它们的实现中声明。</p>
<p>如果你是从<code>C++</code>或者<code>Java</code>转行过来的，你可能会很疑问为什么只加前缀，而不是声明它为私有方法。在目标<code>Objective-C</code>中，没有办法将方法标记为私有的。所有的对象都能相应所有的消息(看第12节)，并且可以在运行时决定是否相应某个消息(看第14节)。<code>Objective-C</code>是在运行时执行给定消息的查找的，并且没有机制去限制什么东西、什么时候、什么范围影响消息。只剩下命名约定来指定语义，如私有方法。新手可能对这种方式感到不太舒服，但<code>Objective-C</code>就是这样一门语言，需要你去接受它的动态性和活力。但是动态性也是需要规则的，使用命名约定是实现这一目标的一种方法。</p>
<p>苹果倾向于使用单一下划线来作为它私有方法的前缀。所以你可能认为遵循苹果的提示并使用下划线是个好主意。然而，这有一个潜在的灾难性的问题；如果你继承了一个苹果的类，并在这个子类中使用了这种方法，你可能会无意中覆盖苹果的一个私有方法。基于这个原因，苹果已经说明了你应该避免使用下划线作为前缀。动态方法调度，从无法给方法指定作用域这点来看，这是不好的地方，但从另一方面看，它又是强大的。</p>
<p>覆盖苹果私有方法这种情况是常有的，例如，如果你正在创建一个<code>iOS</code>应用的视图控制器，你需要子类化<code>UIViewController</code>。视图控制器可以有很多状态，你需要一个清楚所有状态的方法，当你的控制器出现在屏幕上时，调用这个方法。因此，你可能会实现这样的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface EOCViewController : UIViewController</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCViewController</div><div class="line"></div><div class="line">- (void)_resetViewController &#123;</div><div class="line">    // Reset state and views</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然而，<code>UIViewController</code>也实现了一个叫做<code>_resetViewController</code>的私有方法。从你写了这个私有方法开始，当你调用它时，总是会调用<code>EOCViewController</code>的这个方法，而不是<code>UIViewController</code>的。除非你深入了解这个库，否则你不会你知道这一点，因为这个方法并未暴漏出来。毕竟，这是一种用下划线表示的私有方法。在这种情况下，你的视图控制器可能会发生一些奇怪的事情，因为<code>UIViewController</code>的实现未被调用，或者你会诧异为什么这个方法的调用次数过于频繁。</p>
<p>总之，当你在一个既不是苹果也不是你自己的框架中对类进行子类化时，除非文档说明，否则你无法知道框架使用的什么私有前缀（如果有的话）。在这种情况下，你可以选择使用你的类前缀（看第15节）作为私有方法前缀，从而大大减少潜在冲突的风险。同样，你也应该考虑其他人也可能会子类化你的类。这就是为什么你应该为私有方法名添加前缀。如果没有实现的源代码，除非使用非常复杂的工具，否则没有办法找出类实现的私有方法。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>给私有方法名添加前缀，这样很容易与公共方法区别开来。</li>
<li>避免使用单个下划线作为方法前缀，因为这是由苹果使用的。</li>
</ul>
<h3 id="理解objective-c错误模型"><a href="#理解objective-c错误模型" class="headerlink" title="理解objective-c错误模型"></a>理解objective-c错误模型</h3><p>许多现代语言，包括<code>Objective-C</code>，都有异常处理。如果你是一个java后台，你可能习惯于使用异常来处理错误情况。如果你习惯于异常处理任务，你需要忘记你知道的关于异常的一切并重新开始。</p>
<p>首先要注意的是，默认情况下异常机制在<code>ARC</code>(看第30节)下是不安全的。实际上，这个意思是任何该在异常作用域结束时释放的对象都不会被释放。当然你可以通过打开一个编译器标志使异常得到安全处理，但是这需要引入额外的代码，并且即使没有抛出异常，这部分额外代码也需要运行。这个编译器标志是<code>-fobjc-arc-exceptions</code>。</p>
<p>即使不使用<code>ARC</code>，也很难写出不会引起内存泄露的安全代码。假设一个资源被创建并在不再需要时释放它。如果在资源释放之前抛出异常，则该资源将永远无法释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">id someResource = /* ... */;</div><div class="line">if ( /* check for error */ ) &#123;</div><div class="line">    @throw [NSException exceptionWithName:@&quot;ExceptionName&quot;</div><div class="line">                                   reason:@&quot;There was an error&quot;</div><div class="line">                                 userInfo:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[someResource doSomething];</div><div class="line">[someResource release];</div></pre></td></tr></table></figure>
<p>当然，解决这个问题的办法就是把释放代码放在抛出异常之前。但是，如果有很多的资源释放和更复杂的代码路径，代码很容易变得杂乱。另外，如果在这样的代码中添加了某些代码，那么在抛出异常之前，很容易忘记添加释放。</p>
<p><code>Objective-C</code>现在使用的方法是只抛出重大异常，并且不需要再恢复了，即直接退出应用程序。这样就不用再考虑异常安全的代码了。</p>
<p>记住异常只能用于致命错误，例如当你创建了一个抽象基类，别人使用基类初始化或者未覆盖初始化方法时抛出异常。<code>Objective-C</code>不像其他语言一样，它没有构造方法一说。因此达到这个目的的最简单办法就是如果子类未重写父类必须重写的办法，那就抛出异常。任何试图使用基类创建实例的做法都将会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)mustOverrideMethod &#123;</div><div class="line">    NSString *reason = [NSString stringWithFormat:</div><div class="line">                        @&quot;%@ must be overridden&quot;,</div><div class="line">                        NSStringFromSelector(_cmd)];</div><div class="line">    @throw [NSException</div><div class="line">        exceptionWithName:NSInternalInconsistencyException</div><div class="line">                   reason:reason</div><div class="line">                 userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果异常仅适用于致命错误，那么其他类型的错误呢？当错误发生时，<code>Objective-C</code>的通常选择是返回<code>nil</code>或者<code>0</code>，或者是使用<code>NSError</code>。有一个例子就是当初始化失败，返回<code>nil</code>或者<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (id)initWithValue:(id)value &#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        if ( /* Value means instance can&apos;t be created */ ) &#123;</div><div class="line">            self = nil;</div><div class="line">        &#125; else &#123;</div><div class="line">        // Initialize instance</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这种情况下，如果<code>value</code>值为空，则实例不能创建，将<code>self</code>设置为<code>nil</code>，并且返回<code>nil</code>。这样初始化的方法将知道发生了一个错误，因为没有实例被创建。</p>
<p>使用<code>NSError</code>可以提供许多的灵活性，因为可以将错误返回给调用者。一个<code>NSError</code>对象封装了三条信息：</p>
<p><strong>Error domain (String)</strong></p>
<p>错误产生的范围。这个通常是一个全局变量，用于表示错误的根源。例如，<code>NSURL</code>的处理系统，如果在获得数据时发生了错误，那么就会使用<code>NSURLErrorDomain</code>来表示。</p>
<p><strong>Error code (Integer)</strong></p>
<p>唯一的错误代码，用于指示错误域内具体的错误。通常，使用枚举来代表多种错误情况的集合。例如，<code>HTTP</code>请求失败时的<code>HTTP</code>状态码。</p>
<p><strong>User info (Dictionary)</strong></p>
<p>有关此错误的额外信息，例如一个本地化字符串或者导致该错误的别的错误信息，这样可以构成一个错误链。</p>
<p>在API设计中，<code>NSError</code>的第一种常见用法是通过委托协议传递。当错误发生时，该错误会通过协议的某个方法传递给调用者。例如，<code>NSURLConnection</code>的协议<code>NSURLConnectionDelegate</code>包含了下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</div></pre></td></tr></table></figure>
<p>当一个连接出现错误时，例如一个远程连接超时，就会调用此方法处理相关错误。这个代理方法不是必须实现的，这取决于使用者是否想知道有关错误。这比直接抛一个异常要好，因为它可以由使用者去决定是否实现。</p>
<p>另一个常用的使用方式是将<code>NSError</code>对象作为方法的一个参数。它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)doSomething:(NSError**)error</div></pre></td></tr></table></figure>
<p>传递给方法的是一个指针，而这个指针又指向一个指针，这个才是指向<code>NSError</code>对象的。或者也可以把它当做一个直接指向<code>NSError</code>对象的指针。这样可以使方法在经由输出参数返回错误信息的同时还能返回一个普同的值。用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">BOOL ret = [object doSomething:&amp;error];</div><div class="line">if (error) &#123;</div><div class="line">    // There was an error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常像这样返回错误的方法也会返回一个<code>Bool</code>值用来表示操作成功或者失败。如果你不关心错误信息，你可以直接判断<code>Bool</code>值，反之，你可以判断错误信息。当你不在乎错误信息时，你可以将它设置为<code>nil</code>。比如说，你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL ret = [object doSomething:nil];</div><div class="line">if (ret) &#123;</div><div class="line">    // There was an error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，当使用ARC时，编译器会自动将<code>NSError**</code>转化成<code>NSError*__autoreleasing*</code>；这意味着这个指针对象将会自动释放。这个对象必须自动释放，因为<code>doSomething:</code>这个方法不能保证调用者会释放<code>NSError</code>对象，所以必须加入<code>autorelease</code>。这与大部分方法的返回值语义相同了（以new、alloc、copy、mutableCopy开头的方法当然不在此列）。</p>
<p>方法通过输出参数返回错误类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (BOOL)doSomething:(NSError**)error &#123;</div><div class="line">    // Do something that may cause an error</div><div class="line">    if ( /* there was an error */ ) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            // Pass the &apos;error&apos; through the out-parameter</div><div class="line">            *error = [NSError errorWithDomain:domain code:code</div><div class="line">                                 userInfo:userInfo];</div><div class="line">        &#125;</div><div class="line">        return NO; ///&lt; Indicate failure</div><div class="line">    &#125; else &#123;</div><div class="line">        return YES; ///&lt; Indicate success</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过使用<code>*error</code>语法，为错误参数解引用，这意味着错误参数所指的那个指针要指向新的<code>NSError</code>对象了。这个错误参数必须检测它是否为空，因为空指针解引用会导致段错误并且程序崩溃。因为调用者可能会将其设为空，所以必须判断这种情况。</p>
<p><code>NSError</code>对象里的错误范围、错误码、额外的错误信息将根据错误的具体情况填入适当的内容。这使得调用者可以根据不同错误情况进行不同的处理。错误范围最好定义为一个全局常量字符串，错误码最好是枚举类型。例如，你可以这样定义它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// EOCErrors.h</div><div class="line">extern NSString *const EOCErrorDomain;</div><div class="line"></div><div class="line">typedef NS_ENUM(NSUInteger, EOCError) &#123;</div><div class="line">    EOCErrorUnknown = 1,</div><div class="line">    EOCErrorInternalInconsistency = 100,</div><div class="line">    EOCErrorGeneralFault = 105,</div><div class="line">    EOCErrorBadInput = 500,</div><div class="line">&#125;;</div><div class="line">// EOCErrors.m</div><div class="line">NSString *const EOCErrorDomain = @&quot;EOCErrorDomain&quot;;</div></pre></td></tr></table></figure>
<p>在你的库中创建一个错误范围是考虑周到的，因为它允许你创建并且返回一个<code>NSError</code>对象，使用者可以确定它来自你的库。为错误码创建一个枚举类型是好的主意，因为它记录具体的错误并且给代码一个有意义的名字。你甚至可以在头文件以注释形式定义更多更详细的错误信息。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>仅应在发生致命错误导致程序崩溃时使用<code>NSExceptions</code>。</li>
<li>对于不致命的错误，提供一个协议方法处理错误或者传入一个<code>NSError</code>对象是好的办法。</li>
</ul>
<h3 id="理解NSCopying协议"><a href="#理解NSCopying协议" class="headerlink" title="理解NSCopying协议"></a>理解NSCopying协议</h3><p>我们经常会对一个对象就行拷贝。在<code>Objective-C</code>中，是通过<code>copy</code>方法进行拷贝的。而对类进行拷贝的方法是实现<code>NSCopying</code>协议，它只包含了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone*)zone</div></pre></td></tr></table></figure>
<p>以前的空间是使用不同的段内存的并且创建对象都是一个确定的空间。现在，每一个应用都只有一个空间：默认空间。虽然你还需要实现这个协议方法，但是你不需要担心那个空间参数。</p>
<p>这个拷贝方法在<code>NSObject</code>实现了，但仅仅是通过默认空间调用了<code>copyWithZone:</code>。不止<code>copy</code>方法需要覆盖重写，<code>copyWithZone:</code>也需要覆盖重写。</p>
<p>为了让类支持拷贝，你需要遵循<code>NSCopying</code>协议，并且实现协议中唯一的方法。例如，有个表示人的类。在这个类的接口中，你需要声明你遵循<code>NSCopying</code>协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject &lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line">            andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后，你需要实现这个协议的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone*)zone &#123;</div><div class="line">    EOCPerson *copy = [[[self class] allocWithZone:zone]</div><div class="line">                       initWithFirstName:_firstName</div><div class="line">                             andLastName:_lastName];</div><div class="line">    return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子简单的使用初始化方法进行了复制。有时，你可能需要更进一步的工作，例如，你要拷贝的某个对象并没有在初始化方法中进行赋值。例如，<code>EOCPerson</code>类有一个数组用于表示这个人的朋友，并且通过一些方法去增加和删除其余的<code>EOCPerson</code>对象。在这种情况下，你还需要复制好友数组。下面是一个完整的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject &lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line">            andLastName:(NSString*)lastName;</div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson &#123;</div><div class="line">    </div><div class="line">    NSMutableSet *_friends;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123;</div><div class="line">    </div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _firstName = [firstName copy];</div><div class="line">        _lastName = [lastName copy];</div><div class="line">        _friends = [NSMutableSet new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person &#123;</div><div class="line">    </div><div class="line">    [_friends addObject:person];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFriend:(EOCPerson*)person &#123;</div><div class="line">    </div><div class="line">    [_friends removeObject:person];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)copyWithZone:(NSZone*)zone &#123;</div><div class="line"></div><div class="line">    EOCPerson *copy = [[[self class] allocWithZone:zone]</div><div class="line">                       initWithFirstName:_firstName</div><div class="line">                             andLastName:_lastName];</div><div class="line">    copy-&gt;_friends = [_friends mutableCopy];</div><div class="line">    </div><div class="line">    return copy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这一次，这个协议方法有了一些变化，增加了对<code>_friends</code>变量的拷贝。注意这里使用了<code>-&gt;</code>语法，因为这是一个内部变量。其实也可以声明为一个属性，但因为从未在外部使用，所以也就没什么必要了。</p>
<p>这个例子引出了一个有趣的问题：为什么要拷贝<code>_friends</code>变量？你可以不进行拷贝，这样每个对象都将使用相同的可变集合。但是这样做的话，当原始对象的<code>_friends</code>变量添加了一个朋友，那么所有拷贝的对象都将添加一个朋友。这显然不是你想要的。但是如果集合是不可变的，那么您可以选择不拷贝，反正集合不能修改，并且这样可以避免内存中存在两个完全一样的集合。</p>
<p>通常情况下，应该像本例这样，使用指定的初始化器去进行拷贝。但是有些时候不需要这样做，因为初始化方法有时候会产生一些副作用，比如一些无用的附加操作。比如，初始化方法可能会设置一个复杂的内部数据结构，并且这个数据结构马上要被别的数据所覆盖，那么就没必要进行初始化了。</p>
<p>如果你回头去看<code>copyWithZone:</code>方法，你会发现<code>_friends</code>是使用<code>mutableCopy</code>方法进行复制的。这个方法来自另一个协议，叫做<code>NSMutableCopying</code>。它的定义跟<code>NSCopying</code>协议是很相似的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)mutableCopyWithZone:(NSZone*)zone</div></pre></td></tr></table></figure>
<p><code>mutableCopy</code>就像上面的<code>copy</code>方法一样，都是使用默认空间调用的。如果你的类分为了可变和不可变两个版本，那么你也需要实现这个协议。当你这样使用时，你需要在<code>copyWithZone:</code>中返回一份不可变拷贝。不论你拷贝的对象是可变还是不可变，都应该在<code>mutableCopyWithZone:</code>中返回一份可变拷贝。类似的，如果你需要一份不可变拷贝，那么你应该调用<code>copy</code>方法。</p>
<p>下面的规则适用于可变数组和不可变数组的所有情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[NSMutableArray copy] =&gt; NSArray</div><div class="line">-[NSArray mutableCopy] =&gt; NSMutableArray</div></pre></td></tr></table></figure>
<p>有一个微妙的情况需要注意，一个可变对象调用可<code>copy</code>方法会返回一个不可变实例。这样做可以很容易的在可变对象和不可变对象之间进行切换。另一种可以达到这个目的办法是使用三个方法：<code>copy</code>、<code>immutableCopy</code>、<code>mutableCopy</code>，<code>copy</code>总是返回相同的类，其余两个方法返回特定的实例。但是如果使用者并不知道其所用实例是否可变，那么就不太好了。例如某个方法把可变对象当做不可变对象给了你，你使用这个对象调用<code>copy</code>。这时，你以为它是不可变对象但它其实是可变的。</p>
<p>你可以通过内省(看第14节)来确定对象的类型，但是这样会增加拷贝的复杂度。为了安全起见，你会只使用<code>immutableCopy</code>和<code>mutableCopy</code>，但是这样又回到了两个方法的情况。这和只有<code>copy</code>和<code>mutableCopy</code>是一样的。为什么会叫<code>copy</code>而不是<code>immutableCopy</code>呢，是因为这两个方法并不完全是为可变类和不可变类设计的，有些类是没有可变和不可变之分的。所以<code>immutableCopy</code>是一个坏名字。</p>
<p>拷贝还有一个问题是，进行的拷贝是深拷贝还是浅拷贝。深拷贝会对拷贝所有数据。通常，我们使用的容器类，都是浅拷贝，即只拷贝容器本身，不拷贝容器元素。这样做的主要原因是容器中可能含有无法拷贝的元素；另外，复制每个对象是不好的。图3.2展示了深拷贝和浅拷贝的区别。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%203.2.png" alt=""></p>
<p><strong>Figure 3.2</strong> 深拷贝和浅拷贝的区别。浅拷贝的所有内容都指向原始内容。深拷贝的所有内容都指向拷贝后的内容。</p>
<p>通常，你希望自己的类遵循系统框架的拷贝模式，即使用<code>copyWithZone:</code>进行浅拷贝。但是如果需要，也可以添加一个深拷贝的方法。例如<code>NSSet</code>，它就在初始化时提供了一个方法进行深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems</div></pre></td></tr></table></figure>
<p>如果<code>copyItems</code>为<code>YES</code>，那么集合中的所有元素都会接收到拷贝的消息，然后以拷贝后的元素组成新的集合，并返回。</p>
<p>在<code>EOCPerson</code>的例子中，朋友的集合是使用<code>copyWithZone:</code>进行拷贝的，根据上面内容得知，它们进行的是浅拷贝，不会逐个复制集合的元素。但是如果需要一个深拷贝，你可以提供这样一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (id)deepCopy &#123;</div><div class="line">    </div><div class="line">    EOCPerson *copy = [[[self class] alloc]</div><div class="line">                       initWithFirstName:_firstName</div><div class="line">                             andLastName:_lastName];</div><div class="line">    </div><div class="line">    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</div><div class="line">                                             copyItems:YES];</div><div class="line">    return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有实现深拷贝的协议，这个事情是留给你的每个类去做的。你只需要决定你是否提供深拷贝。另外，你也不应该假设<code>NSCopying</code>协议实现的是深拷贝。在绝大多数情况下，这是一个浅拷贝。如果你需要任何对象的深拷贝，除非有文档指出这个<code>NSCopying</code>协议实现的是深拷贝，要么找到相关方法，要么自己实现。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果你的对象需要拷贝，那么你需要实现<code>NSCopying</code>协议。</li>
<li>如果你需要可变和不可变两个版本，那么你需要实现<code>NSCopying</code>和<code>NSMutableCopying</code>协议。</li>
<li>开发者可以选择使用深拷贝还是浅拷贝，但尽量使用浅拷贝。</li>
<li>如果你的对象需要深拷贝，那么添加一个深拷贝方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第三章：接口和API设计&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第二章</title>
    <link href="http://yoursite.com/2017/05/14/Object,%20Messaging,%20and%20the%20Runtime/"/>
    <id>http://yoursite.com/2017/05/14/Object, Messaging, and the Runtime/</id>
    <published>2017-05-14T06:57:56.000Z</published>
    <updated>2017-07-01T04:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<code>Objective-C</code>等面向对象的语言中，对象就是基石，提供数据存储和传递的功能。消息是在过程中对象之间进行数据传递和执行操作。深入理解这些功能如何工作对于构建高效和可维护代码是至关重要的。</p>
<p>当程序运行后，<code>Objective-C</code>中的<code>runtime</code>为其提供相关支持。<code>runtime</code>提供了关键的函数使对象之间可以传递消息以及创建类实例的所有逻辑。理解这一切如何工作会使你成为一个更好的开发者。</p>
<h3 id="理解属性"><a href="#理解属性" class="headerlink" title="理解属性"></a>理解属性</h3><p>属性是<code>Objective-C</code>的一个功能，用于对象对数据的封装。<code>Objective-C</code>对象通常会把它们所需要的数据保存为各种实例变量。实例变量的访问通常通过存取方法。<code>getter</code>方法用来读取变量，<code>setter</code>方法用来设置变量。这个概念是标准的，并且通过属性这个功能成为了<code>Objective-C 2.0</code>的一部分，这让开发者令编译器去自动生成读写方法。这个功能引入了一个新语法即点语法，通过点语法访问数据存储可以减少代码的冗长。你可能已经使用了属性，但你可能不知道它所有的功能。而且，还有很多与之相关的问题。第6节主要说明哪些问题可以通过属性解决并且指出主要的功能。</p>
<p>用一个类去表示一个人的信息可能要存储名字，出生日期，地址等等。你可能这样在一个类的公共接口中声明这些变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCPerson : NSObject &#123;</div><div class="line">    </div><div class="line">@public</div><div class="line">    NSString *_firstName;</div><div class="line">    NSString *_lastName;</div><div class="line">@private</div><div class="line">    NSString *_someInternalData;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你从事过<code>Java</code>或者<code>C++</code>开发，这种写法是熟悉的，你可以定义变量的作用域。然而，这种技术在<code>Objective-C</code>中很少使用。这种方法的问题是在编译时就定义了对象的布局。无论任何时候访问<code>_firstName</code>变量，都会通过编译器偏移硬编码去访问存储对象的内存空间。如果你不在<code>_firstName</code>之前添加任何变量这样做都是没问题的。例如：假设在<code>_firstName</code>之前添加一个变量：</p>
<hr>
<p>译者言：由于对象布局在编译时已定，对象内存偏移量自然固定，此处硬编码代指偏移量。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject &#123;</div><div class="line">    </div><div class="line">@public</div><div class="line">    NSDate *_dateOfBirth;</div><div class="line">    NSString *_firstName;</div><div class="line">    NSString *_lastName;</div><div class="line">@private</div><div class="line">    NSString *_someInternalData;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>之前的偏移量代表<code>_firstName</code>而现在代表<code>_dateOfBirth</code>了。任何通过硬编码读取的地方都将读取到一个错误的值。为了说明这一点，假设指针是4个字节，图2.1分别展示了添加<code>_dateOfBirth</code>变量之前和之后的类的内存布局。<br><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.1.png" alt=""></p>
<p><strong>Figure 2.1</strong> 添加变量前类的布局和添加变量后类的布局</p>
<p>当类定义发生变化时，如果代码使用了编译时的偏移量那么将出现问题，除非重新编译。例如，一个代码库中的代码使用了旧的类定义。如果链接的代码使用了新的类定义，那么在运行时将出现不兼容的情况。为了解决这个问题，各种语言都提出了自己的解决办法。<code>Objective-C</code>的做法是，将实例变量看做特殊的变量，由类变量(第14节详细的讲述了类对象)去存储它的偏移量。在运行时，会去查找偏移量，当类定义发生改变，偏移量也随之改变。这样无论如何访问一个变量，都会使用正确的偏移量。你甚至可以在运行期间给类添加实例变量。这就是稳固的<code>ABI</code>(应用程序二进制接口)。<code>ABI</code>定义了许多内容，其中一项是生成代码时的规则。稳固的<code>ABI</code>也意味着你可以在类扩展中或者实现文件中定义实例变量。因此，你不需要在接口文件中声明所有的实例变量，因此你不需要在公共接口中泄露任何你的内部实现信息。</p>
<p>另一种解决这个问题的办法是使用存取方法而不是直接访问实例变量。虽然属性最终仍是由实例变量实现的，但是属性提供了一种简洁的抽象。你可以自己编写存取方法，但是在标准的<code>Objective-C</code>代码格式中，存取方法遵循严格的命名规则。因为严格的命名，<code>Objective-C</code>才能根据变量名自动创建存取方法。这就是<code>@property</code>语法的来源。</p>
<p>在对象接口的定义中使用<code>@property</code>，这是一种标准的写法，以提供对象的存取方法。因此，可以把属性当做一种简称，通过它去访问一个给定类型和给定名字的变量。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject</div><div class="line">@property NSString *firstName;</div><div class="line">@property NSString *lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对于类的使用者，上面的代码是等价于下面的代码的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject</div><div class="line">- (NSString *)firstName;</div><div class="line">- (void)setFirstName:(NSString *)firstName;</div><div class="line">- (NSString *)lastName;</div><div class="line">- (void)setLastName:(NSString *)lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用属性，你可以使用点语法。在<code>C</code>中你访问栈结构体的成员也是使用类似语法。编译器会将点语法转化为存取方法，与你直接调用是一样的。因此，使用点语法和直接调用时没有任何差异的。下面展示了等价的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EOCPerson *aPerson = [EOCPerson new];</div><div class="line">    </div><div class="line">aPerson.firstName = @&quot;Bob&quot;; // Same as;</div><div class="line">[aPerson setFirstName:@&quot;Bob&quot;];</div><div class="line">    </div><div class="line">NSString *lastName = aPerson.lastName; // Same as;</div><div class="line">NSString *lastName = [aPerson lastName];</div></pre></td></tr></table></figure>
<p>属性的好处还不止这些。如果你使用它，编译器将会通过一个叫做自动合成的功能生成那些方法代码。需要强调的是，编译器会在编译时自动生成代码，所以你在编辑器中是看不到自动合成的方法的。除了自动生成上述代码，编译器也会自动生成一个合适类型的变量，并且会在名字前面加下划线。在前面的代码中，他自动生成了两个变量：<code>_firstName</code>和<code>_lastName</code>。通过在类实现中使用<code>@synthesize</code>语法，这两个实例变量名字是可以控制的，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementation EOCPerson</div><div class="line">@synthesize firstName = _myFirstName;</div><div class="line">@synthesize lastName = _myLastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用上面的语法会产生两个实例变量，分别叫做<code>_myFirstName</code>和<code>_myLastName</code>，用于代替默认生成的。不过一般不会去改变默认的变量名；然而如果你不喜欢使用下划线去命名变量，你可以使用这个方法去设置你想要的。但是我建议你使用默认的命名规则，如果每个人都遵循这个规则，那么每个人读代码都是容易理解的。</p>
<p>如果你不想编译器给你自动生成存取方法，你可以自己去实现这些方法。然而，如果你仅实现了存取方法中的一个，那么编译器仍会自动生成另一个方法。另一种阻止它自动生成的办法是使用<code>@dynamic</code>关键字，这会告诉编译器不要自动生成实例变量返回给属性并且不会自动生成存取方法。而且，当编译代码访问这个属性时，编译器将会忽略实际上存取方法还没有定义的情况，并且相信它在运行时是可以使用的。例如，如果一个类继承自<code>NSManagedObject</code>类，它的存取方法需要在运行时动态创建。<code>NSManagedObject</code>类之所以这样做是因为子类的属性不是实例变量。它的数据来源于后台数据库。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSManagedObject</div><div class="line">@property NSString *firstName;</div><div class="line">@property NSString *lastName;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">@dynamic firstName, lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个类中，编译器不会自动生成存取方法或者实例变量。如果你尝试去访问某个属性，编译器也没有警告信息。</p>
<h4 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h4><p>属性的另一个问题是你应该知道它所有的特质。你可以通过它去影响编译器生成的存取方法。例如下面这个属性使用了三个特质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readwrite, copy) NSString *firstName;</div></pre></td></tr></table></figure>
<p>属性可以使用4类特质。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>通常，生成的存取方法包含锁去保持原子性。如果你设置了<code>nonatomic</code>特质，那么就不会有锁了。请注意，尽管没有<code>atomic</code>特质(<code>atomic</code>特质是由你不设置<code>nonatomic</code>特质得来的)，但是你仍何以在属性特质中写上，并且编译器不会报错。如果你自己实现存取方法，你应该指定与其相符的原子性。</p>
<h4 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h4><ul>
<li><strong>readwrite</strong> 读写权限时，<code>getter</code>和<code>setter</code>方法都是可用的。如果属性是自动合成的，那么编译器将会自动生成两个方法。</li>
<li><strong>readonly</strong> 只读权限时，只有<code>getter</code>方法是可用的，如果属性是自动合成的，那么编译器将只生成<code>getter</code>方法。当你想暴漏一个只读属性给外部，并且需要在内部重新定义它为可读写时，你可以使用它。第27节讲了更多内容。</li>
</ul>
<h4 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h4><p>属性用于封装数据，数据需要有具体的所有权。它仅仅影响setter方法。例如，用<code>setter</code>方法设置一个值时，它是应该保持新值还是将其直接赋给底层实例变量?当编译器自动生成存取方法时，它要取决于这些特质去生成代码。如果你自己实现存取方法，你应该指定与其相符的特质。</p>
<ul>
<li><strong>assign</strong> 它的<code>setter</code>方法只会简单的给标量类型的值赋值，例如<code>CGFloat</code>或者<code>NSInteger</code>。</li>
<li><strong>strong</strong> 这种特质表示定义了一个拥有关系。当为这个属性赋值时，首先持有新值，接着释放旧值，然后将新值赋给这个属性。</li>
<li><strong>weak</strong> 这种特质表示定义了一个非拥有关系。当为这个属性赋值时，它是不持有新值的；也不释放旧值。它是类似于<code>assign</code>特质的，但当目标对象释放时，它的值会被自动置为nil。</li>
<li><strong>unsafe_unretained</strong> 它同<code>assign</code>语义相似，但是它适用于对象类型，它表达了一个非拥有关系，当目标对象销毁时，它不会自动置为nil，这点与<code>weak</code>是有区别的。</li>
<li><strong>copy</strong> 这种特质类似<code>strong</code>特质，定义一个拥有关系；然而，它是用拷贝替代持有新值的。当属性是类似与<code>NSString *</code>时，经常用此特质保证其封装性，因为可能通过<code>setter</code>方法给予其一个可变值。如果赋的值是可变的，那么这个属性的类型可能就在对象不知道的情况下改变。所以就需要使用<code>copy</code>特质去使对象中的字符串不会在无意中被改变。任何需要保持不可变的对象都应该使用<code>copy</code>去修饰。</li>
</ul>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>通过使用下面的特质可以控制存取方法的名字：</p>
<ul>
<li><p><strong>getter=<name></name></strong> 指定<code>getter</code>的名字。当你想给一个<code>Boolean</code>属性加上is前缀时，通常使用这个方法。例如，在<code>UISwitch</code>类中，表示状态开关的属性就是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,getter=isOn) BOOL on;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>setter=<name></name></strong> 指定<code>setter</code>的名字。这个方法不常用的。</p>
</li>
</ul>
<p>你可以通过这些特质细微的控制自动生成的存取方法。然而，需要谨记的是，如果你实现了自己的存取方法，你应该遵循指定的特质。例如，一个属性使用了<code>copy</code>特质，你需要在<code>setter</code>中拷贝它。否则，会误导属性的使用者。而且，如果不遵守这个约定，那么将会产生bug。</p>
<p>即使你可以通过别的方法设置属性，你也要遵循定义时的特质。例如，考虑扩充下<code>EOCPerson</code>类。属性声明时，使用了<code>copy</code>特质，因为它可能是可变的。这个类也增加了一个初始化方法，用于设置名和姓的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSManagedObject</div><div class="line"></div><div class="line">@property (copy) NSString *firstName;</div><div class="line">@property (copy) NSString *lastName;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString *)firstName</div><div class="line">               lastName:(NSString *)lastName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在实现自定义初始化方法时，遵循定义时的<code>copy</code>语义是非常重要的。因为属性定义就像类和对象之间的协议一样。所以初始化的代码应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</div><div class="line">    </div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        </div><div class="line">        _firstName = [firstName copy];</div><div class="line">        _lastName = [lastName copy];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会问为什么不简单的使用属性的<code>setter</code>方式去设置，如果总是使用<code>setter</code>设置，那将会保证属性的正确设置。你永远不该在<code>init</code>方法中使用存取方法，具体请看第7节。</p>
<p>如果你已经读了第18节，你应该知道，最好使对象不可变。将上述内容应用在<code>EOCPerson</code>类中，你需要设置两个属性为<code>readonly</code>。在初始化中设置它们的值，然后它们将不能被修改。在本例中，对你使用的值使用内存管理语义是重要的。所以属性定义的代码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (copy, readonly) NSString *firstName;</div><div class="line">@property (copy, readonly) NSString *lastName;</div></pre></td></tr></table></figure>
<p>因为是只读属性，所以编译器不会为其自动生成<code>setter</code>方法。这样做是重要的，可以表明在初始化时设置了这两个属性值。没有这样的声明，使用这个类的人就可能不知道已经在<code>init</code>方法中使用了<code>copy</code>，因此他们可能会在调用初始化方法之前自行拷贝。这种操作是多余且低效的。</p>
<p>如果你想知道<code>atomic</code>和<code>nonatomic</code>的区别。前面说过，使用了<code>atomic</code>的属性的存取方法会自动加锁确保原子性。这个意思是如果两个线程同时对属性进行读写操作，这个值不论在任何时候始终是有效的。如果不加所得情况下，当一个线程正在进行修改时，另一个线程进行读取，可能会将其未修改完的值读出来。如果发生了这种情况，读到的值可能是无效的。</p>
<p>如果你是在iOS中开发，那么你会注意到所有属性声明为<code>nonatomic</code>。这样做的历史原因是，加锁消耗比较大，可能会产生性能问题。通常，原子性并不是必须的，因为它不能确保线程安全，需要更深层次的锁定机制才能保证其线程安全。例如，即使使用了原子性，一个线程在连续读取某个属性值时，另一个线程修改了这个属性，仍将不能确保读到的是正确的值。因此，在iOS开发中你将一直使用<code>nonatomic</code>去修饰属性。但是在Mac OS X中，你不需要担心<code>atomic</code>带来的性能问题。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>@property</code>语法提供了一种对象封装数据的定义。</li>
<li>使用正确的特质提供数据存储。</li>
<li>在设置属性所对应的实例变量时，需要遵循该属性的语义。</li>
<li>在iOS中使用<code>nonatomic</code>，因为它会严重消耗性能。</li>
</ul>
<h3 id="在对象内部直接访问实例变量"><a href="#在对象内部直接访问实例变量" class="headerlink" title="在对象内部直接访问实例变量"></a>在对象内部直接访问实例变量</h3><p>属性总是用于访问外部对象的实例变量，但是在<code>Objective-C</code>社区中如何访问内部变量却是争执不休的。有些建议仍使用属性去访问实例变量，有些建议直接访问实例变量，有些两者混用。作者强烈推荐在读取实例变量时直接访问而在设置值时使用属性访问。</p>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject  </div><div class="line">@property (nonatomic, copy) NSString *firstName;  </div><div class="line">@property (nonatomic, copy) NSString *lastName;  </div><div class="line"> </div><div class="line">// Convenience for firstName + &quot; &quot; + lastName:  </div><div class="line">- (NSString*)fullName;  </div><div class="line">- (void)setFullName:(NSString*)fullName;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这两个便捷方法<code>fullName</code>和<code>setFullName</code>可能是这样实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (NSString*)fullName &#123;  </div><div class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,  </div><div class="line">            self.firstName, self.lastName];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">/** The following assumes all full names have exactly 2  </div><div class="line"> *  parts. The method could be rewritten to support more  </div><div class="line"> *  exotic names.  </div><div class="line"> */  </div><div class="line">- (void)setFullName:(NSString*)fullName &#123;  </div><div class="line">    NSArray *components =  </div><div class="line">        [fullName componentsSeparatedByString:@&quot; &quot;];  </div><div class="line">    self.firstName = [components objectAtIndex:0];  </div><div class="line">    self.lastName = [components objectAtIndex:1];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>setter</code>和<code>getter</code>中，我们使用点语法访问实例变量。假设现在重写<code>setter</code>和<code>getter</code>方法直接访问变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (NSString*)fullName &#123;  </div><div class="line">    return [NSStringstringWithFormat:@&quot;%@ %@&quot;,  </div><div class="line">            _firstName, _lastName];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (void)setFullName:(NSString*)fullName &#123;  </div><div class="line">    NSArray *components =  </div><div class="line">        [fullName componentsSeparatedByString:@&quot; &quot;];  </div><div class="line">    _firstName = [components objectAtIndex:0];  </div><div class="line">    _lastName = [components objectAtIndex:1];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两种方式是有些许差异的：</p>
<ul>
<li>毫无疑问直接访问实例变量是更快的，因为它不需要通过<code>Objective-C</code>方法派发(看第11节)。编译器通过代码直接访问存储对象实例的内存空间。</li>
<li>直接调用实例变量会绕过<code>setter</code>的内存管理语义。例如，你的属性声明了<code>copy</code>特质，直接调用实例变量不会发生<code>copy</code>事件。新的值将会被保存，旧的值将会被释放。</li>
<li>当直接访问实例变量时，KVO不会被触发。这可能会是一个问题，不过这主要取决你对这个对象的行为。</li>
<li>通过属性访问可以更轻易的定位到与这个属性有关的问题，因为你可以给<code>setter</code>、<code>getter</code>方法添加断点去看谁在什么时候访问了这个属性。</li>
</ul>
<p>一个好的折中的办法是在写时通过<code>setter</code>方法设置，读时直接调用实例变量。这样做可以在读时有更高的效率，在写时也不会失去控制。最重要的是通过<code>setter</code>方法去写将保证你遵循内存管理语义。然而，这样做会有一些小的问题。</p>
<p>第一个问题是当你的值是在初始化方法中设置的时候。这里，你应该一直使用直接调用实例变量的方法，因为子类可能重写了它的<code>setter</code>方法。考虑下<code>EOCPerson</code>有一个叫做<code>EOCSmithPerson</code>的子类，这个类是专门用于表示名字叫<code>smith</code>的。这个子类可能会覆盖<code>lastName</code>的<code>setter</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setLastName:(NSString*)lastName &#123;  </div><div class="line">    if (![lastName isEqualToString:@&quot;Smith&quot;]) &#123;  </div><div class="line">        [NSException raise:NSInvalidArgumentException  </div><div class="line">                    format:@&quot;Last name must be Smith&quot;];  </div><div class="line">    &#125;  </div><div class="line">    self.lastName = lastname;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>EOCPerson</code>基类可能在初始化时将名字设为空字符。如果它通过<code>setter</code>方法去这样设置，那么子类的<code>setter</code>将会被调用并且会抛出一个异常。然而，在有一些情况中，你必须在初始化时使用<code>setter</code>方法。当实例变量是声明在一个父类中的时候；你不能通过直接调用实例变量时，那么你必须使用<code>setter</code>方法。</p>
<p>另一个问题是当属性使用懒加载时。在这种情况下，你必须通过<code>getter</code>访问；如果没有，那个实例变量将永远不会初始化。例如，<code>EOCPerson</code>类可能有一个属性通过一个复杂对象去代表人脑。如果这个属性很少用并且初始化成本较高的，你可能在<code>getter</code>中使用懒加载，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (EOCBrain*)brain &#123;  </div><div class="line">    if (!_brain) &#123;  </div><div class="line">        _brain = [Brain new];  </div><div class="line">    &#125;  </div><div class="line">    return _brain;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你直接调用实例变量且没有调用过<code>getter</code>方法，大脑这个属性永远不会创建，所以你需要通过属性的存取方法去访问它。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在内部使用数据时，通过直接调用实例变量来读，通过调用属性来写。</li>
<li>在初始化和销毁中，不论读还是写都通过实例变量直接访问。</li>
<li>当你使用了懒加载时，你需要使用属性去读。</li>
</ul>
<h3 id="理解对象的等同性"><a href="#理解对象的等同性" class="headerlink" title="理解对象的等同性"></a>理解对象的等同性</h3><p>比较对象相等是非常有用的。然而，使用等于操作符去判断相等通常不是你想做的，因为这样做比较的是它们的指针本身，而不是指针指向的对象。相应的，你应该使用声明在<code>NSObject</code>协议中的<code>isEqual:</code>方法去检验两个对象是否相等。通常情况下，两个不同类的对象总是不相等的。如果你已经知道你要检查的两个对象是同一个类，那么你可以使用它们自己提供的相同性检测方法。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *foo = @&quot;Badger 123&quot;;  </div><div class="line">NSString *bar = [NSString stringWithFormat:@&quot;Badger %i&quot;, 123];  </div><div class="line">BOOL equalA = (foo == bar); //&lt; equalAequalA = NO </div><div class="line">BOOL equalB = [foo isEqual:bar]; //&lt; equalBequalB = YES </div><div class="line">BOOL equalC = [foo isEqualToString:bar]; //&lt; equalCequalC = YES</div></pre></td></tr></table></figure>
<p>你可以看到等号操作符与使用等价方法的不同。<code>NSString</code>是一个自己实现了等价比较方法的类，方法名叫做<code>isEqualToString:</code>。使用这个方法的对象一定是一个<code>NSString</code>对象；否则，比较结果就会返回undefined。使用这个方法是比使用<code>isEqual:</code>更快的，它需要别的步骤，因为它不知道比较的对象是什么类型的。</p>
<p>这两个方法的核心等价判断是<code>NSObject</code>的协议方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object;</div><div class="line">- (NSUInteger)hash;</div></pre></td></tr></table></figure>
<p>这两个<code>NSObject</code>类的方法的默认实现是只有两个对象指向相同的地址时才相等。为了在自定义对象中覆写这些方法，你必须去了解它们的原理。任意两个对象使用<code>isEqual:</code>方法比对结果是相等，那么它们的<code>hash</code>方法也一定会返回相同的值。然而，两个对象的<code>hash</code>方法返回相同的值，它们<code>isEqual:</code>方法的比对结果不一定相等。</p>
<p>例如，考虑下面的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface EOCPerson : NSObject  </div><div class="line">@property (nonatomic, copy) NSString *firstName;  </div><div class="line">@property (nonatomic, copy) NSString *lastName;  </div><div class="line">@property (nonatomic, assign) NSUInteger age;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果所有条件都是相等的，那么两个<code>EOCPerson</code>对象相等。所以<code>isEqual:</code>方法应该这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object &#123;  </div><div class="line">    if (self == object) return YES;  </div><div class="line">    if ([self class] != [object class]) return NO;  </div><div class="line"> </div><div class="line">    EOCPerson *otherPerson = (EOCPerson*)object;  </div><div class="line">    if (![_firstName isEqualToString:otherPerson.firstName])  </div><div class="line">        return NO;  </div><div class="line">    if (![_lastName isEqualToString:otherPerson.lastName])  </div><div class="line">        return NO;  </div><div class="line">    if (_age != otherPerson.age)  </div><div class="line">        return NO;  </div><div class="line">    return YES;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，对比两个对象的指针是否相同。如果指针相同，那么对象一定相等，因为它们是同一个对象。其次，比较两个对象的类。如果两个对象的类不同，那么两个对象不相等。毕竟，一个<code>EOCPerson</code>类不可能等于<code>EOCDog</code>类。当然，你可能希望一个<code>EOCPerson</code>实例等于它一个子类的实例；例如，<code>EOCSmithPerson</code>。这说明在继承层次中，判断相等性是一个常见问题。当你实现了<code>isEqual:</code>方法时，你应该考虑这个问题。最后，没一个属性去检查相等性。如果它们中的任何一个不相等，那么两个对象被认为是不相等；否则，它们是相等的。</p>
<p>接下来实现<code>hash</code>方法。回想一下相等性原则，当两个对象相等，那么它们的哈希码一定相等，但是两个对象的哈希码相等，它们本身却不一定相等。因此如果你复写了<code>isEqual:</code>方法，通常也会覆写<code>hash</code>方法。一个更好的<code>hash</code>方法是像下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;  </div><div class="line">    return 1337;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可是，如果在集合中使用这种办法，这将可能会产生性能问题。因为集合使用哈希表中的哈希码做索引。一个集合的实现是使用哈希存储对象到不同的数组。当给集合添加新对象时，会根据哈希码找到与其对应的数组，对比所有对象，看其是否与新加对象相等。如果相等，说明新加的对象已经在集合里面了。因此，如果所有的对象哈希码都一样，那么在集合中已有1000000个对象时，每次给集合添加对象都会遍历对比这1000000个对象。</p>
<p>另一种实现哈希方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;  </div><div class="line">    NSString *stringToHash =  </div><div class="line">        [NSStringstringWithFormat:@&quot;%@:%@:%i&quot;,  </div><div class="line">            _firstName, _lastName, _age];  </div><div class="line">    return [stringToHash hash];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次的哈希算法是通过创建一个字符串并将字符串的哈希码返回。这么做符合约定，因为两个相等的<code>EOCPerson</code>总会生成相等哈希码。然而，这种方法是比返回单一数值的速度慢的，因为你需要创建一个字符串。当给一个集合添加对象时，这仍会导致性能问题，因为要给集合添加对象，仍然需要去计算对象的hash值。</p>
<p>第三种也是最后一种方法是创建一个类似于这样的哈希码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;  </div><div class="line">    NSUInteger firstNameHash = [_firstName hash];  </div><div class="line">    NSUInteger lastNameHash = [_lastName hash];  </div><div class="line">    NSUInteger ageHash = _age;  </div><div class="line">    return firstNameHash ^ lastNameHash ^ ageHash;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法是一个这种的办法，既能保持一定的效率，又能使生成的哈希码在一定范围之内。当然，这样还会导致生成相同的哈希码的碰撞，但是至少不会重复太多次。在编写哈希码时，你应该基于当前的业务要求去权衡哈希碰撞频率和创建哈希的性能消耗。</p>
<h4 id="特定类的等同性方法"><a href="#特定类的等同性方法" class="headerlink" title="特定类的等同性方法"></a>特定类的等同性方法</h4><p>除了前面说的<code>NSString</code>类提供了特定的等同性方法，还提供特定方法的类还有<code>NSArray(isEqualToArray:)</code>和<code>NSDictionary(isEqualToDictionary:)</code>，如果对比的对象不是数组或者字典，这两种方法都会抛出异常。<code>Objective-C</code>在编译器并没有严格的类行检测，这样就容易使用错误的对象去对比，所以你应该确定当前对象的类型是正确的。</p>
<p>如果等同性对比比较频繁，那么你可能会创建自己的等同性方法；因此，效率高的重要原因是不需要检查类型。另一个原因是，提供一个指定方法是用于修饰的，它看起来是更好、更易读的，这也是<code>NSString</code>类提供<code>isEqualToString:</code>方法的动机之一。使用此种方法的代码是更易读的，并且也不需要再去检查两个对比对象的类型了。</p>
<p>如果你创建一个特定等同性方法，你需要覆盖<code>isEqual:</code>方法并且通过判断两个对比对象的类型是否相同。如果不相同，就使用父类的实现方法去判断。例如，<code>EOCPerson</code>类的实现应该像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123;  </div><div class="line">    if (self == object) return YES;  </div><div class="line"> </div><div class="line">    if (![_firstName isEqualToString:otherPerson.firstName])  </div><div class="line">        return NO;  </div><div class="line">    if (![_lastName isEqualToString:otherPerson.lastName])  </div><div class="line">        return NO;  </div><div class="line">    if (_age != otherPerson.age)  </div><div class="line">        return NO;  </div><div class="line">    return YES;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (BOOL)isEqual:(id)object &#123;  </div><div class="line">    if ([self class] == [object class]) &#123;  </div><div class="line">        return [self isEqualToPerson:(EOCPerson*)object];  </div><div class="line">    &#125; else &#123;  </div><div class="line">        return [super isEqual:object];  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="等同性对比的深度"><a href="#等同性对比的深度" class="headerlink" title="等同性对比的深度"></a>等同性对比的深度</h4><p>当你创建一个等价方法时，你需要决定是检查整个对象的等同性或者仅仅只是一些条件的等同性。<code>NSArray</code>的对比方法是先对比两个数组包含的个数，其次遍历它们，使用<code>isEqual:</code>对比每个元素。如果所有的元素都相等，那么可以认为两个数组相等，这是深度等同性对比。不过有时你仅需要判断一部分数据段是相等的，这对于等同性对比也是可以的。</p>
<p>例如，使用<code>EOCPerson</code>类，如果实例来源于一个数据库，它们可能会添加一个属性用于唯一标示，即使用数据库中的主键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property NSUInteger identifier;</div></pre></td></tr></table></figure>
<p>在这种情况下，可能仅仅需要去检查<code>identifier</code>是否匹配即可，尤其是如果<code>identifier</code>属性特质被声明为只读，那么你可以确定如果两个对象拥有同样的表示符，它们确实代表了相同的对象并且相等。这可以避免对比每个<code>EOCPerson</code>对象的每个数据位，如果你确定它们的标示符相等，那么剩下的数据也相等，因为它们是相同的数据源。</p>
<p>在你的等同性方法中，是否需要检查所有条件的等同性，取决于被检测的对象。只有你才知道在什么情况下两个实例相等。</p>
<h4 id="容器中可变类的等同性"><a href="#容器中可变类的等同性" class="headerlink" title="容器中可变类的等同性"></a>容器中可变类的等同性</h4><p>考虑一个重要的情况，在容器中添加一个可变类。一旦你将一个对象添加入一个集合中，那么这个对象的哈希码不应该再改变。前面，我说了集合是根据哈希码去存储对象的。如果哈希码一旦发生变化，集合中的对象将会产生一个错误。为了解决这个问题，你可以确保哈希码不是根据可变部分的对象计算出来的或者保证一旦放入集合中就不再修改它。在第18节，我详细阐述了为了你需要使对象不可变。对于这个问题，下面有一个很好的例子。</p>
<p>通过测试<code>NSMutableSet</code>和<code>NSMutableArrays</code>，你可以看到这个问题。开始的时候给集合添加一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *set = [NSMutableSetnew];  </div><div class="line"> </div><div class="line">NSMutableArray *arrayA = [@[@1, @2] mutableCopy];  </div><div class="line">[set addObject:arrayA];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1,2))&#125;</div></pre></td></tr></table></figure>
<p>集合中现在有一个对象：带有两个元素的数组。现在使用相同的方法给集合添加一个同样顺序的数组，下面的代码展示了给集合添加一个新的数组以及添加后集合的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arrayB = [@[@1, @2] mutableCopy];  </div><div class="line">[set addObject:arrayB];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1,2))&#125;</div></pre></td></tr></table></figure>
<p>这个集合仍然只保存了一个对象，因为新添加的数组对象是已经在集合中存在的了。现在我们添加一个跟集合中不同的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arrayC = [@[@1] mutableCopy];  </div><div class="line">[set addObject:arrayC];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1),(1,2))&#125;</div></pre></td></tr></table></figure>
<p>果然，集合现在包含了两个数组：一个原来的数组和一个新的数组，因为<code>arrayC</code>与集合中已有的数组不相等。最后，我们修改<code>arrayC</code>使其等于之前集合中的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[arrayC addObject:@2];  </div><div class="line">NSLog(@&quot;set = %@&quot;, set);  </div><div class="line">// Output: set = &#123;((1,2),(1,2))&#125;</div></pre></td></tr></table></figure>
<p>哦，我的天，现在在集合中存在两个相同的数组了。这个集合没有遵守集合的定义，但是我们现在却无法确保这点了。因为我们修改了一个已经在集合中的对象了。如果我们拷贝这个集合，将会更加可怕：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSSet *setB = [set copy];  </div><div class="line">NSLog(@&quot;setB = %@&quot;, setB);  </div><div class="line">// Output: setB = &#123;((1,2))&#125;</div></pre></td></tr></table></figure>
<p>这个拷贝出来的集合仅有一个对象，这个集合像是先创建一个空的集合，然后逐步从原集合中添加元素得到的。这可能是也可能不是你想要的结果。你可能想要忽视这个错误，按原样复制一个集合。或者你就是想这样做。这两种拷贝情况都是有效的，这进一步说明了刚才的问题，如果修改某个已经加入集合的对象，将会产生不可预料的情况。</p>
<p>举这个例子是想告诉大家，当你修改某个已经加入集合的对象会造成什么后果。这不是说不能这样做，而是你这样做了之后要考虑其后果。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果想检测等同性，你需要提供<code>isEqual:</code>和<code>hash</code>方法。</li>
<li>相同的对象，哈希码一定是相等的；但是哈希码相等，对象却不一定相等。</li>
<li>确定你对比对象同等性时是否需要对比每个对象。</li>
<li>编写哈希算法时，应该使用计算速度快并且碰撞几率低的算法。</li>
</ul>
<h3 id="使用类簇模式隐藏实现细节"><a href="#使用类簇模式隐藏实现细节" class="headerlink" title="使用类簇模式隐藏实现细节"></a>使用类簇模式隐藏实现细节</h3><p>在一个抽象基类中，使用类簇可以很好的隐藏实现细节。在<code>Objective-C</code>的系统框架中，这种模式是非常普遍的。<code>UIKit</code>中有一个例子，就是<code>iOS</code>的UI框架中的<code>UIButton</code>类。创建一个按钮，你会调用下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (UIButton*)buttonWithType:(UIButtonType)buttonType;</div></pre></td></tr></table></figure>
<p>返回对象的类型取决于按钮类型。所有的子类都继承自相同的基类，即<code>UIButton</code>类。这样做使用者就不需要关心生成的按钮类型以及按钮如何绘画的具体细节。这一切只需要知道如何创建一个按钮；如何设置标题这样的属性；如何设置点击的动作。</p>
<p>回到按钮绘画的问题上面，它可以通过使用一个类去处理所有按钮的绘画并且基于它们的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;  </div><div class="line">    if (_type == TypeA) &#123;  </div><div class="line">        // Draw TypeA button  </div><div class="line">    &#125; else if (_type == TypeB) &#123;  </div><div class="line">        // Draw TypeB button  </div><div class="line">    &#125; /* ... */  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看起来是清晰的，但是如果有许多方法基于这个类型的切换去绘制，那么这个方法就会变得非常笨重。一个好的程序员会对这进行重构，通过创建多个子类去实现特定的功能用于对应每种按钮类型。然而这样做需要使用者知道所有的子类。这时就该使用类簇模式了，这种模式提供多个子类，并通过将其实现细节隐藏在基类，用以保持头文件的干净。你不需要创建子类的实例，你通过基类创建它们即可。</p>
<h4 id="创建一个类簇"><a href="#创建一个类簇" class="headerlink" title="创建一个类簇"></a>创建一个类簇</h4><p>有一个关于如何创建类簇的例子，考虑一个处理雇员的类，这个类包含雇员的名字和销售额以及每天该做的工作。但是每个雇员每天的工作是不一样的。管理者不关心每个雇员如何完成任务，他只会告诉每个雇员该做什么。</p>
<p>首先，你需要定义这个基类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123;  </div><div class="line">    EOCEmployeeTypeDeveloper,  </div><div class="line">    EOCEmployeeTypeDesigner,  </div><div class="line">    EOCEmployeeTypeFinance,  </div><div class="line">&#125;;  </div><div class="line"> </div><div class="line">@interface EOCEmployee : NSObject  </div><div class="line"> </div><div class="line">@property (copy) NSString *name;  </div><div class="line">@property NSUInteger salary;  </div><div class="line"> </div><div class="line">// Helper for creating Employee objects  </div><div class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;  </div><div class="line"> </div><div class="line">// Make Employees do their respective day&apos;s work  </div><div class="line">- (void)doADaysWork;  </div><div class="line"> </div><div class="line">@end  </div><div class="line"> </div><div class="line">@implementation EOCEmployee  </div><div class="line"> </div><div class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;  </div><div class="line">    switch (type) &#123;  </div><div class="line">        case EOCEmployeeTypeDeveloper:  </div><div class="line">            return [EOCEmployeeDeveloper new];  </div><div class="line">            break;  </div><div class="line">        case EOCEmployeeTypeDesigner:  </div><div class="line">            return [EOCEmployeeDesigner new];  </div><div class="line">            break;  </div><div class="line">        case EOCEmployeeTypeFinance:  </div><div class="line">            return [EOCEmployeeFinance new];  </div><div class="line">            break;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (void)doADaysWork &#123;  </div><div class="line">    // Subclasses implement this.  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>每一个具体的子类继承自基类。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface EOCEmployeeDeveloper : EOCEmployee  </div><div class="line">@end  </div><div class="line"> </div><div class="line">@implementation EOCEmployeeDeveloper  </div><div class="line"> </div><div class="line">- (void)doADaysWork &#123;  </div><div class="line">    [self writeCode];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个例子中，这个基类实现了一个基类方法的声明，它通过雇员的类型去创建并初始化不同的实例。这个工厂模式是创建一个类簇的一种方法。</p>
<p>不幸的是，<code>Objective-C</code>语言没有指定一个类是基类的功能。相应的，开发者通常会在这个类中写明类的用法。在这种情况下，头文件没有声明初始化方法，它意味着实例变量并不是立即创建的。另一种确定没使用基类实例的方法是在基类的<code>doADaysWork</code>方法中抛出一个异常。然而，这种做法是非常极端的并且也不是必需的。</p>
<p>还有一个点需要注意的，当使用的对象的类是类簇的一个成员时，要注意它的类型信息(看第14节)。因为你可能认为你创建的是某个类的实例，但实际上确实它的某个子类的实例。在前面的例子中，你可能以为调用<code>[employee isMemberOfClass:[EOCEmployee class]]</code>的结果是<code>YES</code>，但<code>employee</code>其实不是<code>EOCEmployee</code>类初始化的对象，而是其子类，所以它会返回<code>NO</code>。</p>
<h4 id="Cocoa中的类簇"><a href="#Cocoa中的类簇" class="headerlink" title="Cocoa中的类簇"></a>Cocoa中的类簇</h4><p>系统框架中有许多类簇。大多数的集合类都是类簇，例如<code>NSArray</code>和它对应的可变类<code>NSMutableArray</code>。所以，实际上它有两个基类：一个可变数组和一个不可变数组。它仍然是一个类簇但是却有两个公共接口。不可变类中定义的方法适用于所有的数组，可变类定义的方法仅适用于可变数组。实际上类簇意味着它们在实现自身时可以共享代码，以及可以在创建时把不可变数组变为可变数组，反之亦然。</p>
<p>在<code>NSArray</code>中，当你创建一个实例时，它其实是另一个类创建的实例，这个类的用途就是占位。之后这个占位数组会转化为另一个的实例，而那个类则是<code>NSArray</code>的具体子类。这是一个很好的实现，但它超出了本书的讲解范围。</p>
<p>理解像<code>NSArray</code>这样的类是一个类簇是重要的，因为别的原因，你可能会写出这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = /* ... */;  </div><div class="line">if ([maybeAnArray class] == [NSArray class]) &#123;  </div><div class="line">        // Will never be hit  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了<code>NSArray</code>是一个类簇，可以使你理解上面的代码是错误的，其中<code>if</code>语句的条件永远不可能为真。<code>[maybeAnArray class]</code>返回的类永远不可能是<code>NSArray</code>类，因为<code>NSArray</code>初始化方法返回的变量是由隐藏在类簇内部的某个隐藏类实现的。</p>
<p>注意在类簇中对比实例变量的类是可以的。不适用之前的方法，你应该使用类型信息查询方法。第14节讲述了那些方法。替换之前类对象等同性比较方法，你因该这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = /* ... */;  </div><div class="line">if ([maybeAnArray isKindOfClass:[NSArray class]]) &#123;  </div><div class="line">        // Will be hit  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给类簇添加具体的子类是正常的需求，但是这么做的时候要小心。在<code>Emloyee</code>的例子中，如果没有工厂方法代码，去添加新的子类是不可能的。在<code>Cocoa</code>的类簇中，例如<code>NSArray</code>，它是可以的，但是有一些规则必须去遵守。这几条规则如下：</p>
<ul>
<li><p>子类应该继承自类簇的抽象基类。</p>
<p>  在<code>NSArray</code>中，它可以继承自不可变数组的基类或者可变数组的基类。</p>
</li>
<li><p>子类应该定义自己的存储方式。</p>
<p>  开发者编写<code>NSArray</code>子类时，经常在这个问题上受阻。子类必须用一个实例标量存储数组中的对象。这看起来与我们预想相反，我们以为<code>NSArray</code>自己会存储它们。但是请记住，<code>NSArray</code>仅仅是一个包在其他隐藏对象外面的壳，它只是定义了一些数组通用的接口。对于这个子类来说，可以是用<code>NSArray</code>来保存其实例。</p>
</li>
<li><p>子类应当覆写父类文档中指明需要覆写的方法。    </p>
<p>  每个抽象基类都有一些方法需要子类一定实现的。在<code>NSArray</code>中，需要实现的方法有<code>count</code>和<code>objectAtIndex:</code>。另外的方法，像<code>lastObject</code>，不需要去实现，因为可以使用前两个方法实现这个方法。</p>
</li>
</ul>
<p>实现子类时所需要遵循的规范一般都在类的文档中，所以你首先应该阅读它们。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类簇模式可以使用一套简单的公共接口隐藏实现的细节。</li>
<li>类簇在系统框架中是经常使用的。</li>
<li>在定义类簇的子类时，需要注意遵循基类的协议。如果有文档，那么首先阅读它。</li>
</ul>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><p>有时，你想在对象中存储信息。通常，你通常会从那个对象类继承一个子类，然后使用子类去存储。然而，你不能一直这样做，因为类的实例可能是因为某种机制所创建的，并且你不能使这种机制使用你的类创建实例。这时候<code>Objective-C</code>中一个叫做<code>Associated Objects</code>的功能就派上用场了。</p>
<p>对象关联其它对象，并使用一个键去表示它。它们使用存储策略是维持存储对象的内存管理语义。这个存储策略由<code>objc_AssociationPolicy</code>的枚举值定义，表2.1展示了它所包含的值，同事还列出了与之等价的属性的特质(第6节讲述了属性的信息)。</p>
<p><strong>Table 2.1</strong> 对象关联类型<br><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Table%202.1.png" alt=""></p>
<p>关联对象的管理是使用下面语法实现的：</p>
<ul>
<li><p><code>void objc_setAssociatedObject(id object, void*key, id value, 
objc_AssociationPolicy policy)</code></p>
<p>使用给定的键和存储策略为对象设置关联对象值。</p>
</li>
<li><p><code>id objc_getAssociatedObject(id object, void*key)</code></p>
<p>使用给定的键从对象中获取关联对象值。</p>
</li>
<li><p><code>void objc_removeAssociatedObjects(id object)</code></p>
<p>移除对象的所有关联对象。</p>
</li>
</ul>
<p>关联对象的存取方法是类似字典对象这种的，字典通过调用<code>[object setObject:value forKey:key]</code>与<code>[object objectForKey:key]</code>存取，关联对象同样使用特定的键存储关联的值。但是有一个重要的不同需要知道，关联对象的键是个指针。而字典对象的键是一个字符串，只需要字符串相同就可以了。但是关联对象的键必须是同一个指针才可以匹配。因此，关联对象通常使用全局静态变量作为键。</p>
<h4 id="一个使用关联对象的例子"><a href="#一个使用关联对象的例子" class="headerlink" title="一个使用关联对象的例子"></a>一个使用关联对象的例子</h4><p>在iOS开发中，经常会使用<code>UIAlertView</code>类，给用户提供一个基于当前视图的弹窗。当用户点击按钮时有一个代理协议用于处理这个点击事件；然而，使用代理协议需要拆分创建代码和点击事件。由于代码分成两块，所以读起来有些不方便。下面有一个使用<code>UIAlertView</code>的例子，与我们一般写法一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)askUserAQuestion &#123;  </div><div class="line">    UIAlertView *alert = [[UIAlertView alloc]  </div><div class="line">                             initWithTitle:@&quot;Question&quot;  </div><div class="line">                               message:@&quot;What do you want to do?&quot;  </div><div class="line">                                 delegate:self  </div><div class="line">                        cancelButtonTitle:@&quot;Cancel&quot;  </div><div class="line">                        otherButtonTitles:@&quot;Continue&quot;, nil];  </div><div class="line">        [alert show];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">// UIAlertViewDelegate protocol method  </div><div class="line">- (void)alertView:(UIAlertView *)alertView  </div><div class="line">        clickedButtonAtIndex:(NSInteger)buttonIndex  </div><div class="line">&#123;  </div><div class="line">    if (buttonIndex == 0) &#123;  </div><div class="line">        [self doCancel];  </div><div class="line">    &#125; else &#123;  </div><div class="line">        [self doContinue];  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想在同一个类弹出超过一个弹窗，那么这种写法将会变得更加凌乱，因为你接着需要通过代理方法去检查弹窗的参数，并基于此选择相应的逻辑。如果弹窗创建时就可以决定每个按钮该做什么，那么逻辑就会清楚很多。这时可以使用关联对象去处理。一个解决办法是当创建弹窗时给它设置一个block并且当协议方法触发时调用这个blcok。它实现是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt; </div><div class="line"> </div><div class="line">static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;;  </div><div class="line"> </div><div class="line">- (void)askUserAQuestion &#123;  </div><div class="line">    UIAlertView *alert = [[UIAlertViewalloc]  </div><div class="line">                             initWithTitle:@&quot;Question&quot;  </div><div class="line">                               message:@&quot;What do you want to do?&quot;  </div><div class="line">                                  delegate:self  </div><div class="line">                        cancelButtonTitle:@&quot;Cancel&quot;  </div><div class="line">                        otherButtonTitles:@&quot;Continue&quot;, nil];  </div><div class="line"> </div><div class="line">        void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123;  </div><div class="line">          if (buttonIndex == 0) &#123;  </div><div class="line">              [self doCancel];  </div><div class="line">        &#125; else &#123;  </div><div class="line">            	 [self doContinue];  </div><div class="line">        &#125;  </div><div class="line">    &#125;;  </div><div class="line"> </div><div class="line">      objc_setAssociatedObject(alert,  </div><div class="line">                               EOCMyAlertViewKey,  </div><div class="line">                               block,  </div><div class="line">	                            BJC_ASSOCIATION_COPY);  </div><div class="line"> </div><div class="line">      [alert show];  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">// UIAlertViewDelegate protocol method  </div><div class="line">- (void)alertView:(UIAlertView*)alertView  </div><div class="line">        clickedButtonAtIndex:(NSInteger)buttonIndex  </div><div class="line">&#123;  </div><div class="line">    void (^block)(NSInteger) =  </div><div class="line">        objc_getAssociatedObject(alertView, EOCMyAlertViewKey);  </div><div class="line">    block(buttonIndex);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用这种方法，创建弹窗的代码和回调结果的代码都在同一个位置，这样比之前的代码更易读，因为你不需要在两处代码之间来回看就可知道为什么使用弹窗了。然而使用这种办法你需要小心一个问题，如果block捕捉了某些变量，这可能会造成循环引用。关于这个问题更具体的信息请看第40节。</p>
<p>如你所见，这种方法是非常好用的，但是你应该确保仅仅是你没有别的办法达到你想做的时再去使用它。如果滥用它，你的代码将会很快超出控制并且难以排查问题。循环引用产生的原因是难以发现的，因为关联对象之间并没有明确的定义，内存管理语义定义在关联时期，而不是声明时期。所以当你使用这种方法时需要小心，不要因为某处可以用它就使用它。另一个实现弹窗的办法是创建子类，将block作为一个属性添加进子类。如果多次使用弹窗时，我认为使用这种办法是优于使用关联对象的。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>关联对象提供了一种方法去关联两个对象。</li>
<li>定义关联对象时可使用内存管理语义去模仿属性的拥有或非拥有关系。</li>
<li>当另一种方法不能实现时，才去使用关联对象，因为它可能产生难以查找的异常。</li>
</ul>
<h3 id="理解objc-msgSend的作用"><a href="#理解objc-msgSend的作用" class="headerlink" title="理解objc_msgSend的作用"></a>理解objc_msgSend的作用</h3><p>在<code>Objective-C</code>中通过对象调用方法是做的最多的事情之一。在<code>Objective-C</code>术语中，它被称作消息传递。消息有名字或者选择器，带有参数，并且可能会有一个返回值。</p>
<p>因为<code>Objective-C</code>是C的超集，去了解C中的函数调用时一个好的主意。众所周知，C的函数调用时静态绑定，即在编译时就知道函数的调用。例如，考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">void printHello() &#123;  </div><div class="line">    printf(&quot;Hello, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line">void printGoodbye() &#123;  </div><div class="line">    printf(&quot;Goodbye, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">void doTheThing(int type) &#123;  </div><div class="line">    if (type == 0) &#123;  </div><div class="line">        printHello();  </div><div class="line">    &#125; else &#123;  </div><div class="line">        printGoodbye();  </div><div class="line">    &#125;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略内联函数这种情况，当上述代码编译时，<code>printHello</code>函数和<code>printGoodbye</code>函数是已知的，编译器会直接发出指令去调用函数。在指令集中函数的地址就是有效的硬编码。现在考虑下下述代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">void printHello() &#123;  </div><div class="line">    printf(&quot;Hello, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line">void printGoodbye() &#123;  </div><div class="line">    printf(&quot;Goodbye, world!\n&quot;);  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">void doTheThing(int type) &#123;  </div><div class="line">    void (*fnc)();  </div><div class="line">    if (type == 0) &#123;  </div><div class="line">        fnc = printHello;  </div><div class="line">    &#125; else &#123;  </div><div class="line">        fnc = printGoodbye;  </div><div class="line">    &#125;  </div><div class="line">    fnc();  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里就需要使用动态绑定了，因为在运行时之前都不知道函数如何调用。在第一个和第二个例子中，编译器生成的指令集是不同的。第一个例子中，函数的调用是在if和else这两种情况中的。第二个例子中，仅有一个调用，不过是有一定代价的，即待调用的函数地址无法硬编码在指令集中，而是要在运行期读取出来。</p>
<p>在<code>Obejctvie-C</code>中，当传递消息给对象时，是通过动态绑定机制去决定调用哪个方法的。在底层所有的方法都是普通的C函数，但是当对象接收到信息后，调用哪一个方法完全取决于运行时，甚至可以在程序运行过程去修改它，这使得<code>Objective-C</code>成为一门真正的动态语言。</p>
<p>给对象发送消息看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>someObject</code>是消息接收者，<code>messageName:</code>是选择器。选择器和参数的组合被称作消息。当编译器看到这个消息时，它将这个消息转化为一条标准的C函数，所调用的函数是消息传递机制中的核心函数，叫做<code>objc_msgSend</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_msgSend(id self, SEL cmd, ...)</div></pre></td></tr></table></figure>
<p>这是一个参数个数可变的参数，它可以接受两个或两个以上的参数。第一个参数是消息接收者，第二个参数是选择器(SEL的类型是selector)，剩下的参数就是消息参数，顺序与它们传递时一致。选择器指的是方法的名字。在计算机术语中，选择器和方法这两个术语经常交替使用。编译器会将上面的例子中的消息转化成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id returnValue = objc_msgSend(someObject,  </div><div class="line">                              @selector(messageName:),  </div><div class="line">                              parameter);</div></pre></td></tr></table></figure>
<p><code>objc_msgSend</code>函数会依据消息接收者和选择器去调用合适的方法。为了做到这一点，这个函数会去查找消息接收者所属类中的方法实现列表，如果能查找到与接收器名字匹配的方法，就跳转至其实现代码。如果没有找到，这个函数会遍历其继承层次查找这个方法并跳转至其实现代码。如果仍没有找到匹配的方法，那么就执行消息转发。更详细的消息转发机制请看第12节。</p>
<p>这样说来，调用一个方法会需要很多步骤。幸运的是，<code>objc_msgSend</code>会在快速查找表中缓存结果，每个类都有这样一块缓存，所以后面给相同的类和方法组合发送消息是非常快速的。即使这样，快速查找仍然是比静态绑定方法的速度慢的，但是一旦方法缓存，也不会差太多。实际上，消息传递并不是一个应用程序的瓶颈。如果是，你可以编写纯C函数，只在调用需要时，将<code>Objective-C</code>对象状态传递进去。</p>
<p>上面说的仅仅基于确定的消息。另外的边缘情形则需要交给<code>Objective-C</code>运行时的另一些函数：</p>
<ul>
<li><p><code>objc_msgSend_stret</code></p>
<p>如果发送的消息返回结构体，那么可交由此函数处理。当返回的类型是结构体且能被放进CPU寄存器时，使用这个函数处理。如果寄存器不能容纳返回类型，那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</p>
</li>
<li><p><code>objc_msgSend_fpret</code></p>
<p>如果发送消息的返回值是浮点数，那么可交由此函数处理。某些处理器调用函数时，需要对浮点型寄存器进行特殊处理，这意味着标准的<code>objc_msgSend</code>是不适合的。这个函数存在的作用是处理x86等架构中的一些特殊的情况。</p>
</li>
<li><p><code>objc_msgSendSuper</code></p>
<p>发送消息给父类，例如<code>[super message:parameter]</code>，使用这个方法。它也有两个等价于<code>objc_msgSend_stret</code>和<code>objc_msgSend_fpret</code>的函数，用于处理发给父类的消息。</p>
</li>
</ul>
<p>刚才提到过，<code>objc_msgSend</code>等函数一旦搜寻到正确的方法实现就跳转至其实现代码。之所以能这样做，是因为每个<code>Objective-C</code>对象方法都能看做是一个简单的C函数，它的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</div></pre></td></tr></table></figure>
<p>函数的名字可能不像上面那样，但我用类和选择器去组合它，仅仅是为了说明它的原理。每个类里面都有一张表，其中的指针会指向函数，以选择器名字为键去查找。<code>objc_msgSend</code>等函数正是通过这张表来寻找应该执行的方法并跳至其实现的。注意原型和<code>objc_msgSend</code>函数很相似，但这不是巧合。它简化跳转方法并且可以更好的使用尾调用优化。</p>
<p>当一个方法的最后一行是调用另一个函数，那么就可以使用尾调用优化。编译器可产生跳转至下一个函数的指令码，也不用生成新的栈帧。这仅当一个函数最后的操作是调用另一个函数且不需要使用返回值做任何事情，才能执行尾调用优化。这项优化对<code>objc_msgSend</code>是非常重要的，因为没有它，每次调用<code>Objective-C</code>方法，栈将会在栈踪迹中显示所有<code>objc_msgSend</code>调用的函数。并且，也将会经常发生栈溢出现象。</p>
<p>实际上，你在写<code>Objective-C</code>代码时，不需要担心这些问题，但是理解这些操作的本质对开发来说是有益的。如果你理解了在发送消息时发生了什么，你可以了解你的代码是如何执行的并且在调试时，也能理解为什么栈回溯中总会出现<code>objc_msgSend</code>函数。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>一个消息由一个接收者，一个选择器，参数组成。给对象发送消息相当于对象调用方法。</li>
<li>当调用时，所有的消息都需要通过动态消息发送系统来处理，它会查找方法的实现然后运行它们。</li>
</ul>
<h3 id="理解消息转发"><a href="#理解消息转发" class="headerlink" title="理解消息转发"></a>理解消息转发</h3><p>第11节解释了理解对象消息机制是重要的。第12节探讨当对象遇到无法处理的消息时发生了什么。类可以理解消息仅仅是因为它实现了相对应的方法。类接收到一个无法理解的信息会发生错误，但它并不是发生在编译时。因为方法是在运行时被添加到类中的，所以编译器并不知道对应的方法是否存在。当某个类接受到一个它不理解的消息，对象通过使用消息转发，一个允许开发者预处理的设计。开发者可以通过它去处理那些类无法理解的消息。</p>
<p>即使你不知道消息转发，但你可能已经遇到过由消息转发流程处理的消息了。每次你在控制台看到这样的信息，它是因为你给某个对象传递了消息但是那个对象无法处理它，所以它通过转发机制，将消息转发给了<code>NSObject</code>的默认实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-[__NSCFNumber lowercaseString]: unrecognized selector sent to  </div><div class="line">instance 0x87  </div><div class="line">*** Terminating app due to uncaught exception  </div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber  </div><div class="line">lowercaseString]: unrecognized selector sent to instance 0x87&apos;</div></pre></td></tr></table></figure>
<p>这是从<code>NSObject</code>的<code>doesNotRecognizeSelector:</code>方法抛出的一个异常，它告诉你这个消息的接收者类型是<code>__NSCFNumber</code>，并且这个接收者无法理解这个叫做<code>lowercasrString</code>的选择器。在上述示例中这并不奇怪，因为<code>NSNumber</code>是没有那个方法的(<code>__NSCFNumber是为了实现无缝桥接而使用的内部类，当你初始化一个NSNumber实例时，它会被创建</code>)。在这个例子中，应用程序最后以崩溃而告终，但是你可以在你的类中拦截到转发机制去执行你想要的逻辑替代崩溃。</p>
<p>转发路径是分为两大阶段的。第一个阶段是给接收者的类一个机会去动态的添加一个方法，用于处理未知的选择器。这叫做动态方法解析。第二个阶段涉及完整的消息转发机制。如果运行时间已经过了第一阶段，那么接收者就无法再以添加方法的方式去相应选择器。所以它告诉接收者自己去尝试处理。这也分为两步。首先，它会问别的对象是否接受这个消息。如果有，运行时会转移消息并结束消息转发。如果没有替代的接收者，则启动完整的转发机制，使用<code>NSInvocation</code>对象去把所有与消息有关的细节包装起来并给开发者最后一个机会去处理它。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>当一个对象接收到一个它不能理解的方法时，在它所属类中调用的第一个方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector;</div></pre></td></tr></table></figure>
<p>这个方法带有一个当前类无对应实现的选择器并且返回一个布尔值指示是否在运行期有可以对应选择器的实例方法添加到本类。因此，在触发其余转发机制之前这个类有第二次机会去添加对应的实现。还有一个类似的方法，叫做<code>resolveClassMethod:</code>，当一个未实现的方法是类方法而不是实例方法时会调用它。</p>
<p>使用这种方法依赖于这个方法实现已经是可用的，准备动态的插入类中。这个方法经常被用做实现<code>@dynamic</code>属性(看第6节)，例如在<code>CoreData</code>中访问NSManagedObjects属性，因为访问方法需要去手动实现，这样属性才可以在编译时被知道。</p>
<p>这样一个<code>resolveInstanceMethod:</code>实现，对于使用<code>@dynamic</code>属性看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">id autoDictionaryGetter(id self, SEL _cmd);  </div><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value);  </div><div class="line"> </div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector &#123;  </div><div class="line">    NSString *selectorString = NSStringFromSelector(selector);  </div><div class="line">    if ( /* selector is from a @dynamic property */ ) &#123;  </div><div class="line">        if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;  </div><div class="line">            class_addMethod(self,  </div><div class="line">                            selector,  </div><div class="line">                            (IMP)autoDictionarySetter,  </div><div class="line">                            &quot;v@:@&quot;);  </div><div class="line">        &#125; else &#123;  </div><div class="line">            class_addMethod(self,  </div><div class="line">                            selector,  </div><div class="line">                            (IMP)autoDictionaryGetter,  </div><div class="line">                            &quot;@@:&quot;);  </div><div class="line">        &#125;  </div><div class="line">        return YES;  </div><div class="line">    &#125;  </div><div class="line">return [super resolveInstanceMethod:selector];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先将选择器转为一个字符串，并且检查它是否是一个<code>setter</code>方法。如果前缀带有set字符，假定它是一个<code>setter</code>方法；否则，假定它是一个<code>getter</code>方法。在每种情况下，都会对给定选择器的类添加一个方法，它指向一个C函数的实现。在这些C函数中将会通过代码来控制类使用某种数据结构去存储属性数据。例如，在<code>CoreData</code>中，这些方法将通过后端数据库去检索或更新值。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>第二步处理未知选择器的方法是询问接收者是否有一个可用的替代接收者去处理相应的消息。这个方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)selector</div></pre></td></tr></table></figure>
<p>传递未知的选择器并且返回符合预期的接收者，当未找到符合预期的接收者，将返回nil。这个方法可以让我们通过组合来模拟多重继承的某些特性。一个对象内部可能还有一系列别的对象，在这个方法中它可以返回能够处理的选择器相关的内部对象，并使其在外界看来像是它亲自处理一样。</p>
<p>注意，我们无法再这一步对消息做出改变。如果消息需要在发送给备用接收者之前做改变，那么我们需要使用完整的转发机制。</p>
<h4 id="完整转发机制"><a href="#完整转发机制" class="headerlink" title="完整转发机制"></a>完整转发机制</h4><p>如果转发算法已经走到这一步，那么能做的事仅有使用完整的转发机制了。首先创建一个<code>NSInvocaton</code>对象，用于包含不能处理的消息的所有细节。这个对象包含选择器，目标接收者，和参数。在触发<code>NSInvocaton</code>对象可时，这将导致消息派发系统去将消息派发给指定的对象。</p>
<p>此步骤调用的转发方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation*)invocation</div></pre></td></tr></table></figure>
<p>一个简单的实现是改变这个对象的目标并触发它。这样的实现与备用接收者是等价的，但是很少有人使用这么简单的实现。更有用的实现是可以在调用前通过某些办法改变这个消息，比如拼接另一个参数或者改变选择器。</p>
<p>实现此方法时，如果发现调用不是由该类处理，那么应该调用它的父类去处理。这意味着在继承链上的所有父类都有机会去处理这个调用，直至<code>NSObject</code>的实现。如果最后该消息仍没有处理，那么仍会调用<code>doesNotRecognizeSelector:</code>抛出异常。</p>
<h4 id="完整的转发机制图"><a href="#完整的转发机制图" class="headerlink" title="完整的转发机制图"></a>完整的转发机制图</h4><p>图2.2这张流程图描述了消息转发机制处理消息的各个步骤。</p>
<p>在每一步，接收者都有机会去处理消息。每一步处理代价都比上一步大。最好的处理时机在第一部，因为方法在运行时被添加将会被运行时缓存，当你使用同一个类的实例再次调用时，它不需要再走转发机制就可以找到这个选择器了。如果能找到一个备用接收者，那么在第二步处理是优于第三步处理的。在第三步中，仅是修改有关的调用目标，那在第二步做这个是比第三步更简单的，并且也不需要再去创建<code>NSInvocaton</code>对象。</p>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.2.png" alt=""></p>
<h4 id="动态方法解析的完整示例"><a href="#动态方法解析的完整示例" class="headerlink" title="动态方法解析的完整示例"></a>动态方法解析的完整示例</h4><p>为了说明如何使用消息转发机制，下面的例子展示了使用动态方法解析显现<code>@dynamic</code>属性。考虑一个对象允许你存储任何对象进去，类似一个字典，但需要通过属性提供存取方法。这个类的设计思路是你可以添加属性定义并使用<code>@dynamic</code>声明它，类将处理存储和获取方法。这听起来是不是很不错？</p>
<p>这个类的接口大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt; </div><div class="line"> </div><div class="line">@interface EOCAutoDictionary : NSObject  </div><div class="line">@property (nonatomic, strong) NSString *string;  </div><div class="line">@property (nonatomic, strong) NSNumber *number;  </div><div class="line">@property (nonatomic, strong) NSDate *date;  </div><div class="line">@property (nonatomic, strong) id opaqueObject;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这个例子中，这些属性具体是什么是不重要的。我之所以写这么多类型只是为了展示这个功能的强大。在类的内部，每一个属性将都存放在字典中，所以类开始的实现是下面这样的，包含使用<code>@dynamic</code>声明属性，这样这些属性的实例变量和存取方法就不会自动生成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import “EOCAutoDictionary.h&quot;  </div><div class="line">#import &lt;objc/runtime.h&gt; </div><div class="line"> </div><div class="line">@interface EOCAutoDictionary ()  </div><div class="line">@property (nonatomic, strong) NSMutableDictionary *backingStore;  </div><div class="line">@end  </div><div class="line">@implementation EOCAutoDictionary  </div><div class="line"> </div><div class="line">@dynamic string, number, date, opaqueObject;  </div><div class="line"> </div><div class="line">- (id)init &#123;  </div><div class="line">    if ((self = [super init])) &#123;  </div><div class="line">         _backingStore = [NSMutableDictionary new];  </div><div class="line">    &#125;  </div><div class="line">    return self;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是本例重要的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector &#123;  </div><div class="line">    NSString *selectorString = NSStringFromSelector(selector);  </div><div class="line">    if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;  </div><div class="line">        class_addMethod(self,  </div><div class="line">                        selector,  </div><div class="line">                        (IMP)autoDictionarySetter,  </div><div class="line">                        &quot;v@:@&quot;);  </div><div class="line">    &#125; else &#123;  </div><div class="line">        class_addMethod(self,  </div><div class="line">                        selector,  </div><div class="line">                        (IMP)autoDictionaryGetter,  </div><div class="line">                        &quot;@@:&quot;);  </div><div class="line">    &#125;  </div><div class="line">    return YES;  </div><div class="line">&#125;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>首次调用一个位于<code>EOCAutoDictionary</code>实例中的属性时，运行时找不到对应的选择器，因为它们即没有直接实现也没有自动合成。例如，假如要向<code>opaqueObject</code>对象写入信息，那么将会调用<code>setOpaqueObject:</code>方法。同理，在读取该属性时，会调用<code>opaqueObject</code>方法。<code>resolveInstanceMethod:</code>方法会检测方法是不是含有set前缀，以此区分<code>setter</code>和<code>getter</code>方法。在每种情况下，都会向类中增加一个方法去处理选择器，这两个方法分别是<code>autoDictionarySetter</code>及<code>autoDictionaryGetter</code>函数的指针。这时就可以使用运行时的<code>class_addMethod</code>方法，给类动态的添加方法，用于处理对应的选择器，并且带有所添加方法的指针。最后一个参数表示实现方法的类型编码。在本例中，编码开头的字符表示方法的返回值类型，后续字符则表示其所接受的各个参数。</p>
<p><code>getter</code>函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">id autoDictionaryGetter(id self, SEL _cmd) &#123;  </div><div class="line">        // Get the backing store from the object  </div><div class="line">        EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;  </div><div class="line">        NSMutableDictionary *backingStore = typedSelf.backingStore;  </div><div class="line"> </div><div class="line">        // The key is simply the selector name  </div><div class="line">        NSString *key = NSStringFromSelector(_cmd);  </div><div class="line"> </div><div class="line">        // Return the value  </div><div class="line">        return [backingStore objectForKey:key];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，<code>setter</code>函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value) &#123;  </div><div class="line">        // Get the backing store from the object  </div><div class="line">        EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;  </div><div class="line">        NSMutableDictionary *backingStore = typedSelf.backingStore;  </div><div class="line"> </div><div class="line">        /** The selector will be for example, &quot;setOpaqueObject:&quot;.  </div><div class="line">          *  We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first  </div><div class="line">          *  letter of the remainder.  </div><div class="line">          */  </div><div class="line">        NSString *selectorString = NSStringFromSelector(_cmd);  </div><div class="line">        NSMutableString *key = [selectorString mutableCopy];  </div><div class="line"> </div><div class="line">        // Remove the &apos;:&apos; at the end  </div><div class="line">    	 [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];  </div><div class="line"> </div><div class="line">        // Remove the &apos;set&apos; prefix  </div><div class="line">        [key deleteCharactersInRange:NSMakeRange(0, 3)];  </div><div class="line"> </div><div class="line">        // Lowercase the first character  </div><div class="line">        NSString *lowercaseFirstChar =  </div><div class="line">        	[[key substringToIndex:1] lowercaseString];  </div><div class="line">    	 [key replaceCharactersInRange:NSMakeRange(0, 1)  </div><div class="line">           					withString:lowercaseFirstChar];  </div><div class="line"> </div><div class="line">       if (value) &#123;  </div><div class="line">      		 [backingStore setObject:value forKey:key];  </div><div class="line">   		 &#125; else &#123;  </div><div class="line">        	 [backingStore removeObjectForKey:key];  </div><div class="line">    	 &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>EOCAutoDictionary</code>的方法很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EOCAutoDictionary *dict = [EOCAutoDictionary new];  </div><div class="line">dict.date = [NSDate dateWithTimeIntervalSince1970:475372800];  </div><div class="line">NSLog(@&quot;dict.date = %@&quot;, dict.date);  </div><div class="line">// Output: dict.date = 1985-01-24 00:00:00 +0000</div></pre></td></tr></table></figure>
<p>其它属性在字典中的实现也类似于日期属性，如果要添加新的属性，也可以使用<code>@property</code>定义，<code>@dynamic</code>声明它。在iOS的<code>CoreAnimation</code>框架中，<code>CALayer</code>类也是用来类似的方法。这是的<code>CALayer</code>成为可以兼容键值对容器的类，这意味着你可以随意添加键值对，并以属性的方法访问它。于是，开发者就可以向其中新增自定义的属性了，这些属性值的存储工作由基类直接负责，我们只需在CALayer的子类中定义新属性即可。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>如果对象无法响应选择器，则进入消息转发流程。</li>
<li>运行时的动态方法解析可以使我们给类添加我们需要使用的方法。</li>
<li>对象可以把无法处理的选择器交给其他对象去处理。</li>
<li>当前述步骤未处理选择器时，启动完成的转发机制。</li>
</ul>
<h3 id="考虑使用方法交换去调式不透明方法"><a href="#考虑使用方法交换去调式不透明方法" class="headerlink" title="考虑使用方法交换去调式不透明方法"></a>考虑使用方法交换去调式不透明方法</h3><p>在<code>Objective-C</code>中，当给对象发送消息时，它的一系列调用是发生在运行期的，第11节详细阐述了这个过程。你可能会在运行时修改给定选择器的对应方法。这是可以的。这个功能有巨大的用途，你可以使用它修改类中的方法对于某些你没有代码的方法，不需要子类和重载方法。因此，这个新的函数可以被所有类的实例使用而不仅是重载方法的子类实例。这种方法通常被称为<code>Method Swizzling</code>。</p>
<p>一个类的方法列表中包含一个选择器名字列表用于映射，告诉动态消息系统在哪里找到给定方法的实现。这个实现是作为函数指针被存储的，叫做<code>IMP</code>s，如下面的原型：<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.3.png" alt=""></p>
<p><strong>Figure 2.3</strong> <code>NSString</code>的选择器表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id (*IMP)(id, SEL, ...)</div></pre></td></tr></table></figure>
<p><code>NSString</code>类可以响应这些选择器的调用<code>lowercaseString</code>，<code>uppercaseString</code>，<code>capitalizedString</code>以及其它方法。每一个选择器指向一个不同的实现，类似于图2.3。</p>
<p><code>Objective-C</code>运行时暴露的一些方法可以操作这张表。你可以给列表添加选择器，改变实现指向，或者交换两个选择器的实现。执行其中的一些操作，类方法表可能像图2.4。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.4.png" alt=""></p>
<p><strong>Figure 2.4</strong> 执行了一些操作后，<code>NSString</code>选择器的表</p>
<p>添加了一个新的叫做<code>newSelector</code>选择器，改变了<code>capitalizedString</code>的实现，并且交换了<code>lowercaseString</code>和<code>uppercaseString</code>的实现。上述修改均无须编写子类，只要修改了方法表的布局，就会反映到程序中所有的<code>NSString</code>实例之上。怎么样，这是一个强大的功能吧。</p>
<p>这节的话题会讲述两个方法交换的过程。这样做可以为已有方法添加新功能。在讲述如何给已有方法添加功能之前，我将先讲述如何去交换两个已经存在的方法。交换方法实现，你应该使用下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void method_exchangeImplementations(Method m1, Method m2)</div></pre></td></tr></table></figure>
<p>这个函数中的参数用于交换。它们可以通过下面的函数获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector)</div></pre></td></tr></table></figure>
<p>这个方法使用给定的选择器在类中去检索方法。在前面的例子中，交换<code>lowercaseString</code>和<code>uppercaseString</code>的实现，需要执行下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Method originalMethod =  </div><div class="line">    class_getInstanceMethod([NSStringclass],  </div><div class="line">                            @selector(lowercaseString));  </div><div class="line">Method swappedMethod =  </div><div class="line">    class_getInstanceMethod([NSStringclass],  </div><div class="line">                            @selector(uppercaseString));  </div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>从这时起，所有的<code>NSString</code>实例调用<code>lowercaseString</code>方法时，都会调用<code>uppercaseString</code>的实现，反之亦然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;ThIs iS tHe StRiNg&quot;;  </div><div class="line"> </div><div class="line">NSString *lowercaseString = [string lowercaseString];  </div><div class="line">NSLog(@&quot;lowercaseString = %@&quot;, lowercaseString);  </div><div class="line">// Output: lowercaseString = THIS IS THE STRING  </div><div class="line"> </div><div class="line">NSString *uppercaseString = [string uppercaseString];  </div><div class="line">NSLog(@&quot;uppercaseString = %@&quot;, uppercaseString);  </div><div class="line">// Output: uppercaseString = this is the string</div></pre></td></tr></table></figure>
<p>上面展示了如何交换两个方法实现，但是在实际使用中，简单的交换两个实现不是非常有用的。毕竟，你为什么要交换<code>lowercaseString</code>和<code>uppercaseString</code>的实现，它们已经做的不错了。你没有任何理由去交换它们。但是同样的方法可以用来给已有的方法添加新功能。假如你想记录调用<code>lowercaseString</code>时的某些信息。同样的办法可以达到这个目的。它需要你去实现一个新的方法并包含你想要的功能，然后通过交换去替代掉原有方法。</p>
<p>可以使用category去添加的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSString (EOCMyAdditions)  </div><div class="line">- (NSString*)eoc_myLowercaseString;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个方法与原有的<code>lowercaseString</code>方法交换，交换后的方法表如图2.5。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.5.png" alt=""></p>
<p>新方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@implementation NSString (EOCMyAdditions)  </div><div class="line">- (NSString*)eoc_myLowercaseString &#123;  </div><div class="line">    NSString *lowercase = [self eoc_myLowercaseString];  </div><div class="line">    NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);  </div><div class="line">    return lowercase;  </div><div class="line">&#125;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这看起来像是会陷入递归调用的死循环，但是要记住它们的实现已经交换了。所以在运行时，当查找<code>eoc_myLowercaseString</code>选择器时，它会调用<code>lowercaseString</code>的实现。最后，交换两个方法的实现，像下面这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Method originalMethod =  </div><div class="line">    class_getInstanceMethod([NSString class],  </div><div class="line">                            @selector(lowercaseString));  </div><div class="line">Method swappedMethod =  </div><div class="line">    class_getInstanceMethod([NSString class],  </div><div class="line">                            @selector(eoc_myLowercaseString));  </div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>从现在起，所有的<code>NSString</code>实例调用<code>lowercaseString</code>方法时，都会在日志中打印出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;ThIs iS tHe StRiNg&quot;;  </div><div class="line">NSString *lowercaseString = [string lowercaseString];  </div><div class="line">// Output: ThIs iS tHe StRiNg =&gt; this is the string</div></pre></td></tr></table></figure>
<p>通过这个方案，开发者可以对那些无法知道实现的方法增加日志输出，这对调试来时是非常有用的。然而此方法也应只在调试模式使用它。很少有人在全局类中使用它。不要因为你能使用它就去用它。过多的使用会使你的代码难以阅读和难以控制。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在运行时可以给类中添加方法或者替换某个指定的选择器的实现。</li>
<li>使用一个方法实现去替代另一个方法实现，叫做<code>Method Swizzling</code>，开发者通常用其为已有方法添加功能。</li>
<li>在调试模式下，通过运行时去修改方法实现是好的做法，但是不能滥用。</li>
</ul>
<h3 id="理解类对象"><a href="#理解类对象" class="headerlink" title="理解类对象"></a>理解类对象</h3><p><code>Objective-C</code>实际上是一门极其动态的语言。第11节讲述了在运行时如何查找一个方法的实现，第12节讲述了当一个类不能响应一个确定的选择器时的转发机制。但是消息接收者是什么：那个对象自身？runtime怎么知道那个对象的类型？在编译时对象的类型并未绑定，而是在运行时确定的。此外，一个特殊的类型<code>id</code>，它可以表示任意的<code>Objective-C</code>对象类型。通常，指定的对象类型是已知的，所以编译器才能在它认为接收者无法接收某条消息时发出警告。相反的，当对象类型是<code>id</code>时，编译器将假定它可以相应所有的消息。</p>
<p>从第12节你可以知道，编译器无法知道一个确定类型到底能理解多少选择器，因为它们可以在运行时动态添加。然而，即使知道可能会在运行时添加方法，编译器也觉得可以在某个头文件中看到方法原型的定义，这样它可以知道完整的方法签名，用于生成消息派发所需的正确代码。</p>
<p>在运行时检查对象的类型也被称作内省，这是一个强大且有用的功能，它作为<code>NSObject</code>协议的一部分内置在<code>Foundation</code>框架中，凡是由公共根类(NSObject与NSProxy)继承来的类都要遵守它。使用这些方法而不是直接对比对象的类是明智的，我将在后面讲述为什么不要直接对比。不过在介绍类型信息查询技术之前，我们先讲一些基础知识，看看<code>Objective-C</code>对象的本质是什么。</p>
<p>每一个<code>Objective-C</code>对象实例指向一块内存区域。这就是为什么当你声明一个变量时，看到类型后面有一个<code>*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *pointerVariable = @&quot;Some string&quot;;</div></pre></td></tr></table></figure>
<p>编过C语言程序的人都知道这是什么意思。对于没写过C语言的程序员来说，<code>pointerVariable</code>是一个存放内存地址的变量，而<code>NSString</code>自身的数据就存于那个地址中。因此这个变量指向<code>NSString</code>实例。所有的<code>Objective-C</code>对象都是这样的；如果想在栈上初始化一个对象，你将会收到一个来自编译器的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String stackVariable = @&quot;Some string&quot;;  </div><div class="line">// error: interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p>通用的对象类型<code>id</code>，它本身就是一个指针，所以你可以这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id genericTypedString = @&quot;Some string&quot;;</div></pre></td></tr></table></figure>
<p>这个定义的语义与<code>NSString*</code>是相同的。它们的区别在于指明类型的情况下，对于这个实例如果你尝试调用一个类中不存在的方法，编译器可以帮助你检查，并且发出警告信息。</p>
<p>在<code>runtime</code>的头文件中，所有的对象的数据结构都是这样定义的，<code>id</code>类型本身也在这定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_object &#123;  </div><div class="line">    Class isa;  </div><div class="line">&#125; *id;</div></pre></td></tr></table></figure>
<p>因此，每个对象的首个成员是<code>Class</code>类型的变量。这个变量定义了对象所属的类型，常常被称为<code>isa</code>指针。例如，刚才的例子中的对象是一个<code>NSString</code>。类对象也定义在<code>runtime</code>的头文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;  </div><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa;  </div><div class="line">    Class super_class;  </div><div class="line">    const char *name;  </div><div class="line">    long version;  </div><div class="line">    long info;  </div><div class="line">    long instance_size;  </div><div class="line">    struct objc_ivar_list *ivars;  </div><div class="line">    struct objc_method_list **methodLists;  </div><div class="line">    struct objc_cache *cache;  </div><div class="line">    struct objc_protocol_list *protocols;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个结构体存放类的元数据，例如类实例的方法实现和实例变量。实际上这个结构体也有一个<code>isa</code>指针，并且是第一个变量，它意味着<code>Class</code>自身也是一个<code>Objective-C</code>对象。这个结构体也有另一个变量，叫做<code>super_class</code>，这个是类的父类。类的类型是另一个类，叫做元类，用来表述类对象本身所具备的元数据。类方法就定义在元类中，因为它可以理解成类对象的实例方法。每个类仅有一个类对象，每个类对象也只有一个元类。</p>
<p>一个叫做<code>someClass</code>的类继承自<code>NSObject</code>，继承链如图2.6。<img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%202.6.png" alt=""></p>
<p><strong>Figure 2.6</strong> <code>SomeClass</code>的实例继承链，它继承自<code>NSObject</code>，包含元类的继承。</p>
<p><code>super_class</code>指针确立了继承关系，<code>isa</code>指针则描述了实例所属的类。你可以通过操作这个布局来执行内省(检查对象的类型)。你可以通过它找到一个对象是否可以响应某个确定的选择器并且遵循某个确定的协议，并且确定对象所属类的继承信息。</p>
<h4 id="检查类的继承"><a href="#检查类的继承" class="headerlink" title="检查类的继承"></a>检查类的继承</h4><p>内省方法可以用作去检查类的继承。你可以使用<code>isMemberOfClass:</code>判断一个对象是否是某个确定类的实例，或者使用<code>isKindOfClass:</code>去检查某个对象是否是某个确定类或者任何继承自它的类的实例。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *dict = [NSMutableDictionary new];  </div><div class="line">[dict isMemberOfClass:[NSDictionary class]]; ///&lt; NO </div><div class="line">[dict isMemberOfClass:[NSMutableDictionary class]]; ///&lt; YES </div><div class="line">[dict isKindOfClass:[NSDictionary class]]; ///&lt; YES </div><div class="line">[dict isKindOfClass:[NSArray class]]; ///&lt; NO</div></pre></td></tr></table></figure>
<p>像这种内省类型的原理是通过<code>isa</code>指针获得对象的类，并且使用<code>super_class</code>去遍历整条继承链。由于对象类型是动态的，所以这个功能是非常重要的。<code>Objective-C</code>与你了解的其他语言不同，在<code>Objective-C</code>中，必须查询类型信息，才能完全了解对象的真实类型。</p>
<p>由于<code>Objective-C</code>使用动态类型绑定，所以查询对象所属类的功能是非常有用的。当你从集合中获取对象时，内省是非常常用的，因为它们不是强类型，意思是指当对象是从集合中获取的时候，它们通常是<code>id</code>类型。如果需要知道具体的类型，那么就可以使用内省：例如，想根据数组中存储的对象生成以逗号分隔的字符串，并将其存至文本文件，就可以使用下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array &#123;  </div><div class="line">    NSMutableString *string = [NSMutableString new];  </div><div class="line">    for (id object in array) &#123;  </div><div class="line">        if ([object isKindOfClass:[NSString class]]) &#123;  </div><div class="line">            [string appendFormat:@&quot;%@,&quot;, object];  </div><div class="line">        &#125; else if ([object isKindOfClass:[NSNumber class]]) &#123;  </div><div class="line">            [string appendFormat:@&quot;%d,&quot;, [object intValue]];  </div><div class="line">        &#125; else if ([object isKindOfClass:[NSData class]]) &#123;  </div><div class="line">            NSString *base64Encoded = /* base64 encoded data */;  </div><div class="line">            [string appendFormat:@&quot;%@,&quot;, base64Encoded];  </div><div class="line">        &#125; else &#123;  </div><div class="line">            // Type not supported  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return string;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>去检查类对象的等价性也是可以的。如果你要这样做，那么可以使用<code>==</code>操作符而不要使用你对比对象时常用的<code>isEqual:</code>方法(看第8节)。理由是在一个应用程序中，没个类都是单例，并且每个类仅会有一个类对象存在。因此，另外一种可以准确判断对象是否为某类实例的办法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id object = /* ... */;  </div><div class="line">if ([object class] == [EOCSomeClass class]) &#123;  </div><div class="line">    // &apos;object&apos; is an instance of EOCSomeClass  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使能这样做，你也应该使用内省方法去判断而不是直接调用<code>==</code>操作符，因为内省方法可以完整的处理消息转发(看第12节)的情况。考虑下一个对象将它的所有选择器都转发给另一个对象了，这样的对象叫做代理，并且对于这些类似的对象都以<code>NSProxy</code>为根类。</p>
<p>通常情况下，假如这样的代理对象调用<code>class</code>方法，那将返回代理类(例如：<code>NSProxy</code>的子类)，而非接受的代理的对象所属的类。然而，如果是这样的内省方法，例如<code>isKindOfClass:</code>，那么代理对象会把这个方法转发给接受代理的对象。这意味着这条消息的返回值与直接在接受代理对象上面查询的结果是一样的。因此，这样检查出来的类对象与调用<code>class</code>方法返回的类对象不同，<code>class</code>方法所返回的类表示发起代理的对象，而非接受代理的对象。</p>
<h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul>
<li>每个实例都有一个<code>isa</code>指针，用于表明它的类型与指向类对象，而类对象构成了类的继承链。</li>
<li>当在编译时不能确实对象类型时，应该使用内省去确定对象的具体类型。</li>
<li>应该总是使用内省去检查对象类型，而不是直接对比类对象，因为对象可能实现了消息转发。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第一章</title>
    <link href="http://yoursite.com/2017/04/29/Accustoming%20Yourself%20to%20Objective-C/"/>
    <id>http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/</id>
    <published>2017-04-29T06:48:05.000Z</published>
    <updated>2017-05-18T10:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。</p>
<p>书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。</p>
<h3 id="了解Objective-C的本源"><a href="#了解Objective-C的本源" class="headerlink" title="了解Objective-C的本源"></a>了解Objective-C的本源</h3><p>Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 	Messaging (Objective-C)</div><div class="line">	Object *obj = [Object new];</div><div class="line">	[obj performWith:parameter1 and:parameter2];</div><div class="line">	</div><div class="line">// 	Function calling (C++)</div><div class="line">	Object *obj = new Object;</div><div class="line">	obj-&gt;perform(parameter1, parameter2);</div></pre></td></tr></table></figure>
<p>两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。</p>
<p>Objective-C在运行时做了更多的工作而不是编译时。<code>runtime</code>包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，<code>runtime</code>包含所有内存管理的方法。本质上，<code>runtime</code>是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当<code>runtime</code>更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。</p>
<p>Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure>
<p>这种语法大多来源于C，声明一个叫做<code>someString</code>的变量，类型是<code>NSString *</code>。它的意思是这是一个<code>NSString</code>类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	NSString stackString;</div><div class="line">//	error:interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p><code>someString</code>变量指向某个内存地址，在堆上初始化，包含一个<code>NSString</code>对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div><div class="line">NSString *anotherString = someString;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png" alt=""></p>
<p><strong>Figure 1.1</strong> 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它</p>
<p>这仅有一个<code>NSString</code>实例，但有两个变量指向同它。这两个变量的类型是<code>NSString *</code>，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：<code>NSString</code>实例的内存地址。</p>
<p>图1.1说明了这个结构。<code>NSString</code>实例存储了表示实际字符串所需要的字节。</p>
<p>在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。</p>
<p>Objective-C堆上的内存管理是已经抽象的。你不需要使用<code>malloc</code>和<code>free</code>去初始化和释放对象内存。Objective-C的<code>runtime</code>通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。</p>
<p>有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如<code>CGRect</code>，来源于<code>CoreGraphics</code>框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGRect frame;</div><div class="line">frame.origin.x = 0.0f;</div><div class="line">frame.origin.y = 10.0f;</div><div class="line">frame.size.width = 100.0f;</div><div class="line">frame.siez.height = 150.0f;</div></pre></td></tr></table></figure>
<p><code>CGRect</code>是一个C的结构体，定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGRect &#123;</div><div class="line">	CGRect origin;</div><div class="line">	CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CGRect CGRect;</div></pre></td></tr></table></figure>
<p>这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如<code>CGRect</code>。</p>
<p>在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>Objective-C是C的超集，添加了面向对象的功能。</li>
<li>Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。 </li>
<li>Objective-C是运行时而不是编译时，通过消息决定代码如何运行。</li>
<li>了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。</li>
</ul>
<h3 id="减少在头文件中使用import"><a href="#减少在头文件中使用import" class="headerlink" title="减少在头文件中使用import"></a>减少在头文件中使用import</h3><p>Objective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有<code>.h</code>的是头文件，带有<code>.m</code>的是实现文件。当你创建一个类时，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对所有类来说，导入<code>Foundation.h</code>是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建<code>UIViewController</code>的子类。这些类的头文件将会导入<code>UIKit.h</code>。</p>
<p>目前来讲，这个类的写法是没问题的。它导入了整个<code>Foundation</code>框架，但是并不需要在意。<code>EOCPerson</code>类继承自<code>Foundation</code>框架中的某一个类，它将会使用框架的一大部分功能。继承自<code>UIViewController</code>的类也是一样，它将会使用<code>UIKit</code>框架的一大部分功能。</p>
<p>随着时间的推移，你可能创建了一叫做<code>EOCEmployer</code>的新类。然后你决定一个<code>EOCPerson</code>实例持有一个<code>EOCEmployer</code>实例。所以你提前给它加了一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个问题出现了，当你编译时发现<code>EOCEmployer</code>是缺失的。这个时候编译器一定会提示你在<code>EOCPerson.h</code>中导入<code>EOCEmployer.h</code>。通常你是在<code>EOCPerson.h</code>顶部加入导入的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCEmployer.h&quot;</div></pre></td></tr></table></figure>
<p>这将使他正常编译，但这是一个坏的习惯。因为编译<code>EOCPerson</code>不需要知道<code>EOCEmployer</code>的详细信息。仅需要知道有一个叫做<code>EOCEmployer</code>的类存在即可。幸运的是，有一个办法可以告诉编译器这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@class EOCEmployer;</div></pre></td></tr></table></figure>
<p>这叫做向前声明这个类。这样<code>EOCPerson</code>的头文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//	EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCEmployer;</div><div class="line"></div><div class="line">@interfrace EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, copy) EOCEmployer *employer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当你为了在实现文件中使用它时，你需要知道<code>EOCEmployer</code>的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line">#import &quot;EOCEmployer.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果<code>EOCEmployer.h</code>是在<code>EOCPerson.h</code>中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。</p>
<p>使用前向声明会缓解两个类互相引用的问题。考虑下当<code>EOCEmployer</code>有两个方法去添加和移除<code>EOCPerson</code>的实例会发生什么，在头文件像这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)addEmployee:(EOCPerson *)person;</div><div class="line">- (void)removeEmployee:(EOCPerson *)person;</div></pre></td></tr></table></figure>
<p>这时，在相反的情况下处于同样的原因，<code>EOCPerson</code>类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用<code>#import</code>而不是<code>#include</code>可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。</p>
<p>有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。</p>
<p>例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//	EOCRectangle.h</div><div class="line">#import &quot;EOCShape.h&quot;</div><div class="line">#import &quot;EOCDrawable.h&quot;</div><div class="line"></div><div class="line">@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;</div><div class="line"></div><div class="line">@property (nonatomic, assign) float width;</div><div class="line">@property (nonatomic, assign) float height;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果<code>EOCDrawable</code>协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。</p>
<p>即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即<code>.m</code>中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。</p>
<p>每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。</li>
<li>有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。</li>
</ul>
<h3 id="多使用Literal-Syntax少使用与之等价的方法"><a href="#多使用Literal-Syntax少使用与之等价的方法" class="headerlink" title="多使用Literal Syntax少使用与之等价的方法"></a>多使用Literal Syntax少使用与之等价的方法</h3><hr>
<p>译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。</p>
<hr>
<p>当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用<code>Foundation</code>去书写Objective-C代码，你通常在练习中使用它们。这些类是<code>NSString、NSNumber、NSArray、NSDictionary</code>。它们的数据结构即是它们自身所代表的意思。</p>
<p>众所周知Objective-C拥有冗长的语法。这是真的。然而，自从<code>Objective-C 1.0</code>开始，有一个非常简单的办法去创建一个<code>NSString</code>对象。它被称为<strong>String Literal</strong>并且看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;Effective Objective-C 2.0&quot;;</div></pre></td></tr></table></figure>
<p>这种类型的语法是不存在的，通常创建一个<code>NSString</code>对象是需要调用<code>alloc</code>方法后，调用<code>init</code>方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括<code>NSNumber、NSArray、NSDictionary</code>的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。</p>
<h4 id="Literal-Numbers"><a href="#Literal-Numbers" class="headerlink" title="Literal Numbers"></a>Literal Numbers</h4><p>有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用<code>NSNumber</code>实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</div></pre></td></tr></table></figure>
<p>它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = @1;</div></pre></td></tr></table></figure>
<p>如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有<code>NSNumber</code>实例可以代表的数据类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSNumber *intNumber = @1;</div><div class="line">NSNumber *floatNumber = @2.5f;</div><div class="line">NSNumber *doubleNumber = @3.14159;</div><div class="line">NSNumber *boolNumber = @YES;</div><div class="line">NSNumber *charNumber = @&apos;a&apos;;</div></pre></td></tr></table></figure>
<p>这种Literal Syntax也适用于表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x = 5;</div><div class="line">float y = 6.32f;</div><div class="line">NSNumber *expressionNumber = @(x * y);</div></pre></td></tr></table></figure>
<p>使用Literal Syntax对于数值来说是非常有用的。这样做可以使<code>NSNumber</code>对象更简洁明了，因为声明的大部分是值而不是多余的语法。</p>
<h4 id="Literal-Arrays"><a href="#Literal-Arrays" class="headerlink" title="Literal Arrays"></a>Literal Arrays</h4><p>数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</div></pre></td></tr></table></figure>
<p>使用Literal Syntax之后，仅需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];</div></pre></td></tr></table></figure>
<p>这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用<code>objectAtIndex: method:</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = [animals objectAtIndex:1];</div></pre></td></tr></table></figure>
<p>而使用Literal Syntax，只需要像下面的做法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = animals[1];</div></pre></td></tr></table></figure>
<p>这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。</p>
<p>然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的<a href="https://www.zhihu.com/question/20651624?sort=created" target="_blank" rel="external">语法糖</a>。这个异常看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception </div><div class="line">&apos;NSInvalidArgumentException&apos;, reason: &apos;*** </div><div class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to </div><div class="line">insert nil object from objects[0]&apos;</div></pre></td></tr></table></figure>
<p>这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id object1 = /*...*/;</div><div class="line">id object2 = /*...*/;</div><div class="line">id object3 = /*...*/;</div><div class="line">    </div><div class="line">NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];</div><div class="line">NSArray *arrayB = @[object1, object2, object3];</div></pre></td></tr></table></figure>
<p>现在考虑这样一个场景，当<strong>object1</strong>和<strong>object3</strong>指向一个有效的<code>Objective-C</code>对象，但是<strong>object2</strong>是空的。这literal array，<strong>arrayB</strong>，将会抛出一个异常。然而，<strong>arrayA</strong> 仍将会被创建但只包含<strong>object1</strong>对象。原因是<code>arrayWithObjects:</code>方法添加参数，遇到nil终止，这比预想的结束的早。</p>
<p>这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。</p>
<h4 id="Literal-Dictionaries"><a href="#Literal-Dictionaries" class="headerlink" title="Literal Dictionaries"></a>Literal Dictionaries</h4><p>字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是<code>Objective-C</code>代码中常用的。创建一个使用是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:</div><div class="line">		@&quot;Matt&quot;, @&quot;firstName&quot;, </div><div class="line">		@&quot;Galloway&quot;, @&quot;lastName&quot;, </div><div class="line">		[NSNumber numberWithInt:28], @&quot;age&quot;, </div><div class="line">		nil];</div></pre></td></tr></table></figure>
<p>这令人相当困惑，因为这顺序是<strong>object, key, object, key, …</strong>。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = </div><div class="line">	@&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, </div><div class="line">	  @&quot;lastName&quot; : @&quot;Galloway&quot;, </div><div class="line">	  @&quot;age&quot; : @28&#125;;</div></pre></td></tr></table></figure>
<p>这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是<code>Objective-C</code>对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个<code>NSNumber</code>实例中。但是Literal Syntax意味着它只是一个额外的字符。</p>
<p>就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于<code>dictionaryWithObjectsAndKeys:</code>方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。</p>
<p>另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = [personData objectForKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>与之等价的Literal Syntax是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = personData[@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。</p>
<h4 id="Mutable-Arrays-and-Dictionaries"><a href="#Mutable-Arrays-and-Dictionaries" class="headerlink" title="Mutable Arrays and Dictionaries"></a>Mutable Arrays and Dictionaries</h4><p>以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];</div><div class="line">[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure>
<p>通过Literal Syntax设置时这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutableArray[1] = @&quot;dog&quot;;</div><div class="line">mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;;</div></pre></td></tr></table></figure>
<h4 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h4><p>使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于<code>NSArray、NSNumber、NSDictionary</code>是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用<code>NSString</code>类。</p>
<p>同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，<code>mutableCopy</code>必须被调用，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy];</div></pre></td></tr></table></figure>
<p>它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。</li>
<li>通过下标法访问数组或者字典。</li>
<li>使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。</li>
</ul>
<h3 id="优先使用类型常量，减少使用-define预处理"><a href="#优先使用类型常量，减少使用-define预处理" class="headerlink" title="优先使用类型常量，减少使用#define预处理"></a>优先使用类型常量，减少使用#define预处理</h3><p>在写代码时，你经常想去定义一个常量。例如，一个<code>UIView</code>类出现和消失时它自身的动画。你可能想定义一个常量来代表动画持续的时间。你已经学会了<code>Objective-C</code>和<code>C</code>的基础，所以你决定使用的方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ANIMATION_DURATION 0.3</div></pre></td></tr></table></figure>
<p>这是一个预处理指定；每当在你的代码中出现<code>ANIMATION_DURATION</code>字符，就用0.3替代。这看起来就是你想要的，但是这种定义没有类型信息。它就像是声明了一个叫做“duration”的事物意指它的value与时间有关系，但它并不是明确的。并且，它会将所有<code>ANIMATION_DURATION</code>替换掉，如果它声明在头文件中，别的任何导入了这个头文件的类都将被替代。</p>
<p>为了解决这个问题，你应该使用编译器。有一个比使用预处理更好的办法，去定义一个常量。例如，下面这种定义常量类型为<code>NSTimeInterval</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>注意这种格式，它是有类型信息的，这种用法是好的，因为我们可以清楚地知道常量的定义。它的类型是<code>NSTimeInterval</code>，并且它有助于指出变量的使用。如果你定义了许多常量，它将会帮助以后阅读代码的人。</p>
<p>也会指出这个变量如何命名的。通常的惯例是在常量前面加上小写字母<code>k</code>（加k的原因据说是constant的首字母读音，或者德语一般写作konstant）并将其放置在实现文件中。对于需要暴露给其它类的常量，通常使用其类名作为前缀。第19节展示了更多的命名标准。</p>
<p>在哪里定义常量是重要的。有时，使用预处理定义常量是诱人的，但这是一个坏的习惯，特别是命名方式没有遵循标准的时候，它们不会冲突。例如：<code>ANIMATION_DURATION</code>常量定义在头文件是一个坏的命名。它将显示在所有导入了这个头文件的文件中。甚至作为标准的<code>static const</code>也不该出现在头文件中。自从<code>Objective-C</code>不使用命名空间（namespaces），上面的代码将会声明一个叫做<code>kAnimationDuration</code>的全局变量。它的名字前缀应该使用其所作用的类的名字，例如<code>EOCViewClassAnimationDuration</code>。第19节展示了更多的关于使用清晰命名的方案。</p>
<p>一个不需要暴露给外界的常量，应该在需要使用它的实现文件中定义。例如，如果那个动画持续时间的常量被用在一个<code>UIView</code>的子类，子类在一个iOS应用中，它看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//EOCAnimatedView.h</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface EOCAnimatedView : UIView</div><div class="line">- (void)animate;</div><div class="line">@end</div><div class="line"></div><div class="line">//EOCAnimatedView.m</div><div class="line">#import &quot;EOCAnimatedView.h&quot;</div><div class="line"></div><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div><div class="line"></div><div class="line">@implementation EOCAnimatedView</div><div class="line">- (void)animate &#123;</div><div class="line">    </div><div class="line">    [UIView animateWithDuration:kAnimationDuration</div><div class="line">                     animations:^()&#123;</div><div class="line">                     	//  Perform animations</div><div class="line">                     &#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用<code>static const</code>声明常量是重要的。使用<code>const</code>修饰符代表如果你试图在之后修改值，编译器将会报错。在这种情况下，这种做法是必需的。这个值不应该被改变。<code>static</code>修饰符的意思是其作用范围在定义它的编译单元内。编译器将其接收到的内容编译成一个目标文件，这个目标文件就是编译单元。在<code>Objective-C</code>中，每一个编译单元就是每一个实现文件。所以在前面的例子中，<code>kAnimationDuration</code>将被声明在<code>EOCAnimatedView.m</code>生成的目标文件中。如果变量没有使用<code>static</code>修饰，编译器将会创建一个外部符号给它。如果另一个编译单元也声明了一个相同名字的变量，将会抛出一个类似的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _ kAnimationDuration in:</div><div class="line">	EOCAnimatedView.o</div><div class="line">	EOCOtherView.o</div></pre></td></tr></table></figure>
<p>实际上，当使用<code>static</code>和<code>const</code>声明一个变量时，编译器最终不会创建一个符号，而是使用存在的值去替代变量，就像宏定义一样。谨记，无论如何，显示类型信息的做法是更好的。</p>
<p>有时，你会想给外部暴漏一个常量。例如，如果你的类使用<code>NSNotificationCenter</code>通知别的类，你可能想这样做。这个功能是一个对象发送通知，另一个对象注册并接收它。通知有一个字符串做名字，并且你可能将其声明为一个外部可见的常量。这样做的意思是可以让任何一个想去注册接收通知的类不需要知道实际的字符名字，而仅使用这个常量。</p>
<p>这种常量需要出现在全局的符号表中，从而可以在声明它之外的编译单元使用。因此，这些常量需要声明在不同与<code>static const</code>示例的地方。这个变量应该像这样被声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// In the header file</div><div class="line">extern NSString *const EOCStringConstant;</div><div class="line"></div><div class="line">// In the implementation file</div><div class="line">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</div></pre></td></tr></table></figure>
<p>这个常量声明在头文件，定义在实现文件。在常量类型中，<code>const</code>修饰符是非常重要的。这些声明是从后向前读的，意思是在这种情况下，<code>EOCStringConstant</code>是一个常量指向一个字符串。这正是我们想要的；常量不允许修改所指向的字符串对象。</p>
<p>当编译器在文件中发现一个<code>extern</code>修饰的常量被使用时，<code>extern</code>关键字会告诉编译器，在导入的类中去寻找。这个关键字告诉编译器在全局符号表中有一个<code>EOCStringConstant</code>的符号。这意味着编译器可以不知道常量的定义而去使用它。编译器简单的知道当文件链接为二进制文件时常量是存在的。</p>
<p>常量必须被定义并且仅定义一次。它通常定义在实现文件，声明在它的头文件。编译器将会为从实现文件生成的目标文件的数据段中的字符串分配存储空间。无论它在哪里被使用，当这个目标文件跟其他文件链接生成最后的二进制时，链接器都将能找到它的全局符号。</p>
<p>实际上，符号出现在全局符号表的意思是你应该小心常量的命名。例如，一个处理登录的类会在登录后对整个应用发送一个通知。这个通知看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// EOCLoginManager.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">extern NSString *const EOCLoginManagerDidLoginNotification;</div><div class="line"></div><div class="line">@interface EOCLoginManager : NSObject</div><div class="line">- (void)login;</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCLoginManager.m</div><div class="line">#import &quot;EOCLoginManager.h&quot;</div><div class="line"></div><div class="line">NSString *const EOCLoginManagerDidLoginNotification =</div><div class="line">	@&quot;EOCLoginManagerDidLoginNotification&quot;;</div><div class="line"></div><div class="line">@implementation EOCLoginManager</div><div class="line"></div><div class="line">- (void)login &#123;</div><div class="line">    // Perfoem login asynchronously, then call &apos;p_didLogin&apos;.</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_didLogin &#123;</div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter]</div><div class="line">      postNotificationName:EOCLoginManagerDidLoginNotification</div><div class="line">      					object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意常量的名字。常量前缀使用类的名字是谨慎的并且可以帮助你去避免冲突。这在整个系统框架中都是常见的。<code>UIKit</code>，例如，将通知名称以相同的办法声明为全局常量。这些名字包括<code>UIApplicationDidEnterBackgroundNotification</code>和<code>UIApplicationWillEnterForegroundNotification</code>.</p>
<p>其它类型的常量同样可以这样做。如果动画持续时间需要暴露在<code>EOCAnimatiedView</code>类之外，在上面的例子中，你可以这样声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//EOCAnimatedView.h</div><div class="line">extern const NSTimeInterval kAnimationDuration;</div><div class="line"></div><div class="line">//EOCAnimatedView.m</div><div class="line">const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure>
<p>用这种方法定义一个常量是优于使用宏定义的，因为编译器可以确定这个值不能被改变。在<code>EOCAnimatedView.m</code>定义一次，它的值可以在任何地方使用。一个宏定义可以重复定义，意味着一个程序的不同部分可能使用了不同的值。</p>
<p>综上所述，对于常量避免使用宏定义。相反，使用编译器可以观察的常量，如在实现文件中使用<code>static</code>、<code>const</code>声明常量。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul>
<li>避免宏定义。它们不包含任何类型信息并且可以在编译前被简单的查找替换。它们可以重新定义并且没有警告，使得整个应用的值不一致。</li>
<li>使用<code>static</code>、<code>const</code>在实现文件中定义特定编译单元的常量。这些常量将不会被暴露在全局字符表中，所以它们的名字不需要命名空间。</li>
<li>使用<code>extern</code>在头文件声明它们，在关联的实现文件定义它们。这些常量将出现在全局字符表，所以它们的名字应该需要命名空间，通常使用类名作为前缀是合理的。</li>
</ul>
<h3 id="使用枚举表示状态、选项、状态码"><a href="#使用枚举表示状态、选项、状态码" class="headerlink" title="使用枚举表示状态、选项、状态码"></a>使用枚举表示状态、选项、状态码</h3><p>因为<code>Objective-C</code>是基于<code>C</code>的，<code>C</code>的所有功能<code>Objective-C</code>都是适用的。其中一个就是枚举类型，<code>enum</code>。它在系统框架中被广泛使用，但是常常被开发者忽略。它用于定义命名常量是非常有用的，例如，错误状态码和定义选项是可以组合的。感谢<code>C++11</code>标准支持了它，最近的系统版本包含枚举类型。是的，<code>Objective-C</code>也得益于<code>C++11</code>的标准。</p>
<p>枚举仅仅是命名常量的一种方法。一个简单的枚举集合可以用来表示一个对象的状态。例如，一个socket链接使用枚举表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用一个枚举意味着代码是可读的，因为每一个状态可以通过一个易读的值去代表。在枚举中编译器给每个成员一个唯一的值，从0开始每个成员加1。这种枚举是依靠编译器支持的但需要足够的位数去表示枚举。在前面的枚举中，仅需要1个字节就够了，因为它的最大值是2。</p>
<p>然而定义枚举变量的方式却不太简洁，需要使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure>
<p>如果每次不用使用<code>enum</code>只使用<code>EOCConnectionState</code>就好了。为了这样做，你添加一个<code>typedef</code>给枚举定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef enum EOCConnectionState EOCConnectionState;</div></pre></td></tr></table></figure>
<p>它的意思是使用<code>EOCConnectionState</code>代替<code>enum EOCConnectionState</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure>
<p><code>C++11</code>标准的问世给枚举带来了一些变化。其中一个变化是可以决定使用哪种“数据类型”去存储枚举类型。这样做的好处是可以使用向前声明了。如果不指定数据类型，枚举类型无法使用向前声明，因为编译器无法知道数据类型的大小。因此，当用到枚举类型时，编译器无法知道应该给变量分配多大的空间。</p>
<p>给枚举指定数据类型，你可以使用下面这种语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger &#123; /*...*/&#125;;</div></pre></td></tr></table></figure>
<p>上面代码的意思是保证枚举的变量类型是<code>NSInteger</code>。如果你乐意，这种类型的向前声明可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger;</div></pre></td></tr></table></figure>
<p>你可以给枚举成员定义一个确切的值，而不是让编译器帮你指定。这语法看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState &#123;</div><div class="line">    EOCConnectionStateDisconnected = 1,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这意思是<code>EOCConnectionStateDisconnected</code>的值为1而不是0.别的成员变量的值同之前一样，依次递增1。例如，<code>EOCConnectionStateConnected</code>的值就是3。</p>
<p>另一种使用枚举类型的情况是去定义选项，特指当选项可以组合在一起时。只要当各选项定义的对，那么就可以使用“按位或运算符”去组合它们。例如，考虑下面的枚举类型，在<code>iOS</code>的<code>UI</code>框架中，用来表示某个视图如何调整大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing &#123;</div><div class="line">    UIViewAutoresizingNone                 = 0,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每一个选项都可以开启或者关闭，使用上面的语法可以控制它因为每个选项都仅有单一的一位值去代表它自身。使用“按位或操作”可以组合多个选项。例如：<code>UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight</code>。图1.2展示了每个枚举成员和组合两个成员后的位布局。</p>
<p>通过“按位与操作”是可以判断出某个选项是否启用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing resizing =  </div><div class="line">    UIViewAutoresizingFlexibleWidth |  </div><div class="line">    UIViewAutoresizingFlexibleHeight;  </div><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;  </div><div class="line">       // UIViewAutoresizingFlexibleWidth is set  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.2.png" alt=""></p>
<p><strong>图1.2</strong>每个选项值的二进制表示形式，以及两个选项值运用“按位或运算”之后的二进制形式。</p>
<p>枚举在系统框架中使用非常广泛。另一个例子是<code>iOS</code>中的<code>UIKit</code>框架中的，用枚举值列举视图所支持的方向并告诉系统。它使用一个叫做<code>UIInterfaceOrientationMask</code>的枚举类型来实现，并且你可以实现一个叫做<code>supportedInterfaceOrientations</code>的方法去告诉系统视图所支持的方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)supportedInterfaceOrientations &#123;  </div><div class="line">  return UIInterfaceOrientationMaskPortrait |  </div><div class="line">         UIInterfaceOrientationMaskLandscapeLeft;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Foundation</code>框架中有一些辅助宏定义，用这些宏定义可以指定枚举值的数据类型。它们提供了向后兼容性，当编译器支持新的语法特性时，它们使用新的语法；当编译器只支持旧语法特性时，它们使用旧的语法特性。这些宏是由<code>#define</code>预处理指令定义的。一个支持像<code>EOCConnectionState</code>这种普通类型的枚举，另一个支持像<code>UIViewAutoresizing</code>这种一系列选项的枚举。你可以像下面这样使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</div><div class="line">    EOCConnectionStateDisconnected,</div><div class="line">    EOCConnectionStateConnecting,</div><div class="line">    EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123;  </div><div class="line">    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,  </div><div class="line">    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,  </div><div class="line">    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,  </div><div class="line">    EOCPermittedDirectionRight = 1 &lt;&lt; 3,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些宏的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L&amp;&amp;  </div><div class="line">        (__has_extension(cxx_strong_enums) ||  </div><div class="line">         __has_feature(objc_fixed_enum))  </div><div class="line">    ) ||  </div><div class="line">    (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))  </div><div class="line">    #define NS_ENUM(_type, _name)  </div><div class="line">           enum _name : _type _name; enum _name : _type  </div><div class="line">    #if (__cplusplus)  </div><div class="line">        #define NS_OPTIONS(_type, _name)  </div><div class="line">               type _name; enum : _type  </div><div class="line">    #else  </div><div class="line">        #define NS_OPTIONS(_type, _name)  </div><div class="line">               enum _name : _type _name; enum _name : _type  </div><div class="line">    #endif  </div><div class="line">#else  </div><div class="line">    #define NS_ENUM(_type, _name) _type _name; enum  </div><div class="line">    #define NS_OPTIONS(_type, _name) _type _name; enum  </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>由于要处理不同的情况所以要用多种方式去定义两个宏。第一个判断是检查编译器是否支持新式枚举的特性。这个布尔逻辑看起来相当复杂，但它的意思就是判断编译器是否支持新特性。如果不支持，那么就用老的方式。</p>
<p>如果新特性是可用的，那么<code>NS_ENUM</code>宏所定义的类型展开后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectionState : NSUInteger EOCConnectionState;  </div><div class="line">enum EOCConnectionState : NSUInteger &#123;  </div><div class="line">    EOCConnectionStateDisconnected,  </div><div class="line">    EOCConnectionStateConnecting,  </div><div class="line">    EOCConnectionStateConnected,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>NS_OPTIONS</code>宏的展开是取决于编译形式的。如果以<code>C++</code>形式编译，那么<code>NS_OPTIONS</code>宏展开与<code>NS_ENUM</code>宏展开是不一样的，否则是一样的。为什么？因为<code>C++</code>环境下两个枚举值通过<code>按位或运算</code>结果与非<code>C++</code>环境下是不同的。前面已经提到了，作为选项的枚举值经常会通过<code>按位或运算</code>进行组合。当两个值通过<code>按位或运算</code>后，<code>C++</code>认为它们所代表的值类型是<code>NSUInteger</code>。并且也不允许饮食转换为枚举类型。为了说明这个，我们考虑将<code>EOCPermittedDirection</code>以<code>NS_ENUM</code>形式展开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCPermittedDirection : int EOCPermittedDirection;  </div><div class="line">enum EOCPermittedDirection : int &#123;  </div><div class="line">    EOCPermittedDirectionUp    = 1 &lt;&lt; 0,  </div><div class="line">    EOCPermittedDirectionDown  = 1 &lt;&lt; 1,  </div><div class="line">    EOCPermittedDirectionLeft  = 1 &lt;&lt; 2,  </div><div class="line">    EOCPermittedDirectionRight = 1 &lt;&lt; 3,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EOCPermittedDirection permittedDirections =  </div><div class="line">    EOCPermittedDirectionLeft | EOCPermittedDirectionUp;</div></pre></td></tr></table></figure>
<p>当在<code>C++</code>或者<code>Objective-C++</code>环境下，将会出现下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error: cannot initialize a variable of type  </div><div class="line">&apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos;</div></pre></td></tr></table></figure>
<p>你必须将通过<code>按位或操作</code>的结果显示的转化为<code>EOCPermittedDirection</code>。所以，在<code>C++</code>的环境下应该使用<code>NS_OPTIONS</code>，省去显示转化这一步。因此，如果需要<code>按位或操作</code>的枚举值应当尽量使用<code>NS_OPTIONS</code>，而不需要的，则使用<code>NS_ENUM</code>。</p>
<p>枚举可以用在很多情况下。选项和状态已经在前面讲过了；然后更多的情况同样适用。对错误使用状态码是一个好的习惯。把逻辑含义相似的代码放入一个枚举中，用于替代使用预定义和常量。另一个好的地方是样式。例如，你有一个<code>UI</code>元素可以创建不同的样式，一个枚举集合可以完美的表示每个样式。</p>
<p>最后一点是关于在<code>switch</code>中使用枚举变量。又是，你会这样定义它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;  </div><div class="line">    EOCConnectionStateDisconnected,  </div><div class="line">    EOCConnectionStateConnecting,  </div><div class="line">    EOCConnectionStateConnected,  </div><div class="line">&#125;;  </div><div class="line"> </div><div class="line">switch (_currentState) &#123;  </div><div class="line">    EOCConnectionStateDisconnected:  </div><div class="line">        // Handle disconnected state  </div><div class="line">        break;  </div><div class="line">    EOCConnectionStateConnecting:  </div><div class="line">        // Handle connecting state  </div><div class="line">        break;  </div><div class="line">    EOCConnectionStateConnected:  </div><div class="line">        // Handle connected state  </div><div class="line">        break;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们习惯在<code>switch</code>语句中加上默认分支。然而，当使用枚举值表示状态时，最好不要写一个默认分支。这样做的原因是，当你在稍后添加了一个新的状态，那么编译器将会警告你，提示你有新的状态未加入<code>switch</code>分支。如果有一个默认的分支，编译器将会处理它，那么编译器将不会发出警告。这个问题同样适用于别的使用<code>NS_ENUM</code>的定义中。例如，你定义一个<code>UI</code>元素，你将会希望每个情况都有一个确定的样式。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>使用枚举来表示状态机的状态，传递给函数的选项，或者错误码，并且起一个易读的名字。</li>
<li>如果把一个传递给方法的选项表示为枚举类型，同时还需要多重操作，可以将它们的值设为2的幂，然后通过<code>按位或操作</code>将其组合起来。</li>
<li>使用<code>NS_ENUM</code>和<code>NS_OPTIONS</code>宏最好给枚举定义一个明确的数据类型。这样做的意思是确定枚举的数据类型是开发者设置的，而不是编译器指定的。</li>
<li>在<code>switch</code>中使用枚举时，不要设置默认分支。这样在你添加新枚举后，编译器会提醒你添加新分支。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>基本内容图解</title>
    <link href="http://yoursite.com/2017/04/17/BasePrinciple_Img/"/>
    <id>http://yoursite.com/2017/04/17/BasePrinciple_Img/</id>
    <published>2017-04-17T11:32:16.000Z</published>
    <updated>2017-08-08T03:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Some principle！！！</p>
<a id="more"></a>
<h3 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E7%BC%96%E8%AF%91%E5%9E%8B:%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.jpeg" alt=""></p>
<h3 id="APP运行时的内存分布"><a href="#APP运行时的内存分布" class="headerlink" title="APP运行时的内存分布"></a>APP运行时的内存分布</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpeg" alt=""></p>
<h3 id="计算机硬件构成"><a href="#计算机硬件构成" class="headerlink" title="计算机硬件构成"></a>计算机硬件构成</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6.png" alt=""></p>
<h3 id="UIView的实现构成"><a href="#UIView的实现构成" class="headerlink" title="UIView的实现构成"></a>UIView的实现构成</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/UIView%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9E%84%E6%88%90.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Some principle！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://yoursite.com/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码解析</title>
    <link href="http://yoursite.com/2017/03/14/Weex_3/"/>
    <id>http://yoursite.com/2017/03/14/Weex_3/</id>
    <published>2017-03-14T11:26:52.000Z</published>
    <updated>2017-03-24T04:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0</p>
<a id="more"></a>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。</p>
<p>WeexDemo的入口是<code>[WXSDKEngine initSDKEnvironment];</code>。这个Method的主要代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];</div><div class="line">NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">[WXSDKEngine initSDKEnvironment:script];</div></pre></td></tr></table></figure>
<p>首先，读取一个叫做main.js的文件内容，然后将其内容作为<code>[WXSDKEngine initSDKEnvironment:script]</code>初始化的参数。<br>我们继续来看这个method的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!script || script.length &lt;= 0) &#123;</div><div class="line">        WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;);</div><div class="line">        return;</div><div class="line">&#125;</div><div class="line">[self registerDefaults];</div><div class="line">[[WXSDKManager bridgeMgr] executeJsFramework:script];</div></pre></td></tr></table></figure>
<h3 id="注册和执行"><a href="#注册和执行" class="headerlink" title="注册和执行"></a>注册和执行</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>首先，是对传递进来的js代码做判断，其次调用了一个<code>registerDefaults</code>的method，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    [self _registerDefaultComponents];</div><div class="line">    [self _registerDefaultModules];</div><div class="line">    [self _registerDefaultHandlers];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="Register-Componet"><a href="#Register-Componet" class="headerlink" title="Register Componet"></a>Register Componet</h5><p>这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz</div><div class="line">&#123;</div><div class="line">    [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties</div><div class="line">&#123;</div><div class="line">    if (!name || !clazz) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">    [WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</div><div class="line">    NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name];</div><div class="line">    dict[@&quot;type&quot;] = name;</div><div class="line">    if (properties) &#123;</div><div class="line">        NSMutableDictionary *props = [properties mutableCopy];</div><div class="line">        if ([dict[@&quot;methods&quot;] count]) &#123;</div><div class="line">            [props addEntriesFromDictionary:dict];</div><div class="line">        &#125;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[props]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。<code>@&quot;append&quot;:@&quot;tree&quot;</code>代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，<code>@&quot;append&quot;:@&quot;node&quot;</code>代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用<code>WXComponentFactory</code>进行注册，在这之前先讲几个相关类的功能，免得迷糊。</p>
<ul>
<li>WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承</li>
<li>WXComponentConfig: 继承<code>WXInvocationConfig</code>类，存储每个Component的method、name、classname</li>
<li>WXComponentFactory：单例类，通过字典存储<code>WXComponentConfig</code>对象，通过每个<code>WXComponentConfig</code>对象操作每个Component的method、name、classname。</li>
</ul>
<p>首先通过<code>WXComponentFactory</code>调用<code>- (void)registerComponent:(NSString 
*)name withClass:(Class)clazz withPros:(NSDictionary *)pros</code>方法注册。使用Assert判断，然后创建一个<code>WXComponentConfig</code>对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用<code>[config registerMethods];</code>将类中的method通过runtime存储在<code>WXComponentConfig</code>中，存取时加锁保证安全。其次调用<code>- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name</code>方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法<code>registerComponents</code>，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">export function registerComponents (newComponents) &#123;</div><div class="line">  if (Array.isArray(newComponents)) &#123;</div><div class="line">    newComponents.forEach(component =&gt; &#123;</div><div class="line">      if (!component) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      if (typeof component === &apos;string&apos;) &#123;</div><div class="line">        components[component] = true</div><div class="line">      &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123;</div><div class="line">        components[component.type] = component</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Register-Module"><a href="#Register-Module" class="headerlink" title="Register Module"></a>Register Module</h5><p>注册Module，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;);   </div><div class="line">NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];</div><div class="line">NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];</div><div class="line">[[WXSDKManager bridgeMgr] registerModules:dict];</div></pre></td></tr></table></figure>
<p>先介绍几个类：</p>
<ul>
<li>WXModuleConfig：继承<code>WXInvocationConfig</code>类，存储每个Component的method、name</li>
<li>WXModuleFactory：单例类，通过字典操作<code>WXModuleConfig</code>对象</li>
</ul>
<p>查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法<code>registerModules</code>。</p>
<h5 id="Register-Handler"><a href="#Register-Handler" class="headerlink" title="Register Handler"></a>Register Handler</h5><p>注册Handler，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">[WXHandlerFactory registerHandler:handler withProtocol:protocol];</div></pre></td></tr></table></figure>
<p>照例介绍几个类：</p>
<ul>
<li>WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储</li>
</ul>
<p>注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。</p>
<h4 id="ExecuteJs"><a href="#ExecuteJs" class="headerlink" title="ExecuteJs"></a>ExecuteJs</h4><p>最后调用<code>[[WXSDKManager bridgeMgr] executeJsFramework:script];</code>执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。</p>
<p>首先介绍几个类：</p>
<ul>
<li>WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能</li>
<li>WXSDKManager：单例类，通过一个字典存储所有<code>WXSDKInstance</code>实例，key是一个唯一值；一个<code>WXBridgeManager</code>实例</li>
<li>WXBridgeManager：单例类，注册，渲染功能都通过调用<code>WXBridgeContext</code>对象去跟JS交互</li>
<li>WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。</li>
<li>WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使<code>WXBridgeContext</code>调用</li>
</ul>
<p>现在可以从那句代码开始讲了，<code>[WXSDKManager bridgeMgr]</code>这个对象是一个单例，他在JS线程调用<code>executeJsFramework</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (!script) return;</div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">WXPerformBlockOnBridgeThread(^()&#123;</div><div class="line">    [weakSelf.bridgeCtx executeJsFramework:script];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>先是判空，其次weakSelf防止循环引用，然后在一个叫做<code>&quot;com.taobao.weex.bridge&quot;</code>的线程调用<code>executeJsFramework</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">WXAssertBridgeThread();</div><div class="line">WXAssertParam(script);</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_START(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">[self.jsBridge executeJSFramework:script];</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_END(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">if ([self.jsBridge exception]) &#123;</div><div class="line">    NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]];</div><div class="line">    WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);</div><div class="line">&#125; else &#123;</div><div class="line">    WX_MONITOR_SUCCESS(WXMTJSFramework);</div><div class="line">    //the JSFramework has been load successfully.</div><div class="line">    self.frameworkLoadFinished = YES;</div><div class="line">    </div><div class="line">    [self executeAllJsService];</div><div class="line">    </div><div class="line">    JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil];</div><div class="line">    if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123;</div><div class="line">        [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //execute methods which has been stored in methodQueue temporarily.</div><div class="line">    for (NSDictionary *method in _methodQueue) &#123;</div><div class="line">        [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [_methodQueue removeAllObjects];</div><div class="line">    </div><div class="line">    WX_MONITOR_PERF_END(WXPTInitalize);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先断言当前线程是否是<code>&quot;com.taobao.weex.bridge&quot;</code>线程，其次断言js代码，使用<code>WXBridgeProtocol</code>协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。</p>
<h3 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h3><h4 id="JavaScriptCore简介"><a href="#JavaScriptCore简介" class="headerlink" title="JavaScriptCore简介"></a>JavaScriptCore简介</h4><p>上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。</p>
<ul>
<li>JSVirtualMachine：为JavaScript提供运行资源</li>
<li>JSContext：为JavaScript提供运行环境</li>
<li>JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量</li>
</ul>
<h4 id="JavaScriptCore示例"><a href="#JavaScriptCore示例" class="headerlink" title="JavaScriptCore示例"></a>JavaScriptCore示例</h4><p>这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了：</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];</div><div class="line">NSLog(@&quot;%@&quot;, value); 输出5</div><div class="line">context[@&quot;sum&quot;] = @&quot;40&quot;;</div><div class="line">NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40</div></pre></td></tr></table></figure>
<p>首先初始化一个JSContext对象，可以使用<code>JSVirtualMachine</code>对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个<code>JSVirtualMachine</code>对象，所以这个js运行的资源，不可或缺。</p>
<p>第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。</p>
<p>第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。</p>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</div><div class="line">        context.exception = exception;</div><div class="line">        NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另一个要注意的点就是这里，JavaScriptCore会在<code>exceptionHandler</code>中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用<code>[JSContext currentContext]</code>获取当前的context。如果直接引用外部的context会造成循环饮用。</p>
<h5 id="invokeMethod"><a href="#invokeMethod" class="headerlink" title="invokeMethod"></a>invokeMethod</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;];    </div><div class="line">JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];</div><div class="line">NSLog(@&quot;%@&quot;, sum); 输出7</div></pre></td></tr></table></figure>
<p>初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexCallJS.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码文件夹的解释</title>
    <link href="http://yoursite.com/2017/03/14/Weex_2/"/>
    <id>http://yoursite.com/2017/03/14/Weex_2/</id>
    <published>2017-03-14T08:01:24.000Z</published>
    <updated>2017-03-15T03:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0</p>
<a id="more"></a>
<h3 id="Weex文件夹"><a href="#Weex文件夹" class="headerlink" title="Weex文件夹"></a>Weex文件夹</h3><pre><code>*最不重要的文件夹：Controller、Debug、Handler
*不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket
*稍微重要的文件夹：Component、Module、Protocol
*重要的文件夹：Display、Events、Layout、View
*最重要的文件夹：Bridge、Engine、Manager、Model
</code></pre><blockquote>
<p>Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油；</p>
<p>Debug：一个调试类，酱油；</p>
<p>Handler：两个类实现了两个Weex的Protocol，酱油；</p>
<p>Loader：一个类是Network的回调实现，一个类是WebSocket的回调。</p>
<p>Monitor：一个监测的类，输出一些信息。</p>
<p>Network:一个小型的网络请求库</p>
<p>Utility：一些常用方法的封装</p>
<p>WebSocket：对SRWebSocket的封装</p>
<p>Componet：对各种view的封装，如果需要扩展view就跟这个有关</p>
<p>Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method</p>
<p>Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。</p>
<p>Display：WXComponent的展示</p>
<p>Events：WXComponent的事件</p>
<p>Layout：WXComponent的布局</p>
<p>View：WXComponent的View</p>
<p>Bridge：Weex与NativeJS之间的桥接</p>
<p>Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等</p>
<p>Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。</p>
<p>Manager：Weex中各种管理的类</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Book</title>
    <link href="http://yoursite.com/2017/02/26/ReadBook_iOS/"/>
    <id>http://yoursite.com/2017/02/26/ReadBook_iOS/</id>
    <published>2017-02-26T11:03:08.000Z</published>
    <updated>2017-09-07T06:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个优秀iOS开发所需阅读的相关书籍</p>
<a id="more"></a>
<ol>
<li><strong>《iOS7应用开发技术详解》</strong>在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如<strong>14.2</strong>手势事件、<strong>11.3.5</strong>的<code>UIViewAutoresizing</code>等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看<strong>16</strong>、<strong>17</strong>章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。</li>
<li><strong>《iOS开发进阶》</strong>这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。</li>
<li><strong>《Objective-C高级编程》</strong>这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西<code>引用计数</code>，<code>Block</code>，<code>GCD</code>。<code>引用计数</code>这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；<code>Block</code>这块主要看的是clang rewrite 之后的代码；<code>GCD</code>是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。</li>
<li><strong>《Effective Objective-C 2.0》</strong> Effective系列的经典丛书之一，iOS开发者必读书籍之一。总共分为7章52节，有代码规范，有知识点剖析，涵盖面极广，适合初中级开发者，高级开发者需要进一步深挖其中的知识体系。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个优秀iOS开发所需阅读的相关书籍&lt;/p&gt;
    
    </summary>
    
      <category term="ReadBook" scheme="http://yoursite.com/categories/ReadBook/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex的简单使用</title>
    <link href="http://yoursite.com/2017/02/01/Weex_1/"/>
    <id>http://yoursite.com/2017/02/01/Weex_1/</id>
    <published>2017-02-01T08:33:44.000Z</published>
    <updated>2017-03-24T10:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解一下Weex的大概原理以及简单的使用</p>
<a id="more"></a>
<h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><ul>
<li>与RN相同原理，某些方面优于RN</li>
<li>js语法，比Native体验稍差，比hybrid app体验好太多</li>
<li>js一端代码，三端使用</li>
<li>iOS/Android脱离写UI的噩梦</li>
<li>文档不够完善</li>
</ul>
<h3 id="Weex原理"><a href="#Weex原理" class="headerlink" title="Weex原理"></a>Weex原理</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexTree.png" alt=""></p>
<h3 id="Weex使用"><a href="#Weex使用" class="headerlink" title="Weex使用"></a>Weex使用</h3><ul>
<li>首先，在<code>AppDelegate</code>中调用<code>[WXSDKEngine initSDKEnvironment]</code>进行注册</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line"></div><div class="line">    [WXSDKEngine initSDKEnvironment];    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其次，在需要使用的ViewController中定义一个<code>WXSDKInstance</code>实例和UI个<code>UIView</code>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) WXSDKInstance *instance;</div><div class="line">@property (nonatomic) UIView *weexView;</div></pre></td></tr></table></figure>
<ul>
<li>紧接着，初始化<code>WXSDKInstance</code>实例，设置它的viewController、frame属性，实现它的生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">_instance = [[WXSDKInstance alloc] init];</div><div class="line">_instance.viewController = self;</div><div class="line">_instance.frame = [UIScreen mainScreen].bounds;</div><div class="line">    </div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">_instance.onCreate = ^(UIView *view) &#123;</div><div class="line">    [weakSelf.weexView removeFromSuperview];</div><div class="line">    weakSelf.weexView = view;</div><div class="line">    [weakSelf.view addSubview:weakSelf.weexView];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onFailed = ^(NSError *error) &#123;</div><div class="line">    NSLog(@&quot;failed %@&quot;,error);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.renderFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;render finish&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onRenderProgress = ^(CGRect renderRect) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;renderProgress&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.updateFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;update Finish&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>最后，使用<code>WXSDKInstance</code>实例调用<code>renderWithURL:</code>方法即可。记得在<code>dealloc</code>中释放<code>WXSDKInstance</code>实例哦😯</li>
</ul>
<p><code>[self.instance renderWithURL:[NSURL URLWithString:renderURL]];</code></p>
<h3 id="Weex的自定义"><a href="#Weex的自定义" class="headerlink" title="Weex的自定义"></a>Weex的自定义</h3><ul>
<li>Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承<code>WXComponent</code>，滑动组件继承<code>WXScrollerComponent</code></li>
<li>handler: Native提供一个协议。weex官方定义了常用的部分，如<code>WXImgLoaderProtocol</code>图片下载。如果需要自定义，注意需遵守协议<code>WXModuleProtocol</code></li>
<li>module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议<code>WXModuleProtocol</code>，需要自定义Method，如果需要返回值使用<code>WXModuleCallback</code>返回</li>
<li>总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];</div><div class="line">[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];</div><div class="line">[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)];</div></pre></td></tr></table></figure>
<p>基本的Weex知识就是这些，具体使用方法请参照<a href="https://weex.apache.org/cn/" target="_blank" rel="external">官方文档</a>和demo<a href="https://github.com/alibaba/weex" target="_blank" rel="external">链接</a>。<br>下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲解一下Weex的大概原理以及简单的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
</feed>
