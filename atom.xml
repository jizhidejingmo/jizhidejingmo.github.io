<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YownYang&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-29T06:48:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YownYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译《Effective Objective-C 2.0》第一章</title>
    <link href="http://yoursite.com/2017/04/29/Accustoming%20Yourself%20to%20Objective-C/"/>
    <id>http://yoursite.com/2017/04/29/Accustoming Yourself to Objective-C/</id>
    <published>2017-04-29T06:48:05.000Z</published>
    <updated>2017-04-29T06:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是翻译《Effective Objective-C 2.0》的第一章</p>
<a id="more"></a>
<h3 id="第1章-对Objective-C的认识"><a href="#第1章-对Objective-C的认识" class="headerlink" title="第1章:对Objective-C的认识"></a>第1章:对Objective-C的认识</h3><p>Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。</p>
<p>书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。</p>
<h4 id="第1节-了解Objective-C的本源"><a href="#第1节-了解Objective-C的本源" class="headerlink" title="第1节:了解Objective-C的本源"></a>第1节:了解Objective-C的本源</h4><p>Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 	Messaging (Objective-C)</div><div class="line">	Object *obj = [Object new];</div><div class="line">	[obj performWith:parameter1 and:parameter2];</div><div class="line">	</div><div class="line">// 	Function calling (C++)</div><div class="line">	Object *obj = new Object;</div><div class="line">	obj-&gt;perform(parameter1, parameter2);</div></pre></td></tr></table></figure>
<p>两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。</p>
<p>Objective-C在运行时做了更多的工作而不是编译时。<code>runtime</code>包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，<code>runtime</code>包含所有内存管理的方法。本质上，<code>runtime</code>是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当<code>runtime</code>更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。</p>
<p>Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure>
<p>这种语法大多来源于C，声明一个叫做<code>someString</code>的变量，类型是<code>NSString *</code>。它的意思是这是一个<code>NSString</code>类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	NSString stackString;</div><div class="line">//	error:interface type cannot be statically allocated</div></pre></td></tr></table></figure>
<p><code>someString</code>变量指向某个内存地址，在堆上初始化，包含一个<code>NSString</code>对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div><div class="line">NSString *anotherString = someString;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/yownyang/Resource/raw/master/Image/OC/Figure%201.1.png" alt=""></p>
<p><strong>Figure 1.1</strong> 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它</p>
<p>这仅有一个<code>NSString</code>实例，但有两个变量指向同它。这两个变量的类型是<code>NSString *</code>，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：<code>NSString</code>实例的内存地址。</p>
<p>图1.1说明了这个结构。<code>NSString</code>实例存储了表示实际字符串所需要的字节。</p>
<p>在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。</p>
<p>Objective-C堆上的内存管理是已经抽象的。你不需要使用<code>malloc</code>和<code>free</code>去初始化和释放对象内存。Objective-C的<code>runtime</code>通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。</p>
<p>有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如<code>CGRect</code>，来源于<code>CoreGraphics</code>框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGRect frame;</div><div class="line">frame.origin.x = 0.0f;</div><div class="line">frame.origin.y = 10.0f;</div><div class="line">frame.size.width = 100.0f;</div><div class="line">frame.siez.height = 150.0f;</div></pre></td></tr></table></figure>
<p><code>CGRect</code>是一个C的结构体，定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGRect &#123;</div><div class="line">	CGRect origin;</div><div class="line">	CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CGRect CGRect;</div></pre></td></tr></table></figure>
<p>这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如<code>CGRect</code>。</p>
<p>在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。</p>
<p><strong>小结</strong></p>
<p>Objective-C是C的超集，添加了面向对象的功能。<br>Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。Objective-C是运行时而不是编译时，通过消息决定代码如何运行。</p>
<p>了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是翻译《Effective Objective-C 2.0》的第一章&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>基本内容图解</title>
    <link href="http://yoursite.com/2017/04/17/BasePrinciple_Img/"/>
    <id>http://yoursite.com/2017/04/17/BasePrinciple_Img/</id>
    <published>2017-04-17T11:32:16.000Z</published>
    <updated>2017-04-17T11:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Some principle！！！</p>
<a id="more"></a>
<p>最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解:<img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E7%BC%96%E8%AF%91%E5%9E%8B:%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.jpeg" alt=""></p>
<p>就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后…<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpeg" alt=""></p>
<p>突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6.png" alt=""></p>
<p>对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Some principle！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://yoursite.com/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码解析</title>
    <link href="http://yoursite.com/2017/03/14/Weex_3/"/>
    <id>http://yoursite.com/2017/03/14/Weex_3/</id>
    <published>2017-03-14T11:26:52.000Z</published>
    <updated>2017-03-24T04:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0</p>
<a id="more"></a>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。</p>
<p>WeexDemo的入口是<code>[WXSDKEngine initSDKEnvironment];</code>。这个Method的主要代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];</div><div class="line">NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];</div><div class="line">[WXSDKEngine initSDKEnvironment:script];</div></pre></td></tr></table></figure>
<p>首先，读取一个叫做main.js的文件内容，然后将其内容作为<code>[WXSDKEngine initSDKEnvironment:script]</code>初始化的参数。<br>我们继续来看这个method的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!script || script.length &lt;= 0) &#123;</div><div class="line">        WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;);</div><div class="line">        return;</div><div class="line">&#125;</div><div class="line">[self registerDefaults];</div><div class="line">[[WXSDKManager bridgeMgr] executeJsFramework:script];</div></pre></td></tr></table></figure>
<h3 id="注册和执行"><a href="#注册和执行" class="headerlink" title="注册和执行"></a>注册和执行</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>首先，是对传递进来的js代码做判断，其次调用了一个<code>registerDefaults</code>的method，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    [self _registerDefaultComponents];</div><div class="line">    [self _registerDefaultModules];</div><div class="line">    [self _registerDefaultHandlers];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="Register-Componet"><a href="#Register-Componet" class="headerlink" title="Register Componet"></a>Register Componet</h5><p>这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz</div><div class="line">&#123;</div><div class="line">    [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties</div><div class="line">&#123;</div><div class="line">    if (!name || !clazz) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">    [WXComponentFactory registerComponent:name withClass:clazz withPros:properties];</div><div class="line">    NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name];</div><div class="line">    dict[@&quot;type&quot;] = name;</div><div class="line">    if (properties) &#123;</div><div class="line">        NSMutableDictionary *props = [properties mutableCopy];</div><div class="line">        if ([dict[@&quot;methods&quot;] count]) &#123;</div><div class="line">            [props addEntriesFromDictionary:dict];</div><div class="line">        &#125;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[props]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [[WXSDKManager bridgeMgr] registerComponents:@[dict]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。<code>@&quot;append&quot;:@&quot;tree&quot;</code>代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，<code>@&quot;append&quot;:@&quot;node&quot;</code>代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用<code>WXComponentFactory</code>进行注册，在这之前先讲几个相关类的功能，免得迷糊。</p>
<ul>
<li>WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承</li>
<li>WXComponentConfig: 继承<code>WXInvocationConfig</code>类，存储每个Component的method、name、classname</li>
<li>WXComponentFactory：单例类，通过字典存储<code>WXComponentConfig</code>对象，通过每个<code>WXComponentConfig</code>对象操作每个Component的method、name、classname。</li>
</ul>
<p>首先通过<code>WXComponentFactory</code>调用<code>- (void)registerComponent:(NSString 
*)name withClass:(Class)clazz withPros:(NSDictionary *)pros</code>方法注册。使用Assert判断，然后创建一个<code>WXComponentConfig</code>对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用<code>[config registerMethods];</code>将类中的method通过runtime存储在<code>WXComponentConfig</code>中，存取时加锁保证安全。其次调用<code>- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name</code>方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法<code>registerComponents</code>，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">export function registerComponents (newComponents) &#123;</div><div class="line">  if (Array.isArray(newComponents)) &#123;</div><div class="line">    newComponents.forEach(component =&gt; &#123;</div><div class="line">      if (!component) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      if (typeof component === &apos;string&apos;) &#123;</div><div class="line">        components[component] = true</div><div class="line">      &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123;</div><div class="line">        components[component.type] = component</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Register-Module"><a href="#Register-Module" class="headerlink" title="Register Module"></a>Register Module</h5><p>注册Module，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;);   </div><div class="line">NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];</div><div class="line">NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];</div><div class="line">[[WXSDKManager bridgeMgr] registerModules:dict];</div></pre></td></tr></table></figure>
<p>先介绍几个类：</p>
<ul>
<li>WXModuleConfig：继承<code>WXInvocationConfig</code>类，存储每个Component的method、name</li>
<li>WXModuleFactory：单例类，通过字典操作<code>WXModuleConfig</code>对象</li>
</ul>
<p>查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法<code>registerModules</code>。</p>
<h5 id="Register-Handler"><a href="#Register-Handler" class="headerlink" title="Register Handler"></a>Register Handler</h5><p>注册Handler，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;);</div><div class="line">    </div><div class="line">[WXHandlerFactory registerHandler:handler withProtocol:protocol];</div></pre></td></tr></table></figure>
<p>照例介绍几个类：</p>
<ul>
<li>WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储</li>
</ul>
<p>注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。</p>
<h4 id="ExecuteJs"><a href="#ExecuteJs" class="headerlink" title="ExecuteJs"></a>ExecuteJs</h4><p>最后调用<code>[[WXSDKManager bridgeMgr] executeJsFramework:script];</code>执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。</p>
<p>首先介绍几个类：</p>
<ul>
<li>WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能</li>
<li>WXSDKManager：单例类，通过一个字典存储所有<code>WXSDKInstance</code>实例，key是一个唯一值；一个<code>WXBridgeManager</code>实例</li>
<li>WXBridgeManager：单例类，注册，渲染功能都通过调用<code>WXBridgeContext</code>对象去跟JS交互</li>
<li>WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。</li>
<li>WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使<code>WXBridgeContext</code>调用</li>
</ul>
<p>现在可以从那句代码开始讲了，<code>[WXSDKManager bridgeMgr]</code>这个对象是一个单例，他在JS线程调用<code>executeJsFramework</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (!script) return;</div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">WXPerformBlockOnBridgeThread(^()&#123;</div><div class="line">    [weakSelf.bridgeCtx executeJsFramework:script];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>先是判空，其次weakSelf防止循环引用，然后在一个叫做<code>&quot;com.taobao.weex.bridge&quot;</code>的线程调用<code>executeJsFramework</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">WXAssertBridgeThread();</div><div class="line">WXAssertParam(script);</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_START(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">[self.jsBridge executeJSFramework:script];</div><div class="line">    </div><div class="line">WX_MONITOR_PERF_END(WXPTFrameworkExecute);</div><div class="line">    </div><div class="line">if ([self.jsBridge exception]) &#123;</div><div class="line">    NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]];</div><div class="line">    WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);</div><div class="line">&#125; else &#123;</div><div class="line">    WX_MONITOR_SUCCESS(WXMTJSFramework);</div><div class="line">    //the JSFramework has been load successfully.</div><div class="line">    self.frameworkLoadFinished = YES;</div><div class="line">    </div><div class="line">    [self executeAllJsService];</div><div class="line">    </div><div class="line">    JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil];</div><div class="line">    if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123;</div><div class="line">        [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //execute methods which has been stored in methodQueue temporarily.</div><div class="line">    for (NSDictionary *method in _methodQueue) &#123;</div><div class="line">        [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [_methodQueue removeAllObjects];</div><div class="line">    </div><div class="line">    WX_MONITOR_PERF_END(WXPTInitalize);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先断言当前线程是否是<code>&quot;com.taobao.weex.bridge&quot;</code>线程，其次断言js代码，使用<code>WXBridgeProtocol</code>协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。</p>
<h3 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h3><h4 id="JavaScriptCore简介"><a href="#JavaScriptCore简介" class="headerlink" title="JavaScriptCore简介"></a>JavaScriptCore简介</h4><p>上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。</p>
<ul>
<li>JSVirtualMachine：为JavaScript提供运行资源</li>
<li>JSContext：为JavaScript提供运行环境</li>
<li>JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量</li>
</ul>
<h4 id="JavaScriptCore示例"><a href="#JavaScriptCore示例" class="headerlink" title="JavaScriptCore示例"></a>JavaScriptCore示例</h4><p>这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了：</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];</div><div class="line">NSLog(@&quot;%@&quot;, value); 输出5</div><div class="line">context[@&quot;sum&quot;] = @&quot;40&quot;;</div><div class="line">NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40</div></pre></td></tr></table></figure>
<p>首先初始化一个JSContext对象，可以使用<code>JSVirtualMachine</code>对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个<code>JSVirtualMachine</code>对象，所以这个js运行的资源，不可或缺。</p>
<p>第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。</p>
<p>第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。</p>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</div><div class="line">        context.exception = exception;</div><div class="line">        NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另一个要注意的点就是这里，JavaScriptCore会在<code>exceptionHandler</code>中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用<code>[JSContext currentContext]</code>获取当前的context。如果直接引用外部的context会造成循环饮用。</p>
<h5 id="invokeMethod"><a href="#invokeMethod" class="headerlink" title="invokeMethod"></a>invokeMethod</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;];    </div><div class="line">JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];</div><div class="line">NSLog(@&quot;%@&quot;, sum); 输出7</div></pre></td></tr></table></figure>
<p>初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。<br><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexCallJS.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex源码文件夹的解释</title>
    <link href="http://yoursite.com/2017/03/14/Weex_2/"/>
    <id>http://yoursite.com/2017/03/14/Weex_2/</id>
    <published>2017-03-14T08:01:24.000Z</published>
    <updated>2017-03-15T03:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0</p>
<a id="more"></a>
<h3 id="Weex文件夹"><a href="#Weex文件夹" class="headerlink" title="Weex文件夹"></a>Weex文件夹</h3><pre><code>*最不重要的文件夹：Controller、Debug、Handler
*不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket
*稍微重要的文件夹：Component、Module、Protocol
*重要的文件夹：Display、Events、Layout、View
*最重要的文件夹：Bridge、Engine、Manager、Model
</code></pre><blockquote>
<p>Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油；</p>
<p>Debug：一个调试类，酱油；</p>
<p>Handler：两个类实现了两个Weex的Protocol，酱油；</p>
<p>Loader：一个类是Network的回调实现，一个类是WebSocket的回调。</p>
<p>Monitor：一个监测的类，输出一些信息。</p>
<p>Network:一个小型的网络请求库</p>
<p>Utility：一些常用方法的封装</p>
<p>WebSocket：对SRWebSocket的封装</p>
<p>Componet：对各种view的封装，如果需要扩展view就跟这个有关</p>
<p>Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method</p>
<p>Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。</p>
<p>Display：WXComponent的展示</p>
<p>Events：WXComponent的事件</p>
<p>Layout：WXComponent的布局</p>
<p>View：WXComponent的View</p>
<p>Bridge：Weex与NativeJS之间的桥接</p>
<p>Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等</p>
<p>Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。</p>
<p>Manager：Weex中各种管理的类</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Book</title>
    <link href="http://yoursite.com/2017/02/26/ReadBook_iOS/"/>
    <id>http://yoursite.com/2017/02/26/ReadBook_iOS/</id>
    <published>2017-02-26T11:03:08.000Z</published>
    <updated>2017-04-01T03:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS相关书籍…</p>
<a id="more"></a>
<ol>
<li><strong>《iOS7应用开发技术详解》</strong>在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如<strong>14.2</strong>手势事件、<strong>11.3.5</strong>的<code>UIViewAutoresizing</code>等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看<strong>16</strong>、<strong>17</strong>章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。</li>
<li><strong>《iOS开发进阶》</strong>这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。</li>
<li><strong>《Objective-C高级编程》</strong>这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西<code>引用计数</code>，<code>Block</code>，<code>GCD</code>。<code>引用计数</code>这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；<code>Block</code>这块主要看的是clang rewrite 之后的代码；<code>GCD</code>是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS相关书籍…&lt;/p&gt;
    
    </summary>
    
      <category term="ReadBook" scheme="http://yoursite.com/categories/ReadBook/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS-Weex的简单使用</title>
    <link href="http://yoursite.com/2017/02/01/Weex_1/"/>
    <id>http://yoursite.com/2017/02/01/Weex_1/</id>
    <published>2017-02-01T08:33:44.000Z</published>
    <updated>2017-03-24T10:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解一下Weex的大概原理以及简单的使用</p>
<a id="more"></a>
<h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><ul>
<li>与RN相同原理，某些方面优于RN</li>
<li>js语法，比Native体验稍差，比hybrid app体验好太多</li>
<li>js一端代码，三端使用</li>
<li>iOS/Android脱离写UI的噩梦</li>
<li>文档不够完善</li>
</ul>
<h3 id="Weex原理"><a href="#Weex原理" class="headerlink" title="Weex原理"></a>Weex原理</h3><p><img src="https://github.com/yownyang/Resource/raw/master/Image/Weex/WeexTree.png" alt=""></p>
<h3 id="Weex使用"><a href="#Weex使用" class="headerlink" title="Weex使用"></a>Weex使用</h3><ul>
<li>首先，在<code>AppDelegate</code>中调用<code>[WXSDKEngine initSDKEnvironment]</code>进行注册</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line"></div><div class="line">    [WXSDKEngine initSDKEnvironment];    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其次，在需要使用的ViewController中定义一个<code>WXSDKInstance</code>实例和UI个<code>UIView</code>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) WXSDKInstance *instance;</div><div class="line">@property (nonatomic) UIView *weexView;</div></pre></td></tr></table></figure>
<ul>
<li>紧接着，初始化<code>WXSDKInstance</code>实例，设置它的viewController、frame属性，实现它的生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">_instance = [[WXSDKInstance alloc] init];</div><div class="line">_instance.viewController = self;</div><div class="line">_instance.frame = [UIScreen mainScreen].bounds;</div><div class="line">    </div><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">_instance.onCreate = ^(UIView *view) &#123;</div><div class="line">    [weakSelf.weexView removeFromSuperview];</div><div class="line">    weakSelf.weexView = view;</div><div class="line">    [weakSelf.view addSubview:weakSelf.weexView];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onFailed = ^(NSError *error) &#123;</div><div class="line">    NSLog(@&quot;failed %@&quot;,error);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.renderFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;render finish&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.onRenderProgress = ^(CGRect renderRect) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;renderProgress&quot;);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">_instance.updateFinish = ^(UIView *view) &#123;</div><div class="line">    NSLog(@&quot;update Finish&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>最后，使用<code>WXSDKInstance</code>实例调用<code>renderWithURL:</code>方法即可。记得在<code>dealloc</code>中释放<code>WXSDKInstance</code>实例哦😯</li>
</ul>
<p><code>[self.instance renderWithURL:[NSURL URLWithString:renderURL]];</code></p>
<h3 id="Weex的自定义"><a href="#Weex的自定义" class="headerlink" title="Weex的自定义"></a>Weex的自定义</h3><ul>
<li>Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承<code>WXComponent</code>，滑动组件继承<code>WXScrollerComponent</code></li>
<li>handler: Native提供一个协议。weex官方定义了常用的部分，如<code>WXImgLoaderProtocol</code>图片下载。如果需要自定义，注意需遵守协议<code>WXModuleProtocol</code></li>
<li>module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议<code>WXModuleProtocol</code>，需要自定义Method，如果需要返回值使用<code>WXModuleCallback</code>返回</li>
<li>总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];</div><div class="line">[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];</div><div class="line">[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)];</div></pre></td></tr></table></figure>
<p>基本的Weex知识就是这些，具体使用方法请参照<a href="https://weex.apache.org/cn/" target="_blank" rel="external">官方文档</a>和demo<a href="https://github.com/alibaba/weex" target="_blank" rel="external">链接</a>。<br>下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲解一下Weex的大概原理以及简单的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
  </entry>
  
</feed>
