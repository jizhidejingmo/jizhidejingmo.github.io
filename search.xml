<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第四章]]></title>
      <url>%2F2017%2F06%2F19%2FProtocols%20and%20Categories%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第四章：协议和分类 简介协议是Objective-C语言的一个功能，类似Java的接口。Objective-C没有多重继承，因此我们把某个类应该实现的方法定义在协议中。协议最多的用法是实现委托模式(看第23节)，但是它也有别的用法。了解并使用它们可以使代码更易于维护，因为这是记录代码接口的好方法。 分类也是Objective-C语言的一个重要功能。它提供了一种给类添加方法而不需要添加子类的机制，而在其他方法中则不行。由于运行时的高度动态性，这一特性成为可能，但它也有一些缺陷，你应该在使用之前了解这些缺陷。 通过委托与数据源协议进行对象间通信对象之间经常需要通信。Objective-C开发者都知道一种叫做委托协议的设计模式。它的本质是定义一个接口，使任何遵循这个接口的类成为另一个类的委托(PS:为了便于理解，定义接口的类是委托类，遵循接口的类是被委托类)。当事件发生时，委托类就可以获取一些信息或者告知被委托类。 使用这种模式可以使得数据解耦。例如，一个展示数据列表的类应该只处理数据展示的逻辑，而不需要知道数据的类型或者数据之间的逻辑。这个视图对象应该有某个属性去处理数据和事件。它们各自被称为数据源和委托。 在Objective-C中，实现这种模式的常用方法是使用协议这种语言特性，它被用于整个Cocoa框架。如果你使用了这种功能，你会发现你的代码非常健壮。 例如，有一个类是从网络获取数据的。这个类从远端服务器获得数据。服务器可能需要花费很多时间才会相应，如果一直处在等待中，这是一种坏的体验。所以，通常会使用委托模式，这个网络类会有一个协议对象，并且当数据返回时，回调这个对象。图4.1展示了这个概念；EOCDataModel对象是被委托类，EOCNetworkFetcher是委托类。EOCDataModel让EOCNetworkFetcher执行一个异步任务，当任务执行完毕时，EOCNetworkFetcher调用这个委托。 Figure 4.1 一次委托回调的流程。注意委托对象并不需要一定是EOCDataModel实例，也可以是另外的实例。 使用Objective-C的协议可以很容易的实现这个模式。像图4.1这种情况，这个协议可能是这样定义的: 12345678@protocol EOCNetworkFetcherDelegate- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error;@end 一个委托协议的命名通常是类名后面追加delegate，整个名字使用骆驼命名法。给你的委托协议使用这种命名法可以使任何使用者都感到熟悉。 类会使用协议声明一个属性用于存放被委托者。在我们的例子中， 定义属性的类就是EOCNetworkFetcher类。因此，这个类的接口是这样的： 123@interface EOCNetworkFetcher : NSObject@property (nonatomic, weak) id &lt;EOCNetworkFetcherDelegate&gt; delegate;@end 确保这个属性定义为weak而不是strong是非常重要的，因为它必须是非拥有关系。通常情况下，被委托者对象也会持有本对象。例如，一个对象想使用EOCNetworkFetcher，它将会持有EOCNetworkFetcher对象直到用完为止。如果属性使用strong特质持有被委托者对象，那么就会形成循环引用。因此，这个协议属性需要定义成weak或者unsafe_unretained，如果需要在释放时自动情况值，那么需要使用weak，如果不需要释放，那么就使用unsafe_unretained。它们的持有关系如图4.2。 Figure 4.2 持有关系图展示了不保留delegate属性，可以避免循环引用。 实现委托的办法是声明某个类遵循协议，然后实现任何你想使用的协议方法。你可以在接口文件中声明类遵循的协议，也可以在类扩展(看第27节)中实现。如果你想告诉别人你事先了某个协议那么在接口中实现；但是像委托这种情况，一般都是在类的内部使用。所以它通常像这样被声明在类扩展中： 12345678910111213141516@interface EOCDataModel () &lt;EOCNetworkFetcherDelegate&gt;@end@implementation EOCDataModel- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data &#123; /* Handle data */&#125;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error &#123; /* Handle error */&#125;@end 通常，协议中的方法是可以选择实现的，因为被委托对象可能并不关心所有的方法。在这个例子中，DataModel类可能不关心错误的方法，所以它可能不会实现networkFetcher:didFailWithError:这个方法。为了指明可选方法，通过使用@optional关键字标注大部分或者所有的方法： 12345678910@protocol EOCNetworkFetcherDelegate@optional- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error;@end 如果要在通过被委托对象调用可选方法，那么就要判断被委托对象是否能响应这个方法。在EOCNetworkFetcher这个例子中，它可能是这样写的： 123456NSData *data = /* data obtained from network */;if ([_delegate respondsToSelector: @selector(networkFetcher:didReceiveData:)]) &#123; [_delegate networkFetcher:self didReceiveData:data];&#125; respondsToSelector:这个方法用于确认被委托者是否实现了某个方法。如果实现了，就调用它；如果没实现，什么也不做。这样的话，协议方法就是可选的了，并且不会因为没有实现某个方法而出问题。即使没有设置被委托对象，也是没有问题的，因为给空发送消息将会使得if语句的值为false。 协议中的方法名也是很重要的。方法名应该准确描述当前发生了什么，以及为什么要处理此事件。在这个例子中，协议方法读起来非常清楚，一个存在的EOCNetworkFetcher对象刚刚接收到了一些数据。你应该通过协议方法将被委托对象传递出去，就像上面的例子一样，这样当有特殊情况时可以根据被委托实例进行区分。例如： 12345678- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data &#123; if (fetcher == _myFetcherA) &#123; /* Handle data */ &#125; else if (fetcher == _myFetcherB) &#123; /* Handle data */ &#125;&#125; 这里有两个被委托实例，所以要区分到底哪个实例接受了数据。如果没有传入被委托实例，那么同一时间只能处理一个网络请求，这样不是很好。 协议方法也可以用来从被委托者中获取消息。例如，EOCNetworkFetcher类可能想提供这样一个机制，当获取数据发生重定向时，那么将向被委托对象询问是否允许发生重定向。这个协议方法看起来是这样的： 1- (BOOL)networkFetcher:(EOCNetworkFetcher*)fetcher shouldFollowRedirectToURL:(NSURL*)url; 这个例子解释了为什么这种模式叫做委托模式，因为是一个对象委托另一个对象去处理一些行为。 协议也可以提供一套接口给需要获取数据的类使用。这种委托模式被称为数据源模式，因为它的作用是给委托者提供数据。数据源模式中，信息从被委托者流向委托者；而正常的委托模式，信息是从委托者流向被委托者。图4.3展示了这个流程。 Figure 4.3 数据源模式中，信息从被委托者流向委托者；而在普通的委托模式，信息是从委托者流向被委托者。 例如，用户界面的列表对象使用数据源协议获取数据用于展示在列表中。列表视图还有一个委托协议用来处理用户操作。通过分隔数据源和委托协议，提供了一个清晰的接口，因为它们的逻辑也被分离了。另外，你可以使用一个对象处理数据源，另一个对象处理委托。然而，一般情况下，两者都是同一个对象。 如果数据源的方法和委托的方法大多数可选的，那么你将会写大量类似这样的代码： 1234if ([_delegate respondsToSelector:@selector(someClassDidSomething:)]) &#123; [_delegate someClassDidSomething];&#125; 检查被委托者是否实现了一个确定的方法是非常迅速的，但是如果一直这样做，那么除了第一次之外其余的是多余的。如果被委托对象本身没有发生变化，那么不太可能会突然开始响应或停止响应某个方法。因此，可以将被委托者是否能响应方法的结果缓存在协议中。例如，EOCNetworkFetcher类有一个被委托对象，它用于表示获取进度的回调方法，每当进度发生变化，就会调用被委托对象实现的协议方法。那么在这个生命周期中，这个方法将会被多次调用，并且每次都会检查是否相应这个方法。 将刚才说的方法加进协议中，目前协议中的定义是这样的： 12345678910111213@protocol EOCNetworkFetcherDelegate@optional- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didUpdateProgressTo:(float)progress;@end 这里新增了一个叫做networkFetcher:didUpdateProgressTo:的方法。缓存这个相应结果的最好办法是使用位段数据结构。这是一项很少使用的C语言特性，但在这里确实很合适的。它允许你定义一个确定的结构体位段，并且设置特定的值。看起来是这样的： 123456struct data &#123; unsigned int fieldA : 8; unsigned int fieldB : 4; unsigned int fieldC : 2; unsigned int fieldD : 1;&#125;; 在这个结构体中，fieldA使用8个二进制位，fieldB使用4个二进制位，fieldC使用2个二进制位，fieldD使用1个二进制位。所以fieldA可以表示0-255的数字，fieldD可以表示0或者1。如果创建的结构体中只有大小为1的位段，那么就能把许多布尔值塞入数据中了。以EOCNetworkFetcher类为例，你可以设置一个包含有位段的结构体为实例变量，结构体中的没一个变量代表一个协议方法。这个结构体是这样的： 1234567891011@interface EOCNetworkFetcher () &#123; struct &#123; unsigned int didReciveData : 1; unsigned int didFailWithError : 1; unsigned int didUpdateProgressTo : 1; &#125; _delegateFlags;&#125;@end 这里，我使用了类扩展去添加实例变量，具体描述在第27节；这个实例变量是一个结构体包含三个位段，每个位段代表一个协议方法。在EOCNetworkFetcher类中，可以像下面这样查询并设置结构体中的位段： 123456// Set flag_delegateFlags.didReceiveData = 1;// Check flagif (_delegateFlags.didReceiveData) &#123; // Yes, flag set&#125; 这个结构体用来魂村被委托对象是否能相应某个指定方法的结果。实现缓存功能的代码可以写在delegate属性的setter方法中： 1234567- (void)setDelegate:(id&lt;EOCNetworkFetcher&gt;)delegate &#123; _delegate = delegate; _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector (networkFetcher:didUpdateProgressTo:)] ;&#125; 这样每次调用delegate的相关方法时，就不需要检测被委托对象是否能响应指定的方法了，可以直接查询结构体中的标志： 1234if (_delegateFlags.didUpdateProgressTo) &#123; [_delegate networkFetcher:self didUpdateProgressTo:currentProgress];&#125; 如果多次调用判断方法，那么这个优化是有价值的。是否优化需要取决你的代码。你应该使用性能检测工具检测你的代码是否遇到性能瓶颈，如果需要优化可以使用类似技巧。如果频繁从数据源获取数据，那么该优化技术极大可能提高程序效率。 小结 委托模式为对象提供了一套接口，使其可将相关事件告诉其他对象。 在协议中把可能需要处理的事件定义成方法。 当一个对象需要从别的对象获取数据时，使用委托模式。在这种情况下，该模式被称为数据源模式。 如果需要，可以实现包含位段的结构体，用于缓存被委托者相应指定方法的结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第三章]]></title>
      <url>%2F2017%2F06%2F08%2FInterface%20and%20API%20Design%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第三章：接口和API设计 简介一旦你构建过一个应用程序，那么你可能会想在将来的项目中重用部分代码。你甚至可能想要发布一些代码给他人使用。即使你认为你不会这样做，你也可能在别的地方用到。当你阅读过本节，它将帮你写出合适的接口声明。这意味着你需要理解各种缺陷，才能写出标准模板一样的Objective-C代码。 近年来，随着iOS的问世，带来了大量的开源社区和流行的组件，你经常会在自己的项目里使用别人的代码。相似的，别人也可能会使用你的代码，所以写出清晰的代码可以使别人更快、更容易的整合你的代码。并且谁也不知道，你写下的某个库会不会被成千上万的应用使用呢！ 使用前缀名去避免命名空间冲突不像别的语言，Objective-C没有命名空间功能。由于这个原因，如果没有采取措施去避免，命名冲突是非常容易出现的。由于符号重复编译错误，命名冲突对应用的影响是可能导致项目无法链接，例如： 123456duplicate symbol _OBJC_METACLASS_$_EOCTheClass in: build/something.o build/something_else.oduplicate symbol _OBJC_CLASS_$_EOCTheClass in: build/something.o build/something_else.o 这个错误结果是因为某个符号在EOCTheClass类和其元类(看第14节)的符号表定义了两次。在应用程序的两部分代码中，同时存在EOCTheClass类的两个实现，那个符号也就自然会定义两次。 更糟糕的是，如果在链接时没有发现某个库包含了一份重复的代码，而是在运行时加载。在这种情况下，动态加载器将会遭遇重复符号错误并且导致应用程序崩溃。 仅有一种办法去避免这个问题就是去使用一个粗糙的命名空间：给所有的名字加上一个确定的前缀。这个前缀应该选择你公司名字或者应用名字或者两者结合。例如，如果你的公司名字叫做Effective Widgets，你可能决定在应用中使用EWS前缀，如果是EWB前缀，仅仅因为你的应用叫做Effective Browser。即使你加上了前缀也不会没有名称冲突，但是会减少发生的次数。 如果你使用Cocoa创建应用程序，需要注意苹果已经表明可能会使用任意两个字母作为前缀，所以在这种情况下，你应该选择三个字母做前缀。例如，如果你不遵守这项约定并使用了TW作为前缀，那么将会产生问题。当iOS 5.0的SDK发布时，它带来了Twitter框架，并且选择TW作为前缀，有一个叫做TWRequest的类用于支持Twitter API的HTTP请求。如果你的公司叫做Tiny Widgets，并且有你自己用的API，那么你很大可能会有一个叫做TWRequest的类。 在你的应用中，前缀不该带有类名但应该适用于所有的类。第25节讲述了如果类别基于存在的类，类别名字和方法名字前缀的重要性。另一个常被忽视的问题是与C函数的冲突或者你在类的实现文件中使用的全局变量。通常很容易忘记全局变量在编译后的目标文件中是作为顶级符号出现的。例如，在iOS SDK中的AudioToolbox框架，它有一个函数用于播放一个声音文件。你可以给它一个回调从而在它结束时调用它。你可能会去写一个类，当声音文件播放结束时，去调用它，像下面这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// EOCSoundPlayer.h#import &lt;Foundation/Foundation.h&gt;@class EOCSoundPlayer;@protocol EOCSoundPlayerDelegate &lt;NSObject&gt;- (void)soundPlayerDidFinish:(EOCSoundPlayer*)player;@end@interface EOCSoundPlayer : NSObject@property (nonatomic, weak) id &lt;EOCSoundPlayerDelegate&gt; delegate;- (id)initWithURL:(NSURL *)url;- (void)playSound;@end// EOCSoundPlayer.m#import &quot;EOCSoundPlayer.h&quot;#import &lt;AudioToolbox/AudioToolbox.h&gt;void completion(SystemSoundID ssID, void *clientData) &#123; EOCSoundPlayer *player = (__bridge EOCSoundPlayer*)clientData; if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) &#123; [player.delegate soundPlayerDidFinish:player]; &#125;&#125;@implementation EOCSoundPlayer &#123; SystemSoundID _systemSoundID;&#125;- (id)initWithURL:(NSURL *)url &#123; if (self = [super init]) &#123; AudioServicesCreateSystemSoundID((__bridge CFURLRef)url, &amp;_systemSoundID); &#125; return self;&#125;- (void)dealloc &#123; AudioServicesDisposeSystemSoundID(_systemSoundID);&#125;- (void)playSound &#123; AudioServicesAddSystemSoundCompletion( _systemSoundID, NULL, NULL, completion, (__bridge void*)self); AudioServicesPlaySystemSound(_systemSoundID);&#125;@end 这看起来没什么问题，但是从这个目标文件的符号表中发现了一点不同，如下： 1234567891011121314151600000230 t -[EOCSoundPlayer .cxx_destruct]0000014c t -[EOCSoundPlayer dealloc]000001e0 t -[EOCSoundPlayer delegate]0000009c t -[EOCSoundPlayer initWithURL:]00000198 t -[EOCSoundPlayer playSound]00000208 t -[EOCSoundPlayer setDelegate:]00000b88 S _OBJC_CLASS_$_EOCSoundPlayer00000bb8 S _OBJC_IVAR_$_EOCSoundPlayer._delegate00000bb4 S _OBJC_IVAR_$_EOCSoundPlayer._systemSoundID00000b9c S _OBJC_METACLASS_$_EOCSoundPlayer00000000 T _completion00000bf8 s l_OBJC_$_INSTANCE_METHODS_EOCSoundPlayer00000c48 s l_OBJC_$_INSTANCE_VARIABLES_EOCSoundPlayer00000c78 s l_OBJC_$_PROP_LIST_EOCSoundPlayer00000c88 s l_OBJC_CLASS_RO_$_EOCSoundPlayer00000bd0 s l_OBJC_METACLASS_RO_$_EOCSoundPlayer 注意符号表的中间部分，有一个符号叫做_completion。它是completion函数创建的用于在声音播放结束时做一些事情。即使它是在实现文件实现的，并且没有在头文件声明它，它依然作为顶级符号出现在这里。因此，如果某处创建的函数也叫做completion，那么将会出现一个错误，像下面这样的： 123duplicate symbol _completion in: build/EOCSoundPlayer.o build/EOCAnotherClass.o 更糟糕的是如果你把库给别人用，他们在自己的应用中使用它。如果你暴漏了一个类似_completion的符号，任何使用你这个库的人都可能会创建一个叫做_completion的函数，这是非常不幸的。 所以你应该给它加上类似于C函数的前缀。例如，在之前的例子中，你可以将completion命名为EOCSoundPlayerCompletion。如果符号曾在回溯堆栈时出现，即使出现问题，也是异域排查的。 当你使用第三方库或者将你的代码制作成库给别人使用时，你要特别小心重复符号的问题。当你在你的应用程序中使用了第三方库时，重复符号错误是容易发生的。在这种情况下，通常会使用自己的前缀去给所有的第三方库加上前缀。例如，如果你的库叫做EOCLibrary并且你添加了一个叫做XYZLibrary的库，你将给XYZLibrary添加EOC前缀。然后应用程序使用XYZLibrary时，就没有命名冲突的机会了，如图3.1。 Figure 3.1 避免第三方库两次编译：一次应用程序本身另一次是库本身 仔细检查并更改所有的名字，看起来是件乏味的事情，但如果你想避免命名冲突，那是很有用的。你可能会问为什么需要这样做，并且为什么应用程序不能简单的包含XYZLibrary库本身并且使用它的实现。这也是可以的，但你考虑下面这个场景，你的应用程序包含另一个第三方库，叫做ABCLibrary，并且它也使用了XYZLibrary。在这种情况下，如果你和ABCLibrary库的作者都没有前缀，那么应用程序仍将发生重复符号的错误。或者你使用XYZLibrary的X版本，但是应用需要的功能是Y版本，那么它将会自动拷贝。如果你在开发的时候使用流行的第三方库，你将经常看到这种类型的前缀。 小结 选择一个适合的前缀，可以是公司名，应用名，或者都可以。并且一直使用这个前缀。 当你使用的第三方库依赖你自己的库，考虑给它的名字加上你的前缀。 提供指定的初始化器所有的对象都需要初始化。当你初始化一个对象时，有时你不需要给他任何信息，有时需要。这种情况通常出现在没有信息就不能执行相应的方法的情况。例如，iOS的UIKit框架中的UITableViewCell，组中不同类型的cell需要不同的类型和标示符，这样可以使用cell对象的复用功能，而不需要一直去创建。在初始化时，赋予对象执行任务所需的信息，在术语上称为指定初始化器。 一个类中有多种方法去创建实例，那么这个类可能会有多个初始化方法。这是很好的，但是应该其余方法调用指定的初始化方法。一个例子是NSDate，像下面这样的初始化方法： 123456- (id)init- (id)initWithString:(NSString*)string- (id)initWithTimeIntervalSinceNow:(NSTimeInterval)seconds- (id)initWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate*)refDate- (id)initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds- (id)initWithTimeIntervalSince1970:(NSTimeInterval)seconds 上述情况中的指定初始化器是- (id)initWithTimeIntervalSinceReferenceDate:，类中的文档说明了这一点。它的意思是别的初始化方法其实都是调用了这个初始化方法。因此，指定的初始化器是存储内部数据的唯一地方。如果需要改变数据存储，那么仅需要改变这个方法就可以了。 例如，考虑一个代表范围的类。它的接口应该像下面这样： 12345#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject@property (nonatomic, assign, readonly) float width;@property (nonatomic, assign, readonly) float height;@end 注意上述属性是只读(看第18节)的。这意味着矩形对象不能在外部修改它的属性。所以你可能创建一个这样的初始化方法： 123456789- (id)initWithWidth:(float)width andHeight:(float)height&#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125; 但是如果某些调用使用[[EOCRectangle alloc] init]去创建实例呢？这样做是合法的，因为EOCRectangle的父类是NSObject，NSObject实现了一个叫做init的方法，它将所有的对象设置为0(或者是等价于0的数据类型)。如果这个方法被调用，那么EOCRectangle实例的宽和高都将为0。虽然这可能是你想要的，但是你可能更喜欢设置一个默认值，或者通过抛出异常告诉调用者，必须使用你的指定的初始化方法。在EOCRectangle这种情况下，它可能会这样覆盖init方法： 123456789101112// Using default values- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125; // Throwing an exception- (id)init &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:andHeight: instead.&quot; userInfo:nil];&#125; 注意设置默认值的版本如何调用初始化方法的。它也可以通过直接设置_width和_height两个实例变量。然而，如果类的存储发生了一些变化。例如，通过一个结构体去存储宽和高的值的集合，你将会需要修改两个方法的逻辑。在这个简单例子中，这还不算坏，但是想象下一个复杂的类有很多初始化方法和复杂的数据。那么将会很容易忘记修改其中的一个，从而导致冲突。 想象下，你现在想去给EOCRectangle创建一个叫做EOCSquare的子类。这种使用场景很常见，但是初始化器该怎么办？很明显，应该强制宽和高相等，因为它是一个正方形！所以你可能决定这样创建初始化： 12345678910111213#import &quot;EOCRectangle.h&quot;@interface EOCSquare : EOCRectangle- (id)initWithDimension:(float)dimension;@end@implementation EOCSquare- (id)initWithDimension:(float)dimension &#123; return [super initWithWidth:dimension andHeight:dimension];&#125;@end 它将变成EOCSquare的初始化器。注意它如何调用父类的指定初始化器。如果你往回看了EOCRectangle的指定初始化器，你将会看到它也调用了父类的指定初始化器。指定初始化器链条是重要的。然而，它仍然可能调用initWithWidth:andHeight:或者init方法去创建对象。你当然不想这样喽，因为有人可能会创建一个宽高不一致的正方形。这是一个重要的点在你子类化某个类时。在子类中如果你有一个不同名字的指定初始化器，你应该总是覆盖指定初始化器。在EOCSquare这种情况下，你可以覆盖EOCRectangle的指定初始化器： 1234- (id)initWithWidth:(float)width andHeight:(float)height &#123; float dimension = MAX(width, height); return [self initWithDimension:dimension];&#125; 注意EOCSquare的指定初始化器是如何调用的。在这种实现情况下，如果调用者调用init方法，仍将产生神奇的事情。回想下EOCRectangle类，init方法的实现是去调用自身的指定初始化器，并且设置默认值。它仍然工作，但是因为initWithWidth:andHeight:方法已经被覆盖，所以它会调用EOCSquare的实现，它会依次调用初始化方法。这样一切正常，并不会创建一个宽高不等的正方形。 有时，你并不想去覆盖父类的指定初始化器，因为没有意义。例如，你可能会觉得一个EOCSquare对象使用initWithWidth:andHeight:方法创建很奇怪。你可能会认为它是一个使用错误。这种情况下，通常的做法是覆盖这个方法并且抛出一个异常： 123456- (id)initWithWidth:(float)width andHeight:(float)height &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instead.&quot; userInfo:nil];&#125; 这看起来有点过于严格，但有时是必要的，这样可以保持内部数据的一致性。在EOCRectangle和EOCSquare这种情况下，这意味着如果调用init方法会抛出错误，因为init方法会调用initWithWidth:andHeight:。这时，你可能会去重写init方法，并让其调用initWithDimension:。 123- (id)init &#123; return [self initWithDimension:5.0f];&#125; 然而，在Objective-C中，抛出异常代表这是一个致命错误(看21节)，如果不能初始化实例，抛出异常应该是最后的选择。 在一些情况下，你可能需要多个指定初始化器。当对象可以以两种不同方式去初始化，那么就需要不止一个指定初始化器了。一个例子是NSCoding的协议，这是一种序列化机制，允许对象进行编码和解码。这种机制在Appkit和UIKit中也是使用广泛的，这两个UI框架分别源于Mac OS X和iOS，并且给对象提供用XML序列化NIB的能力，视图控制器控制解压缩。 NSCoding协议定义了序列化时应该实现下面的方法： 1- (id)initWithCoder:(NSCoder*)decoder; 这种方法通常不是你的主要的指定初始化器，因为它还需要解码器去解码它。例外，如果父类也实现了NSCoding协议，那也需要调用父类的initWithCoder:方法。严格来说，你有两个指定初始化器，因为不止一个初始化方法调用父类的初始化方法。 应用到EOCRectangle类是这样的： 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject &lt;NSCoding&gt;@property (nonatomic, assign, readonly) float width;@property (nonatomic, assign, readonly) float height;- (id)initWithWidth:(float)width andHeight:(float)height;@end@implementation EOCRectangle// Designated initializer- (id)initWithWidth:(float)width andHeight:(float)height&#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// Superclass&apos;s designated initializer- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Initializer from NSCoding- (id)initWithCoder:(NSCoder*)decoder &#123; // Call through to super&apos;s designated initializer if ((self = [super init])) &#123; _width = [decoder decodeFloatForKey:@&quot;width&quot;]; _height = [decoder decodeFloatForKey:@&quot;height&quot;]; &#125; return self; &#125;@end 注意NSCoding的初始化方法，它调用了父类的初始化而不是它自己的初始化。然而，如果父类也实现了NSCoding，它将调用NSCoding自身的指定初始化器。例如下面的类： 123456789101112131415161718192021222324#import &quot;EOCRectangle.h&quot;@interface EOCSquare : EOCRectangle- (id)initWithDimension:(float)dimension;@end@implementation EOCSquare// Designated initializer- (id)initWithDimension:(float)dimension &#123; return [super initWithWidth:dimension andHeight:dimension];&#125;// Superclass designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; float dimension = MAX(width, height); return [self initWithDimension:dimension];&#125;// NSCoding designated initializer- (id)initWithCoder:(NSCoder*)decoder &#123; if ((self = [super initWithCoder:decoder])) &#123; // EOCSquare&apos;s specific initializer &#125; return self; &#125;@end 所有的初始化方法都调用到父类的实现，即initWithCoder:。子类在初始化的任何事情之前调用它，先完成父类的初始化。这样，EOCSquare也可以完全兼容NSCoding协议。如果你是调用你自己的初始化方法或者别的父类的初始化方法，对于EOCSquare的实例来说，EOCRectangle的initWithCoder:方法永远不会被调用，并且宽高两个实例变量永远不会被解码。 小结 在你的类中指定初始化器，并且用文档标明它。所有的别的初始化器都应该调用它。 如果子类的初始化器不同于父类的初始化器，确保你覆写了父类的初始化器。 当子类覆写了父类的初始化器，不应该抛出异常。 实现description方法在调试的时候，你经常会输出一个对象来获得有用的信息。其中一个办法是输出对象的所有属性，通常像下面这样： 1NSLog(@&quot;object = %@&quot;, object); 当你以字符串方式输出对象时，这时对象将调用description方法并且替代%@符号。所以，如果输出对象是一个数组，大概是这样的： 12NSArray *object = @[@&quot;A string&quot;, @(123)];NSLog(@&quot;object = %@&quot;, object); 它的输出是： 1234object = ( &quot;A string&quot;, 123 ) 但是如果你尝试输出一个自己的类，你经常看到这样的结果： 1object = &lt;EOCPerson: 0x7fd9a1600600&gt; 这样的输出是没有数组的输出有帮助的。除非你在你的类中覆写了description方法，否则只会调用NSObject的默认实现。这个方法定义在NSObject协议中，但是NSObject类实现了它。NSObject协议有许多方法，它这样做的原因是NSObject并不是唯一根类。例如NSProxy是另一个根类，它遵循NSObject协议。因为其余根类的子类也可能需要实现协议中的某些方法。如你所见，默认实现并没有太大用。它仅仅展示了对象的类名以及内存地址。如果你仅仅想知道两个对象是不是相同，那它是有用的。然而你可能更想知道它更多的信息。 为了输出有用的东西，你需要去覆写description方法并且返回你想知道的信息。例如，考虑下面的类的描述方法： 12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName;@end@implementation EOCPerson- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; &#125; return self;&#125;@end 一个典型的description方法实现是这样的： 12345- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@\&quot;&gt;&quot;, [self class], self, _firstName, _lastName];&#125; 如果你像这样调用它，它将输出这些信息： 12345EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&quot;Bob&quot; lastName:@&quot;Smith&quot;];NSLog(@&quot;person = %@&quot;, person);// Output:// person = &lt;EOCPerson: 0x7fb249c030f0, &quot;Bob Smith&quot;&gt; 这样的输出很清晰，并且输出了很多有用的信息。我建议应该像默认实现那样，展示类名和指针地址，因为它有时候是有用的。尽管之前的NSArray并没有输出这些，并且也没有明文规定。不过你在description方法中输出的应该是所用到的。 有一个简单的办法去实现包含大量信息的description方法，那就是在返回中包含字典。它的返回值大概是这样的： 1234&#123; key: value; foo: bar;&#125; 可以通过在自己的description方法中形成一个字典并返回包含此词典的字符串。例如，下面的类描述一个位置对象包含一个标题和经纬度： 12345678910111213141516171819202122232425262728#import &lt;Foundation/Foundation.h&gt;@interface EOCLocation : NSObject@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign, readonly) float latitude;@property (nonatomic, assign, readonly) float longitude;- (id)initWithTitle:(NSString*)title latitude:(float)latitude longitude:(float)longitude;@end@implementation EOCLocation- (id)initWithTitle:(NSString*)title latitude:(float)latitude longitude:(float)longitude &#123; if ((self = [super init])) &#123; _title = [title copy]; _latitude = latitude; _longitude = longitude; &#125; return self;&#125;@end 如果description方法能同时输出标题和经纬度就非常好了。如果使用字典，那么description方法可能像这样： 12345678910- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;, [self class], self, @&#123;@&quot;title&quot;:_title, @&quot;latitude&quot;:@(_latitude), @&quot;longitude&quot;:@(_longitude)&#125; ];&#125; 它的输出是这样的： 12345location = &lt;EOCLocation: 0x7f98f2e01d20, &#123; latitude = &quot;51.506&quot;; longitude = 0; title = London;&#125;&gt; 这比刚才仅有指针和类名是有用多的，并且对象的所有属性都很好的展示了出来。你可以总是使用字符串去描述每个变量，但是当更多的属性被加入这个类，字典这种方法更易于操作。 NSObject协议中另一个与之类似的方法叫做debugDescription。它们的不同在于debugDescription是在调式器中输出对象时调用的。NSObject类默认实现就是调用description方法。例如，以EOCPerson类为例，在调试器中运行应用程序，并且断点在输出对象之后，像下面这样： 1234EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&quot;Bob&quot; lastName:@&quot;Smith&quot;];NSLog(@&quot;person = %@&quot;, person);// Breakpoint here 当断点触发时，控制台准备接收输出。在LLDB调试器中，使用po命令输出对象，像下面这样的： 123EOCTest[640:c07] person = &lt;EOCPerson: 0x712a4d0, &quot;Bob Smith&quot;&gt;(lldb) po person(EOCPerson *) $1 = 0x0712a4d0 &lt;EOCPerson: 0x712a4d0, &quot;Bob Smith&quot;&gt; 注意，调试器中加上了一些额外的信息(EOCPerson *) $1 = 0x0712a4d0。后面的部分来源于debugDescription方法。 你可能只想在description方法中展示正常的人名，在debugDescription方法展示更深入的信息。这种情况下，这两个方法看起来是这样的： 12345678- (NSString*)description &#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName];&#125;- (NSString*)debugDescription &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@\&quot;&gt;&quot;, [self class], self, _firstName, _lastName];&#125; 这次运行相同的代码，并且打印对象，输出如下： 123EOCTest[640:c07] person = Bob Smith(lldb) po person(EOCPerson *) $1 = 0x07117fb0 &lt;EOCPerson: 0x7117fb0, &quot;Bob Smith&quot;&gt; 这种做法是当你在正常调试时不需要看到类名、对象地址等额外信息，在调试器的环境下仍能轻松访问完整信息时使用。Foundation框架中的NSArray类就是一个很好的例子。例如： 123NSArray *array = @[@&quot;Effective Objective-C 2.0&quot;, @(123), @(YES)];NSLog(@&quot;array = %@&quot;, array);// Breakpoint here 这时，运行程序，在断点处停止，并且输出数组对象： 1234567891011EOCTest[713:c07] array = ( &quot;Effective Objective-C 2.0&quot;, 123, 1)(lldb) po array(NSArray *) $1 = 0x071275b0 &lt;__NSArrayI 0x71275b0&gt;( Effective Objective-C 2.0, 123, 1) 小结 覆写description方法以提供实例的字符串描述。 如果想要对象在调试器中做更多事，那么覆写debugDescription方法。 尽量使用不可变对象在设计一个类时，理想情况下，考虑使用属性(看第6节)去存储数据。当使用属性时，你可以限制属性是只读的。默认情况下，属性是可读写的，这使你所有类都是可变的。然而，通常读取到数据之后是不需要改变的。例如，对象存储的数据来自只读的web service，如地图上的兴趣点列表，那么没有情况需要对象可变。如果这样的对象发生了改变，数据将不会被发送给服务器。如第8节所述，如果可变对象存储在集合中，则集合的内部数据结构很容易变得不一致。因此，我建议只在对象需要改变时，使用可变对象。 实际上，这意味着将外部属性设为只读，并且只暴漏需要暴漏的数据。例如，考虑一个类来处理地图上的兴趣点，这些数据来自web service。你可以像下面这样从某个类开始： 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface EOCPointOfInterest : NSObject@property (nonatomic, copy) NSString *identifier;@property (nonatomic, copy) NSString *title;@property (nonatomic, assign) float latitude;@property (nonatomic, assign) float longitude;- (id)initWithIdentifier:(NSString*)identifier title:(NSString*)title latitude:(float)latitude longitude:(float)longitude;@end 所有的数据都来自web service，标示符是服务端给一个兴趣点的标记。一旦兴趣点被创建，并且从服务端拿到数据之后，就不应该在任何场景下去修改。在别的语言中，你可能会创建一个私有变量，并且仅有一个getter方法。然而，在Objective-C中，当你使用属性时，这是非常容易的并且不需要考虑私有变量。 为了使EOCPointOfInterest类不可变，你可以给所有的属性添加只读特质： 1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface EOCPointOfInterest : NSObject@property (nonatomic, copy, readonly) NSString *identifier;@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign, readonly) float latitude;@property (nonatomic, assign, readonly) float longitude;- (id)initWithIdentifier:(NSString*)identifier title:(NSString*)title latitude:(float)latitude longitude:(float)longitude;@end 这确保任何人试图修改某个属性值，编译时都会报错。这些属性的值还可以正常读取，但不能改变，所以EOCPointOfInterest数据不会产生不同。因此，任何人使用这个对象的人都可以确信数据不会被修改的。对象自身的数据结构也不会变的不一致。这种情况下，地图上显示的EOCPointOfInterest对象兴趣点的经纬度都不用担心被修改。 你可能会想为什么会有内存管理语义，因为它是只读的，是没有setter方法的。好吧，你可以简化上面的代码： 1234@property (nonatomic, readonly) NSString *identifier;@property (nonatomic, readonly) NSString *title;@property (nonatomic, readonly) float latitude;@property (nonatomic, readonly) float longitude; 但是，使用内存管理语义是有用的，对你之后将属性特质设置为读写也是容易的。 你可能希望在对象内部对数据进行修改，而不是外部。在这种情况下，通常的做法是重新声明它为读写特质。当然，当属性特质是非原子性时，多个线程同时读写会造成权限的竞争。这是可能的，在一个观察者读取的同时，在内部修改这个属性。这种情况应该被杜绝，所有的访问无论是内部的还是外部的，或者是不同的队列(看第41节)，都应该是同步的。 通过使用分类功能在类的内部将属性重新声明为读写特质。你可以像写在头文件一样重新声明它，只要拥有相同的特质和扩展的读写状态。在EOCPointOfInterest的例子中，类别中的声明可能是这样的： 1234567891011121314#import &quot;EOCPointOfInterest.h&quot;@interface EOCPointOfInterest ()@property (nonatomic, copy, readwrite) NSString *identifier;@property (nonatomic, copy, readwrite) NSString *title;@property (nonatomic, assign, readwrite) float latitude;@property (nonatomic, assign, readwrite) float longitude;@end@implementation EOCPointOfInterest/* ... */@end 现在，这属性可以在EOCPointOfInterest类的实现内部进行修改了。更准确的说，通过使用KVC这种方法，在外部也可以对对象进行修改，例如下面这种： 1[pointOfInterest setValue:@&quot;abc&quot; forKey:@&quot;identifier&quot;]; 这是因为KVC是直接调用的identifier的setter方法，即使你这个方法并没有暴漏在头文件。然而，这样做被视为对类API的非法入侵，如果有什么问题，还是需要开发者自身去解决。 一个不讲道理的开发者可以通过在类上使用内省来确定类对象的内存布局中属性的实例变量的偏移量而不是setter方法。开发者可以通过这种办法去设置实例变量，但这种行为被视为对类API的非法入侵。但从技术上来说，围绕缺失了头文件的setter方法这种可能性，你不应该忽略使你的对象是不可变的。 在定义类的公共API时，要记住的另一点是集合类属性是否是可变的或不可变的。例如，你有一个代表人的类，并且可以存储这个人的朋友列表，你可能想使用一个属性去存储这个人的朋友列表。如果这个人的朋友会添加和删除，那么这个属性应该设置为可变的。在这种情况下，应该暴漏一个只读特质并且不可变的集合，但它其实是拷贝了内部的可变集合。例如，像下面类的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSSet *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;@end// EOCPerson.m#import &quot;EOCPerson.h&quot;@interface EOCPerson ()@property (nonatomic, copy, readwrite) NSString *firstName;@property (nonatomic, copy, readwrite) NSString *lastName;@end@implementation EOCPerson &#123; NSMutableSet *_internalFriends;&#125;- (NSSet*)friends &#123; return [_internalFriends copy];&#125; - (void)addFriend:(EOCPerson*)person &#123; [_internalFriends addObject:person];&#125; - (void)removeFriend:(EOCPerson*)person &#123; [_internalFriends removeObject:person];&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; _firstName = firstName; _lastName = lastName; _internalFriends = [NSMutableSet new]; &#125; return self;&#125;@end 你也可以直接将friends属性设置为可变集合并通过直接操作集合去删除和增加朋友，而不是通过addFriend:和removeFriend:方法。但是这样数据就能随意修改，容易产生bug。如果EOCPerson类中的朋友集合可以被外部改变，这可能会造成一些问题。例如，当添加朋友或者删除朋友时，这个对象想做一些别的事情，这时，这个对象就会变得不一致。 在这点上，同样重要的是不要给你反回的对象做内省，去判断它是否是可变的。例如，你可能使用一个包含EOCPerson类的库。库的开发者可能没有返回一个内部可变集合的拷贝，而是直接返回了可变集合本身。如果这个集合非常大，这是合法合理的，因为拷贝的代价太大。它返回一个NSMutableSet是合法的，因为它是NSSet的子类，在这种情况下，你可能会这样写： 123456EOCPerson *person = /* ... */;NSSet *friends = person.friends;if ([friends isKindOfClass:[NSMutableSet class]]) &#123; NSMutableSet *mutableFriends = (NSMutableSet*)friends; /* mutate the set */&#125; 无论如何，你应该避免这种写法。你并没有跟EOCPerson类预定什么，所以你不应该在此处使用内省。重点是，这个对象可能没办法处理你要的操作。因此，你不应该假设它可以。 小结 尽量创建不可变对象。 如果属性需要在内部设置，那么暴露给外部的应该设置为只读，在类别中设置为读写。 通过方法去操作可变集合，而不是直接暴漏可变集合本身。 使用清晰而协调的命名方式在Objective-C中，类的命名，方法的命名，变量的命名等等都是重要的因素。新手总是说语言冗长，因为使用的语法结构可以像自然语言一样阅读。命名的时候常常包括一些介词(in、for、with等等)，而别的语言经常忽略这些。例如，考虑下面的代码段： 12NSString *text = @&quot;The quick brown fox jumped over the lazy dog&quot;;NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;fox&quot; withString:@&quot;cat&quot;]; 上述代码经常被认为是把一个简单的表达式复杂成了一句啰嗦的话。毕竟，执行的替换方法长达48个字符。但是它读起来像一句话：“使用cat字符串替换text字符串中的fox字符串并且赋值给一个新的字符串。” 这句话完美的表达了正在发生的事情。在不冗长的语言中，大概是这样的： 12string text = &quot;The quick brown fox jumped over the lazy dog&quot;;string newText = text.replace(&quot;fox&quot;, &quot;cat&quot;); 但是上面的命令中，text.replace的参数是什么意思？fox字符串替代cat，还是相反？而且，替换函数替换所有字符还是第一个？这非常不清晰。虽然Objective-C的语法更长，但是却非常清晰。 你还会注意到不论是变量名还是方法名，使用的都是首字母小写的骆驼式命名法。另外，类名是以大写字母开头并且带有两个或者三个字符的前缀（看第15节）。这个风格遍布整个Objective-C代码。如果你愿意你可以使用你自己的风格，但是在Objective-C中骆驼风格将确保你命名的健壮。 方法命名如果你之前学过别的语言，例如C++或者Java，你习惯于函数命名的简洁，并且必须查看函数原型以确定参数做什么。然而，这使得代码难以阅读，因为你经常需要返回原型来记住函数的作用。例如，考虑一个代表范围的类。在C++中，你可能这样定义它： 123456789class Rectangle &#123;public: Rectangle(float width, float height); float getWidth(); float getHeight();private: float width; float height;&#125;; 如果你不熟悉C++，那也没关系。你只需要意识到有一个叫做Rectangle的类，里面有两个实例变量，宽和高。它也有一个接受宽和高的方法用于创建类的实例，叫做构造器。它也有宽高的访问方法。当使用这个类时，你会这样创建实例： 1Rectangle *aRectangle = new Rectangle(5.0f, 10.0f); 当你回头看这些代码时，你不能清楚的知道5.0f和10.0f代表什么。你大概可以猜到它是构成矩形的宽高，但你知道第一个参数是宽还是高？你需要回头去看看定义的构造方法。 Objective-C通过更长的方法命名解决了这个问题。与上述C++代码等价的Objective-C代码如下： 12345678910#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject@property (nonatomic, assign, readonly) float width;@property (nonatomic, assign, readonly) float height;- (id)initWithSize:(float)width :(float)height;@end 这样的写法可以轻松的知道等价的构造器方法和方法名叫做initWithSize:。你可能认为它很奇怪或者在第二个参数的冒号前面没有字符是语法错误的。实际上，语法是非常合理的，但它犯了和C++函数命名一样的毛病。如果你使用这个类，你会在相同的位置看到这个问题: 12EOCRectangle *aRectangle = [[EOCRectangle alloc] initWithSize:5.0f :10.0f]; 一个更好的写法是像下面这样的： 1- (id)initWithWidth:(float)width andHeight:(float)height; 这是冗长的，但对于使用时，每个变量的意思都是清晰的： 1EOCRectangle *aRectangle = [[EOCRectangle alloc] initWithWidth:5.0f andHeight:10.0f]; 新手往往很难使用Objective-C冗长的命名，尽管冗长的命名可以增加代码的可读性。不要害怕使用长的方法名。确保方法名是他们需要表达的，但不是让你使用极长的命名。你的方法名应该统一和清晰。 以EOCRectangle类为例子。好的方法命名像下面这样： 12- (EOCRectangle*)unionRectangle:(EOCRectangle*)rectangle- (float)area 不好的的方法命名像下面这样： 12- (EOCRectangle*)union:(EOCRectangle*)rectangle // Unclear- (float)calculateTheArea // Too verbose 清楚地方法命名就像读一篇文章一样，从左到右阅读。遵循方法命名规则并不是强制的，但这样做将会确保你的代码易于维护和被其他人阅读。 NSString类是一个好的命名示例，它遵循了良好的命名规则。这有一些它的方法以及为什么这样命名的解释： + string 这是一个工厂方法，用于创建一个新的空字符串。通过方法名表示返回值。 + stringWithString: 这是一个工厂方法，使用另一个字符串创建一个新的字符串。同创建空的字符串的工厂方法一样，它通过方法名的第一个单词表示返回值。 + localizedStringWithFormat: 这是一个工厂方法，使用指定的格式去创建一个本地化的字符串。它的返回值是方法名的第二个单词，这是因为对返回类型进行修饰是合理的。尽管它返回的仍然是字符串，但它是一种更具体的字符串，因为它已经本地化了。 - lowercaseString 将一个字符的所有字符转化为小写。它创建了一个新的字符串而不是转化者本身，因此它遵循返回类型作为方法名的一部分的规则。不过修饰符仍应在类型之前。 - intValue 将字符串解析为整数。因为它的返回类型是int，所以它的第一个单词是int。通常你不会缩写类型。例如string不会缩写成str。int是类型名字，所以方法名的后缀带有value而不是单一单词。单一单词通常用在属性上面。因为int不是属性，所以添加value限制它。 - length 获取字符串的长度。这是一个单独的短语，因为它实际上是一个字符串的属性。对于这个方法有一个不好的名字，叫做stringLength。string这个单词是多余的，因为这个方法的接收者本身就是个字符串。 - lengthOfBytesUsingEncoding: 获取使用给定编码方式编码的字节数组长度。这与length方法类似，所以可以用同样的理由解释。另外，这个方法需要一个参数。方法名称在描述其类型的名词之后立即放置参数。 - getCharacters:range: 在字符串的给定范围内获取单个字符。这是一个例子，因为这不是一个访问方法，所以添加get前缀，不像一些其他的语言。这里使用的原因是字符是通过作为第一个参数传入的数组返回的。完整的方法签名如下： - (void)getCharacters:(unichar*)buffer range:(NSRange)aRange 第一个参数，缓冲区，应该是指向足够容纳所请求范围内字符的数组的指针。该方法通过一个参数（通常称为out-parameter）返回，而不是通过返回值，因为它从内存管理角度更有意义。该方法的调用者处理所有内存管理，而不是由方法执行创建，并要求调用方释放它。第二个参数是以名词描述其类型，就像正常参数一样。有时，这些参数名前面都有一个介词；例如，这个方法可以叫做getCharacters:inRange:。如果参数超过其他参数需要额外的意义，通常是这样做的。 - hasPrefix: 确定字符串前缀是否是给定字符。它的返回值是一个Bool值，所以通常这样使用它，像读句子一样。例如： 1[@&quot;Effective Objective-C&quot; hasPrefix:@&quot;Effective&quot;] == YES 如果方法名是prefix:，它不容易理解的。相似的，如果是isPrefixedWith:，它是太长的并且听起来也过于笨拙。 - isEqualToString: 确定两个字符串是否相等。它的返回值是一个Bool值，就像上面的hasPrefix:方法一样，方法的名称确保该方法像句子一样阅读。另一个使用is前缀的地方是Bool属性。如果属性名是enabled，例如它的访问方法是setEnabled:和isEnabled。总之，遵循一些规则将帮助你给方法命名。 如果方法返回一个新值，那么方法的第一个单词应该是它的类型，除非它需要一个修饰词，例如localizedString方法。这个规则不适用于属性访问器，因为他们在逻辑上没有创建一个新的对象。即使它们可能会返回一个拷贝的内部对象。这些访问器方法代表属性本身。 一个参数应该紧挨着一个描述它类型的名词。 如果一个对象需要参数来执行操作，那么导致对象上发生动作的方法应该包含一个动词，然后是一个名词（或多个名词）。 不要使用缩写，例如str，使用全名，例如string。 Bool属性的前缀应该使用is。方法返回一个Bool值但不应该直接返回属性应该带有has或者is前缀，这取决于你使用的场景。 使用前缀get的方法，返回值应该是某个输出参数，例如填充C风格的数组。 类名和协议名应该给类和协议提供前缀以避免命名空间冲突（看第15节）并且应该结构化，使它们从左到右阅读，就像方法一样。例如，NSArray类和它的对应可变类NSMutableArray，mutable应该在array之前，因为它描述了一个指定的类型。 为了说明命名惯例，考虑下面UIKit中的类： UIView (class) 所有的视图都继承自这个类。它们是用户界面的构建块，执行按钮、文本字段和表的绘制。类的名字是对它的解释以及整个UIKit框架的UI前缀。 UIViewController (class) 一个视图处理绘画视图但不负责控制在视图中显示。这就是这个类的工作：一个“视图控制器”。它以这样的方式命名，它保持左到右可读性。 UITableView (class) 这是一个特定的视图，用于显示列表数据。所以给父类名字添加特定前缀来区别视图的种类。在命名管理中，使用给父类加前缀是常见的。它可以被命名为UITable，但这样不能清除的指出它是一个视图。你需要查找接口声明以确定它是什么。如果你要创建一个表格视图用于显示图像，你可以创建一个子类叫做EOCImageTableView。例如，你总是使用自己的前缀，而不是父类的前缀。原因是你没有权利向另一个框架的命名空间添加一些东西，而另一个框架可能决定在将来创建一个同名的类。 UITableViewController (class) 正如表格是一种特定的视图，这是一种特殊的视图控制器专门设计用来控制表格视图。因此，它以类似的方式命名。 UITableViewDelegate (protocol) 该协议定义了一个接口，通过该接口，表格视图可以与另一个对象通信，并以它定义委托接口的类命名，从而保证了正确的可读性。（关于委托模式的更多信息，请参阅项目23）。 最重要的是，你应该使你的命名保持一致。另外，如果你的类在另一个框架，确保遵守命名约定。例如，你创建一个视图的子类，那么类名的后缀应该加上view。类似地，如果创建了自己的委托协议，则应该将它命名为它代表的类，带有Delegate后缀。坚持这种命名结构将确保当你或其他人稍后使用它时，你的代码是易懂的。 小结 创建接口时，遵循Objective-C的命名规则，接口将会是健壮的。 确保方法名称简洁而精确，并使其使用像阅读句子一样从左向右。 在方法命中避免使用类型缩写。 最重要的是，确保你自己的代码中方法名的一致性。 为私有方法名加前缀一个类做的事情远比外部调用多的多。编写类实现时，通常会编写一些给类内部使用的方法。对于这样的方法，我建议给它们的名称加上前缀。通过将公共方法与私有方法区分开来，有助于调试。 给私有方法加标记的另一个原因是在修改方法名时易于区分。如果一个方法是公开的，那么修改它时应该加倍小心，因为可能对外部造成影响。因此，这个类的使用者也需要进行修改。但是，如果该方法是内部方法，则只有类自己的代码需要更改，对公开的API没有影响。对私有方法进行标记意味着在进行这种更改时很容易看出区别。 要使用什么样的前缀看你个人喜好，但我有一个好的选择是前缀包含一个字母p和_。因为p代表private，_在方法名开始之前有了视觉的差距。方法名仍继续使用骆驼命名法，即第一个字母小写。例如，一个叫做EOCObject的类，它的私有方法可能是这样的： 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;@interface EOCObject : NSObject- (void)publicMethod;@end@implementation EOCObject- (void)publicMethod &#123; /* ... */ &#125;- (void)p_privateMethod &#123; /* ... */ &#125;@end 与公共方法不同，私有方法不会出现在接口定义中。有时，您希望在类扩展中声明私有方法（看第27节）；然而，最近的编译器修改意味着在使用方法之前不需要声明它。通常，私有方法只能在它们的实现中声明。 如果你是从C++或者Java转行过来的，你可能会很疑问为什么只加前缀，而不是声明它为私有方法。在目标Objective-C中，没有办法将方法标记为私有的。所有的对象都能相应所有的消息(看第12节)，并且可以在运行时决定是否相应某个消息(看第14节)。Objective-C是在运行时执行给定消息的查找的，并且没有机制去限制什么东西、什么时候、什么范围影响消息。只剩下命名约定来指定语义，如私有方法。新手可能对这种方式感到不太舒服，但Objective-C就是这样一门语言，需要你去接受它的动态性和活力。但是动态性也是需要规则的，使用命名约定是实现这一目标的一种方法。 苹果倾向于使用单一下划线来作为它私有方法的前缀。所以你可能认为遵循苹果的提示并使用下划线是个好主意。然而，这有一个潜在的灾难性的问题；如果你继承了一个苹果的类，并在这个子类中使用了这种方法，你可能会无意中覆盖苹果的一个私有方法。基于这个原因，苹果已经说明了你应该避免使用下划线作为前缀。动态方法调度，从无法给方法指定作用域这点来看，这是不好的地方，但从另一方面看，它又是强大的。 覆盖苹果私有方法这种情况是常有的，例如，如果你正在创建一个iOS应用的视图控制器，你需要子类化UIViewController。视图控制器可以有很多状态，你需要一个清楚所有状态的方法，当你的控制器出现在屏幕上时，调用这个方法。因此，你可能会实现这样的方法： 12345678910111213#import &lt;UIKit/UIKit.h&gt;@interface EOCViewController : UIViewController@end@implementation EOCViewController- (void)_resetViewController &#123; // Reset state and views&#125;@end 然而，UIViewController也实现了一个叫做_resetViewController的私有方法。从你写了这个私有方法开始，当你调用它时，总是会调用EOCViewController的这个方法，而不是UIViewController的。除非你深入了解这个库，否则你不会你知道这一点，因为这个方法并未暴漏出来。毕竟，这是一种用下划线表示的私有方法。在这种情况下，你的视图控制器可能会发生一些奇怪的事情，因为UIViewController的实现未被调用，或者你会诧异为什么这个方法的调用次数过于频繁。 总之，当你在一个既不是苹果也不是你自己的框架中对类进行子类化时，除非文档说明，否则你无法知道框架使用的什么私有前缀（如果有的话）。在这种情况下，你可以选择使用你的类前缀（看第15节）作为私有方法前缀，从而大大减少潜在冲突的风险。同样，你也应该考虑其他人也可能会子类化你的类。这就是为什么你应该为私有方法名添加前缀。如果没有实现的源代码，除非使用非常复杂的工具，否则没有办法找出类实现的私有方法。 小结 给私有方法名添加前缀，这样很容易与公共方法区别开来。 避免使用单个下划线作为方法前缀，因为这是由苹果使用的。 理解objective-c错误模型许多现代语言，包括Objective-C，都有异常处理。如果你是一个java后台，你可能习惯于使用异常来处理错误情况。如果你习惯于异常处理任务，你需要忘记你知道的关于异常的一切并重新开始。 首先要注意的是，默认情况下异常机制在ARC(看第30节)下是不安全的。实际上，这个意思是任何该在异常作用域结束时释放的对象都不会被释放。当然你可以通过打开一个编译器标志使异常得到安全处理，但是这需要引入额外的代码，并且即使没有抛出异常，这部分额外代码也需要运行。这个编译器标志是-fobjc-arc-exceptions。 即使不使用ARC，也很难写出不会引起内存泄露的安全代码。假设一个资源被创建并在不再需要时释放它。如果在资源释放之前抛出异常，则该资源将永远无法释放： 123456789id someResource = /* ... */;if ( /* check for error */ ) &#123; @throw [NSException exceptionWithName:@&quot;ExceptionName&quot; reason:@&quot;There was an error&quot; userInfo:nil];&#125;[someResource doSomething];[someResource release]; 当然，解决这个问题的办法就是把释放代码放在抛出异常之前。但是，如果有很多的资源释放和更复杂的代码路径，代码很容易变得杂乱。另外，如果在这样的代码中添加了某些代码，那么在抛出异常之前，很容易忘记添加释放。 Objective-C现在使用的方法是只抛出重大异常，并且不需要再恢复了，即直接退出应用程序。这样就不用再考虑异常安全的代码了。 记住异常只能用于致命错误，例如当你创建了一个抽象基类，别人使用基类初始化或者未覆盖初始化方法时抛出异常。Objective-C不像其他语言一样，它没有构造方法一说。因此达到这个目的的最简单办法就是如果子类未重写父类必须重写的办法，那就抛出异常。任何试图使用基类创建实例的做法都将会抛出异常： 123456789- (void)mustOverrideMethod &#123; NSString *reason = [NSString stringWithFormat: @&quot;%@ must be overridden&quot;, NSStringFromSelector(_cmd)]; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];&#125; 但是如果异常仅适用于致命错误，那么其他类型的错误呢？当错误发生时，Objective-C的通常选择是返回nil或者0，或者是使用NSError。有一个例子就是当初始化失败，返回nil或者0： 12345678910- (id)initWithValue:(id)value &#123; if ((self = [super init])) &#123; if ( /* Value means instance can&apos;t be created */ ) &#123; self = nil; &#125; else &#123; // Initialize instance &#125; &#125; return self;&#125; 在这种情况下，如果value值为空，则实例不能创建，将self设置为nil，并且返回nil。这样初始化的方法将知道发生了一个错误，因为没有实例被创建。 使用NSError可以提供许多的灵活性，因为可以将错误返回给调用者。一个NSError对象封装了三条信息： Error domain (String) 错误产生的范围。这个通常是一个全局变量，用于表示错误的根源。例如，NSURL的处理系统，如果在获得数据时发生了错误，那么就会使用NSURLErrorDomain来表示。 Error code (Integer) 唯一的错误代码，用于指示错误域内具体的错误。通常，使用枚举来代表多种错误情况的集合。例如，HTTP请求失败时的HTTP状态码。 User info (Dictionary) 有关此错误的额外信息，例如一个本地化字符串或者导致该错误的别的错误信息，这样可以构成一个错误链。 在API设计中，NSError的第一种常见用法是通过委托协议传递。当错误发生时，该错误会通过协议的某个方法传递给调用者。例如，NSURLConnection的协议NSURLConnectionDelegate包含了下面的方法： 1- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error 当一个连接出现错误时，例如一个远程连接超时，就会调用此方法处理相关错误。这个代理方法不是必须实现的，这取决于使用者是否想知道有关错误。这比直接抛一个异常要好，因为它可以由使用者去决定是否实现。 另一个常用的使用方式是将NSError对象作为方法的一个参数。它看起来是这样的： 1- (BOOL)doSomething:(NSError**)error 传递给方法的是一个指针，而这个指针又指向一个指针，这个才是指向NSError对象的。或者也可以把它当做一个直接指向NSError对象的指针。这样可以使方法在经由输出参数返回错误信息的同时还能返回一个普同的值。用法如下： 12345NSError *error = nil;BOOL ret = [object doSomething:&amp;error];if (error) &#123; // There was an error&#125; 通常像这样返回错误的方法也会返回一个Bool值用来表示操作成功或者失败。如果你不关心错误信息，你可以直接判断Bool值，反之，你可以判断错误信息。当你不在乎错误信息时，你可以将它设置为nil。比如说，你可以这样写： 1234BOOL ret = [object doSomething:nil];if (ret) &#123; // There was an error&#125; 实际上，当使用ARC时，编译器会自动将NSError**转化成NSError*__autoreleasing*；这意味着这个指针对象将会自动释放。这个对象必须自动释放，因为doSomething:这个方法不能保证调用者会释放NSError对象，所以必须加入autorelease。这与大部分方法的返回值语义相同了（以new、alloc、copy、mutableCopy开头的方法当然不在此列）。 方法通过输出参数返回错误类似这样： 12345678910111213- (BOOL)doSomething:(NSError**)error &#123; // Do something that may cause an error if ( /* there was an error */ ) &#123; if (error) &#123; // Pass the &apos;error&apos; through the out-parameter *error = [NSError errorWithDomain:domain code:code userInfo:userInfo]; &#125; return NO; ///&lt; Indicate failure &#125; else &#123; return YES; ///&lt; Indicate success &#125;&#125; 通过使用*error语法，为错误参数解引用，这意味着错误参数所指的那个指针要指向新的NSError对象了。这个错误参数必须检测它是否为空，因为空指针解引用会导致段错误并且程序崩溃。因为调用者可能会将其设为空，所以必须判断这种情况。 NSError对象里的错误范围、错误码、额外的错误信息将根据错误的具体情况填入适当的内容。这使得调用者可以根据不同错误情况进行不同的处理。错误范围最好定义为一个全局常量字符串，错误码最好是枚举类型。例如，你可以这样定义它们： 1234567891011// EOCErrors.hextern NSString *const EOCErrorDomain;typedef NS_ENUM(NSUInteger, EOCError) &#123; EOCErrorUnknown = 1, EOCErrorInternalInconsistency = 100, EOCErrorGeneralFault = 105, EOCErrorBadInput = 500,&#125;;// EOCErrors.mNSString *const EOCErrorDomain = @&quot;EOCErrorDomain&quot;; 在你的库中创建一个错误范围是考虑周到的，因为它允许你创建并且返回一个NSError对象，使用者可以确定它来自你的库。为错误码创建一个枚举类型是好的主意，因为它记录具体的错误并且给代码一个有意义的名字。你甚至可以在头文件以注释形式定义更多更详细的错误信息。 小结 仅应在发生致命错误导致程序崩溃时使用NSExceptions。 对于不致命的错误，提供一个协议方法处理错误或者传入一个NSError对象是好的办法。 理解NSCopying协议我们经常会对一个对象就行拷贝。在Objective-C中，是通过copy方法进行拷贝的。而对类进行拷贝的方法是实现NSCopying协议，它只包含了一个方法： 1- (id)copyWithZone:(NSZone*)zone 以前的空间是使用不同的段内存的并且创建对象都是一个确定的空间。现在，每一个应用都只有一个空间：默认空间。虽然你还需要实现这个协议方法，但是你不需要担心那个空间参数。 这个拷贝方法在NSObject实现了，但仅仅是通过默认空间调用了copyWithZone:。不止copy方法需要覆盖重写，copyWithZone:也需要覆盖重写。 为了让类支持拷贝，你需要遵循NSCopying协议，并且实现协议中唯一的方法。例如，有个表示人的类。在这个类的接口中，你需要声明你遵循NSCopying协议： 123456789101112#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &lt;NSCopying&gt;@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;@end 然后，你需要实现这个协议的方法： 123456- (id)copyWithZone:(NSZone*)zone &#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; return copy;&#125; 这个例子简单的使用初始化方法进行了复制。有时，你可能需要更进一步的工作，例如，你要拷贝的某个对象并没有在初始化方法中进行赋值。例如，EOCPerson类有一个数组用于表示这个人的朋友，并且通过一些方法去增加和删除其余的EOCPerson对象。在这种情况下，你还需要复制好友数组。下面是一个完整的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &lt;NSCopying&gt;@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;@end@implementation EOCPerson &#123; NSMutableSet *_friends;&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; _friends = [NSMutableSet new]; &#125; return self;&#125;- (void)addFriend:(EOCPerson*)person &#123; [_friends addObject:person];&#125;- (void)removeFriend:(EOCPerson*)person &#123; [_friends removeObject:person];&#125;- (id)copyWithZone:(NSZone*)zone &#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [_friends mutableCopy]; return copy;&#125;@end 这一次，这个协议方法有了一些变化，增加了对_friends变量的拷贝。注意这里使用了-&gt;语法，因为这是一个内部变量。其实也可以声明为一个属性，但因为从未在外部使用，所以也就没什么必要了。 这个例子引出了一个有趣的问题：为什么要拷贝_friends变量？你可以不进行拷贝，这样每个对象都将使用相同的可变集合。但是这样做的话，当原始对象的_friends变量添加了一个朋友，那么所有拷贝的对象都将添加一个朋友。这显然不是你想要的。但是如果集合是不可变的，那么您可以选择不拷贝，反正集合不能修改，并且这样可以避免内存中存在两个完全一样的集合。 通常情况下，应该像本例这样，使用指定的初始化器去进行拷贝。但是有些时候不需要这样做，因为初始化方法有时候会产生一些副作用，比如一些无用的附加操作。比如，初始化方法可能会设置一个复杂的内部数据结构，并且这个数据结构马上要被别的数据所覆盖，那么就没必要进行初始化了。 如果你回头去看copyWithZone:方法，你会发现_friends是使用mutableCopy方法进行复制的。这个方法来自另一个协议，叫做NSMutableCopying。它的定义跟NSCopying协议是很相似的： 1- (id)mutableCopyWithZone:(NSZone*)zone mutableCopy就像上面的copy方法一样，都是使用默认空间调用的。如果你的类分为了可变和不可变两个版本，那么你也需要实现这个协议。当你这样使用时，你需要在copyWithZone:中返回一份不可变拷贝。不论你拷贝的对象是可变还是不可变，都应该在mutableCopyWithZone:中返回一份可变拷贝。类似的，如果你需要一份不可变拷贝，那么你应该调用copy方法。 下面的规则适用于可变数组和不可变数组的所有情况： 12-[NSMutableArray copy] =&gt; NSArray-[NSArray mutableCopy] =&gt; NSMutableArray 有一个微妙的情况需要注意，一个可变对象调用可copy方法会返回一个不可变实例。这样做可以很容易的在可变对象和不可变对象之间进行切换。另一种可以达到这个目的办法是使用三个方法：copy、immutableCopy、mutableCopy，copy总是返回相同的类，其余两个方法返回特定的实例。但是如果使用者并不知道其所用实例是否可变，那么就不太好了。例如某个方法把可变对象当做不可变对象给了你，你使用这个对象调用copy。这时，你以为它是不可变对象但它其实是可变的。 你可以通过内省(看第14节)来确定对象的类型，但是这样会增加拷贝的复杂度。为了安全起见，你会只使用immutableCopy和mutableCopy，但是这样又回到了两个方法的情况。这和只有copy和mutableCopy是一样的。为什么会叫copy而不是immutableCopy呢，是因为这两个方法并不完全是为可变类和不可变类设计的，有些类是没有可变和不可变之分的。所以immutableCopy是一个坏名字。 拷贝还有一个问题是，进行的拷贝是深拷贝还是浅拷贝。深拷贝会对拷贝所有数据。通常，我们使用的容器类，都是浅拷贝，即只拷贝容器本身，不拷贝容器元素。这样做的主要原因是容器中可能含有无法拷贝的元素；另外，复制每个对象是不好的。图3.2展示了深拷贝和浅拷贝的区别。 Figure 3.2 深拷贝和浅拷贝的区别。浅拷贝的所有内容都指向原始内容。深拷贝的所有内容都指向拷贝后的内容。 通常，你希望自己的类遵循系统框架的拷贝模式，即使用copyWithZone:进行浅拷贝。但是如果需要，也可以添加一个深拷贝的方法。例如NSSet，它就在初始化时提供了一个方法进行深拷贝： 1- (id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems 如果copyItems为YES，那么集合中的所有元素都会接收到拷贝的消息，然后以拷贝后的元素组成新的集合，并返回。 在EOCPerson的例子中，朋友的集合是使用copyWithZone:进行拷贝的，根据上面内容得知，它们进行的是浅拷贝，不会逐个复制集合的元素。但是如果需要一个深拷贝，你可以提供这样一个方法： 12345678910- (id)deepCopy &#123; EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;&#125; 没有实现深拷贝的协议，这个事情是留给你的每个类去做的。你只需要决定你是否提供深拷贝。另外，你也不应该假设NSCopying协议实现的是深拷贝。在绝大多数情况下，这是一个浅拷贝。如果你需要任何对象的深拷贝，除非有文档指出这个NSCopying协议实现的是深拷贝，要么找到相关方法，要么自己实现。 小结 如果你的对象需要拷贝，那么你需要实现NSCopying协议。 如果你需要可变和不可变两个版本，那么你需要实现NSCopying和NSMutableCopying协议。 开发者可以选择使用深拷贝还是浅拷贝，但尽量使用浅拷贝。 如果你的对象需要深拷贝，那么添加一个深拷贝方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第二章]]></title>
      <url>%2F2017%2F05%2F14%2FObject%2C%20Messaging%2C%20and%20the%20Runtime%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时 简介在Objective-C等面向对象的语言中，对象就是基石，提供数据存储和传递的功能。消息是在过程中对象之间进行数据传递和执行操作。深入理解这些功能如何工作对于构建高效和可维护代码是至关重要的。 当程序运行后，Objective-C中的runtime为其提供相关支持。runtime提供了关键的函数使对象之间可以传递消息以及创建类实例的所有逻辑。理解这一切如何工作会使你成为一个更好的开发者。 理解属性属性是Objective-C的一个功能，用于对象对数据的封装。Objective-C对象通常会把它们所需要的数据保存为各种实例变量。实例变量的访问通常通过存取方法。getter方法用来读取变量，setter方法用来设置变量。这个概念是标准的，并且通过属性这个功能成为了Objective-C 2.0的一部分，这让开发者令编译器去自动生成读写方法。这个功能引入了一个新语法即点语法，通过点语法访问数据存储可以减少代码的冗长。你可能已经使用了属性，但你可能不知道它所有的功能。而且，还有很多与之相关的问题。第6节主要说明哪些问题可以通过属性解决并且指出主要的功能。 用一个类去表示一个人的信息可能要存储名字，出生日期，地址等等。你可能这样在一个类的公共接口中声明这些变量： 12345678910#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &#123; @public NSString *_firstName; NSString *_lastName;@private NSString *_someInternalData;&#125;@end 如果你从事过Java或者C++开发，这种写法是熟悉的，你可以定义变量的作用域。然而，这种技术在Objective-C中很少使用。这种方法的问题是在编译时就定义了对象的布局。无论任何时候访问_firstName变量，都会通过编译器偏移硬编码去访问存储对象的内存空间。如果你不在_firstName之前添加任何变量这样做都是没问题的。例如：假设在_firstName之前添加一个变量： 译者言：由于对象布局在编译时已定，对象内存偏移量自然固定，此处硬编码代指偏移量。 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &#123; @public NSDate *_dateOfBirth; NSString *_firstName; NSString *_lastName;@private NSString *_someInternalData;&#125;@end 之前的偏移量代表_firstName而现在代表_dateOfBirth了。任何通过硬编码读取的地方都将读取到一个错误的值。为了说明这一点，假设指针是4个字节，图2.1分别展示了添加_dateOfBirth变量之前和之后的类的内存布局。 Figure 2.1 添加变量前类的布局和添加变量后类的布局 当类定义发生变化时，如果代码使用了编译时的偏移量那么将出现问题，除非重新编译。例如，一个代码库中的代码使用了旧的类定义。如果链接的代码使用了新的类定义，那么在运行时将出现不兼容的情况。为了解决这个问题，各种语言都提出了自己的解决办法。Objective-C的做法是，将实例变量看做特殊的变量，由类变量(第14节详细的讲述了类对象)去存储它的偏移量。在运行时，会去查找偏移量，当类定义发生改变，偏移量也随之改变。这样无论如何访问一个变量，都会使用正确的偏移量。你甚至可以在运行期间给类添加实例变量。这就是稳固的ABI(应用程序二进制接口)。ABI定义了许多内容，其中一项是生成代码时的规则。稳固的ABI也意味着你可以在一个分类中或者实现文件中定义实例变量。因此，你不需要在接口文件中声明所有的实例变量，因此你不需要在公共接口中泄露任何你的内部实现信息。 另一种解决这个问题的办法是使用存取方法而不是直接访问实例变量。虽然属性最终仍是由实例变量实现的，但是属性提供了一种简洁的抽象。你可以自己编写存取方法，但是在标准的Objective-C代码格式中，存取方法遵循严格的命名规则。因为严格的命名，Objective-C才能根据变量名自动创建存取方法。这就是@property语法的来源。 在对象接口的定义中使用@property，这是一种标准的写法，以提供对象的存取方法。因此，可以把属性当做一种简称，通过它去访问一个给定类型和给定名字的变量。例如，考虑下面的代码： 1234@interface EOCPerson : NSObject@property NSString *firstName;@property NSString *lastName;@end 对于类的使用者，上面的代码是等价于下面的代码的： 123456@interface EOCPerson : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end 使用属性，你可以使用点语法。在C中你访问栈结构体的成员也是使用类似语法。编译器会将点语法转化为存取方法，与你直接调用是一样的。因此，使用点语法和直接调用时没有任何差异的。下面展示了等价的代码： 1234567EOCPerson *aPerson = [EOCPerson new]; aPerson.firstName = @&quot;Bob&quot;; // Same as;[aPerson setFirstName:@&quot;Bob&quot;]; NSString *lastName = aPerson.lastName; // Same as;NSString *lastName = [aPerson lastName]; 属性的好处还不止这些。如果你使用它，编译器将会通过一个叫做自动合成的功能生成那些方法代码。需要强调的是，编译器会在编译时自动生成代码，所以你在编辑器中是看不到自动合成的方法的。除了自动生成上述代码，编译器也会自动生成一个合适类型的变量，并且会在名字前面加下划线。在前面的代码中，他自动生成了两个变量：_firstName和_lastName。通过在类实现中使用@synthesize语法，这两个实例变量名字是可以控制的，像这样： 1234@implementation EOCPerson@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 使用上面的语法会产生两个实例变量，分别叫做_myFirstName和_myLastName，用于代替默认生成的。不过一般不会去改变默认的变量名；然而如果你不喜欢使用下划线去命名变量，你可以使用这个方法去设置你想要的。但是我建议你使用默认的命名规则，如果每个人都遵循这个规则，那么每个人读代码都是容易理解的。 如果你不想编译器给你自动生成存取方法，你可以自己去实现这些方法。然而，如果你仅实现了存取方法中的一个，那么编译器仍会自动生成另一个方法。另一种阻止它自动生成的办法是使用@dynamic关键字，这会告诉编译器不要自动生成实例变量返回给属性并且不会自动生成存取方法。而且，当编译代码访问这个属性时，编译器将会忽略实际上存取方法还没有定义的情况，并且相信它在运行时是可以使用的。例如，如果一个类继承自NSManagedObject类，它的存取方法需要在运行时动态创建。NSManagedObject类之所以这样做是因为子类的属性不是实例变量。它的数据来源于后台数据库。例如： 12345678@interface EOCPerson : NSManagedObject@property NSString *firstName;@property NSString *lastName;@end@implementation EOCPerson@dynamic firstName, lastName;@end 在这个类中，编译器不会自动生成存取方法或者实例变量。如果你尝试去访问某个属性，编译器也没有警告信息。 属性特质属性的另一个问题是你应该知道它所有的特质。你可以通过它去影响编译器生成的存取方法。例如下面这个属性使用了三个特质： 1@property (nonatomic, readwrite, copy) NSString *firstName; 属性可以使用4类特质。 原子性通常，生成的存取方法包含锁去保持原子性。如果你设置了nonatomic特质，那么就不会有锁了。请注意，尽管没有atomic特质(atomic特质是由你不设置nonatomic特质得来的)，但是你仍何以在属性特质中写上，并且编译器不会报错。如果你自己实现存取方法，你应该指定与其相符的原子性。 读写权限 readwrite 读写权限时，getter和setter方法都是可用的。如果属性是自动合成的，那么编译器将会自动生成两个方法。 readonly 只读权限时，只有getter方法是可用的，如果属性是自动合成的，那么编译器将只生成getter方法。当你想暴漏一个只读属性给外部，并且需要在内部重新定义它为可读写时，你可以使用它。第27节讲了更多内容。 内存管理语义属性用于封装数据，数据需要有具体的所有权。它仅仅影响setter方法。例如，用setter方法设置一个值时，它是应该保持新值还是将其直接赋给底层实例变量?当编译器自动生成存取方法时，它要取决于这些特质去生成代码。如果你自己实现存取方法，你应该指定与其相符的特质。 assign 它的setter方法只会简单的给标量类型的值赋值，例如CGFloat或者NSInteger。 strong 这种特质表示定义了一个拥有关系。当为这个属性赋值时，首先持有新值，接着释放旧值，然后将新值赋给这个属性。 weak 这种特质表示定义了一个非拥有关系。当为这个属性赋值时，它是不持有新值的；也不释放旧值。它是类似于assign特质的，但当目标对象释放时，它的值会被自动置为nil。 unsafe_unretained 它同assign语义相似，但是它适用于对象类型，它表达了一个非拥有关系，当目标对象销毁时，它不会自动置为nil，这点与weak是有区别的。 copy 这种特质类似strong特质，定义一个拥有关系；然而，它是用拷贝替代持有新值的。当属性是类似与NSString *时，经常用此特质保证其封装性，因为可能通过setter方法给予其一个可变值。如果赋的值是可变的，那么这个属性的类型可能就在对象不知道的情况下改变。所以就需要使用copy特质去使对象中的字符串不会在无意中被改变。任何需要保持不可变的对象都应该使用copy去修饰。 方法名通过使用下面的特质可以控制存取方法的名字： getter= 指定getter的名字。当你想给一个Boolean属性加上is前缀时，通常使用这个方法。例如，在UISwitch类中，表示状态开关的属性就是这样定义的： 1@property(nonatomic,getter=isOn) BOOL on; setter= 指定setter的名字。这个方法不常用的。 你可以通过这些特质细微的控制自动生成的存取方法。然而，需要谨记的是，如果你实现了自己的存取方法，你应该遵循指定的特质。例如，一个属性使用了copy特质，你需要在setter中拷贝它。否则，会误导属性的使用者。而且，如果不遵守这个约定，那么将会产生bug。 即使你可以通过别的方法设置属性，你也要遵循定义时的特质。例如，考虑扩充下EOCPerson类。属性声明时，使用了copy特质，因为它可能是可变的。这个类也增加了一个初始化方法，用于设置名和姓的值： 123456789@interface EOCPerson : NSManagedObject@property (copy) NSString *firstName;@property (copy) NSString *lastName;- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName;@end 在实现自定义初始化方法时，遵循定义时的copy语义是非常重要的。因为属性定义就像类和对象之间的协议一样。所以初始化的代码应该是这样的： 12345678910- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; &#125; return self;&#125; 你可能会问为什么不简单的使用属性的setter方式去设置，如果总是使用setter设置，那将会保证属性的正确设置。你永远不该在init方法中使用存取方法，具体请看第7节。 如果你已经读了第18节，你应该知道，最好使对象不可变。将上述内容应用在EOCPerson类中，你需要设置两个属性为readonly。在初始化中设置它们的值，然后它们将不能被修改。在本例中，对你使用的值使用内存管理语义是重要的。所以属性定义的代码是这样的： 12@property (copy, readonly) NSString *firstName;@property (copy, readonly) NSString *lastName; 因为是只读属性，所以编译器不会为其自动生成setter方法。这样做是重要的，可以表明在初始化时设置了这两个属性值。没有这样的声明，使用这个类的人就可能不知道已经在init方法中使用了copy，因此他们可能会在调用初始化方法之前自行拷贝。这种操作是多余且低效的。 如果你想知道atomic和nonatomic的区别。前面说过，使用了atomic的属性的存取方法会自动加锁确保原子性。这个意思是如果两个线程同时对属性进行读写操作，这个值不论在任何时候始终是有效的。如果不加所得情况下，当一个线程正在进行修改时，另一个线程进行读取，可能会将其未修改完的值读出来。如果发生了这种情况，读到的值可能是无效的。 如果你是在iOS中开发，那么你会注意到所有属性声明为nonatomic。这样做的历史原因是，加锁消耗比较大，可能会产生性能问题。通常，原子性并不是必须的，因为它不能确保线程安全，需要更深层次的锁定机制才能保证其线程安全。例如，即使使用了原子性，一个线程在连续读取某个属性值时，另一个线程修改了这个属性，仍将不能确保读到的是正确的值。因此，在iOS开发中你将一直使用nonatomic去修饰属性。但是在Mac OS X中，你不需要担心atomic带来的性能问题。 小结 @property语法提供了一种对象封装数据的定义。 使用正确的特质提供数据存储。 在设置属性所对应的实例变量时，需要遵循该属性的语义。 在iOS中使用nonatomic，因为它会严重消耗性能。 在对象内部直接访问实例变量属性总是用于访问外部对象的实例变量，但是在Objective-C社区中如何访问内部变量却是争执不休的。有些建议仍使用属性去访问实例变量，有些建议直接访问实例变量，有些两者混用。作者强烈推荐在读取实例变量时直接访问而在设置值时使用属性访问。 考虑下面的代码： 12345678@interface EOCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; // Convenience for firstName + &quot; &quot; + lastName: - (NSString*)fullName; - (void)setFullName:(NSString*)fullName; @end 这两个便捷方法fullName和setFullName可能是这样实现的： 123456789101112131415- (NSString*)fullName &#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName]; &#125; /** The following assumes all full names have exactly 2 * parts. The method could be rewritten to support more * exotic names. */ - (void)setFullName:(NSString*)fullName &#123; NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;]; self.firstName = [components objectAtIndex:0]; self.lastName = [components objectAtIndex:1]; &#125; 在setter和getter中，我们使用点语法访问实例变量。假设现在重写setter和getter方法直接访问变量： 1234567891011- (NSString*)fullName &#123; return [NSStringstringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName]; &#125; - (void)setFullName:(NSString*)fullName &#123; NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;]; _firstName = [components objectAtIndex:0]; _lastName = [components objectAtIndex:1]; &#125; 这两种方式是有些许差异的： 毫无疑问直接访问实例变量是更快的，因为它不需要通过Objective-C方法派发(看第11节)。编译器通过代码直接访问存储对象实例的内存空间。 直接调用实例变量会绕过setter的内存管理语义。例如，你的属性声明了copy特质，直接调用实例变量不会发生copy事件。新的值将会被保存，旧的值将会被释放。 当直接访问实例变量时，KVO不会被触发。这可能会是一个问题，不过这主要取决你对这个对象的行为。 通过属性访问可以更轻易的定位到与这个属性有关的问题，因为你可以给setter、getter方法添加断点去看谁在什么时候访问了这个属性。 一个好的折中的办法是在写时通过setter方法设置，读时直接调用实例变量。这样做可以在读时有更高的效率，在写时也不会失去控制。最重要的是通过setter方法去写将保证你遵循内存管理语义。然而，这样做会有一些小的问题。 第一个问题是当你的值是在初始化方法中设置的时候。这里，你应该一直使用直接调用实例变量的方法，因为子类可能重写了它的setter方法。考虑下EOCPerson有一个叫做EOCSmithPerson的子类，这个类是专门用于表示名字叫smith的。这个子类可能会覆盖lastName的setter方法： 1234567- (void)setLastName:(NSString*)lastName &#123; if (![lastName isEqualToString:@&quot;Smith&quot;]) &#123; [NSException raise:NSInvalidArgumentException format:@&quot;Last name must be Smith&quot;]; &#125; self.lastName = lastname; &#125; EOCPerson基类可能在初始化时将名字设为空字符。如果它通过setter方法去这样设置，那么子类的setter将会被调用并且会抛出一个异常。然而，在有一些情况中，你必须在初始化时使用setter方法。当实例变量是声明在一个父类中的时候；你不能通过直接调用实例变量时，那么你必须使用setter方法。 另一个问题是当属性使用懒加载时。在这种情况下，你必须通过getter访问；如果没有，那个实例变量将永远不会初始化。例如，EOCPerson类可能有一个属性通过一个复杂对象去代表人脑。如果这个属性很少用并且初始化成本较高的，你可能在getter中使用懒加载，像这样： 123456- (EOCBrain*)brain &#123; if (!_brain) &#123; _brain = [Brain new]; &#125; return _brain; &#125; 如果你直接调用实例变量且没有调用过getter方法，大脑这个属性永远不会创建，所以你需要通过属性的存取方法去访问它。 小结 在内部使用数据时，通过直接调用实例变量来读，通过调用属性来写。 在初始化和销毁中，不论读还是写都通过实例变量直接访问。 当你使用了懒加载时，你需要使用属性去读。 理解对象的等同性比较对象相等是非常有用的。然而，使用等于操作符去判断相等通常不是你想做的，因为这样做比较的是它们的指针本身，而不是指针指向的对象。相应的，你应该使用声明在NSObject协议中的isEqual:方法去检验两个对象是否相等。通常情况下，两个不同类的对象总是不相等的。如果你已经知道你要检查的两个对象是同一个类，那么你可以使用它们自己提供的相同性检测方法。例如，下面的代码： 12345NSString *foo = @&quot;Badger 123&quot;; NSString *bar = [NSString stringWithFormat:@&quot;Badger %i&quot;, 123]; BOOL equalA = (foo == bar); //&lt; equalAequalA = NO BOOL equalB = [foo isEqual:bar]; //&lt; equalBequalB = YES BOOL equalC = [foo isEqualToString:bar]; //&lt; equalCequalC = YES 你可以看到等号操作符与使用等价方法的不同。NSString是一个自己实现了等价比较方法的类，方法名叫做isEqualToString:。使用这个方法的对象一定是一个NSString对象；否则，比较结果就会返回undefined。使用这个方法是比使用isEqual:更快的，它需要别的步骤，因为它不知道比较的对象是什么类型的。 这两个方法的核心等价判断是NSObject的协议方法： 12- (BOOL)isEqual:(id)object;- (NSUInteger)hash; 这两个NSObject类的方法的默认实现是只有两个对象指向相同的地址时才相等。为了在自定义对象中覆写这些方法，你必须去了解它们的原理。任意两个对象使用isEqual:方法比对结果是相等，那么它们的hash方法也一定会返回相同的值。然而，两个对象的hash方法返回相同的值，它们isEqual:方法的比对结果不一定相等。 例如，考虑下面的类： 12345@interface EOCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; @property (nonatomic, assign) NSUInteger age; @end 如果所有条件都是相等的，那么两个EOCPerson对象相等。所以isEqual:方法应该这样写： 12345678910111213- (BOOL)isEqual:(id)object &#123; if (self == object) return YES; if ([self class] != [object class]) return NO; EOCPerson *otherPerson = (EOCPerson*)object; if (![_firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES; &#125; 首先，对比两个对象的指针是否相同。如果指针相同，那么对象一定相等，因为它们是同一个对象。其次，比较两个对象的类。如果两个对象的类不同，那么两个对象不相等。毕竟，一个EOCPerson类不可能等于EOCDog类。当然，你可能希望一个EOCPerson实例等于它一个子类的实例；例如，EOCSmithPerson。这说明在继承层次中，判断相等性是一个常见问题。当你实现了isEqual:方法时，你应该考虑这个问题。最后，没一个属性去检查相等性。如果它们中的任何一个不相等，那么两个对象被认为是不相等；否则，它们是相等的。 接下来实现hash方法。回想一下相等性原则，当两个对象相等，那么它们的哈希码一定相等，但是两个对象的哈希码相等，它们本身却不一定相等。因此如果你复写了isEqual:方法，通常也会覆写hash方法。一个更好的hash方法是像下面这样的： 123- (NSUInteger)hash &#123; return 1337; &#125; 可是，如果在集合中使用这种办法，这将可能会产生性能问题。因为集合使用哈希表中的哈希码做索引。一个集合的实现是使用哈希存储对象到不同的数组。当给集合添加新对象时，会根据哈希码找到与其对应的数组，对比所有对象，看其是否与新加对象相等。如果相等，说明新加的对象已经在集合里面了。因此，如果所有的对象哈希码都一样，那么在集合中已有1000000个对象时，每次给集合添加对象都会遍历对比这1000000个对象。 另一种实现哈希方法如下： 123456- (NSUInteger)hash &#123; NSString *stringToHash = [NSStringstringWithFormat:@&quot;%@:%@:%i&quot;, _firstName, _lastName, _age]; return [stringToHash hash]; &#125; 这次的哈希算法是通过创建一个字符串并将字符串的哈希码返回。这么做符合约定，因为两个相等的EOCPerson总会生成相等哈希码。然而，这种方法是比返回单一数值的速度慢的，因为你需要创建一个字符串。当给一个集合添加对象时，这仍会导致性能问题，因为要给集合添加对象，仍然需要去计算对象的hash值。 第三种也是最后一种方法是创建一个类似于这样的哈希码： 123456- (NSUInteger)hash &#123; NSUInteger firstNameHash = [_firstName hash]; NSUInteger lastNameHash = [_lastName hash]; NSUInteger ageHash = _age; return firstNameHash ^ lastNameHash ^ ageHash; &#125; 这种方法是一个这种的办法，既能保持一定的效率，又能使生成的哈希码在一定范围之内。当然，这样还会导致生成相同的哈希码的碰撞，但是至少不会重复太多次。在编写哈希码时，你应该基于当前的业务要求去权衡哈希碰撞频率和创建哈希的性能消耗。 特定类的等同性方法除了前面说的NSString类提供了特定的等同性方法，还提供特定方法的类还有NSArray(isEqualToArray:)和NSDictionary(isEqualToDictionary:)，如果对比的对象不是数组或者字典，这两种方法都会抛出异常。Objective-C在编译器并没有严格的类行检测，这样就容易使用错误的对象去对比，所以你应该确定当前对象的类型是正确的。 如果等同性对比比较频繁，那么你可能会创建自己的等同性方法；因此，效率高的重要原因是不需要检查类型。另一个原因是，提供一个指定方法是用于修饰的，它看起来是更好、更易读的，这也是NSString类提供isEqualToString:方法的动机之一。使用此种方法的代码是更易读的，并且也不需要再去检查两个对比对象的类型了。 如果你创建一个特定等同性方法，你需要覆盖isEqual:方法并且通过判断两个对比对象的类型是否相同。如果不相同，就使用父类的实现方法去判断。例如，EOCPerson类的实现应该像这样： 12345678910111213141516171819- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123; if (self == object) return YES; if (![_firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES; &#125; - (BOOL)isEqual:(id)object &#123; if ([self class] == [object class]) &#123; return [self isEqualToPerson:(EOCPerson*)object]; &#125; else &#123; return [super isEqual:object]; &#125; &#125; 等同性对比的深度当你创建一个等价方法时，你需要决定是检查整个对象的等同性或者仅仅只是一些条件的等同性。NSArray的对比方法是先对比两个数组包含的个数，其次遍历它们，使用isEqual:对比每个元素。如果所有的元素都相等，那么可以认为两个数组相等，这是深度等同性对比。不过有时你仅需要判断一部分数据段是相等的，这对于等同性对比也是可以的。 例如，使用EOCPerson类，如果实例来源于一个数据库，它们可能会添加一个属性用于唯一标示，即使用数据库中的主键。 1@property NSUInteger identifier; 在这种情况下，可能仅仅需要去检查identifier是否匹配即可，尤其是如果identifier属性特质被声明为只读，那么你可以确定如果两个对象拥有同样的表示符，它们确实代表了相同的对象并且相等。这可以避免对比每个EOCPerson对象的每个数据位，如果你确定它们的标示符相等，那么剩下的数据也相等，因为它们是相同的数据源。 在你的等同性方法中，是否需要检查所有条件的等同性，取决于被检测的对象。只有你才知道在什么情况下两个实例相等。 容器中可变类的等同性考虑一个重要的情况，在容器中添加一个可变类。一旦你将一个对象添加入一个集合中，那么这个对象的哈希码不应该再改变。前面，我说了集合是根据哈希码去存储对象的。如果哈希码一旦发生变化，集合中的对象将会产生一个错误。为了解决这个问题，你可以确保哈希码不是根据可变部分的对象计算出来的或者保证一旦放入集合中就不再修改它。在第18节，我详细阐述了为了你需要使对象不可变。对于这个问题，下面有一个很好的例子。 通过测试NSMutableSet和NSMutableArrays，你可以看到这个问题。开始的时候给集合添加一个数组： 123456NSMutableSet *set = [NSMutableSetnew]; NSMutableArray *arrayA = [@[@1, @2] mutableCopy]; [set addObject:arrayA]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 集合中现在有一个对象：带有两个元素的数组。现在使用相同的方法给集合添加一个同样顺序的数组，下面的代码展示了给集合添加一个新的数组以及添加后集合的情况： 1234NSMutableArray *arrayB = [@[@1, @2] mutableCopy]; [set addObject:arrayB]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 这个集合仍然只保存了一个对象，因为新添加的数组对象是已经在集合中存在的了。现在我们添加一个跟集合中不同的数组： 1234NSMutableArray *arrayC = [@[@1] mutableCopy]; [set addObject:arrayC]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1),(1,2))&#125; 果然，集合现在包含了两个数组：一个原来的数组和一个新的数组，因为arrayC与集合中已有的数组不相等。最后，我们修改arrayC使其等于之前集合中的数组： 123[arrayC addObject:@2]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2),(1,2))&#125; 哦，我的天，现在在集合中存在两个相同的数组了。这个集合没有遵守集合的定义，但是我们现在却无法确保这点了。因为我们修改了一个已经在集合中的对象了。如果我们拷贝这个集合，将会更加可怕： 123NSSet *setB = [set copy]; NSLog(@&quot;setB = %@&quot;, setB); // Output: setB = &#123;((1,2))&#125; 这个拷贝出来的集合仅有一个对象，这个集合像是先创建一个空的集合，然后逐步从原集合中添加元素得到的。这可能是也可能不是你想要的结果。你可能想要忽视这个错误，按原样复制一个集合。或者你就是想这样做。这两种拷贝情况都是有效的，这进一步说明了刚才的问题，如果修改某个已经加入集合的对象，将会产生不可预料的情况。 举这个例子是想告诉大家，当你修改某个已经加入集合的对象会造成什么后果。这不是说不能这样做，而是你这样做了之后要考虑其后果。 小结 如果想检测等同性，你需要提供isEqual:和hash方法。 相同的对象，哈希码一定是相等的；但是哈希码相等，对象却不一定相等。 确定你对比对象同等性时是否需要对比每个对象。 编写哈希算法时，应该使用计算速度快并且碰撞几率低的算法。 使用类簇模式隐藏实现细节在一个抽象基类中，使用类簇可以很好的隐藏实现细节。在Objective-C的系统框架中，这种模式是非常普遍的。UIKit中有一个例子，就是iOS的UI框架中的UIButton类。创建一个按钮，你会调用下面的方法： 1+ (UIButton*)buttonWithType:(UIButtonType)buttonType; 返回对象的类型取决于按钮类型。所有的子类都继承自相同的基类，即UIButton类。这样做使用者就不需要关心生成的按钮类型以及按钮如何绘画的具体细节。这一切只需要知道如何创建一个按钮；如何设置标题这样的属性；如何设置点击的动作。 回到按钮绘画的问题上面，它可以通过使用一个类去处理所有按钮的绘画并且基于它们的类型： 1234567- (void)drawRect:(CGRect)rect &#123; if (_type == TypeA) &#123; // Draw TypeA button &#125; else if (_type == TypeB) &#123; // Draw TypeB button &#125; /* ... */ &#125; 这样看起来是清晰的，但是如果有许多方法基于这个类型的切换去绘制，那么这个方法就会变得非常笨重。一个好的程序员会对这进行重构，通过创建多个子类去实现特定的功能用于对应每种按钮类型。然而这样做需要使用者知道所有的子类。这时就该使用类簇模式了，这种模式提供多个子类，并通过将其实现细节隐藏在基类，用以保持头文件的干净。你不需要创建子类的实例，你通过基类创建它们即可。 创建一个类簇有一个关于如何创建类簇的例子，考虑一个处理雇员的类，这个类包含雇员的名字和销售额以及每天该做的工作。但是每个雇员每天的工作是不一样的。管理者不关心每个雇员如何完成任务，他只会告诉每个雇员该做什么。 首先，你需要定义这个基类： 12345678910111213141516171819202122232425262728293031323334353637383940typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123; EOCEmployeeTypeDeveloper, EOCEmployeeTypeDesigner, EOCEmployeeTypeFinance, &#125;; @interface EOCEmployee : NSObject @property (copy) NSString *name; @property NSUInteger salary; // Helper for creating Employee objects + (EOCEmployee*)employeeWithType:(EOCEmployeeType)type; // Make Employees do their respective day&apos;s work - (void)doADaysWork; @end @implementation EOCEmployee + (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123; switch (type) &#123; case EOCEmployeeTypeDeveloper: return [EOCEmployeeDeveloper new]; break; case EOCEmployeeTypeDesigner: return [EOCEmployeeDesigner new]; break; case EOCEmployeeTypeFinance: return [EOCEmployeeFinance new]; break; &#125; &#125; - (void)doADaysWork &#123; // Subclasses implement this. &#125; @end 每一个具体的子类继承自基类。例如： 12345678910@interface EOCEmployeeDeveloper : EOCEmployee @end @implementation EOCEmployeeDeveloper - (void)doADaysWork &#123; [self writeCode]; &#125; @end 在这个例子中，这个基类实现了一个基类方法的声明，它通过雇员的类型去创建并初始化不同的实例。这个工厂模式是创建一个类簇的一种方法。 不幸的是，Objective-C语言没有指定一个类是基类的功能。相应的，开发者通常会在这个类中写明类的用法。在这种情况下，头文件没有声明初始化方法，它意味着实例变量并不是立即创建的。另一种确定没使用基类实例的方法是在基类的doADaysWork方法中抛出一个异常。然而，这种做法是非常极端的并且也不是必需的。 还有一个点需要注意的，当使用的对象的类是类簇的一个成员时，要注意它的类型信息(看第14节)。因为你可能认为你创建的是某个类的实例，但实际上确实它的某个子类的实例。在前面的例子中，你可能以为调用[employee isMemberOfClass:[EOCEmployee class]]的结果是YES，但employee其实不是EOCEmployee类初始化的对象，而是其子类，所以它会返回NO。 Cocoa中的类簇系统框架中有许多类簇。大多数的集合类都是类簇，例如NSArray和它对应的可变类NSMutableArray。所以，实际上它有两个基类：一个可变数组和一个不可变数组。它仍然是一个类簇但是却有两个公共接口。不可变类中定义的方法适用于所有的数组，可变类定义的方法仅适用于可变数组。实际上类簇意味着它们在实现自身时可以共享代码，以及可以在创建时把不可变数组变为可变数组，反之亦然。 在NSArray中，当你创建一个实例时，它其实是另一个类创建的实例，这个类的用途就是占位。之后这个占位数组会转化为另一个的实例，而那个类则是NSArray的具体子类。这是一个很好的实现，但它超出了本书的讲解范围。 理解像NSArray这样的类是一个类簇是重要的，因为别的原因，你可能会写出这样的代码： 1234id maybeAnArray = /* ... */; if ([maybeAnArray class] == [NSArray class]) &#123; // Will never be hit &#125; 知道了NSArray是一个类簇，可以使你理解上面的代码是错误的，其中if语句的条件永远不可能为真。[maybeAnArray class]返回的类永远不可能是NSArray类，因为NSArray初始化方法返回的变量是由隐藏在类簇内部的某个隐藏类实现的。 注意在类簇中对比实例变量的类是可以的。不适用之前的方法，你应该使用类型信息查询方法。第14节讲述了那些方法。替换之前类对象等同性比较方法，你因该这样写： 1234id maybeAnArray = /* ... */; if ([maybeAnArray isKindOfClass:[NSArray class]]) &#123; // Will be hit &#125; 给类簇添加具体的子类是正常的需求，但是这么做的时候要小心。在Emloyee的例子中，如果没有工厂方法代码，去添加新的子类是不可能的。在Cocoa的类簇中，例如NSArray，它是可以的，但是有一些规则必须去遵守。这几条规则如下： 子类应该继承自类簇的抽象基类。 在NSArray中，它可以继承自不可变数组的基类或者可变数组的基类。 子类应该定义自己的存储方式。 开发者编写NSArray子类时，经常在这个问题上受阻。子类必须用一个实例标量存储数组中的对象。这看起来与我们预想相反，我们以为NSArray自己会存储它们。但是请记住，NSArray仅仅是一个包在其他隐藏对象外面的壳，它只是定义了一些数组通用的接口。对于这个子类来说，可以是用NSArray来保存其实例。 子类应当覆写父类文档中指明需要覆写的方法。 每个抽象基类都有一些方法需要子类一定实现的。在NSArray中，需要实现的方法有count和objectAtIndex:。另外的方法，像lastObject，不需要去实现，因为可以使用前两个方法实现这个方法。 实现子类时所需要遵循的规范一般都在类的文档中，所以你首先应该阅读它们。 小结 类簇模式可以使用一套简单的公共接口隐藏实现的细节。 类簇在系统框架中是经常使用的。 在定义类簇的子类时，需要注意遵循基类的协议。如果有文档，那么首先阅读它。 在既有类中使用关联对象存放自定义数据有时，你想在对象中存储信息。通常，你通常会从那个对象类继承一个子类，然后使用子类去存储。然而，你不能一直这样做，因为类的实例可能是因为某种机制所创建的，并且你不能使这种机制使用你的类创建实例。这时候Objective-C中一个叫做Associated Objects的功能就派上用场了。 对象关联其它对象，并使用一个键去表示它。它们使用存储策略是维持存储对象的内存管理语义。这个存储策略由objc_AssociationPolicy的枚举值定义，表2.1展示了它所包含的值，同事还列出了与之等价的属性的特质(第6节讲述了属性的信息)。 Table 2.1 对象关联类型 关联对象的管理是使用下面语法实现的： void objc_setAssociatedObject(id object, void*key, id value, objc_AssociationPolicy policy) 使用给定的键和存储策略为对象设置关联对象值。 id objc_getAssociatedObject(id object, void*key) 使用给定的键从对象中获取关联对象值。 void objc_removeAssociatedObjects(id object) 移除对象的所有关联对象。 关联对象的存取方法是类似字典对象这种的，字典通过调用[object setObject:value forKey:key]与[object objectForKey:key]存取，关联对象同样使用特定的键存储关联的值。但是有一个重要的不同需要知道，关联对象的键是个指针。而字典对象的键是一个字符串，只需要字符串相同就可以了。但是关联对象的键必须是同一个指针才可以匹配。因此，关联对象通常使用全局静态变量作为键。 一个使用关联对象的例子在iOS开发中，经常会使用UIAlertView类，给用户提供一个基于当前视图的弹窗。当用户点击按钮时有一个代理协议用于处理这个点击事件；然而，使用代理协议需要拆分创建代码和点击事件。由于代码分成两块，所以读起来有些不方便。下面有一个使用UIAlertView的例子，与我们一般写法一致： 1234567891011121314151617181920- (void)askUserAQuestion &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Question&quot; message:@&quot;What do you want to do?&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Continue&quot;, nil]; [alert show]; &#125; // UIAlertViewDelegate protocol method - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; if (buttonIndex == 0) &#123; [self doCancel]; &#125; else &#123; [self doContinue]; &#125; &#125; 如果你想在同一个类弹出超过一个弹窗，那么这种写法将会变得更加凌乱，因为你接着需要通过代理方法去检查弹窗的参数，并基于此选择相应的逻辑。如果弹窗创建时就可以决定每个按钮该做什么，那么逻辑就会清楚很多。这时可以使用关联对象去处理。一个解决办法是当创建弹窗时给它设置一个block并且当协议方法触发时调用这个blcok。它实现是这样的： 123456789101112131415161718192021222324252627282930313233343536#import &lt;objc/runtime.h&gt; static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;; - (void)askUserAQuestion &#123; UIAlertView *alert = [[UIAlertViewalloc] initWithTitle:@&quot;Question&quot; message:@&quot;What do you want to do?&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Continue&quot;, nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123; if (buttonIndex == 0) &#123; [self doCancel]; &#125; else &#123; [self doContinue]; &#125; &#125;; objc_setAssociatedObject(alert, EOCMyAlertViewKey, block, BJC_ASSOCIATION_COPY); [alert show]; &#125; // UIAlertViewDelegate protocol method - (void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey); block(buttonIndex); &#125; 使用这种方法，创建弹窗的代码和回调结果的代码都在同一个位置，这样比之前的代码更易读，因为你不需要在两处代码之间来回看就可知道为什么使用弹窗了。然而使用这种办法你需要小心一个问题，如果block捕捉了某些变量，这可能会造成循环引用。关于这个问题更具体的信息请看第40节。 如你所见，这种方法是非常好用的，但是你应该确保仅仅是你没有别的办法达到你想做的时再去使用它。如果滥用它，你的代码将会很快超出控制并且难以排查问题。循环引用产生的原因是难以发现的，因为关联对象之间并没有明确的定义，内存管理语义定义在关联时期，而不是声明时期。所以当你使用这种方法时需要小心，不要因为某处可以用它就使用它。另一个实现弹窗的办法是创建子类，将block作为一个属性添加进子类。如果多次使用弹窗时，我认为使用这种办法是优于使用关联对象的。 小结 关联对象提供了一种方法去关联两个对象。 定义关联对象时可使用内存管理语义去模仿属性的拥有或非拥有关系。 当另一种方法不能实现时，才去使用关联对象，因为它可能产生难以查找的异常。 理解objc_msgSend的作用在Objective-C中通过对象调用方法是做的最多的事情之一。在Objective-C术语中，它被称作消息传递。消息有名字或者选择器，带有参数，并且可能会有一个返回值。 因为Objective-C是C的超集，去了解C中的函数调用时一个好的主意。众所周知，C的函数调用时静态绑定，即在编译时就知道函数的调用。例如，考虑下面的代码： 1234567891011121314151617#import &lt;stdio.h&gt; void printHello() &#123; printf(&quot;Hello, world!\n&quot;); &#125; void printGoodbye() &#123; printf(&quot;Goodbye, world!\n&quot;); &#125; void doTheThing(int type) &#123; if (type == 0) &#123; printHello(); &#125; else &#123; printGoodbye(); &#125; return 0; &#125; 忽略内联函数这种情况，当上述代码编译时，printHello函数和printGoodbye函数是已知的，编译器会直接发出指令去调用函数。在指令集中函数的地址就是有效的硬编码。现在考虑下下述代码： 12345678910111213141516171819#import &lt;stdio.h&gt; void printHello() &#123; printf(&quot;Hello, world!\n&quot;); &#125; void printGoodbye() &#123; printf(&quot;Goodbye, world!\n&quot;); &#125; void doTheThing(int type) &#123; void (*fnc)(); if (type == 0) &#123; fnc = printHello; &#125; else &#123; fnc = printGoodbye; &#125; fnc(); return 0; &#125; 在这里就需要使用动态绑定了，因为在运行时之前都不知道函数如何调用。在第一个和第二个例子中，编译器生成的指令集是不同的。第一个例子中，函数的调用是在if和else这两种情况中的。第二个例子中，仅有一个调用，不过是有一定代价的，即待调用的函数地址无法硬编码在指令集中，而是要在运行期读取出来。 在Obejctvie-C中，当传递消息给对象时，是通过动态绑定机制去决定调用哪个方法的。在底层所有的方法都是普通的C函数，但是当对象接收到信息后，调用哪一个方法完全取决于运行时，甚至可以在程序运行过程去修改它，这使得Objective-C成为一门真正的动态语言。 给对象发送消息看起来是这样的： 1id returnValue = [someObject messageName:parameter]; 在这个例子中，someObject是消息接收者，messageName:是选择器。选择器和参数的组合被称作消息。当编译器看到这个消息时，它将这个消息转化为一条标准的C函数，所调用的函数是消息传递机制中的核心函数，叫做objc_msgSend，其原型如下： 1void objc_msgSend(id self, SEL cmd, ...) 这是一个参数个数可变的参数，它可以接受两个或两个以上的参数。第一个参数是消息接收者，第二个参数是选择器(SEL的类型是selector)，剩下的参数就是消息参数，顺序与它们传递时一致。选择器指的是方法的名字。在计算机术语中，选择器和方法这两个术语经常交替使用。编译器会将上面的例子中的消息转化成这样： 123id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); objc_msgSend函数会依据消息接收者和选择器去调用合适的方法。为了做到这一点，这个函数会去查找消息接收者所属类中的方法实现列表，如果能查找到与接收器名字匹配的方法，就跳转至其实现代码。如果没有找到，这个函数会遍历其继承层次查找这个方法并跳转至其实现代码。如果仍没有找到匹配的方法，那么就执行消息转发。更详细的消息转发机制请看第12节。 这样说来，调用一个方法会需要很多步骤。幸运的是，objc_msgSend会在快速查找表中缓存结果，每个类都有这样一块缓存，所以后面给相同的类和方法组合发送消息是非常快速的。即使这样，快速查找仍然是比静态绑定方法的速度慢的，但是一旦方法缓存，也不会差太多。实际上，消息传递并不是一个应用程序的瓶颈。如果是，你可以编写纯C函数，只在调用需要时，将Objective-C对象状态传递进去。 上面说的仅仅基于确定的消息。另外的边缘情形则需要交给Objective-C运行时的另一些函数： objc_msgSend_stret 如果发送的消息返回结构体，那么可交由此函数处理。当返回的类型是结构体且能被放进CPU寄存器时，使用这个函数处理。如果寄存器不能容纳返回类型，那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。 objc_msgSend_fpret 如果发送消息的返回值是浮点数，那么可交由此函数处理。某些处理器调用函数时，需要对浮点型寄存器进行特殊处理，这意味着标准的objc_msgSend是不适合的。这个函数存在的作用是处理x86等架构中的一些特殊的情况。 objc_msgSendSuper 发送消息给父类，例如[super message:parameter]，使用这个方法。它也有两个等价于objc_msgSend_stret和objc_msgSend_fpret的函数，用于处理发给父类的消息。 刚才提到过，objc_msgSend等函数一旦搜寻到正确的方法实现就跳转至其实现代码。之所以能这样做，是因为每个Objective-C对象方法都能看做是一个简单的C函数，它的原型如下： 1&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...) 函数的名字可能不像上面那样，但我用类和选择器去组合它，仅仅是为了说明它的原理。每个类里面都有一张表，其中的指针会指向函数，以选择器名字为键去查找。objc_msgSend等函数正是通过这张表来寻找应该执行的方法并跳至其实现的。注意原型和objc_msgSend函数很相似，但这不是巧合。它简化跳转方法并且可以更好的使用尾调用优化。 当一个方法的最后一行是调用另一个函数，那么就可以使用尾调用优化。编译器可产生跳转至下一个函数的指令码，也不用生成新的栈帧。这仅当一个函数最后的操作是调用另一个函数且不需要使用返回值做任何事情，才能执行尾调用优化。这项优化对objc_msgSend是非常重要的，因为没有它，每次调用Objective-C方法，栈将会在栈踪迹中显示所有objc_msgSend调用的函数。并且，也将会经常发生栈溢出现象。 实际上，你在写Objective-C代码时，不需要担心这些问题，但是理解这些操作的本质对开发来说是有益的。如果你理解了在发送消息时发生了什么，你可以了解你的代码是如何执行的并且在调试时，也能理解为什么栈回溯中总会出现objc_msgSend函数。 小结 一个消息由一个接收者，一个选择器，参数组成。给对象发送消息相当于对象调用方法。 当调用时，所有的消息都需要通过动态消息发送系统来处理，它会查找方法的实现然后运行它们。 理解消息转发第11节解释了理解对象消息机制是重要的。第12节探讨当对象遇到无法处理的消息时发生了什么。类可以理解消息仅仅是因为它实现了相对应的方法。类接收到一个无法理解的信息会发生错误，但它并不是发生在编译时。因为方法是在运行时被添加到类中的，所以编译器并不知道对应的方法是否存在。当某个类接受到一个它不理解的消息，对象通过使用消息转发，一个允许开发者预处理的设计。开发者可以通过它去处理那些类无法理解的消息。 即使你不知道消息转发，但你可能已经遇到过由消息转发流程处理的消息了。每次你在控制台看到这样的信息，它是因为你给某个对象传递了消息但是那个对象无法处理它，所以它通过转发机制，将消息转发给了NSObject的默认实现。 12345-[__NSCFNumber lowercaseString]: unrecognized selector sent to instance 0x87 *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber lowercaseString]: unrecognized selector sent to instance 0x87&apos; 这是从NSObject的doesNotRecognizeSelector:方法抛出的一个异常，它告诉你这个消息的接收者类型是__NSCFNumber，并且这个接收者无法理解这个叫做lowercasrString的选择器。在上述示例中这并不奇怪，因为NSNumber是没有那个方法的(__NSCFNumber是为了实现无缝桥接而使用的内部类，当你初始化一个NSNumber实例时，它会被创建)。在这个例子中，应用程序最后以崩溃而告终，但是你可以在你的类中拦截到转发机制去执行你想要的逻辑替代崩溃。 转发路径是分为两大阶段的。第一个阶段是给接收者的类一个机会去动态的添加一个方法，用于处理未知的选择器。这叫做动态方法解析。第二个阶段涉及完整的消息转发机制。如果运行时间已经过了第一阶段，那么接收者就无法再以添加方法的方式去相应选择器。所以它告诉接收者自己去尝试处理。这也分为两步。首先，它会问别的对象是否接受这个消息。如果有，运行时会转移消息并结束消息转发。如果没有替代的接收者，则启动完整的转发机制，使用NSInvocation对象去把所有与消息有关的细节包装起来并给开发者最后一个机会去处理它。 动态方法解析当一个对象接收到一个它不能理解的方法时，在它所属类中调用的第一个方法是： 1+ (BOOL)resolveInstanceMethod:(SEL)selector; 这个方法带有一个当前类无对应实现的选择器并且返回一个布尔值指示是否在运行期有可以对应选择器的实例方法添加到本类。因此，在触发其余转发机制之前这个类有第二次机会去添加对应的实现。还有一个类似的方法，叫做resolveClassMethod:，当一个未实现的方法是类方法而不是实例方法时会调用它。 使用这种方法依赖于这个方法实现已经是可用的，准备动态的插入类中。这个方法经常被用做实现@dynamic属性(看第6节)，例如在CoreData中访问NSManagedObjects属性，因为访问方法需要去手动实现，这样属性才可以在编译时被知道。 这样一个resolveInstanceMethod:实现，对于使用@dynamic属性看起来是这样的： 123456789101112131415161718192021id autoDictionaryGetter(id self, SEL _cmd); void autoDictionarySetter(id self, SEL _cmd, id value); + (BOOL)resolveInstanceMethod:(SEL)selector &#123; NSString *selectorString = NSStringFromSelector(selector); if ( /* selector is from a @dynamic property */ ) &#123; if ([selectorString hasPrefix:@&quot;set&quot;]) &#123; class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;); &#125; else &#123; class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;); &#125; return YES; &#125; return [super resolveInstanceMethod:selector]; &#125; 首先将选择器转为一个字符串，并且检查它是否是一个setter方法。如果前缀带有set字符，假定它是一个setter方法；否则，假定它是一个getter方法。在每种情况下，都会对给定选择器的类添加一个方法，它指向一个C函数的实现。在这些C函数中将会通过代码来控制类使用某种数据结构去存储属性数据。例如，在CoreData中，这些方法将通过后端数据库去检索或更新值。 备用接收者第二步处理未知选择器的方法是询问接收者是否有一个可用的替代接收者去处理相应的消息。这个方法是这样的： 1- (id)forwardingTargetForSelector:(SEL)selector 传递未知的选择器并且返回符合预期的接收者，当未找到符合预期的接收者，将返回nil。这个方法可以让我们通过组合来模拟多重继承的某些特性。一个对象内部可能还有一系列别的对象，在这个方法中它可以返回能够处理的选择器相关的内部对象，并使其在外界看来像是它亲自处理一样。 注意，我们无法再这一步对消息做出改变。如果消息需要在发送给备用接收者之前做改变，那么我们需要使用完整的转发机制。 完整转发机制如果转发算法已经走到这一步，那么能做的事仅有使用完整的转发机制了。首先创建一个NSInvocaton对象，用于包含不能处理的消息的所有细节。这个对象包含选择器，目标接收者，和参数。在触发NSInvocaton对象可时，这将导致消息派发系统去将消息派发给指定的对象。 此步骤调用的转发方法： 1- (void)forwardInvocation:(NSInvocation*)invocation 一个简单的实现是改变这个对象的目标并触发它。这样的实现与备用接收者是等价的，但是很少有人使用这么简单的实现。更有用的实现是可以在调用前通过某些办法改变这个消息，比如拼接另一个参数或者改变选择器。 实现此方法时，如果发现调用不是由该类处理，那么应该调用它的父类去处理。这意味着在继承链上的所有父类都有机会去处理这个调用，直至NSObject的实现。如果最后该消息仍没有处理，那么仍会调用doesNotRecognizeSelector:抛出异常。 完整的转发机制图图2.2这张流程图描述了消息转发机制处理消息的各个步骤。 在每一步，接收者都有机会去处理消息。每一步处理代价都比上一步大。最好的处理时机在第一部，因为方法在运行时被添加将会被运行时缓存，当你使用同一个类的实例再次调用时，它不需要再走转发机制就可以找到这个选择器了。如果能找到一个备用接收者，那么在第二步处理是优于第三步处理的。在第三步中，仅是修改有关的调用目标，那在第二步做这个是比第三步更简单的，并且也不需要再去创建NSInvocaton对象。 动态方法解析的完整示例为了说明如何使用消息转发机制，下面的例子展示了使用动态方法解析显现@dynamic属性。考虑一个对象允许你存储任何对象进去，类似一个字典，但需要通过属性提供存取方法。这个类的设计思路是你可以添加属性定义并使用@dynamic声明它，类将处理存储和获取方法。这听起来是不是很不错？ 这个类的接口大概是这样的： 12345678#import &lt;Foundation/Foundation.h&gt; @interface EOCAutoDictionary : NSObject @property (nonatomic, strong) NSString *string; @property (nonatomic, strong) NSNumber *number; @property (nonatomic, strong) NSDate *date; @property (nonatomic, strong) id opaqueObject; @end 在这个例子中，这些属性具体是什么是不重要的。我之所以写这么多类型只是为了展示这个功能的强大。在类的内部，每一个属性将都存放在字典中，所以类开始的实现是下面这样的，包含使用@dynamic声明属性，这样这些属性的实例变量和存取方法就不会自动生成了： 12345678910111213141516#import “EOCAutoDictionary.h&quot; #import &lt;objc/runtime.h&gt; @interface EOCAutoDictionary () @property (nonatomic, strong) NSMutableDictionary *backingStore; @end @implementation EOCAutoDictionary @dynamic string, number, date, opaqueObject; - (id)init &#123; if ((self = [super init])) &#123; _backingStore = [NSMutableDictionary new]; &#125; return self; &#125; 然后是本例重要的部分： 12345678910111213141516+ (BOOL)resolveInstanceMethod:(SEL)selector &#123; NSString *selectorString = NSStringFromSelector(selector); if ([selectorString hasPrefix:@&quot;set&quot;]) &#123; class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;); &#125; else &#123; class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;); &#125; return YES; &#125; @end 首次调用一个位于EOCAutoDictionary实例中的属性时，运行时找不到对应的选择器，因为它们即没有直接实现也没有自动合成。例如，假如要向opaqueObject对象写入信息，那么将会调用setOpaqueObject:方法。同理，在读取该属性时，会调用opaqueObject方法。resolveInstanceMethod:方法会检测方法是不是含有set前缀，以此区分setter和getter方法。在每种情况下，都会向类中增加一个方法去处理选择器，这两个方法分别是autoDictionarySetter及autoDictionaryGetter函数的指针。这时就可以使用运行时的class_addMethod方法，给类动态的添加方法，用于处理对应的选择器，并且带有所添加方法的指针。最后一个参数表示实现方法的类型编码。在本例中，编码开头的字符表示方法的返回值类型，后续字符则表示其所接受的各个参数。 getter函数的实现： 1234567891011id autoDictionaryGetter(id self, SEL _cmd) &#123; // Get the backing store from the object EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self; NSMutableDictionary *backingStore = typedSelf.backingStore; // The key is simply the selector name NSString *key = NSStringFromSelector(_cmd); // Return the value return [backingStore objectForKey:key]; &#125; 最后，setter函数的实现： 123456789101112131415161718192021222324252627282930void autoDictionarySetter(id self, SEL _cmd, id value) &#123; // Get the backing store from the object EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self; NSMutableDictionary *backingStore = typedSelf.backingStore; /** The selector will be for example, &quot;setOpaqueObject:&quot;. * We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first * letter of the remainder. */ NSString *selectorString = NSStringFromSelector(_cmd); NSMutableString *key = [selectorString mutableCopy]; // Remove the &apos;:&apos; at the end [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)]; // Remove the &apos;set&apos; prefix [key deleteCharactersInRange:NSMakeRange(0, 3)]; // Lowercase the first character NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString]; [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar]; if (value) &#123; [backingStore setObject:value forKey:key]; &#125; else &#123; [backingStore removeObjectForKey:key]; &#125; &#125; 使用EOCAutoDictionary的方法很简单： 1234EOCAutoDictionary *dict = [EOCAutoDictionary new]; dict.date = [NSDate dateWithTimeIntervalSince1970:475372800]; NSLog(@&quot;dict.date = %@&quot;, dict.date); // Output: dict.date = 1985-01-24 00:00:00 +0000 其它属性在字典中的实现也类似于日期属性，如果要添加新的属性，也可以使用@property定义，@dynamic声明它。在iOS的CoreAnimation框架中，CALayer类也是用来类似的方法。这是的CALayer成为可以兼容键值对容器的类，这意味着你可以随意添加键值对，并以属性的方法访问它。于是，开发者就可以向其中新增自定义的属性了，这些属性值的存储工作由基类直接负责，我们只需在CALayer的子类中定义新属性即可。 小结 如果对象无法响应选择器，则进入消息转发流程。 运行时的动态方法解析可以使我们给类添加我们需要使用的方法。 对象可以把无法处理的选择器交给其他对象去处理。 当前述步骤未处理选择器时，启动完成的转发机制。 考虑使用方法交换去调式不透明方法在Objective-C中，当给对象发送消息时，它的一系列调用是发生在运行期的，第11节详细阐述了这个过程。你可能会在运行时修改给定选择器的对应方法。这是可以的。这个功能有巨大的用途，你可以使用它修改类中的方法对于某些你没有代码的方法，不需要子类和重载方法。因此，这个新的函数可以被所有类的实例使用而不仅是重载方法的子类实例。这种方法通常被称为Method Swizzling。 一个类的方法列表中包含一个选择器名字列表用于映射，告诉动态消息系统在哪里找到给定方法的实现。这个实现是作为函数指针被存储的，叫做IMPs，如下面的原型： Figure 2.3 NSString的选择器表 1id (*IMP)(id, SEL, ...) NSString类可以响应这些选择器的调用lowercaseString，uppercaseString，capitalizedString以及其它方法。每一个选择器指向一个不同的实现，类似于图2.3。 Objective-C运行时暴露的一些方法可以操作这张表。你可以给列表添加选择器，改变实现指向，或者交换两个选择器的实现。执行其中的一些操作，类方法表可能像图2.4。 Figure 2.4 执行了一些操作后，NSString选择器的表 添加了一个新的叫做newSelector选择器，改变了capitalizedString的实现，并且交换了lowercaseString和uppercaseString的实现。上述修改均无须编写子类，只要修改了方法表的布局，就会反映到程序中所有的NSString实例之上。怎么样，这是一个强大的功能吧。 这节的话题会讲述两个方法交换的过程。这样做可以为已有方法添加新功能。在讲述如何给已有方法添加功能之前，我将先讲述如何去交换两个已经存在的方法。交换方法实现，你应该使用下面的函数： 1void method_exchangeImplementations(Method m1, Method m2) 这个函数中的参数用于交换。它们可以通过下面的函数获取： 1Method class_getInstanceMethod(Class aClass, SEL aSelector) 这个方法使用给定的选择器在类中去检索方法。在前面的例子中，交换lowercaseString和uppercaseString的实现，需要执行下面的代码： 1234567Method originalMethod = class_getInstanceMethod([NSStringclass], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSStringclass], @selector(uppercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); 从这时起，所有的NSString实例调用lowercaseString方法时，都会调用uppercaseString的实现，反之亦然： 123456789NSString *string = @&quot;ThIs iS tHe StRiNg&quot;; NSString *lowercaseString = [string lowercaseString]; NSLog(@&quot;lowercaseString = %@&quot;, lowercaseString); // Output: lowercaseString = THIS IS THE STRING NSString *uppercaseString = [string uppercaseString]; NSLog(@&quot;uppercaseString = %@&quot;, uppercaseString); // Output: uppercaseString = this is the string 上面展示了如何交换两个方法实现，但是在实际使用中，简单的交换两个实现不是非常有用的。毕竟，你为什么要交换lowercaseString和uppercaseString的实现，它们已经做的不错了。你没有任何理由去交换它们。但是同样的方法可以用来给已有的方法添加新功能。假如你想记录调用lowercaseString时的某些信息。同样的办法可以达到这个目的。它需要你去实现一个新的方法并包含你想要的功能，然后通过交换去替代掉原有方法。 可以使用category去添加的方法，如下： 123@interface NSString (EOCMyAdditions) - (NSString*)eoc_myLowercaseString; @end 这个方法与原有的lowercaseString方法交换，交换后的方法表如图2.5。 新方法的实现如下： 1234567@implementation NSString (EOCMyAdditions) - (NSString*)eoc_myLowercaseString &#123; NSString *lowercase = [self eoc_myLowercaseString]; NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase); return lowercase; &#125; @end 这看起来像是会陷入递归调用的死循环，但是要记住它们的实现已经交换了。所以在运行时，当查找eoc_myLowercaseString选择器时，它会调用lowercaseString的实现。最后，交换两个方法的实现，像下面这样使用： 1234567Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); 从现在起，所有的NSString实例调用lowercaseString方法时，都会在日志中打印出如下信息： 123NSString *string = @&quot;ThIs iS tHe StRiNg&quot;; NSString *lowercaseString = [string lowercaseString]; // Output: ThIs iS tHe StRiNg =&gt; this is the string 通过这个方案，开发者可以对那些无法知道实现的方法增加日志输出，这对调试来时是非常有用的。然而此方法也应只在调试模式使用它。很少有人在全局类中使用它。不要因为你能使用它就去用它。过多的使用会使你的代码难以阅读和难以控制。 小结 在运行时可以给类中添加方法或者替换某个指定的选择器的实现。 使用一个方法实现去替代另一个方法实现，叫做Method Swizzling，开发者通常用其为已有方法添加功能。 在调试模式下，通过运行时去修改方法实现是好的做法，但是不能滥用。 理解类对象Objective-C实际上是一门极其动态的语言。第11节讲述了在运行时如何查找一个方法的实现，第12节讲述了当一个类不能响应一个确定的选择器时的转发机制。但是消息接收者是什么：那个对象自身？runtime怎么知道那个对象的类型？在编译时对象的类型并未绑定，而是在运行时确定的。此外，一个特殊的类型id，它可以表示任意的Objective-C对象类型。通常，指定的对象类型是已知的，所以编译器才能在它认为接收者无法接收某条消息时发出警告。相反的，当对象类型是id时，编译器将假定它可以相应所有的消息。 从第12节你可以知道，编译器无法知道一个确定类型到底能理解多少选择器，因为它们可以在运行时动态添加。然而，即使知道可能会在运行时添加方法，编译器也觉得可以在某个头文件中看到方法原型的定义，这样它可以知道完整的方法签名，用于生成消息派发所需的正确代码。 在运行时检查对象的类型也被称作内省，这是一个强大且有用的功能，它作为NSObject协议的一部分内置在Foundation框架中，凡是由公共根类(NSObject与NSProxy)继承来的类都要遵守它。使用这些方法而不是直接对比对象的类是明智的，我将在后面讲述为什么不要直接对比。不过在介绍类型信息查询技术之前，我们先讲一些基础知识，看看Objective-C对象的本质是什么。 每一个Objective-C对象实例指向一块内存区域。这就是为什么当你声明一个变量时，看到类型后面有一个*： 1NSString *pointerVariable = @&quot;Some string&quot;; 编过C语言程序的人都知道这是什么意思。对于没写过C语言的程序员来说，pointerVariable是一个存放内存地址的变量，而NSString自身的数据就存于那个地址中。因此这个变量指向NSString实例。所有的Objective-C对象都是这样的；如果想在栈上初始化一个对象，你将会收到一个来自编译器的错误： 12String stackVariable = @&quot;Some string&quot;; // error: interface type cannot be statically allocated 通用的对象类型id，它本身就是一个指针，所以你可以这样使用它： 1id genericTypedString = @&quot;Some string&quot;; 这个定义的语义与NSString*是相同的。它们的区别在于指明类型的情况下，对于这个实例如果你尝试调用一个类中不存在的方法，编译器可以帮助你检查，并且发出警告信息。 在runtime的头文件中，所有的对象的数据结构都是这样定义的，id类型本身也在这定义： 123typedef struct objc_object &#123; Class isa; &#125; *id; 因此，每个对象的首个成员是Class类型的变量。这个变量定义了对象所属的类型，常常被称为isa指针。例如，刚才的例子中的对象是一个NSString。类对象也定义在runtime的头文件中： 12345678910111213typedef struct objc_class *Class; struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; &#125;; 这个结构体存放类的元数据，例如类实例的方法实现和实例变量。实际上这个结构体也有一个isa指针，并且是第一个变量，它意味着Class自身也是一个Objective-C对象。这个结构体也有另一个变量，叫做super_class，这个是类的父类。类的类型是另一个类，叫做元类，用来表述类对象本身所具备的元数据。类方法就定义在元类中，因为它可以理解成类对象的实例方法。每个类仅有一个类对象，每个类对象也只有一个元类。 一个叫做someClass的类继承自NSObject，继承链如图2.6。 Figure 2.6 SomeClass的实例继承链，它继承自NSObject，包含元类的继承。 super_class指针确立了继承关系，isa指针则描述了实例所属的类。你可以通过操作这个布局来执行内省(检查对象的类型)。你可以通过它找到一个对象是否可以响应某个确定的选择器并且遵循某个确定的协议，并且确定对象所属类的继承信息。 检查类的继承内省方法可以用作去检查类的继承。你可以使用isMemberOfClass:判断一个对象是否是某个确定类的实例，或者使用isKindOfClass:去检查某个对象是否是某个确定类或者任何继承自它的类的实例。例如： 12345NSMutableDictionary *dict = [NSMutableDictionary new]; [dict isMemberOfClass:[NSDictionary class]]; ///&lt; NO [dict isMemberOfClass:[NSMutableDictionary class]]; ///&lt; YES [dict isKindOfClass:[NSDictionary class]]; ///&lt; YES [dict isKindOfClass:[NSArray class]]; ///&lt; NO 像这种内省类型的原理是通过isa指针获得对象的类，并且使用super_class去遍历整条继承链。由于对象类型是动态的，所以这个功能是非常重要的。Objective-C与你了解的其他语言不同，在Objective-C中，必须查询类型信息，才能完全了解对象的真实类型。 由于Objective-C使用动态类型绑定，所以查询对象所属类的功能是非常有用的。当你从集合中获取对象时，内省是非常常用的，因为它们不是强类型，意思是指当对象是从集合中获取的时候，它们通常是id类型。如果需要知道具体的类型，那么就可以使用内省：例如，想根据数组中存储的对象生成以逗号分隔的字符串，并将其存至文本文件，就可以使用下列代码： 12345678910111213141516- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array &#123; NSMutableString *string = [NSMutableString new]; for (id object in array) &#123; if ([object isKindOfClass:[NSString class]]) &#123; [string appendFormat:@&quot;%@,&quot;, object]; &#125; else if ([object isKindOfClass:[NSNumber class]]) &#123; [string appendFormat:@&quot;%d,&quot;, [object intValue]]; &#125; else if ([object isKindOfClass:[NSData class]]) &#123; NSString *base64Encoded = /* base64 encoded data */; [string appendFormat:@&quot;%@,&quot;, base64Encoded]; &#125; else &#123; // Type not supported &#125; &#125; return string; &#125; 去检查类对象的等价性也是可以的。如果你要这样做，那么可以使用==操作符而不要使用你对比对象时常用的isEqual:方法(看第8节)。理由是在一个应用程序中，没个类都是单例，并且每个类仅会有一个类对象存在。因此，另外一种可以准确判断对象是否为某类实例的办法如下： 1234id object = /* ... */; if ([object class] == [EOCSomeClass class]) &#123; // &apos;object&apos; is an instance of EOCSomeClass &#125; 即使能这样做，你也应该使用内省方法去判断而不是直接调用==操作符，因为内省方法可以完整的处理消息转发(看第12节)的情况。考虑下一个对象将它的所有选择器都转发给另一个对象了，这样的对象叫做代理，并且对于这些类似的对象都以NSProxy为根类。 通常情况下，假如这样的代理对象调用class方法，那将返回代理类(例如：NSProxy的子类)，而非接受的代理的对象所属的类。然而，如果是这样的内省方法，例如isKindOfClass:，那么代理对象会把这个方法转发给接受代理的对象。这意味着这条消息的返回值与直接在接受代理对象上面查询的结果是一样的。因此，这样检查出来的类对象与调用class方法返回的类对象不同，class方法所返回的类表示发起代理的对象，而非接受代理的对象。 小结 每个实例都有一个isa指针，用于表明它的类型与指向类对象，而类对象构成了类的继承链。 当在编译时不能确实对象类型时，应该使用内省去确定对象的具体类型。 应该总是使用内省去检查对象类型，而不是直接对比类对象，因为对象可能实现了消息转发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第一章]]></title>
      <url>%2F2017%2F04%2F29%2FAccustoming%20Yourself%20to%20Objective-C%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识 简介Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。 书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。 了解Objective-C的本源Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的： 1234567// Messaging (Objective-C) Object *obj = [Object new]; [obj performWith:parameter1 and:parameter2]; // Function calling (C++) Object *obj = new Object; obj-&gt;perform(parameter1, parameter2); 两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。 Objective-C在运行时做了更多的工作而不是编译时。runtime包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，runtime包含所有内存管理的方法。本质上，runtime是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当runtime更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。 Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的： 1NSString *someString = @&quot;The string&quot;; 这种语法大多来源于C，声明一个叫做someString的变量，类型是NSString *。它的意思是这是一个NSString类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的： 12 NSString stackString;// error:interface type cannot be statically allocated someString变量指向某个内存地址，在堆上初始化，包含一个NSString对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象： 12NSString *someString = @&quot;The string&quot;;NSString *anotherString = someString; Figure 1.1 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它 这仅有一个NSString实例，但有两个变量指向同它。这两个变量的类型是NSString *，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：NSString实例的内存地址。 图1.1说明了这个结构。NSString实例存储了表示实际字符串所需要的字节。 在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。 Objective-C堆上的内存管理是已经抽象的。你不需要使用malloc和free去初始化和释放对象内存。Objective-C的runtime通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。 有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如CGRect，来源于CoreGraphics框架： 12345CGRect frame;frame.origin.x = 0.0f;frame.origin.y = 10.0f;frame.size.width = 100.0f;frame.siez.height = 150.0f; CGRect是一个C的结构体，定义是这样的： 12345struct CGRect &#123; CGRect origin; CGSize size;&#125;;typedef struct CGRect CGRect; 这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如CGRect。 在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。 小结 Objective-C是C的超集，添加了面向对象的功能。 Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。 Objective-C是运行时而不是编译时，通过消息决定代码如何运行。 了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。 减少在头文件中使用importObjective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有.h的是头文件，带有.m的是实现文件。当你创建一个类时，它看起来是这样的： 12345678910111213141516// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@end// EOCPerson.m#import &quot;EOCPerson.h&quot;@implementation EOCPerson// Implementation of methods@end 对所有类来说，导入Foundation.h是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建UIViewController的子类。这些类的头文件将会导入UIKit.h。 目前来讲，这个类的写法是没问题的。它导入了整个Foundation框架，但是并不需要在意。EOCPerson类继承自Foundation框架中的某一个类，它将会使用框架的一大部分功能。继承自UIViewController的类也是一样，它将会使用UIKit框架的一大部分功能。 随着时间的推移，你可能创建了一叫做EOCEmployer的新类。然后你决定一个EOCPerson实例持有一个EOCEmployer实例。所以你提前给它加了一个属性： 12345678910// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 一个问题出现了，当你编译时发现EOCEmployer是缺失的。这个时候编译器一定会提示你在EOCPerson.h中导入EOCEmployer.h。通常你是在EOCPerson.h顶部加入导入的方法： 1#import &quot;EOCEmployer.h&quot; 这将使他正常编译，但这是一个坏的习惯。因为编译EOCPerson不需要知道EOCEmployer的详细信息。仅需要知道有一个叫做EOCEmployer的类存在即可。幸运的是，有一个办法可以告诉编译器这样： 1@class EOCEmployer; 这叫做向前声明这个类。这样EOCPerson的头文件看起来是这样的： 123456789101112// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 当你为了在实现文件中使用它时，你需要知道EOCEmployer的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的： 1234567// EOCPerson.m#import &quot;EOCPerson.h&quot;#import &quot;EOCEmployer.h&quot;@implementation EOCPerson// Implementation of methods@end 推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果EOCEmployer.h是在EOCPerson.h中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。 使用前向声明会缓解两个类互相引用的问题。考虑下当EOCEmployer有两个方法去添加和移除EOCPerson的实例会发生什么，在头文件像这样定义： 12- (void)addEmployee:(EOCPerson *)person;- (void)removeEmployee:(EOCPerson *)person; 这时，在相反的情况下处于同样的原因，EOCPerson类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用#import而不是#include可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。 有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。 例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画： 12345678910// EOCRectangle.h#import &quot;EOCShape.h&quot;#import &quot;EOCDrawable.h&quot;@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;@property (nonatomic, assign) float width;@property (nonatomic, assign) float height;@end 这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果EOCDrawable协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。 即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即.m中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。 每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。 小结 总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。 有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。 多使用Literal Syntax少使用与之等价的方法 译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。 当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用Foundation去书写Objective-C代码，你通常在练习中使用它们。这些类是NSString、NSNumber、NSArray、NSDictionary。它们的数据结构即是它们自身所代表的意思。 众所周知Objective-C拥有冗长的语法。这是真的。然而，自从Objective-C 1.0开始，有一个非常简单的办法去创建一个NSString对象。它被称为String Literal并且看起来像这样： 1NSString *someString = @&quot;Effective Objective-C 2.0&quot;; 这种类型的语法是不存在的，通常创建一个NSString对象是需要调用alloc方法后，调用init方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括NSNumber、NSArray、NSDictionary的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。 Literal Numbers有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用NSNumber实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的： 1NSNumber *someNumber = [NSNumber numberWithInt:1]; 它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单： 1NSNumber *someNumber = @1; 如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有NSNumber实例可以代表的数据类型。例如： 12345NSNumber *intNumber = @1;NSNumber *floatNumber = @2.5f;NSNumber *doubleNumber = @3.14159;NSNumber *boolNumber = @YES;NSNumber *charNumber = @&apos;a&apos;; 这种Literal Syntax也适用于表达式： 123int x = 5;float y = 6.32f;NSNumber *expressionNumber = @(x * y); 使用Literal Syntax对于数值来说是非常有用的。这样做可以使NSNumber对象更简洁明了，因为声明的大部分是值而不是多余的语法。 Literal Arrays数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的： 1NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil]; 使用Literal Syntax之后，仅需要使用下面的语法： 1NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;]; 这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用objectAtIndex: method:: 1NSString *dog = [animals objectAtIndex:1]; 而使用Literal Syntax，只需要像下面的做法一样： 1NSString *dog = animals[1]; 这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。 然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的语法糖。这个异常看起来是这样的： 1234*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[0]&apos; 这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下： 123456id object1 = /*...*/;id object2 = /*...*/;id object3 = /*...*/; NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];NSArray *arrayB = @[object1, object2, object3]; 现在考虑这样一个场景，当object1和object3指向一个有效的Objective-C对象，但是object2是空的。这literal array，arrayB，将会抛出一个异常。然而，arrayA 仍将会被创建但只包含object1对象。原因是arrayWithObjects:方法添加参数，遇到nil终止，这比预想的结束的早。 这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。 Literal Dictionaries字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是Objective-C代码中常用的。创建一个使用是这样的： 12345NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Matt&quot;, @&quot;firstName&quot;, @&quot;Galloway&quot;, @&quot;lastName&quot;, [NSNumber numberWithInt:28], @&quot;age&quot;, nil]; 这令人相当困惑，因为这顺序是object, key, object, key, …。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚： 1234NSDictionary *personData = @&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, @&quot;lastName&quot; : @&quot;Galloway&quot;, @&quot;age&quot; : @28&#125;; 这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是Objective-C对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个NSNumber实例中。但是Literal Syntax意味着它只是一个额外的字符。 就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于dictionaryWithObjectsAndKeys:方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。 另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样： 1NSString *lastName = [personData objectForKey:@&quot;lastName&quot;]; 与之等价的Literal Syntax是这样的： 1NSString *lastName = personData[@&quot;lastName&quot;]; 再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。 Mutable Arrays and Dictionaries以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的： 12[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;]; 通过Literal Syntax设置时这样的： 12mutableArray[1] = @&quot;dog&quot;;mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;; Limitations使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于NSArray、NSNumber、NSDictionary是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用NSString类。 同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，mutableCopy必须被调用，像这样： 1NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy]; 它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。 小结 使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。 通过下标法访问数组或者字典。 使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。 优先使用类型常量，减少使用#define预处理在写代码时，你经常想去定义一个常量。例如，一个UIView类出现和消失时它自身的动画。你可能想定义一个常量来代表动画持续的时间。你已经学会了Objective-C和C的基础，所以你决定使用的方法是这样的： 1#define ANIMATION_DURATION 0.3 这是一个预处理指定；每当在你的代码中出现ANIMATION_DURATION字符，就用0.3替代。这看起来就是你想要的，但是这种定义没有类型信息。它就像是声明了一个叫做“duration”的事物意指它的value与时间有关系，但它并不是明确的。并且，它会将所有ANIMATION_DURATION替换掉，如果它声明在头文件中，别的任何导入了这个头文件的类都将被替代。 为了解决这个问题，你应该使用编译器。有一个比使用预处理更好的办法，去定义一个常量。例如，下面这种定义常量类型为NSTimeInterval： 1static const NSTimeInterval kAnimationDuration = 0.3; 注意这种格式，它是有类型信息的，这种用法是好的，因为我们可以清楚地知道常量的定义。它的类型是NSTimeInterval，并且它有助于指出变量的使用。如果你定义了许多常量，它将会帮助以后阅读代码的人。 也会指出这个变量如何命名的。通常的惯例是在常量前面加上小写字母k（加k的原因据说是constant的首字母读音，或者德语一般写作konstant）并将其放置在实现文件中。对于需要暴露给其它类的常量，通常使用其类名作为前缀。第19节展示了更多的命名标准。 在哪里定义常量是重要的。有时，使用预处理定义常量是诱人的，但这是一个坏的习惯，特别是命名方式没有遵循标准的时候，它们不会冲突。例如：ANIMATION_DURATION常量定义在头文件是一个坏的命名。它将显示在所有导入了这个头文件的文件中。甚至作为标准的static const也不该出现在头文件中。自从Objective-C不使用命名空间（namespaces），上面的代码将会声明一个叫做kAnimationDuration的全局变量。它的名字前缀应该使用其所作用的类的名字，例如EOCViewClassAnimationDuration。第19节展示了更多的关于使用清晰命名的方案。 一个不需要暴露给外界的常量，应该在需要使用它的实现文件中定义。例如，如果那个动画持续时间的常量被用在一个UIView的子类，子类在一个iOS应用中，它看起来是这样的： 123456789101112131415161718192021//EOCAnimatedView.h#import &lt;UIKit/UIKit.h&gt;@interface EOCAnimatedView : UIView- (void)animate;@end//EOCAnimatedView.m#import &quot;EOCAnimatedView.h&quot;static const NSTimeInterval kAnimationDuration = 0.3;@implementation EOCAnimatedView- (void)animate &#123; [UIView animateWithDuration:kAnimationDuration animations:^()&#123; // Perform animations &#125;];&#125;@end 使用static const声明常量是重要的。使用const修饰符代表如果你试图在之后修改值，编译器将会报错。在这种情况下，这种做法是必需的。这个值不应该被改变。static修饰符的意思是其作用范围在定义它的编译单元内。编译器将其接收到的内容编译成一个目标文件，这个目标文件就是编译单元。在Objective-C中，每一个编译单元就是每一个实现文件。所以在前面的例子中，kAnimationDuration将被声明在EOCAnimatedView.m生成的目标文件中。如果变量没有使用static修饰，编译器将会创建一个外部符号给它。如果另一个编译单元也声明了一个相同名字的变量，将会抛出一个类似的错误： 123duplicate symbol _ kAnimationDuration in: EOCAnimatedView.o EOCOtherView.o 实际上，当使用static和const声明一个变量时，编译器最终不会创建一个符号，而是使用存在的值去替代变量，就像宏定义一样。谨记，无论如何，显示类型信息的做法是更好的。 有时，你会想给外部暴漏一个常量。例如，如果你的类使用NSNotificationCenter通知别的类，你可能想这样做。这个功能是一个对象发送通知，另一个对象注册并接收它。通知有一个字符串做名字，并且你可能将其声明为一个外部可见的常量。这样做的意思是可以让任何一个想去注册接收通知的类不需要知道实际的字符名字，而仅使用这个常量。 这种常量需要出现在全局的符号表中，从而可以在声明它之外的编译单元使用。因此，这些常量需要声明在不同与static const示例的地方。这个变量应该像这样被声明： 12345// In the header fileextern NSString *const EOCStringConstant;// In the implementation fileNSString *const EOCStringConstant = @&quot;VALUE&quot;; 这个常量声明在头文件，定义在实现文件。在常量类型中，const修饰符是非常重要的。这些声明是从后向前读的，意思是在这种情况下，EOCStringConstant是一个常量指向一个字符串。这正是我们想要的；常量不允许修改所指向的字符串对象。 当编译器在文件中发现一个extern修饰的常量被使用时，extern关键字会告诉编译器，在导入的类中去寻找。这个关键字告诉编译器在全局符号表中有一个EOCStringConstant的符号。这意味着编译器可以不知道常量的定义而去使用它。编译器简单的知道当文件链接为二进制文件时常量是存在的。 常量必须被定义并且仅定义一次。它通常定义在实现文件，声明在它的头文件。编译器将会为从实现文件生成的目标文件的数据段中的字符串分配存储空间。无论它在哪里被使用，当这个目标文件跟其他文件链接生成最后的二进制时，链接器都将能找到它的全局符号。 实际上，符号出现在全局符号表的意思是你应该小心常量的命名。例如，一个处理登录的类会在登录后对整个应用发送一个通知。这个通知看起来是这样的： 1234567891011121314151617181920212223242526272829// EOCLoginManager.h#import &lt;Foundation/Foundation.h&gt;extern NSString *const EOCLoginManagerDidLoginNotification;@interface EOCLoginManager : NSObject- (void)login;@end// EOCLoginManager.m#import &quot;EOCLoginManager.h&quot;NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;;@implementation EOCLoginManager- (void)login &#123; // Perfoem login asynchronously, then call &apos;p_didLogin&apos;.&#125;- (void)p_didLogin &#123; [[NSNotificationCenter defaultCenter] postNotificationName:EOCLoginManagerDidLoginNotification object:nil];&#125;@end 注意常量的名字。常量前缀使用类的名字是谨慎的并且可以帮助你去避免冲突。这在整个系统框架中都是常见的。UIKit，例如，将通知名称以相同的办法声明为全局常量。这些名字包括UIApplicationDidEnterBackgroundNotification和UIApplicationWillEnterForegroundNotification. 其它类型的常量同样可以这样做。如果动画持续时间需要暴露在EOCAnimatiedView类之外，在上面的例子中，你可以这样声明： 12345//EOCAnimatedView.hextern const NSTimeInterval kAnimationDuration;//EOCAnimatedView.mconst NSTimeInterval kAnimationDuration = 0.3; 用这种方法定义一个常量是优于使用宏定义的，因为编译器可以确定这个值不能被改变。在EOCAnimatedView.m定义一次，它的值可以在任何地方使用。一个宏定义可以重复定义，意味着一个程序的不同部分可能使用了不同的值。 综上所述，对于常量避免使用宏定义。相反，使用编译器可以观察的常量，如在实现文件中使用static、const声明常量。 小结 避免宏定义。它们不包含任何类型信息并且可以在编译前被简单的查找替换。它们可以重新定义并且没有警告，使得整个应用的值不一致。 使用static、const在实现文件中定义特定编译单元的常量。这些常量将不会被暴露在全局字符表中，所以它们的名字不需要命名空间。 使用extern在头文件声明它们，在关联的实现文件定义它们。这些常量将出现在全局字符表，所以它们的名字应该需要命名空间，通常使用类名作为前缀是合理的。 使用枚举表示状态、选项、状态码因为Objective-C是基于C的，C的所有功能Objective-C都是适用的。其中一个就是枚举类型，enum。它在系统框架中被广泛使用，但是常常被开发者忽略。它用于定义命名常量是非常有用的，例如，错误状态码和定义选项是可以组合的。感谢C++11标准支持了它，最近的系统版本包含枚举类型。是的，Objective-C也得益于C++11的标准。 枚举仅仅是命名常量的一种方法。一个简单的枚举集合可以用来表示一个对象的状态。例如，一个socket链接使用枚举表示如下： 12345enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;; 使用一个枚举意味着代码是可读的，因为每一个状态可以通过一个易读的值去代表。在枚举中编译器给每个成员一个唯一的值，从0开始每个成员加1。这种枚举是依靠编译器支持的但需要足够的位数去表示枚举。在前面的枚举中，仅需要1个字节就够了，因为它的最大值是2。 然而定义枚举变量的方式却不太简洁，需要使用下面的语法： 1enum EOCConnectionState state = EOCConnectionStateDisconnected; 如果每次不用使用enum只使用EOCConnectionState就好了。为了这样做，你添加一个typedef给枚举定义： 123456enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef enum EOCConnectionState EOCConnectionState; 它的意思是使用EOCConnectionState代替enum EOCConnectionState。 1EOCConnectionState state = EOCConnectionStateDisconnected; C++11标准的问世给枚举带来了一些变化。其中一个变化是可以决定使用哪种“数据类型”去存储枚举类型。这样做的好处是可以使用向前声明了。如果不指定数据类型，枚举类型无法使用向前声明，因为编译器无法知道数据类型的大小。因此，当用到枚举类型时，编译器无法知道应该给变量分配多大的空间。 给枚举指定数据类型，你可以使用下面这种语法： 1enum EOCConnectionStateConnectionState : NSInteger &#123; /*...*/&#125;; 上面代码的意思是保证枚举的变量类型是NSInteger。如果你乐意，这种类型的向前声明可以写成这样： 1enum EOCConnectionStateConnectionState : NSInteger; 你可以给枚举成员定义一个确切的值，而不是让编译器帮你指定。这语法看起来是这样的： 12345enum EOCConnectionStateConnectionState &#123; EOCConnectionStateDisconnected = 1, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;; 这意思是EOCConnectionStateDisconnected的值为1而不是0.别的成员变量的值同之前一样，依次递增1。例如，EOCConnectionStateConnected的值就是3。 另一种使用枚举类型的情况是去定义选项，特指当选项可以组合在一起时。只要当各选项定义的对，那么就可以使用“按位或运算符”去组合它们。例如，考虑下面的枚举类型，在iOS的UI框架中，用来表示某个视图如何调整大小： 123456789enum UIViewAutoresizing &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,&#125;; 每一个选项都可以开启或者关闭，使用上面的语法可以控制它因为每个选项都仅有单一的一位值去代表它自身。使用“按位或操作”可以组合多个选项。例如：UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight。图1.2展示了每个枚举成员和组合两个成员后的位布局。 通过“按位与操作”是可以判断出某个选项是否启用： 123456enum UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123; // UIViewAutoresizingFlexibleWidth is set &#125; 图1.2每个选项值的二进制表示形式，以及两个选项值运用“按位或运算”之后的二进制形式。 枚举在系统框架中使用非常广泛。另一个例子是iOS中的UIKit框架中的，用枚举值列举视图所支持的方向并告诉系统。它使用一个叫做UIInterfaceOrientationMask的枚举类型来实现，并且你可以实现一个叫做supportedInterfaceOrientations的方法去告诉系统视图所支持的方向： 1234- (NSUInteger)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft; &#125; 在Foundation框架中有一些辅助宏定义，用这些宏定义可以指定枚举值的数据类型。它们提供了向后兼容性，当编译器支持新的语法特性时，它们使用新的语法；当编译器只支持旧语法特性时，它们使用旧的语法特性。这些宏是由#define预处理指令定义的。一个支持像EOCConnectionState这种普通类型的枚举，另一个支持像UIViewAutoresizing这种一系列选项的枚举。你可以像下面这样使用它们： 1234567891011typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 这些宏的定义如下： 123456789101112131415161718#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L&amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum)) ) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum)) #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #if (__cplusplus) #define NS_OPTIONS(_type, _name) type _name; enum : _type #else #define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type #endif #else #define NS_ENUM(_type, _name) _type _name; enum #define NS_OPTIONS(_type, _name) _type _name; enum #endif 由于要处理不同的情况所以要用多种方式去定义两个宏。第一个判断是检查编译器是否支持新式枚举的特性。这个布尔逻辑看起来相当复杂，但它的意思就是判断编译器是否支持新特性。如果不支持，那么就用老的方式。 如果新特性是可用的，那么NS_ENUM宏所定义的类型展开后是这样的： 123456typedef enum EOCConnectionState : NSUInteger EOCConnectionState; enum EOCConnectionState : NSUInteger &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected, &#125;; NS_OPTIONS宏的展开是取决于编译形式的。如果以C++形式编译，那么NS_OPTIONS宏展开与NS_ENUM宏展开是不一样的，否则是一样的。为什么？因为C++环境下两个枚举值通过按位或运算结果与非C++环境下是不同的。前面已经提到了，作为选项的枚举值经常会通过按位或运算进行组合。当两个值通过按位或运算后，C++认为它们所代表的值类型是NSUInteger。并且也不允许饮食转换为枚举类型。为了说明这个，我们考虑将EOCPermittedDirection以NS_ENUM形式展开： 1234567typedef enum EOCPermittedDirection : int EOCPermittedDirection; enum EOCPermittedDirection : int &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 考虑下面的代码： 12EOCPermittedDirection permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp; 当在C++或者Objective-C++环境下，将会出现下面的错误： 12error: cannot initialize a variable of type &apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos; 你必须将通过按位或操作的结果显示的转化为EOCPermittedDirection。所以，在C++的环境下应该使用NS_OPTIONS，省去显示转化这一步。因此，如果需要按位或操作的枚举值应当尽量使用NS_OPTIONS，而不需要的，则使用NS_ENUM。 枚举可以用在很多情况下。选项和状态已经在前面讲过了；然后更多的情况同样适用。对错误使用状态码是一个好的习惯。把逻辑含义相似的代码放入一个枚举中，用于替代使用预定义和常量。另一个好的地方是样式。例如，你有一个UI元素可以创建不同的样式，一个枚举集合可以完美的表示每个样式。 最后一点是关于在switch中使用枚举变量。又是，你会这样定义它们： 1234567891011121314151617typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected, &#125;; switch (_currentState) &#123; EOCConnectionStateDisconnected: // Handle disconnected state break; EOCConnectionStateConnecting: // Handle connecting state break; EOCConnectionStateConnected: // Handle connected state break; &#125; 我们习惯在switch语句中加上默认分支。然而，当使用枚举值表示状态时，最好不要写一个默认分支。这样做的原因是，当你在稍后添加了一个新的状态，那么编译器将会警告你，提示你有新的状态未加入switch分支。如果有一个默认的分支，编译器将会处理它，那么编译器将不会发出警告。这个问题同样适用于别的使用NS_ENUM的定义中。例如，你定义一个UI元素，你将会希望每个情况都有一个确定的样式。 小结 使用枚举来表示状态机的状态，传递给函数的选项，或者错误码，并且起一个易读的名字。 如果把一个传递给方法的选项表示为枚举类型，同时还需要多重操作，可以将它们的值设为2的幂，然后通过按位或操作将其组合起来。 使用NS_ENUM和NS_OPTIONS宏最好给枚举定义一个明确的数据类型。这样做的意思是确定枚举的数据类型是开发者设置的，而不是编译器指定的。 在switch中使用枚举时，不要设置默认分支。这样在你添加新枚举后，编译器会提醒你添加新分支。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本内容图解]]></title>
      <url>%2F2017%2F04%2F17%2FBasePrinciple_Img%2F</url>
      <content type="text"><![CDATA[Some principle！！！ 最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解: 就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后… 突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下 对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码解析]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_3%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0 入口学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。 WeexDemo的入口是[WXSDKEngine initSDKEnvironment];。这个Method的主要代码，如下： 123NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];[WXSDKEngine initSDKEnvironment:script]; 首先，读取一个叫做main.js的文件内容，然后将其内容作为[WXSDKEngine initSDKEnvironment:script]初始化的参数。我们继续来看这个method的代码，如下： 123456if (!script || script.length &lt;= 0) &#123; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;); return;&#125;[self registerDefaults];[[WXSDKManager bridgeMgr] executeJsFramework:script]; 注册和执行Register首先，是对传递进来的js代码做判断，其次调用了一个registerDefaults的method，代码如下： 123456static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers];&#125;); Register Componet这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下： 1234567891011121314151617181920212223242526+ (void)registerComponent:(NSString *)name withClass:(Class)clazz&#123; [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];&#125;+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties&#123; if (!name || !clazz) &#123; return; &#125; WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;); [WXComponentFactory registerComponent:name withClass:clazz withPros:properties]; NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name]; dict[@&quot;type&quot;] = name; if (properties) &#123; NSMutableDictionary *props = [properties mutableCopy]; if ([dict[@&quot;methods&quot;] count]) &#123; [props addEntriesFromDictionary:dict]; &#125; [[WXSDKManager bridgeMgr] registerComponents:@[props]]; &#125; else &#123; [[WXSDKManager bridgeMgr] registerComponents:@[dict]]; &#125;&#125; 第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。@&quot;append&quot;:@&quot;tree&quot;代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，@&quot;append&quot;:@&quot;node&quot;代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用WXComponentFactory进行注册，在这之前先讲几个相关类的功能，免得迷糊。 WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承 WXComponentConfig: 继承WXInvocationConfig类，存储每个Component的method、name、classname WXComponentFactory：单例类，通过字典存储WXComponentConfig对象，通过每个WXComponentConfig对象操作每个Component的method、name、classname。 首先通过WXComponentFactory调用- (void)registerComponent:(NSString *)name withClass:(Class)clazz withPros:(NSDictionary *)pros方法注册。使用Assert判断，然后创建一个WXComponentConfig对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用[config registerMethods];将类中的method通过runtime存储在WXComponentConfig中，存取时加锁保证安全。其次调用- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法registerComponents，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。 1234567891011121314export function registerComponents (newComponents) &#123; if (Array.isArray(newComponents)) &#123; newComponents.forEach(component =&gt; &#123; if (!component) &#123; return &#125; if (typeof component === &apos;string&apos;) &#123; components[component] = true &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123; components[component.type] = component &#125; &#125;) &#125;&#125; Register Module注册Module，代码如下： 1234WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;); NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];[[WXSDKManager bridgeMgr] registerModules:dict]; 先介绍几个类： WXModuleConfig：继承WXInvocationConfig类，存储每个Component的method、name WXModuleFactory：单例类，通过字典操作WXModuleConfig对象 查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法registerModules。 Register Handler注册Handler，代码如下： 123WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;); [WXHandlerFactory registerHandler:handler withProtocol:protocol]; 照例介绍几个类： WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储 注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。 ExecuteJs最后调用[[WXSDKManager bridgeMgr] executeJsFramework:script];执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。 首先介绍几个类： WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能 WXSDKManager：单例类，通过一个字典存储所有WXSDKInstance实例，key是一个唯一值；一个WXBridgeManager实例 WXBridgeManager：单例类，注册，渲染功能都通过调用WXBridgeContext对象去跟JS交互 WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。 WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使WXBridgeContext调用 现在可以从那句代码开始讲了，[WXSDKManager bridgeMgr]这个对象是一个单例，他在JS线程调用executeJsFramework，代码如下： 12345if (!script) return;__weak typeof(self) weakSelf = self;WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx executeJsFramework:script];&#125;); 先是判空，其次weakSelf防止循环引用，然后在一个叫做&quot;com.taobao.weex.bridge&quot;的线程调用executeJsFramework方法，代码如下： 123456789101112131415161718192021222324252627282930313233WXAssertBridgeThread();WXAssertParam(script); WX_MONITOR_PERF_START(WXPTFrameworkExecute); [self.jsBridge executeJSFramework:script]; WX_MONITOR_PERF_END(WXPTFrameworkExecute); if ([self.jsBridge exception]) &#123; NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]]; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);&#125; else &#123; WX_MONITOR_SUCCESS(WXMTJSFramework); //the JSFramework has been load successfully. self.frameworkLoadFinished = YES; [self executeAllJsService]; JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil]; if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123; [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]]; &#125; //execute methods which has been stored in methodQueue temporarily. for (NSDictionary *method in _methodQueue) &#123; [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]]; &#125; [_methodQueue removeAllObjects]; WX_MONITOR_PERF_END(WXPTInitalize);&#125;; 首先断言当前线程是否是&quot;com.taobao.weex.bridge&quot;线程，其次断言js代码，使用WXBridgeProtocol协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。 JavaScriptCoreJavaScriptCore简介上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。 JSVirtualMachine：为JavaScript提供运行资源 JSContext：为JavaScript提供运行环境 JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量 JavaScriptCore示例这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了： 简单使用12345JSContext *context = [[JSContext alloc] init];JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];NSLog(@&quot;%@&quot;, value); 输出5context[@&quot;sum&quot;] = @&quot;40&quot;;NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40 首先初始化一个JSContext对象，可以使用JSVirtualMachine对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个JSVirtualMachine对象，所以这个js运行的资源，不可或缺。 第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。 第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。 异常处理1234_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123; context.exception = exception; NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];&#125;; 另一个要注意的点就是这里，JavaScriptCore会在exceptionHandler中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用[JSContext currentContext]获取当前的context。如果直接引用外部的context会造成循环饮用。 invokeMethod1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;]; JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];NSLog(@&quot;%@&quot;, sum); 输出7 初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。 总结上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码文件夹的解释]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_2%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0 Weex文件夹*最不重要的文件夹：Controller、Debug、Handler *不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket *稍微重要的文件夹：Component、Module、Protocol *重要的文件夹：Display、Events、Layout、View *最重要的文件夹：Bridge、Engine、Manager、Model Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油； Debug：一个调试类，酱油； Handler：两个类实现了两个Weex的Protocol，酱油； Loader：一个类是Network的回调实现，一个类是WebSocket的回调。 Monitor：一个监测的类，输出一些信息。 Network:一个小型的网络请求库 Utility：一些常用方法的封装 WebSocket：对SRWebSocket的封装 Componet：对各种view的封装，如果需要扩展view就跟这个有关 Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。 Display：WXComponent的展示 Events：WXComponent的事件 Layout：WXComponent的布局 View：WXComponent的View Bridge：Weex与NativeJS之间的桥接 Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等 Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。 Manager：Weex中各种管理的类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Book]]></title>
      <url>%2F2017%2F02%2F26%2FReadBook_iOS%2F</url>
      <content type="text"><![CDATA[iOS相关书籍… 《iOS7应用开发技术详解》在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如14.2手势事件、11.3.5的UIViewAutoresizing等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看16、17章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。 《iOS开发进阶》这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。 《Objective-C高级编程》这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西引用计数，Block，GCD。引用计数这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；Block这块主要看的是clang rewrite 之后的代码；GCD是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex的简单使用]]></title>
      <url>%2F2017%2F02%2F01%2FWeex_1%2F</url>
      <content type="text"><![CDATA[本篇主要讲解一下Weex的大概原理以及简单的使用 Weex 与RN相同原理，某些方面优于RN js语法，比Native体验稍差，比hybrid app体验好太多 js一端代码，三端使用 iOS/Android脱离写UI的噩梦 文档不够完善 Weex原理 Weex使用 首先，在AppDelegate中调用[WXSDKEngine initSDKEnvironment]进行注册 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXSDKEngine initSDKEnvironment]; return YES;&#125; 其次，在需要使用的ViewController中定义一个WXSDKInstance实例和UI个UIView实例 12@property (nonatomic) WXSDKInstance *instance;@property (nonatomic) UIView *weexView; 紧接着，初始化WXSDKInstance实例，设置它的viewController、frame属性，实现它的生命周期 123456789101112131415161718192021222324252627_instance = [[WXSDKInstance alloc] init];_instance.viewController = self;_instance.frame = [UIScreen mainScreen].bounds; __weak typeof(self) weakSelf = self;_instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView];&#125;; _instance.onFailed = ^(NSError *error) &#123; NSLog(@&quot;failed %@&quot;,error);&#125;; _instance.renderFinish = ^(UIView *view) &#123; NSLog(@&quot;render finish&quot;);&#125;; _instance.onRenderProgress = ^(CGRect renderRect) &#123; NSLog(@&quot;renderProgress&quot;);&#125;; _instance.updateFinish = ^(UIView *view) &#123; NSLog(@&quot;update Finish&quot;);&#125;; 最后，使用WXSDKInstance实例调用renderWithURL:方法即可。记得在dealloc中释放WXSDKInstance实例哦😯 [self.instance renderWithURL:[NSURL URLWithString:renderURL]]; Weex的自定义 Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承WXComponent，滑动组件继承WXScrollerComponent handler: Native提供一个协议。weex官方定义了常用的部分，如WXImgLoaderProtocol图片下载。如果需要自定义，注意需遵守协议WXModuleProtocol module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议WXModuleProtocol，需要自定义Method，如果需要返回值使用WXModuleCallback返回 总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下： 123[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)]; 基本的Weex知识就是这些，具体使用方法请参照官方文档和demo链接。下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。]]></content>
    </entry>

    
  
  
</search>
