<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS-Weex源码解析]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_3%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0 入口学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。 WeexDemo的入口是[WXSDKEngine initSDKEnvironment];。这个Method的主要代码，如下： 123NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];[WXSDKEngine initSDKEnvironment:script]; 首先，读取一个叫做main.js的文件内容，然后将其内容作为[WXSDKEngine initSDKEnvironment:script]初始化的参数。我们继续来看这个method的代码，如下： 123456if (!script || script.length &lt;= 0) &#123; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;); return;&#125;[self registerDefaults];[[WXSDKManager bridgeMgr] executeJsFramework:script]; 注册和执行Register首先，是对传递进来的js代码做判断，其次调用了一个registerDefaults的method，代码如下： 123456static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers];&#125;); Register Componet这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下： 1234567891011121314151617181920212223242526+ (void)registerComponent:(NSString *)name withClass:(Class)clazz&#123; [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];&#125;+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties&#123; if (!name || !clazz) &#123; return; &#125; WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;); [WXComponentFactory registerComponent:name withClass:clazz withPros:properties]; NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name]; dict[@&quot;type&quot;] = name; if (properties) &#123; NSMutableDictionary *props = [properties mutableCopy]; if ([dict[@&quot;methods&quot;] count]) &#123; [props addEntriesFromDictionary:dict]; &#125; [[WXSDKManager bridgeMgr] registerComponents:@[props]]; &#125; else &#123; [[WXSDKManager bridgeMgr] registerComponents:@[dict]]; &#125;&#125; 第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。@&quot;append&quot;:@&quot;tree&quot;代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，@&quot;append&quot;:@&quot;node&quot;代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用WXComponentFactory进行注册，在这之前先讲几个相关类的功能，免得迷糊。 WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承 WXComponentConfig: 继承WXInvocationConfig类，存储每个Component的method、name、classname WXComponentFactory：单例类，通过字典存储WXComponentConfig对象，通过每个WXComponentConfig对象操作每个Component的method、name、classname。 首先通过WXComponentFactory调用- (void)registerComponent:(NSString *)name withClass:(Class)clazz withPros:(NSDictionary *)pros方法注册。使用Assert判断，然后创建一个WXComponentConfig对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用[config registerMethods];将类中的method通过runtime存储在WXComponentConfig中，存取时加锁保证安全。其次调用- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法registerComponents，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。 1234567891011121314export function registerComponents (newComponents) &#123; if (Array.isArray(newComponents)) &#123; newComponents.forEach(component =&gt; &#123; if (!component) &#123; return &#125; if (typeof component === &apos;string&apos;) &#123; components[component] = true &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123; components[component.type] = component &#125; &#125;) &#125;&#125; Register Module注册Module，代码如下： 1234WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;); NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];[[WXSDKManager bridgeMgr] registerModules:dict]; 先介绍几个类： WXModuleConfig：继承WXInvocationConfig类，存储每个Component的method、name WXModuleFactory：单例类，通过字典操作WXModuleConfig对象 查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法registerModules。 Register Handler注册Handler，代码如下： 123WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;); [WXHandlerFactory registerHandler:handler withProtocol:protocol]; 照例介绍几个类： WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储 注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。 ExecuteJs最后调用[[WXSDKManager bridgeMgr] executeJsFramework:script];执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。 首先介绍几个类： WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能 WXSDKManager：单例类，通过一个字典存储所有WXSDKInstance实例，key是一个唯一值；一个WXBridgeManager实例 WXBridgeManager：单例类，注册，渲染功能都通过调用WXBridgeContext对象去跟JS交互 WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。 WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使WXBridgeContext调用 现在可以从那句代码开始讲了，[WXSDKManager bridgeMgr]这个对象是一个单例，他在JS线程调用executeJsFramework，代码如下： 12345if (!script) return;__weak typeof(self) weakSelf = self;WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx executeJsFramework:script];&#125;); 先是判空，其次weakSelf防止循环引用，然后在一个叫做&quot;com.taobao.weex.bridge&quot;的线程调用executeJsFramework方法，代码如下： 123456789101112131415161718192021222324252627282930313233WXAssertBridgeThread();WXAssertParam(script); WX_MONITOR_PERF_START(WXPTFrameworkExecute); [self.jsBridge executeJSFramework:script]; WX_MONITOR_PERF_END(WXPTFrameworkExecute); if ([self.jsBridge exception]) &#123; NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]]; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);&#125; else &#123; WX_MONITOR_SUCCESS(WXMTJSFramework); //the JSFramework has been load successfully. self.frameworkLoadFinished = YES; [self executeAllJsService]; JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil]; if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123; [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]]; &#125; //execute methods which has been stored in methodQueue temporarily. for (NSDictionary *method in _methodQueue) &#123; [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]]; &#125; [_methodQueue removeAllObjects]; WX_MONITOR_PERF_END(WXPTInitalize);&#125;; 首先断言当前线程是否是&quot;com.taobao.weex.bridge&quot;线程，其次断言js代码，使用WXBridgeProtocol协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。 JavaScriptCoreJavaScriptCore简介上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。 JSVirtualMachine：为JavaScript提供运行资源 JSContext：为JavaScript提供运行环境 JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量 JavaScriptCore示例这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了： 简单使用12345JSContext *context = [[JSContext alloc] init];JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];NSLog(@&quot;%@&quot;, value); 输出5context[@&quot;sum&quot;] = @&quot;40&quot;;NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40 首先初始化一个JSContext对象，可以使用JSVirtualMachine对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个JSVirtualMachine对象，所以这个js运行的资源，不可或缺。 第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。 第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。 异常处理1234_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123; context.exception = exception; NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];&#125;; 另一个要注意的点就是这里，JavaScriptCore会在exceptionHandler中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用[JSContext currentContext]获取当前的context。如果直接引用外部的context会造成循环饮用。 invokeMethod1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;]; JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];NSLog(@&quot;%@&quot;, sum); 输出7 初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。 总结上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码文件夹的解释]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_2%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0 Weex文件夹*最不重要的文件夹：Controller、Debug、Handler *不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket *稍微重要的文件夹：Component、Module、Protocol *重要的文件夹：Display、Events、Layout、View *最重要的文件夹：Bridge、Engine、Manager、Model Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油； Debug：一个调试类，酱油； Handler：两个类实现了两个Weex的Protocol，酱油； Loader：一个类是Network的回调实现，一个类是WebSocket的回调。 Monitor：一个监测的类，输出一些信息。 Network:一个小型的网络请求库 Utility：一些常用方法的封装 WebSocket：对SRWebSocket的封装 Componet：对各种view的封装，如果需要扩展view就跟这个有关 Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。 Display：WXComponent的展示 Events：WXComponent的事件 Layout：WXComponent的布局 View：WXComponent的View Bridge：Weex与NativeJS之间的桥接 Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等 Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。 Manager：Weex中各种管理的类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Book]]></title>
      <url>%2F2017%2F02%2F26%2FReadBook_iOS%2F</url>
      <content type="text"><![CDATA[iOS相关书籍… 《iOS7应用开发技术详解》在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如14.2手势事件、11.3.5的UIViewAutoresizing等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看16、17章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。 《iOS开发进阶》这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。 《Objective-C高级编程》这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西引用计数，Block，GCD。引用计数这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；Block这块主要看的是clang rewrite 之后的代码；GCD是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex的简单使用]]></title>
      <url>%2F2017%2F02%2F01%2FWeex_1%2F</url>
      <content type="text"><![CDATA[本篇主要讲解一下Weex的大概原理以及简单的使用 Weex 与RN相同原理，某些方面优于RN js语法，比Native体验稍差，比hybrid app体验好太多 js一端代码，三端使用 iOS/Android脱离写UI的噩梦 文档不够完善 Weex原理 Weex使用 首先，在AppDelegate中调用[WXSDKEngine initSDKEnvironment]进行注册 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXSDKEngine initSDKEnvironment]; return YES;&#125; 其次，在需要使用的ViewController中定义一个WXSDKInstance实例和UI个UIView实例 12@property (nonatomic) WXSDKInstance *instance;@property (nonatomic) UIView *weexView; 紧接着，初始化WXSDKInstance实例，设置它的viewController、frame属性，实现它的生命周期 123456789101112131415161718192021222324252627_instance = [[WXSDKInstance alloc] init];_instance.viewController = self;_instance.frame = [UIScreen mainScreen].bounds; __weak typeof(self) weakSelf = self;_instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView];&#125;; _instance.onFailed = ^(NSError *error) &#123; NSLog(@&quot;failed %@&quot;,error);&#125;; _instance.renderFinish = ^(UIView *view) &#123; NSLog(@&quot;render finish&quot;);&#125;; _instance.onRenderProgress = ^(CGRect renderRect) &#123; NSLog(@&quot;renderProgress&quot;);&#125;; _instance.updateFinish = ^(UIView *view) &#123; NSLog(@&quot;update Finish&quot;);&#125;; 最后，使用WXSDKInstance实例调用renderWithURL:方法即可。记得在dealloc中释放WXSDKInstance实例哦😯 [self.instance renderWithURL:[NSURL URLWithString:renderURL]]; Weex的自定义 Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承WXComponent，滑动组件继承WXScrollerComponent handler: Native提供一个协议。weex官方定义了常用的部分，如WXImgLoaderProtocol图片下载。如果需要自定义，注意需遵守协议WXModuleProtocol module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议WXModuleProtocol，需要自定义Method，如果需要返回值使用WXModuleCallback返回 总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下： 123[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)]; 基本的Weex知识就是这些，具体使用方法请参照官方文档和demo链接。下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。]]></content>
    </entry>

    
  
  
</search>
