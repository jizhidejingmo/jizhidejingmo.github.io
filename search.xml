<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第一章]]></title>
      <url>%2F2017%2F04%2F29%2FAccustoming%20Yourself%20to%20Objective-C%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第一章 第1章:对Objective-C的认识 简介Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。 书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。 了解Objective-C的本源Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的： 1234567// Messaging (Objective-C) Object *obj = [Object new]; [obj performWith:parameter1 and:parameter2]; // Function calling (C++) Object *obj = new Object; obj-&gt;perform(parameter1, parameter2); 两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。 Objective-C在运行时做了更多的工作而不是编译时。runtime包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，runtime包含所有内存管理的方法。本质上，runtime是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当runtime更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。 Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的： 1NSString *someString = @&quot;The string&quot;; 这种语法大多来源于C，声明一个叫做someString的变量，类型是NSString *。它的意思是这是一个NSString类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的： 12 NSString stackString;// error:interface type cannot be statically allocated someString变量指向某个内存地址，在堆上初始化，包含一个NSString对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象： 12NSString *someString = @&quot;The string&quot;;NSString *anotherString = someString; Figure 1.1 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它 这仅有一个NSString实例，但有两个变量指向同它。这两个变量的类型是NSString *，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：NSString实例的内存地址。 图1.1说明了这个结构。NSString实例存储了表示实际字符串所需要的字节。 在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。 Objective-C堆上的内存管理是已经抽象的。你不需要使用malloc和free去初始化和释放对象内存。Objective-C的runtime通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。 有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如CGRect，来源于CoreGraphics框架： 12345CGRect frame;frame.origin.x = 0.0f;frame.origin.y = 10.0f;frame.size.width = 100.0f;frame.siez.height = 150.0f; CGRect是一个C的结构体，定义是这样的： 12345struct CGRect &#123; CGRect origin; CGSize size;&#125;;typedef struct CGRect CGRect; 这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如CGRect。 在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。 小结 Objective-C是C的超集，添加了面向对象的功能。Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。Objective-C是运行时而不是编译时，通过消息决定代码如何运行。 了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。 减少在头文件中使用importObjective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有.h的是头文件，带有.m的是实现文件。当你创建一个类时，它看起来是这样的： 12345678910111213141516// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@end// EOCPerson.m#import &quot;EOCPerson.h&quot;@implementation EOCPerson// Implementation of methods@end 对所有类来说，导入Foundation.h是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建UIViewController的子类。这些类的头文件将会导入UIKit.h。 目前来讲，这个类的写法是没问题的。它导入了整个Foundation框架，但是并不需要在意。EOCPerson类继承自Foundation框架中的某一个类，它将会使用框架的一大部分功能。继承自UIViewController的类也是一样，它将会使用UIKit框架的一大部分功能。 随着时间的推移，你可能创建了一叫做EOCEmployer的新类。然后你决定一个EOCPerson实例持有一个EOCEmployer实例。所以你提前给它加了一个属性： 12345678910// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 一个问题出现了，当你编译时发现EOCEmployer是缺失的。这个时候编译器一定会提示你在EOCPerson.h中导入EOCEmployer.h。通常你是在EOCPerson.h顶部加入导入的方法： 1#import &quot;EOCEmployer.h&quot; 这将使他正常编译，但这是一个坏的习惯。因为编译EOCPerson不需要知道EOCEmployer的详细信息。仅需要知道有一个叫做EOCEmployer的类存在即可。幸运的是，有一个办法可以告诉编译器这样： 1@class EOCEmployer; 这叫做向前声明这个类。这样EOCPerson的头文件看起来是这样的： 123456789101112// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 当你为了在实现文件中使用它时，你需要知道EOCEmployer的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的： 1234567// EOCPerson.m#import &quot;EOCPerson.h&quot;#import &quot;EOCEmployer.h&quot;@implementation EOCPerson// Implementation of methods@end 推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果EOCEmployer.h是在EOCPerson.h中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。 使用前向声明会缓解两个类互相引用的问题。考虑下当EOCEmployer有两个方法去添加和移除EOCPerson的实例会发生什么，在头文件像这样定义： 12- (void)addEmployee:(EOCPerson *)person;- (void)removeEmployee:(EOCPerson *)person; 这时，在相反的情况下处于同样的原因，EOCPerson类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用#import而不是#include可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。 有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。 例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画： 12345678910// EOCRectangle.h#import &quot;EOCShape.h&quot;#import &quot;EOCDrawable.h&quot;@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;@property (nonatomic, assign) float width;@property (nonatomic, assign) float height;@end 这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果EOCDrawable协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。 即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即.m中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。 每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。 小结 总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。 有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本内容图解]]></title>
      <url>%2F2017%2F04%2F17%2FBasePrinciple_Img%2F</url>
      <content type="text"><![CDATA[Some principle！！！ 最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解: 就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后… 突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下 对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码解析]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_3%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0 入口学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。 WeexDemo的入口是[WXSDKEngine initSDKEnvironment];。这个Method的主要代码，如下： 123NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];[WXSDKEngine initSDKEnvironment:script]; 首先，读取一个叫做main.js的文件内容，然后将其内容作为[WXSDKEngine initSDKEnvironment:script]初始化的参数。我们继续来看这个method的代码，如下： 123456if (!script || script.length &lt;= 0) &#123; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;); return;&#125;[self registerDefaults];[[WXSDKManager bridgeMgr] executeJsFramework:script]; 注册和执行Register首先，是对传递进来的js代码做判断，其次调用了一个registerDefaults的method，代码如下： 123456static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers];&#125;); Register Componet这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下： 1234567891011121314151617181920212223242526+ (void)registerComponent:(NSString *)name withClass:(Class)clazz&#123; [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];&#125;+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties&#123; if (!name || !clazz) &#123; return; &#125; WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;); [WXComponentFactory registerComponent:name withClass:clazz withPros:properties]; NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name]; dict[@&quot;type&quot;] = name; if (properties) &#123; NSMutableDictionary *props = [properties mutableCopy]; if ([dict[@&quot;methods&quot;] count]) &#123; [props addEntriesFromDictionary:dict]; &#125; [[WXSDKManager bridgeMgr] registerComponents:@[props]]; &#125; else &#123; [[WXSDKManager bridgeMgr] registerComponents:@[dict]]; &#125;&#125; 第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。@&quot;append&quot;:@&quot;tree&quot;代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，@&quot;append&quot;:@&quot;node&quot;代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用WXComponentFactory进行注册，在这之前先讲几个相关类的功能，免得迷糊。 WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承 WXComponentConfig: 继承WXInvocationConfig类，存储每个Component的method、name、classname WXComponentFactory：单例类，通过字典存储WXComponentConfig对象，通过每个WXComponentConfig对象操作每个Component的method、name、classname。 首先通过WXComponentFactory调用- (void)registerComponent:(NSString *)name withClass:(Class)clazz withPros:(NSDictionary *)pros方法注册。使用Assert判断，然后创建一个WXComponentConfig对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用[config registerMethods];将类中的method通过runtime存储在WXComponentConfig中，存取时加锁保证安全。其次调用- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法registerComponents，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。 1234567891011121314export function registerComponents (newComponents) &#123; if (Array.isArray(newComponents)) &#123; newComponents.forEach(component =&gt; &#123; if (!component) &#123; return &#125; if (typeof component === &apos;string&apos;) &#123; components[component] = true &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123; components[component.type] = component &#125; &#125;) &#125;&#125; Register Module注册Module，代码如下： 1234WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;); NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];[[WXSDKManager bridgeMgr] registerModules:dict]; 先介绍几个类： WXModuleConfig：继承WXInvocationConfig类，存储每个Component的method、name WXModuleFactory：单例类，通过字典操作WXModuleConfig对象 查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法registerModules。 Register Handler注册Handler，代码如下： 123WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;); [WXHandlerFactory registerHandler:handler withProtocol:protocol]; 照例介绍几个类： WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储 注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。 ExecuteJs最后调用[[WXSDKManager bridgeMgr] executeJsFramework:script];执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。 首先介绍几个类： WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能 WXSDKManager：单例类，通过一个字典存储所有WXSDKInstance实例，key是一个唯一值；一个WXBridgeManager实例 WXBridgeManager：单例类，注册，渲染功能都通过调用WXBridgeContext对象去跟JS交互 WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。 WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使WXBridgeContext调用 现在可以从那句代码开始讲了，[WXSDKManager bridgeMgr]这个对象是一个单例，他在JS线程调用executeJsFramework，代码如下： 12345if (!script) return;__weak typeof(self) weakSelf = self;WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx executeJsFramework:script];&#125;); 先是判空，其次weakSelf防止循环引用，然后在一个叫做&quot;com.taobao.weex.bridge&quot;的线程调用executeJsFramework方法，代码如下： 123456789101112131415161718192021222324252627282930313233WXAssertBridgeThread();WXAssertParam(script); WX_MONITOR_PERF_START(WXPTFrameworkExecute); [self.jsBridge executeJSFramework:script]; WX_MONITOR_PERF_END(WXPTFrameworkExecute); if ([self.jsBridge exception]) &#123; NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]]; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);&#125; else &#123; WX_MONITOR_SUCCESS(WXMTJSFramework); //the JSFramework has been load successfully. self.frameworkLoadFinished = YES; [self executeAllJsService]; JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil]; if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123; [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]]; &#125; //execute methods which has been stored in methodQueue temporarily. for (NSDictionary *method in _methodQueue) &#123; [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]]; &#125; [_methodQueue removeAllObjects]; WX_MONITOR_PERF_END(WXPTInitalize);&#125;; 首先断言当前线程是否是&quot;com.taobao.weex.bridge&quot;线程，其次断言js代码，使用WXBridgeProtocol协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。 JavaScriptCoreJavaScriptCore简介上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。 JSVirtualMachine：为JavaScript提供运行资源 JSContext：为JavaScript提供运行环境 JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量 JavaScriptCore示例这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了： 简单使用12345JSContext *context = [[JSContext alloc] init];JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];NSLog(@&quot;%@&quot;, value); 输出5context[@&quot;sum&quot;] = @&quot;40&quot;;NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40 首先初始化一个JSContext对象，可以使用JSVirtualMachine对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个JSVirtualMachine对象，所以这个js运行的资源，不可或缺。 第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。 第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。 异常处理1234_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123; context.exception = exception; NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];&#125;; 另一个要注意的点就是这里，JavaScriptCore会在exceptionHandler中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用[JSContext currentContext]获取当前的context。如果直接引用外部的context会造成循环饮用。 invokeMethod1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;]; JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];NSLog(@&quot;%@&quot;, sum); 输出7 初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。 总结上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码文件夹的解释]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_2%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0 Weex文件夹*最不重要的文件夹：Controller、Debug、Handler *不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket *稍微重要的文件夹：Component、Module、Protocol *重要的文件夹：Display、Events、Layout、View *最重要的文件夹：Bridge、Engine、Manager、Model Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油； Debug：一个调试类，酱油； Handler：两个类实现了两个Weex的Protocol，酱油； Loader：一个类是Network的回调实现，一个类是WebSocket的回调。 Monitor：一个监测的类，输出一些信息。 Network:一个小型的网络请求库 Utility：一些常用方法的封装 WebSocket：对SRWebSocket的封装 Componet：对各种view的封装，如果需要扩展view就跟这个有关 Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。 Display：WXComponent的展示 Events：WXComponent的事件 Layout：WXComponent的布局 View：WXComponent的View Bridge：Weex与NativeJS之间的桥接 Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等 Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。 Manager：Weex中各种管理的类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Book]]></title>
      <url>%2F2017%2F02%2F26%2FReadBook_iOS%2F</url>
      <content type="text"><![CDATA[iOS相关书籍… 《iOS7应用开发技术详解》在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如14.2手势事件、11.3.5的UIViewAutoresizing等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看16、17章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。 《iOS开发进阶》这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。 《Objective-C高级编程》这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西引用计数，Block，GCD。引用计数这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；Block这块主要看的是clang rewrite 之后的代码；GCD是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex的简单使用]]></title>
      <url>%2F2017%2F02%2F01%2FWeex_1%2F</url>
      <content type="text"><![CDATA[本篇主要讲解一下Weex的大概原理以及简单的使用 Weex 与RN相同原理，某些方面优于RN js语法，比Native体验稍差，比hybrid app体验好太多 js一端代码，三端使用 iOS/Android脱离写UI的噩梦 文档不够完善 Weex原理 Weex使用 首先，在AppDelegate中调用[WXSDKEngine initSDKEnvironment]进行注册 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXSDKEngine initSDKEnvironment]; return YES;&#125; 其次，在需要使用的ViewController中定义一个WXSDKInstance实例和UI个UIView实例 12@property (nonatomic) WXSDKInstance *instance;@property (nonatomic) UIView *weexView; 紧接着，初始化WXSDKInstance实例，设置它的viewController、frame属性，实现它的生命周期 123456789101112131415161718192021222324252627_instance = [[WXSDKInstance alloc] init];_instance.viewController = self;_instance.frame = [UIScreen mainScreen].bounds; __weak typeof(self) weakSelf = self;_instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView];&#125;; _instance.onFailed = ^(NSError *error) &#123; NSLog(@&quot;failed %@&quot;,error);&#125;; _instance.renderFinish = ^(UIView *view) &#123; NSLog(@&quot;render finish&quot;);&#125;; _instance.onRenderProgress = ^(CGRect renderRect) &#123; NSLog(@&quot;renderProgress&quot;);&#125;; _instance.updateFinish = ^(UIView *view) &#123; NSLog(@&quot;update Finish&quot;);&#125;; 最后，使用WXSDKInstance实例调用renderWithURL:方法即可。记得在dealloc中释放WXSDKInstance实例哦😯 [self.instance renderWithURL:[NSURL URLWithString:renderURL]]; Weex的自定义 Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承WXComponent，滑动组件继承WXScrollerComponent handler: Native提供一个协议。weex官方定义了常用的部分，如WXImgLoaderProtocol图片下载。如果需要自定义，注意需遵守协议WXModuleProtocol module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议WXModuleProtocol，需要自定义Method，如果需要返回值使用WXModuleCallback返回 总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下： 123[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)]; 基本的Weex知识就是这些，具体使用方法请参照官方文档和demo链接。下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。]]></content>
    </entry>

    
  
  
</search>
