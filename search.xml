<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第二章]]></title>
      <url>%2F2017%2F05%2F14%2FObject%2C%20Messaging%2C%20and%20the%20Runtime%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时 简介在Objective-C等面向对象的语言中，对象就是基石，提供数据存储和传递的功能。消息是在过程中对象之间进行数据传递和执行操作。深入理解这些功能如何工作对于构建高效和可维护代码是至关重要的。 当程序运行后，Objective-C中的runtime为其提供相关支持。runtime提供了关键的函数使对象之间可以传递消息以及创建类实例的所有逻辑。理解这一切如何工作会使你成为一个更好的开发者。 理解属性属性是Objective-C的一个功能，用于对象对数据的封装。Objective-C对象通常会把它们所需要的数据保存为各种实例变量。实例变量的访问通常通过存取方法。getter方法用来读取变量，setter方法用来设置变量。这个概念是标准的，并且通过属性这个功能成为了Objective-C 2.0的一部分，这让开发者令编译器去自动生成读写方法。这个功能引入了一个新语法即点语法，通过点语法访问数据存储可以减少代码的冗长。你可能已经使用了属性，但你可能不知道它所有的功能。而且，还有很多与之相关的问题。第6节主要说明哪些问题可以通过属性解决并且指出主要的功能。 用一个类去表示一个人的信息可能要存储名字，出生日期，地址等等。你可能这样在一个类的公共接口中声明这些变量： 12345678910#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &#123; @public NSString *_firstName; NSString *_lastName;@private NSString *_someInternalData;&#125;@end 如果你从事过Java或者C++开发，这种写法是熟悉的，你可以定义变量的作用域。然而，这种技术在Objective-C中很少使用。这种方法的问题是在编译时就定义了对象的布局。无论任何时候访问_firstName变量，都会通过编译器偏移硬编码去访问存储对象的内存空间。如果你不在_firstName之前添加任何变量这样做都是没问题的。例如：假设在_firstName之前添加一个变量： 译者言：由于对象布局在编译时已定，对象内存偏移量自然固定，此处硬编码代指偏移量。 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &#123; @public NSDate *_dateOfBirth; NSString *_firstName; NSString *_lastName;@private NSString *_someInternalData;&#125;@end 之前的偏移量代表_firstName而现在代表_dateOfBirth了。任何通过硬编码读取的地方都将读取到一个错误的值。为了说明这一点，假设指针是4个字节，图2.1分别展示了添加_dateOfBirth变量之前和之后的类的内存布局。 Figure 2.1 添加变量前类的布局和添加变量后类的布局 当类定义发生变化时，如果代码使用了编译时的偏移量那么将出现问题，除非重新编译。例如，一个代码库中的代码使用了旧的类定义。如果链接的代码使用了新的类定义，那么在运行时将出现不兼容的情况。为了解决这个问题，各种语言都提出了自己的解决办法。Objective-C的做法是，将实例变量看做特殊的变量，由类变量(第14节详细的讲述了类对象)去存储它的偏移量。在运行时，会去查找偏移量，当类定义发生改变，偏移量也随之改变。这样无论如何访问一个变量，都会使用正确的偏移量。你甚至可以在运行期间给类添加实例变量。这就是稳固的ABI(应用程序二进制接口)。ABI定义了许多内容，其中一项是生成代码时的规则。稳固的ABI也意味着你可以在一个分类中或者实现文件中定义实例变量。因此，你不需要在接口文件中声明所有的实例变量，因此你不需要在公共接口中泄露任何你的内部实现信息。 另一种解决这个问题的办法是使用存取方法而不是直接访问实例变量。虽然属性最终仍是由实例变量实现的，但是属性提供了一种简洁的抽象。你可以自己编写存取方法，但是在标准的Objective-C代码格式中，存取方法遵循严格的命名规则。因为严格的命名，Objective-C才能根据变量名自动创建存取方法。这就是@property语法的来源。 在对象接口的定义中使用@property，这是一种标准的写法，以提供对象的存取方法。因此，可以把属性当做一种简称，通过它去访问一个给定类型和给定名字的变量。例如，考虑下面的代码： 1234@interface EOCPerson : NSObject@property NSString *firstName;@property NSString *lastName;@end 对于类的使用者，上面的代码是等价于下面的代码的： 123456@interface EOCPerson : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end 使用属性，你可以使用点语法。在C中你访问栈结构体的成员也是使用类似语法。编译器会将点语法转化为存取方法，与你直接调用是一样的。因此，使用点语法和直接调用时没有任何差异的。下面展示了等价的代码： 1234567EOCPerson *aPerson = [EOCPerson new]; aPerson.firstName = @&quot;Bob&quot;; // Same as;[aPerson setFirstName:@&quot;Bob&quot;]; NSString *lastName = aPerson.lastName; // Same as;NSString *lastName = [aPerson lastName]; 属性的好处还不止这些。如果你使用它，编译器将会通过一个叫做自动合成的功能生成那些方法代码。需要强调的是，编译器会在编译时自动生成代码，所以你在编辑器中是看不到自动合成的方法的。除了自动生成上述代码，编译器也会自动生成一个合适类型的变量，并且会在名字前面加下划线。在前面的代码中，他自动生成了两个变量：_firstName和_lastName。通过在类实现中使用@synthesize语法，这两个实例变量名字是可以控制的，像这样： 1234@implementation EOCPerson@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 使用上面的语法会产生两个实例变量，分别叫做_myFirstName和_myLastName，用于代替默认生成的。不过一般不会去改变默认的变量名；然而如果你不喜欢使用下划线去命名变量，你可以使用这个方法去设置你想要的。但是我建议你使用默认的命名规则，如果每个人都遵循这个规则，那么每个人读代码都是容易理解的。 如果你不想编译器给你自动生成存取方法，你可以自己去实现这些方法。然而，如果你仅实现了存取方法中的一个，那么编译器仍会自动生成另一个方法。另一种阻止它自动生成的办法是使用@dynamic关键字，这会告诉编译器不要自动生成实例变量返回给属性并且不会自动生成存取方法。而且，当编译代码访问这个属性时，编译器将会忽略实际上存取方法还没有定义的情况，并且相信它在运行时是可以使用的。例如，如果一个类继承自NSManagedObject类，它的存取方法需要在运行时动态创建。NSManagedObject类之所以这样做是因为子类的属性不是实例变量。它的数据来源于后台数据库。例如： 12345678@interface EOCPerson : NSManagedObject@property NSString *firstName;@property NSString *lastName;@end@implementation EOCPerson@dynamic firstName, lastName;@end 在这个类中，编译器不会自动生成存取方法或者实例变量。如果你尝试去访问某个属性，编译器也没有警告信息。 属性特质属性的另一个问题是你应该知道它所有的特质。你可以通过它去影响编译器生成的存取方法。例如下面这个属性使用了三个特质： 1@property (nonatomic, readwrite, copy) NSString *firstName; 属性可以使用4类特质。 原子性通常，生成的存取方法包含锁去保持原子性。如果你设置了nonatomic特质，那么就不会有锁了。请注意，尽管没有atomic特质(atomic特质是由你不设置nonatomic特质得来的)，但是你仍何以在属性特质中写上，并且编译器不会报错。如果你自己实现存取方法，你应该指定与其相符的原子性。 读写权限 readwrite 读写权限时，getter和setter方法都是可用的。如果属性是自动合成的，那么编译器将会自动生成两个方法。 readonly 只读权限时，只有getter方法是可用的，如果属性是自动合成的，那么编译器将只生成getter方法。当你想暴漏一个只读属性给外部，并且需要在内部重新定义它为可读写时，你可以使用它。第27节讲了更多内容。 内存管理语义属性用于封装数据，数据需要有具体的所有权。它仅仅影响setter方法。例如，用setter方法设置一个值时，它是应该保持新值还是将其直接赋给底层实例变量?当编译器自动生成存取方法时，它要取决于这些特质去生成代码。如果你自己实现存取方法，你应该指定与其相符的特质。 assign 它的setter方法只会简单的给标量类型的值赋值，例如CGFloat或者NSInteger。 strong 这种特质表示定义了一个拥有关系。当为这个属性赋值时，首先持有新值，接着释放旧值，然后将新值赋给这个属性。 weak 这种特质表示定义了一个非拥有关系。当为这个属性赋值时，它是不持有新值的；也不释放旧值。它是类似于assign特质的，但当目标对象释放时，它的值会被自动置为nil。 unsafe_unretained 它同assign语义相似，但是它适用于对象类型，它表达了一个非拥有关系，当目标对象销毁时，它不会自动置为nil，这点与weak是有区别的。 copy 这种特质类似strong特质，定义一个拥有关系；然而，它是用拷贝替代持有新值的。当属性是类似与NSString *时，经常用此特质保证其封装性，因为可能通过setter方法给予其一个可变值。如果赋的值是可变的，那么这个属性的类型可能就在对象不知道的情况下改变。所以就需要使用copy特质去使对象中的字符串不会在无意中被改变。任何需要保持不可变的对象都应该使用copy去修饰。 方法名通过使用下面的特质可以控制存取方法的名字： getter= 指定getter的名字。当你想给一个Boolean属性加上is前缀时，通常使用这个方法。例如，在UISwitch类中，表示状态开关的属性就是这样定义的： 1@property(nonatomic,getter=isOn) BOOL on; setter= 指定setter的名字。这个方法不常用的。 你可以通过这些特质细微的控制自动生成的存取方法。然而，需要谨记的是，如果你实现了自己的存取方法，你应该遵循指定的特质。例如，一个属性使用了copy特质，你需要在setter中拷贝它。否则，会误导属性的使用者。而且，如果不遵守这个约定，那么将会产生bug。 即使你可以通过别的方法设置属性，你也要遵循定义时的特质。例如，考虑扩充下EOCPerson类。属性声明时，使用了copy特质，因为它可能是可变的。这个类也增加了一个初始化方法，用于设置名和姓的值： 123456789@interface EOCPerson : NSManagedObject@property (copy) NSString *firstName;@property (copy) NSString *lastName;- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName;@end 在实现自定义初始化方法时，遵循定义时的copy语义是非常重要的。因为属性定义就像类和对象之间的协议一样。所以初始化的代码应该是这样的： 12345678910- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; &#125; return self;&#125; 你可能会问为什么不简单的使用属性的setter方式去设置，如果总是使用setter设置，那将会保证属性的正确设置。你永远不该在init方法中使用存取方法，具体请看第7节。 如果你已经读了第18节，你应该知道，最好使对象不可变。将上述内容应用在EOCPerson类中，你需要设置两个属性为readonly。在初始化中设置它们的值，然后它们将不能被修改。在本例中，对你使用的值使用内存管理语义是重要的。所以属性定义的代码是这样的： 12@property (copy, readonly) NSString *firstName;@property (copy, readonly) NSString *lastName; 因为是只读属性，所以编译器不会为其自动生成setter方法。这样做是重要的，可以表明在初始化时设置了这两个属性值。没有这样的声明，使用这个类的人就可能不知道已经在init方法中使用了copy，因此他们可能会在调用初始化方法之前自行拷贝。这种操作是多余且低效的。 如果你想知道atomic和nonatomic的区别。前面说过，使用了atomic的属性的存取方法会自动加锁确保原子性。这个意思是如果两个线程同时对属性进行读写操作，这个值不论在任何时候始终是有效的。如果不加所得情况下，当一个线程正在进行修改时，另一个线程进行读取，可能会将其未修改完的值读出来。如果发生了这种情况，读到的值可能是无效的。 如果你是在iOS中开发，那么你会注意到所有属性声明为nonatomic。这样做的历史原因是，加锁消耗比较大，可能会产生性能问题。通常，原子性并不是必须的，因为它不能确保线程安全，需要更深层次的锁定机制才能保证其线程安全。例如，即使使用了原子性，一个线程在连续读取某个属性值时，另一个线程修改了这个属性，仍将不能确保读到的是正确的值。因此，在iOS开发中你将一直使用nonatomic去修饰属性。但是在Mac OS X中，你不需要担心atomic带来的性能问题。 小结 @property语法提供了一种对象封装数据的定义。 使用正确的特质提供数据存储。 在设置属性所对应的实例变量时，需要遵循该属性的语义。 在iOS中使用nonatomic，因为它会严重消耗性能。 在对象内部直接访问实例变量属性总是用于访问外部对象的实例变量，但是在Objective-C社区中如何访问内部变量却是争执不休的。有些建议仍使用属性去访问实例变量，有些建议直接访问实例变量，有些两者混用。作者强烈推荐在读取实例变量时直接访问而在设置值时使用属性访问。 考虑下面的代码： 12345678@interface EOCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; // Convenience for firstName + &quot; &quot; + lastName: - (NSString*)fullName; - (void)setFullName:(NSString*)fullName; @end 这两个便捷方法fullName和setFullName可能是这样实现的： 123456789101112131415- (NSString*)fullName &#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName]; &#125; /** The following assumes all full names have exactly 2 * parts. The method could be rewritten to support more * exotic names. */ - (void)setFullName:(NSString*)fullName &#123; NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;]; self.firstName = [components objectAtIndex:0]; self.lastName = [components objectAtIndex:1]; &#125; 在setter和getter中，我们使用点语法访问实例变量。假设现在重写setter和getter方法直接访问变量： 1234567891011- (NSString*)fullName &#123; return [NSStringstringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName]; &#125; - (void)setFullName:(NSString*)fullName &#123; NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;]; _firstName = [components objectAtIndex:0]; _lastName = [components objectAtIndex:1]; &#125; 这两种方式是有些许差异的： 毫无疑问直接访问实例变量是更快的，因为它不需要通过Objective-C方法派发(看第11节)。编译器通过代码直接访问存储对象实例的内存空间。 直接调用实例变量会绕过setter的内存管理语义。例如，你的属性声明了copy特质，直接调用实例变量不会发生copy事件。新的值将会被保存，旧的值将会被释放。 当直接访问实例变量时，KVO不会被触发。这可能会是一个问题，不过这主要取决你对这个对象的行为。 通过属性访问可以更轻易的定位到与这个属性有关的问题，因为你可以给setter、getter方法添加断点去看谁在什么时候访问了这个属性。 一个好的折中的办法是在写时通过setter方法设置，读时直接调用实例变量。这样做可以在读时有更高的效率，在写时也不会失去控制。最重要的是通过setter方法去写将保证你遵循内存管理语义。然而，这样做会有一些小的问题。 第一个问题是当你的值是在初始化方法中设置的时候。这里，你应该一直使用直接调用实例变量的方法，因为子类可能重写了它的setter方法。考虑下EOCPerson有一个叫做EOCSmithPerson的子类，这个类是专门用于表示名字叫smith的。这个子类可能会覆盖lastName的setter方法： 1234567- (void)setLastName:(NSString*)lastName &#123; if (![lastName isEqualToString:@&quot;Smith&quot;]) &#123; [NSException raise:NSInvalidArgumentException format:@&quot;Last name must be Smith&quot;]; &#125; self.lastName = lastname; &#125; EOCPerson基类可能在初始化时将名字设为空字符。如果它通过setter方法去这样设置，那么子类的setter将会被调用并且会抛出一个异常。然而，在有一些情况中，你必须在初始化时使用setter方法。当实例变量是声明在一个父类中的时候；你不能通过直接调用实例变量时，那么你必须使用setter方法。 另一个问题是当属性使用懒加载时。在这种情况下，你必须通过getter访问；如果没有，那个实例变量将永远不会初始化。例如，EOCPerson类可能有一个属性通过一个复杂对象去代表人脑。如果这个属性很少用并且初始化成本较高的，你可能在getter中使用懒加载，像这样： 123456- (EOCBrain*)brain &#123; if (!_brain) &#123; _brain = [Brain new]; &#125; return _brain; &#125; 如果你直接调用实例变量且没有调用过getter方法，大脑这个属性永远不会创建，所以你需要通过属性的存取方法去访问它。 小结 在内部使用数据时，通过直接调用实例变量来读，通过调用属性来写。 在初始化和销毁中，不论读还是写都通过实例变量直接访问。 当你使用了懒加载时，你需要使用属性去读。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第一章]]></title>
      <url>%2F2017%2F04%2F29%2FAccustoming%20Yourself%20to%20Objective-C%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识 简介Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。 书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。 了解Objective-C的本源Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的： 1234567// Messaging (Objective-C) Object *obj = [Object new]; [obj performWith:parameter1 and:parameter2]; // Function calling (C++) Object *obj = new Object; obj-&gt;perform(parameter1, parameter2); 两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。 Objective-C在运行时做了更多的工作而不是编译时。runtime包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，runtime包含所有内存管理的方法。本质上，runtime是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当runtime更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。 Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的： 1NSString *someString = @&quot;The string&quot;; 这种语法大多来源于C，声明一个叫做someString的变量，类型是NSString *。它的意思是这是一个NSString类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的： 12 NSString stackString;// error:interface type cannot be statically allocated someString变量指向某个内存地址，在堆上初始化，包含一个NSString对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象： 12NSString *someString = @&quot;The string&quot;;NSString *anotherString = someString; Figure 1.1 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它 这仅有一个NSString实例，但有两个变量指向同它。这两个变量的类型是NSString *，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：NSString实例的内存地址。 图1.1说明了这个结构。NSString实例存储了表示实际字符串所需要的字节。 在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。 Objective-C堆上的内存管理是已经抽象的。你不需要使用malloc和free去初始化和释放对象内存。Objective-C的runtime通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。 有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如CGRect，来源于CoreGraphics框架： 12345CGRect frame;frame.origin.x = 0.0f;frame.origin.y = 10.0f;frame.size.width = 100.0f;frame.siez.height = 150.0f; CGRect是一个C的结构体，定义是这样的： 12345struct CGRect &#123; CGRect origin; CGSize size;&#125;;typedef struct CGRect CGRect; 这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如CGRect。 在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。 小结 Objective-C是C的超集，添加了面向对象的功能。 Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。 Objective-C是运行时而不是编译时，通过消息决定代码如何运行。 了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。 减少在头文件中使用importObjective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有.h的是头文件，带有.m的是实现文件。当你创建一个类时，它看起来是这样的： 12345678910111213141516// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@end// EOCPerson.m#import &quot;EOCPerson.h&quot;@implementation EOCPerson// Implementation of methods@end 对所有类来说，导入Foundation.h是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建UIViewController的子类。这些类的头文件将会导入UIKit.h。 目前来讲，这个类的写法是没问题的。它导入了整个Foundation框架，但是并不需要在意。EOCPerson类继承自Foundation框架中的某一个类，它将会使用框架的一大部分功能。继承自UIViewController的类也是一样，它将会使用UIKit框架的一大部分功能。 随着时间的推移，你可能创建了一叫做EOCEmployer的新类。然后你决定一个EOCPerson实例持有一个EOCEmployer实例。所以你提前给它加了一个属性： 12345678910// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 一个问题出现了，当你编译时发现EOCEmployer是缺失的。这个时候编译器一定会提示你在EOCPerson.h中导入EOCEmployer.h。通常你是在EOCPerson.h顶部加入导入的方法： 1#import &quot;EOCEmployer.h&quot; 这将使他正常编译，但这是一个坏的习惯。因为编译EOCPerson不需要知道EOCEmployer的详细信息。仅需要知道有一个叫做EOCEmployer的类存在即可。幸运的是，有一个办法可以告诉编译器这样： 1@class EOCEmployer; 这叫做向前声明这个类。这样EOCPerson的头文件看起来是这样的： 123456789101112// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 当你为了在实现文件中使用它时，你需要知道EOCEmployer的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的： 1234567// EOCPerson.m#import &quot;EOCPerson.h&quot;#import &quot;EOCEmployer.h&quot;@implementation EOCPerson// Implementation of methods@end 推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果EOCEmployer.h是在EOCPerson.h中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。 使用前向声明会缓解两个类互相引用的问题。考虑下当EOCEmployer有两个方法去添加和移除EOCPerson的实例会发生什么，在头文件像这样定义： 12- (void)addEmployee:(EOCPerson *)person;- (void)removeEmployee:(EOCPerson *)person; 这时，在相反的情况下处于同样的原因，EOCPerson类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用#import而不是#include可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。 有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。 例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画： 12345678910// EOCRectangle.h#import &quot;EOCShape.h&quot;#import &quot;EOCDrawable.h&quot;@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;@property (nonatomic, assign) float width;@property (nonatomic, assign) float height;@end 这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果EOCDrawable协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。 即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即.m中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。 每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。 小结 总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。 有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。 多使用Literal Syntax少使用与之等价的方法 译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。 当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用Foundation去书写Objective-C代码，你通常在练习中使用它们。这些类是NSString、NSNumber、NSArray、NSDictionary。它们的数据结构即是它们自身所代表的意思。 众所周知Objective-C拥有冗长的语法。这是真的。然而，自从Objective-C 1.0开始，有一个非常简单的办法去创建一个NSString对象。它被称为String Literal并且看起来像这样： 1NSString *someString = @&quot;Effective Objective-C 2.0&quot;; 这种类型的语法是不存在的，通常创建一个NSString对象是需要调用alloc方法后，调用init方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括NSNumber、NSArray、NSDictionary的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。 Literal Numbers有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用NSNumber实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的： 1NSNumber *someNumber = [NSNumber numberWithInt:1]; 它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单： 1NSNumber *someNumber = @1; 如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有NSNumber实例可以代表的数据类型。例如： 12345NSNumber *intNumber = @1;NSNumber *floatNumber = @2.5f;NSNumber *doubleNumber = @3.14159;NSNumber *boolNumber = @YES;NSNumber *charNumber = @&apos;a&apos;; 这种Literal Syntax也适用于表达式： 123int x = 5;float y = 6.32f;NSNumber *expressionNumber = @(x * y); 使用Literal Syntax对于数值来说是非常有用的。这样做可以使NSNumber对象更简洁明了，因为声明的大部分是值而不是多余的语法。 Literal Arrays数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的： 1NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil]; 使用Literal Syntax之后，仅需要使用下面的语法： 1NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;]; 这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用objectAtIndex: method:: 1NSString *dog = [animals objectAtIndex:1]; 而使用Literal Syntax，只需要像下面的做法一样： 1NSString *dog = animals[1]; 这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。 然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的语法糖。这个异常看起来是这样的： 1234*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[0]&apos; 这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下： 123456id object1 = /*...*/;id object2 = /*...*/;id object3 = /*...*/; NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];NSArray *arrayB = @[object1, object2, object3]; 现在考虑这样一个场景，当object1和object3指向一个有效的Objective-C对象，但是object2是空的。这literal array，arrayB，将会抛出一个异常。然而，arrayA 仍将会被创建但只包含object1对象。原因是arrayWithObjects:方法添加参数，遇到nil终止，这比预想的结束的早。 这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。 Literal Dictionaries字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是Objective-C代码中常用的。创建一个使用是这样的： 12345NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Matt&quot;, @&quot;firstName&quot;, @&quot;Galloway&quot;, @&quot;lastName&quot;, [NSNumber numberWithInt:28], @&quot;age&quot;, nil]; 这令人相当困惑，因为这顺序是object, key, object, key, …。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚： 1234NSDictionary *personData = @&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, @&quot;lastName&quot; : @&quot;Galloway&quot;, @&quot;age&quot; : @28&#125;; 这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是Objective-C对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个NSNumber实例中。但是Literal Syntax意味着它只是一个额外的字符。 就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于dictionaryWithObjectsAndKeys:方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。 另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样： 1NSString *lastName = [personData objectForKey:@&quot;lastName&quot;]; 与之等价的Literal Syntax是这样的： 1NSString *lastName = personData[@&quot;lastName&quot;]; 再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。 Mutable Arrays and Dictionaries以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的： 12[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;]; 通过Literal Syntax设置时这样的： 12mutableArray[1] = @&quot;dog&quot;;mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;; Limitations使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于NSArray、NSNumber、NSDictionary是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用NSString类。 同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，mutableCopy必须被调用，像这样： 1NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy]; 它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。 小结 使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。 通过下标法访问数组或者字典。 使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。 优先使用类型常量，减少使用#define预处理在写代码时，你经常想去定义一个常量。例如，一个UIView类出现和消失时它自身的动画。你可能想定义一个常量来代表动画持续的时间。你已经学会了Objective-C和C的基础，所以你决定使用的方法是这样的： 1#define ANIMATION_DURATION 0.3 这是一个预处理指定；每当在你的代码中出现ANIMATION_DURATION字符，就用0.3替代。这看起来就是你想要的，但是这种定义没有类型信息。它就像是声明了一个叫做“duration”的事物意指它的value与时间有关系，但它并不是明确的。并且，它会将所有ANIMATION_DURATION替换掉，如果它声明在头文件中，别的任何导入了这个头文件的类都将被替代。 为了解决这个问题，你应该使用编译器。有一个比使用预处理更好的办法，去定义一个常量。例如，下面这种定义常量类型为NSTimeInterval： 1static const NSTimeInterval kAnimationDuration = 0.3; 注意这种格式，它是有类型信息的，这种用法是好的，因为我们可以清楚地知道常量的定义。它的类型是NSTimeInterval，并且它有助于指出变量的使用。如果你定义了许多常量，它将会帮助以后阅读代码的人。 也会指出这个变量如何命名的。通常的惯例是在常量前面加上小写字母k（加k的原因据说是constant的首字母读音，或者德语一般写作konstant）并将其放置在实现文件中。对于需要暴露给其它类的常量，通常使用其类名作为前缀。第19节展示了更多的命名标准。 在哪里定义常量是重要的。有时，使用预处理定义常量是诱人的，但这是一个坏的习惯，特别是命名方式没有遵循标准的时候，它们不会冲突。例如：ANIMATION_DURATION常量定义在头文件是一个坏的命名。它将显示在所有导入了这个头文件的文件中。甚至作为标准的static const也不该出现在头文件中。自从Objective-C不使用命名空间（namespaces），上面的代码将会声明一个叫做kAnimationDuration的全局变量。它的名字前缀应该使用其所作用的类的名字，例如EOCViewClassAnimationDuration。第19节展示了更多的关于使用清晰命名的方案。 一个不需要暴露给外界的常量，应该在需要使用它的实现文件中定义。例如，如果那个动画持续时间的常量被用在一个UIView的子类，子类在一个iOS应用中，它看起来是这样的： 123456789101112131415161718192021//EOCAnimatedView.h#import &lt;UIKit/UIKit.h&gt;@interface EOCAnimatedView : UIView- (void)animate;@end//EOCAnimatedView.m#import &quot;EOCAnimatedView.h&quot;static const NSTimeInterval kAnimationDuration = 0.3;@implementation EOCAnimatedView- (void)animate &#123; [UIView animateWithDuration:kAnimationDuration animations:^()&#123; // Perform animations &#125;];&#125;@end 使用static const声明常量是重要的。使用const修饰符代表如果你试图在之后修改值，编译器将会报错。在这种情况下，这种做法是必需的。这个值不应该被改变。static修饰符的意思是其作用范围在定义它的编译单元内。编译器将其接收到的内容编译成一个目标文件，这个目标文件就是编译单元。在Objective-C中，每一个编译单元就是每一个实现文件。所以在前面的例子中，kAnimationDuration将被声明在EOCAnimatedView.m生成的目标文件中。如果变量没有使用static修饰，编译器将会创建一个外部符号给它。如果另一个编译单元也声明了一个相同名字的变量，将会抛出一个类似的错误： 123duplicate symbol _ kAnimationDuration in: EOCAnimatedView.o EOCOtherView.o 实际上，当使用static和const声明一个变量时，编译器最终不会创建一个符号，而是使用存在的值去替代变量，就像宏定义一样。谨记，无论如何，显示类型信息的做法是更好的。 有时，你会想给外部暴漏一个常量。例如，如果你的类使用NSNotificationCenter通知别的类，你可能想这样做。这个功能是一个对象发送通知，另一个对象注册并接收它。通知有一个字符串做名字，并且你可能将其声明为一个外部可见的常量。这样做的意思是可以让任何一个想去注册接收通知的类不需要知道实际的字符名字，而仅使用这个常量。 这种常量需要出现在全局的符号表中，从而可以在声明它之外的编译单元使用。因此，这些常量需要声明在不同与static const示例的地方。这个变量应该像这样被声明： 12345// In the header fileextern NSString *const EOCStringConstant;// In the implementation fileNSString *const EOCStringConstant = @&quot;VALUE&quot;; 这个常量声明在头文件，定义在实现文件。在常量类型中，const修饰符是非常重要的。这些声明是从后向前读的，意思是在这种情况下，EOCStringConstant是一个常量指向一个字符串。这正是我们想要的；常量不允许修改所指向的字符串对象。 当编译器在文件中发现一个extern修饰的常量被使用时，extern关键字会告诉编译器，在导入的类中去寻找。这个关键字告诉编译器在全局符号表中有一个EOCStringConstant的符号。这意味着编译器可以不知道常量的定义而去使用它。编译器简单的知道当文件链接为二进制文件时常量是存在的。 常量必须被定义并且仅定义一次。它通常定义在实现文件，声明在它的头文件。编译器将会为从实现文件生成的目标文件的数据段中的字符串分配存储空间。无论它在哪里被使用，当这个目标文件跟其他文件链接生成最后的二进制时，链接器都将能找到它的全局符号。 实际上，符号出现在全局符号表的意思是你应该小心常量的命名。例如，一个处理登录的类会在登录后对整个应用发送一个通知。这个通知看起来是这样的： 1234567891011121314151617181920212223242526272829// EOCLoginManager.h#import &lt;Foundation/Foundation.h&gt;extern NSString *const EOCLoginManagerDidLoginNotification;@interface EOCLoginManager : NSObject- (void)login;@end// EOCLoginManager.m#import &quot;EOCLoginManager.h&quot;NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;;@implementation EOCLoginManager- (void)login &#123; // Perfoem login asynchronously, then call &apos;p_didLogin&apos;.&#125;- (void)p_didLogin &#123; [[NSNotificationCenter defaultCenter] postNotificationName:EOCLoginManagerDidLoginNotification object:nil];&#125;@end 注意常量的名字。常量前缀使用类的名字是谨慎的并且可以帮助你去避免冲突。这在整个系统框架中都是常见的。UIKit，例如，将通知名称以相同的办法声明为全局常量。这些名字包括UIApplicationDidEnterBackgroundNotification和UIApplicationWillEnterForegroundNotification. 其它类型的常量同样可以这样做。如果动画持续时间需要暴露在EOCAnimatiedView类之外，在上面的例子中，你可以这样声明： 12345//EOCAnimatedView.hextern const NSTimeInterval kAnimationDuration;//EOCAnimatedView.mconst NSTimeInterval kAnimationDuration = 0.3; 用这种方法定义一个常量是优于使用宏定义的，因为编译器可以确定这个值不能被改变。在EOCAnimatedView.m定义一次，它的值可以在任何地方使用。一个宏定义可以重复定义，意味着一个程序的不同部分可能使用了不同的值。 综上所述，对于常量避免使用宏定义。相反，使用编译器可以观察的常量，如在实现文件中使用static、const声明常量。 小结 避免宏定义。它们不包含任何类型信息并且可以在编译前被简单的查找替换。它们可以重新定义并且没有警告，使得整个应用的值不一致。 使用static、const在实现文件中定义特定编译单元的常量。这些常量将不会被暴露在全局字符表中，所以它们的名字不需要命名空间。 使用extern在头文件声明它们，在关联的实现文件定义它们。这些常量将出现在全局字符表，所以它们的名字应该需要命名空间，通常使用类名作为前缀是合理的。 使用枚举表示状态、选项、状态码因为Objective-C是基于C的，C的所有功能Objective-C都是适用的。其中一个就是枚举类型，enum。它在系统框架中被广泛使用，但是常常被开发者忽略。它用于定义命名常量是非常有用的，例如，错误状态码和定义选项是可以组合的。感谢C++11标准支持了它，最近的系统版本包含枚举类型。是的，Objective-C也得益于C++11的标准。 枚举仅仅是命名常量的一种方法。一个简单的枚举集合可以用来表示一个对象的状态。例如，一个socket链接使用枚举表示如下： 12345enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;; 使用一个枚举意味着代码是可读的，因为每一个状态可以通过一个易读的值去代表。在枚举中编译器给每个成员一个唯一的值，从0开始每个成员加1。这种枚举是依靠编译器支持的但需要足够的位数去表示枚举。在前面的枚举中，仅需要1个字节就够了，因为它的最大值是2。 然而定义枚举变量的方式却不太简洁，需要使用下面的语法： 1enum EOCConnectionState state = EOCConnectionStateDisconnected; 如果每次不用使用enum只使用EOCConnectionState就好了。为了这样做，你添加一个typedef给枚举定义： 123456enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef enum EOCConnectionState EOCConnectionState; 它的意思是使用EOCConnectionState代替enum EOCConnectionState。 1EOCConnectionState state = EOCConnectionStateDisconnected; C++11标准的问世给枚举带来了一些变化。其中一个变化是可以决定使用哪种“数据类型”去存储枚举类型。这样做的好处是可以使用向前声明了。如果不指定数据类型，枚举类型无法使用向前声明，因为编译器无法知道数据类型的大小。因此，当用到枚举类型时，编译器无法知道应该给变量分配多大的空间。 给枚举指定数据类型，你可以使用下面这种语法： 1enum EOCConnectionStateConnectionState : NSInteger &#123; /*...*/&#125;; 上面代码的意思是保证枚举的变量类型是NSInteger。如果你乐意，这种类型的向前声明可以写成这样： 1enum EOCConnectionStateConnectionState : NSInteger; 你可以给枚举成员定义一个确切的值，而不是让编译器帮你指定。这语法看起来是这样的： 12345enum EOCConnectionStateConnectionState &#123; EOCConnectionStateDisconnected = 1, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;; 这意思是EOCConnectionStateDisconnected的值为1而不是0.别的成员变量的值同之前一样，依次递增1。例如，EOCConnectionStateConnected的值就是3。 另一种使用枚举类型的情况是去定义选项，特指当选项可以组合在一起时。只要当各选项定义的对，那么就可以使用“按位或运算符”去组合它们。例如，考虑下面的枚举类型，在iOS的UI框架中，用来表示某个视图如何调整大小： 123456789enum UIViewAutoresizing &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,&#125;; 每一个选项都可以开启或者关闭，使用上面的语法可以控制它因为每个选项都仅有单一的一位值去代表它自身。使用“按位或操作”可以组合多个选项。例如：UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight。图1.2展示了每个枚举成员和组合两个成员后的位布局。 通过“按位与操作”是可以判断出某个选项是否启用： 123456enum UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123; // UIViewAutoresizingFlexibleWidth is set &#125; 图1.2每个选项值的二进制表示形式，以及两个选项值运用“按位或运算”之后的二进制形式。 枚举在系统框架中使用非常广泛。另一个例子是iOS中的UIKit框架中的，用枚举值列举视图所支持的方向并告诉系统。它使用一个叫做UIInterfaceOrientationMask的枚举类型来实现，并且你可以实现一个叫做supportedInterfaceOrientations的方法去告诉系统视图所支持的方向： 1234- (NSUInteger)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft; &#125; 在Foundation框架中有一些辅助宏定义，用这些宏定义可以指定枚举值的数据类型。它们提供了向后兼容性，当编译器支持新的语法特性时，它们使用新的语法；当编译器只支持旧语法特性时，它们使用旧的语法特性。这些宏是由#define预处理指令定义的。一个支持像EOCConnectionState这种普通类型的枚举，另一个支持像UIViewAutoresizing这种一系列选项的枚举。你可以像下面这样使用它们： 1234567891011typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 这些宏的定义如下： 123456789101112131415161718#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L&amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum)) ) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum)) #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #if (__cplusplus) #define NS_OPTIONS(_type, _name) type _name; enum : _type #else #define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type #endif #else #define NS_ENUM(_type, _name) _type _name; enum #define NS_OPTIONS(_type, _name) _type _name; enum #endif 由于要处理不同的情况所以要用多种方式去定义两个宏。第一个判断是检查编译器是否支持新式枚举的特性。这个布尔逻辑看起来相当复杂，但它的意思就是判断编译器是否支持新特性。如果不支持，那么就用老的方式。 如果新特性是可用的，那么NS_ENUM宏所定义的类型展开后是这样的： 123456typedef enum EOCConnectionState : NSUInteger EOCConnectionState; enum EOCConnectionState : NSUInteger &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected, &#125;; NS_OPTIONS宏的展开是取决于编译形式的。如果以C++形式编译，那么NS_OPTIONS宏展开与NS_ENUM宏展开是不一样的，否则是一样的。为什么？因为C++环境下两个枚举值通过按位或运算结果与非C++环境下是不同的。前面已经提到了，作为选项的枚举值经常会通过按位或运算进行组合。当两个值通过按位或运算后，C++认为它们所代表的值类型是NSUInteger。并且也不允许饮食转换为枚举类型。为了说明这个，我们考虑将EOCPermittedDirection以NS_ENUM形式展开： 1234567typedef enum EOCPermittedDirection : int EOCPermittedDirection; enum EOCPermittedDirection : int &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 考虑下面的代码： 12EOCPermittedDirection permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp; 当在C++或者Objective-C++环境下，将会出现下面的错误： 12error: cannot initialize a variable of type &apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos; 你必须将通过按位或操作的结果显示的转化为EOCPermittedDirection。所以，在C++的环境下应该使用NS_OPTIONS，省去显示转化这一步。因此，如果需要按位或操作的枚举值应当尽量使用NS_OPTIONS，而不需要的，则使用NS_ENUM。 枚举可以用在很多情况下。选项和状态已经在前面讲过了；然后更多的情况同样适用。对错误使用状态码是一个好的习惯。把逻辑含义相似的代码放入一个枚举中，用于替代使用预定义和常量。另一个好的地方是样式。例如，你有一个UI元素可以创建不同的样式，一个枚举集合可以完美的表示每个样式。 最后一点是关于在switch中使用枚举变量。又是，你会这样定义它们： 1234567891011121314151617typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected, &#125;; switch (_currentState) &#123; EOCConnectionStateDisconnected: // Handle disconnected state break; EOCConnectionStateConnecting: // Handle connecting state break; EOCConnectionStateConnected: // Handle connected state break; &#125; 我们习惯在switch语句中加上默认分支。然而，当使用枚举值表示状态时，最好不要写一个默认分支。这样做的原因是，当你在稍后添加了一个新的状态，那么编译器将会警告你，提示你有新的状态未加入switch分支。如果有一个默认的分支，编译器将会处理它，那么编译器将不会发出警告。这个问题同样适用于别的使用NS_ENUM的定义中。例如，你定义一个UI元素，你将会希望每个情况都有一个确定的样式。 小结 使用枚举来表示状态机的状态，传递给函数的选项，或者错误码，并且起一个易读的名字。 如果把一个传递给方法的选项表示为枚举类型，同时还需要多重操作，可以将它们的值设为2的幂，然后通过按位或操作将其组合起来。 使用NS_ENUM和NS_OPTIONS宏最好给枚举定义一个明确的数据类型。这样做的意思是确定枚举的数据类型是开发者设置的，而不是编译器指定的。 在switch中使用枚举时，不要设置默认分支。这样在你添加新枚举后，编译器会提醒你添加新分支。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本内容图解]]></title>
      <url>%2F2017%2F04%2F17%2FBasePrinciple_Img%2F</url>
      <content type="text"><![CDATA[Some principle！！！ 最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解: 就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后… 突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下 对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码解析]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_3%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0 入口学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。 WeexDemo的入口是[WXSDKEngine initSDKEnvironment];。这个Method的主要代码，如下： 123NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];[WXSDKEngine initSDKEnvironment:script]; 首先，读取一个叫做main.js的文件内容，然后将其内容作为[WXSDKEngine initSDKEnvironment:script]初始化的参数。我们继续来看这个method的代码，如下： 123456if (!script || script.length &lt;= 0) &#123; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;); return;&#125;[self registerDefaults];[[WXSDKManager bridgeMgr] executeJsFramework:script]; 注册和执行Register首先，是对传递进来的js代码做判断，其次调用了一个registerDefaults的method，代码如下： 123456static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers];&#125;); Register Componet这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下： 1234567891011121314151617181920212223242526+ (void)registerComponent:(NSString *)name withClass:(Class)clazz&#123; [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];&#125;+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties&#123; if (!name || !clazz) &#123; return; &#125; WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;); [WXComponentFactory registerComponent:name withClass:clazz withPros:properties]; NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name]; dict[@&quot;type&quot;] = name; if (properties) &#123; NSMutableDictionary *props = [properties mutableCopy]; if ([dict[@&quot;methods&quot;] count]) &#123; [props addEntriesFromDictionary:dict]; &#125; [[WXSDKManager bridgeMgr] registerComponents:@[props]]; &#125; else &#123; [[WXSDKManager bridgeMgr] registerComponents:@[dict]]; &#125;&#125; 第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。@&quot;append&quot;:@&quot;tree&quot;代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，@&quot;append&quot;:@&quot;node&quot;代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用WXComponentFactory进行注册，在这之前先讲几个相关类的功能，免得迷糊。 WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承 WXComponentConfig: 继承WXInvocationConfig类，存储每个Component的method、name、classname WXComponentFactory：单例类，通过字典存储WXComponentConfig对象，通过每个WXComponentConfig对象操作每个Component的method、name、classname。 首先通过WXComponentFactory调用- (void)registerComponent:(NSString *)name withClass:(Class)clazz withPros:(NSDictionary *)pros方法注册。使用Assert判断，然后创建一个WXComponentConfig对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用[config registerMethods];将类中的method通过runtime存储在WXComponentConfig中，存取时加锁保证安全。其次调用- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法registerComponents，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。 1234567891011121314export function registerComponents (newComponents) &#123; if (Array.isArray(newComponents)) &#123; newComponents.forEach(component =&gt; &#123; if (!component) &#123; return &#125; if (typeof component === &apos;string&apos;) &#123; components[component] = true &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123; components[component.type] = component &#125; &#125;) &#125;&#125; Register Module注册Module，代码如下： 1234WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;); NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];[[WXSDKManager bridgeMgr] registerModules:dict]; 先介绍几个类： WXModuleConfig：继承WXInvocationConfig类，存储每个Component的method、name WXModuleFactory：单例类，通过字典操作WXModuleConfig对象 查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法registerModules。 Register Handler注册Handler，代码如下： 123WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;); [WXHandlerFactory registerHandler:handler withProtocol:protocol]; 照例介绍几个类： WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储 注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。 ExecuteJs最后调用[[WXSDKManager bridgeMgr] executeJsFramework:script];执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。 首先介绍几个类： WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能 WXSDKManager：单例类，通过一个字典存储所有WXSDKInstance实例，key是一个唯一值；一个WXBridgeManager实例 WXBridgeManager：单例类，注册，渲染功能都通过调用WXBridgeContext对象去跟JS交互 WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。 WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使WXBridgeContext调用 现在可以从那句代码开始讲了，[WXSDKManager bridgeMgr]这个对象是一个单例，他在JS线程调用executeJsFramework，代码如下： 12345if (!script) return;__weak typeof(self) weakSelf = self;WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx executeJsFramework:script];&#125;); 先是判空，其次weakSelf防止循环引用，然后在一个叫做&quot;com.taobao.weex.bridge&quot;的线程调用executeJsFramework方法，代码如下： 123456789101112131415161718192021222324252627282930313233WXAssertBridgeThread();WXAssertParam(script); WX_MONITOR_PERF_START(WXPTFrameworkExecute); [self.jsBridge executeJSFramework:script]; WX_MONITOR_PERF_END(WXPTFrameworkExecute); if ([self.jsBridge exception]) &#123; NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]]; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);&#125; else &#123; WX_MONITOR_SUCCESS(WXMTJSFramework); //the JSFramework has been load successfully. self.frameworkLoadFinished = YES; [self executeAllJsService]; JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil]; if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123; [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]]; &#125; //execute methods which has been stored in methodQueue temporarily. for (NSDictionary *method in _methodQueue) &#123; [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]]; &#125; [_methodQueue removeAllObjects]; WX_MONITOR_PERF_END(WXPTInitalize);&#125;; 首先断言当前线程是否是&quot;com.taobao.weex.bridge&quot;线程，其次断言js代码，使用WXBridgeProtocol协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。 JavaScriptCoreJavaScriptCore简介上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。 JSVirtualMachine：为JavaScript提供运行资源 JSContext：为JavaScript提供运行环境 JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量 JavaScriptCore示例这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了： 简单使用12345JSContext *context = [[JSContext alloc] init];JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];NSLog(@&quot;%@&quot;, value); 输出5context[@&quot;sum&quot;] = @&quot;40&quot;;NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40 首先初始化一个JSContext对象，可以使用JSVirtualMachine对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个JSVirtualMachine对象，所以这个js运行的资源，不可或缺。 第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。 第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。 异常处理1234_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123; context.exception = exception; NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];&#125;; 另一个要注意的点就是这里，JavaScriptCore会在exceptionHandler中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用[JSContext currentContext]获取当前的context。如果直接引用外部的context会造成循环饮用。 invokeMethod1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;]; JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];NSLog(@&quot;%@&quot;, sum); 输出7 初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。 总结上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码文件夹的解释]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_2%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0 Weex文件夹*最不重要的文件夹：Controller、Debug、Handler *不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket *稍微重要的文件夹：Component、Module、Protocol *重要的文件夹：Display、Events、Layout、View *最重要的文件夹：Bridge、Engine、Manager、Model Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油； Debug：一个调试类，酱油； Handler：两个类实现了两个Weex的Protocol，酱油； Loader：一个类是Network的回调实现，一个类是WebSocket的回调。 Monitor：一个监测的类，输出一些信息。 Network:一个小型的网络请求库 Utility：一些常用方法的封装 WebSocket：对SRWebSocket的封装 Componet：对各种view的封装，如果需要扩展view就跟这个有关 Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。 Display：WXComponent的展示 Events：WXComponent的事件 Layout：WXComponent的布局 View：WXComponent的View Bridge：Weex与NativeJS之间的桥接 Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等 Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。 Manager：Weex中各种管理的类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Book]]></title>
      <url>%2F2017%2F02%2F26%2FReadBook_iOS%2F</url>
      <content type="text"><![CDATA[iOS相关书籍… 《iOS7应用开发技术详解》在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如14.2手势事件、11.3.5的UIViewAutoresizing等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看16、17章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。 《iOS开发进阶》这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。 《Objective-C高级编程》这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西引用计数，Block，GCD。引用计数这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；Block这块主要看的是clang rewrite 之后的代码；GCD是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex的简单使用]]></title>
      <url>%2F2017%2F02%2F01%2FWeex_1%2F</url>
      <content type="text"><![CDATA[本篇主要讲解一下Weex的大概原理以及简单的使用 Weex 与RN相同原理，某些方面优于RN js语法，比Native体验稍差，比hybrid app体验好太多 js一端代码，三端使用 iOS/Android脱离写UI的噩梦 文档不够完善 Weex原理 Weex使用 首先，在AppDelegate中调用[WXSDKEngine initSDKEnvironment]进行注册 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXSDKEngine initSDKEnvironment]; return YES;&#125; 其次，在需要使用的ViewController中定义一个WXSDKInstance实例和UI个UIView实例 12@property (nonatomic) WXSDKInstance *instance;@property (nonatomic) UIView *weexView; 紧接着，初始化WXSDKInstance实例，设置它的viewController、frame属性，实现它的生命周期 123456789101112131415161718192021222324252627_instance = [[WXSDKInstance alloc] init];_instance.viewController = self;_instance.frame = [UIScreen mainScreen].bounds; __weak typeof(self) weakSelf = self;_instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView];&#125;; _instance.onFailed = ^(NSError *error) &#123; NSLog(@&quot;failed %@&quot;,error);&#125;; _instance.renderFinish = ^(UIView *view) &#123; NSLog(@&quot;render finish&quot;);&#125;; _instance.onRenderProgress = ^(CGRect renderRect) &#123; NSLog(@&quot;renderProgress&quot;);&#125;; _instance.updateFinish = ^(UIView *view) &#123; NSLog(@&quot;update Finish&quot;);&#125;; 最后，使用WXSDKInstance实例调用renderWithURL:方法即可。记得在dealloc中释放WXSDKInstance实例哦😯 [self.instance renderWithURL:[NSURL URLWithString:renderURL]]; Weex的自定义 Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承WXComponent，滑动组件继承WXScrollerComponent handler: Native提供一个协议。weex官方定义了常用的部分，如WXImgLoaderProtocol图片下载。如果需要自定义，注意需遵守协议WXModuleProtocol module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议WXModuleProtocol，需要自定义Method，如果需要返回值使用WXModuleCallback返回 总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下： 123[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)]; 基本的Weex知识就是这些，具体使用方法请参照官方文档和demo链接。下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。]]></content>
    </entry>

    
  
  
</search>
