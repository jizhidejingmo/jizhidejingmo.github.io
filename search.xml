<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第七章]]></title>
      <url>%2F2017%2F07%2F16%2FThe%20System%20Frameworks%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第七章：系统框架。 这是这本书的最后一节了，翻译的有问题的地方看得人还请多多谅解。翻译完这本书就准备闭关，好好沉淀知识了。学习使我开心。 简介你在使用Objective-C进行开发时，不使用框架是不可能的。即使是你使用的根类NSObject，它也是Foundation框架的一部分而不是语言本身的。如果你不想使用Foundation框架，你需要去写自己的根类，自己的集合类，自己的事件循环，和其他有用的类。而且，你也不能使用Objective-C为Mac OS X和iOS开发的其余框架。它们都是强大的，是开发者以年为单位进行优化的。因此，你可能会看到某些部分有感觉古老和笨拙的代码，但也会有意想不到的好东西在里面。 熟悉你使用的系统框架当你使用Objective-C编写程序时，你肯定会用到系统框架，它们会提供许多常用类，例如集合，你只需要编写应用就可以了。如果你不知道这些系统框架提供的功能，你很可能会写一些已经实现的功能。当操作系统更新时，应用的使用者会获取最新的系统框架代码。所以如果你使用了这些框架，你能从中获得性能提高的收益，并且不需要更新你的应用程序。 一个框架其实是由代码集合打包成的动态库，并且将头文件作为接口。有时，第三方库的框架是一个静态库，因为iOS应用程序不允许使用动态库(PS:但是现在的第三方库还是有动态框架的，例如QQ登录)。它们不是真正的框架但是经常这样叫它们。但是，所有的iOS的系统框架都是使用的动态库。 如果你为Mac OS X或者iOS开发图形应用程序，你肯定会用到一个叫做Cocoa的层，它在iOS上被称为Cocoa Touch。Cocoa不是一个框架，它是那些在创建应用时常用框架的集合。 你主要会使用的框架叫做Foundation，它有NSObject、NSArray、 NSDictionary等类。这些类的前缀使用框架的NS前缀，因为它是在NeXTSTEP系统上使用Objective-C语言时确定的。Foundation框架是所有Objective-C应用程序的核心，如果没有它，本书讲的很多东西就是在瞎扯了。 Foundation提供的功能不止集合这些，它也提供了例如字符串处理这种复杂功能。例如，NSLinguisticTagger提供了解析一个字符串并找到其中名词、动词、代词等的功能。简言之，Foundation提供的功能不只是基础。 Foundation有一个叫做CoreFoundation的伴生类。尽管它不是一个Objective-C类，但它仍是一个重要框架，在你编写Objective-C程序时，它可以提供很多与Foundation框架等同功能的函数。Foundation和CoreFoundation不止名字相似，它们也有很多关联。一个众所周知的功能就是通过无缝桥接可以将一个CoreFoundation的C结构体转化为Foundation的Objective-C对象，反之亦然。例如，使用Foundation框架创建一个NSString类型的字符串，它等价于CoreFoundation的CFString。无缝桥接使运行时认为CoreFoundation对象是Objective-C对象。不幸的是，无缝桥接是非常复杂的，所以你自己不太可能手工实现它。这个功能开发时使用还是挺不错的，但是手动实现它，就需要考虑考虑了。 除了Foundation和CoreFoundation之外还有很多系统框架。包括但不限于下列框架： CFNetwork 此框架基于BSD套接字进行封装，提供了C级别的易用的网络基础。Foundation将其包装为Objective-C接口，例如NSURLConnection从一个URL下载数据。 CoreAudio 它提供了一个基于设备硬件的C级别的音频接口。这套框架很难使用，因为音频本身就很复杂。幸运的是，Objective-C抽象了一套更简单易用的API。 AVFoundation 它提供了Objective-C对象可以用来进行音视频的录制和播放功能，例如使用UIView视图去展示一个视频。 CoreData 它提供了Objective-C接口用于将对象存储在数据库中。它可以在Mac OS X 和 iOS上处理数据库数据获取和存储。 CoreText 它提供的C语言接口可以高效的进行文字排版和渲染。 当然还有别的框架，但是从列表就可以看出来，开发应用时，通常需要使用C级别的API。C级别的API绕过Objective-C的运行时可以带来速度的提升。当然，使用C级别的API更要小心内存管理问题，因为ARC仅适用于Objective-C对象。如果你使用这些框架，对它们进行了解是很重要的。 你可能还会编写使用UI框架的Mac OS X 和 iOS应用。它们的核心UI框架，分别被成为AppKit和UIKit，它们都提供了基于Foundation和CoreFoundation构建的Objective-C类。它们提供了UI元素，可以将多个UI元素粘合在一起构成应用程序。在这些主要的UI框架之下是CoreAnimation和CoreGraphics框架。 CoreAnimation是用Objective-C写的，它提供了一些工具用于渲染图形和执行动画。你可能不需要使用这个级别的API，但知道它是很好的。CoreAnimation不是一个框架，但它是QuartzCore框架的一部分。但是在框架中，它仍算是一等公民。 CoreGraphics是用C写的，它提供了数据结构和函数去进行2D渲染。例如，定义CGPoint、CGSize、CGRect的数据结构，而UIKit中的UIView类在定位位置时，这些结构都需要使用。 多数框架是基于UI框架搭建的，例如MapKit，它给iOS提供地图功能。比如Social框架，它给Mac OS X和iOS提供社交网络功能。开发者通常会将这些框架与核心框架结合使用。 总体来讲，许多框架都是直接存在于Mac OS X和iOS。所以，如果你需要写一个辅助类，首先搜索下有没有相应的系统框架吧。通常，它都是已经实现了的。 小结 对开发者而言，许多系统框架都是可以直接用的。最重要的是Foundation和CoreFoundation，它们提供了整个应用程序的许多核心函数。 许多任务都可以使用已有的系统框架，例如音频、视频、网络通信、数据管理。 请记住纯粹用C代码写成的框架是一样重要的，如果你想成为一个好的Objective-C开发者，你应该理解C的核心概念。 相比for循环更喜欢用block枚举在项目中，枚举一个集合是非常常见的任务，Objective-C也有很多方法可以做到，从C的标准for循环，到Objective-C1.0的NSEnumerator，到Objective-C2.0的快速枚举。block的出现给语言添加了一些开发者经常忽视的方法。这些方法允许你通过一个block去枚举集合，集合中的每个元素都会运行并且是易于使用的。 这些集合是通常会使用枚举的，如NSArray、NSDictionary、NSSet。另外，自定义的集合枚举也可以支持，但这不是我们这节要讲的内容。 for循环for循环是以前常用的遍历数组的好办法，它来源于C语言。这个方法非常基础所以限制很大。通常是这样使用它： 12345NSArray *anArray = /* ... */;for (int i = 0; i &lt; anArray.count; i++) &#123; id object = anArray[i]; // Do something with &apos;object&apos;&#125; 这是可以接受的，但当遍历字典或集合时它变得复杂： 123456789101112131415// DictionaryNSDictionary *aDictionary = /* ... */;NSArray *keys = [aDictionary allKeys];for (int i = 0; i &lt; keys.count; i++) &#123; id key = keys[i]; id value = aDictionary[key]; // Do something with &apos;key&apos; and &apos;value&apos;&#125;// SetNSSet *aSet = /* ... */;NSArray *objects = [aSet allObjects];for (int i = 0; i &lt; objects.count; i++) &#123; id object = objects[i]; // Do something with &apos;object&apos;&#125; 因为字典和集合是无序的，所以没有办法直接通过确定的整数值去获取数据。因此，你需要将字典的所有键或者集合的所有对象，将其组成一个有序的数组，然后通过枚举访问每个值。创建这个数组是一个额外的工作，并导致有额外对象持有集合中的对象。当然，这些对象会在数组释放时释放的，但这个方法不是必须调用的。从技术上讲，使用for循环，其他所有对象枚举时都需要创建一个额外的数组。 使用for循环也可以向后枚举，开始数值是集合对象的最大个数，每次循环建议，当数值为0时，停止循环。这也是非常简单的。 Objective-C 1.0使用NSEnumerator进行枚举NSEnumerator是一个抽象基类，它仅定义了两个方法用于让子类实现： 12- (NSArray*)allObjects- (id)nextObject 关键方法是nextObject，它返回枚举中的下一个对象。每次这个方法被调用，内部的数据结构都会返回下一个对象。这样枚举中的所有对象都会返回，当枚举到最后一个时，返回nil。 Foundation框架中的集合类都实现了这个方法。例如，枚举数组是这样的： 123456NSArray *anArray = /* ... */;NSEnumerator *enumerator = [anArray objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // Do something with &apos;object&apos;&#125; 这根for循环很相似，但也有额外的工作。它的唯一好处大概就是所有的集合枚举都是使用相似的语法。例如，考虑下面的字典和集合的枚举： 123456789101112131415// DictionaryNSDictionary *aDictionary = /* ... */;NSEnumerator *enumerator = [aDictionary keyEnumerator];idkey;while ((key = [enumerator nextObject]) != nil) &#123; id value = aDictionary[key]; // Do something with &apos;key&apos; and &apos;value&apos;&#125;// SetNSSet *aSet = /* ... */;NSEnumerator *enumerator = [aSet objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // Do something with &apos;object&apos;&#125; 字典的枚举是稍有不同的，因为字典有键和值，所以需要根据键去获取字典中的值。使用NSEnumerator还有个好处就是可以使用不同种类的枚举器。例如，一个数组，可以使用逆向枚举。例如： 123456NSArray *anArray = /* ... */;NSEnumerator *enumerator = [anArray reverseObjectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // Do something with &apos;object&apos;&#125; 这样是比for循环语法更易阅读的。 快速枚举快速枚举产生于Objective-C2.0。快速枚举和NSEnumerator是非常相似的，不过语法是非常简洁的，它为for循环添加了in关键字。使用关键字的语法是非常简洁的，例如数组： 1234NSArray *anArray = /* ... */;for (id object in anArray) &#123; // Do something with &apos;object&apos;&#125; 这样是非常简单的！如果一个类的对象想进行枚举，它只要遵循NSFastEnumeration协议。这个协议只定义了一个方法： 123- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState*)state objects:(id*)stackbuffer count:(NSUInteger)length 这个方法的原理不是本节所讲述的内容。但是，网上是有关于它们的优秀教程的。需要注意的是它可以同时返回多个对象，这样使得枚举循环更高效。 字典和集合的枚举如下： 1234567891011// DictionaryNSDictionary *aDictionary = /* ... */;for (id key in aDictionary) &#123; id value = aDictionary[key]; // Do something with &apos;key&apos; and &apos;value&apos;&#125;// SetNSSet *aSet = /* ... */;for (id object in aSet) &#123; // Do something with &apos;object&apos;&#125; 逆向枚举也可以通过NSEnumerator实现，因为它也实现了NSFastEnumeration。所以如果要逆向一个数组，你可以这样做： 1234NSArray *anArray = /* ... */;for (id object in [anArray reverseObjectEnumerator]) &#123; // Do something with &apos;object&apos;&#125; 这个方法的语法是最简单和高效的，但是如果你需要在遍历字典时，使用字典的键和值，你仍然需要额外的步骤。另外，这个循环不像传统for循环，它无法很容易的获取下标值。在许多场景中，下标都是非常有用的。 基于block的枚举在当前的Objective-C语言中，最新的一种做法是基于block来遍历。例如数组的基本枚举： 1- (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block 这个方法的系列中还可以传入一系列的参数，我们将在稍后讨论它们。 对于数组和集合，block每次执行时都会带有一个当前对象和当前下标以及一个bool值的指针。前两个参数与正常循环一样。第三个参数提供了停止枚举的一种机制。 例如，你可以使用这个方法枚举一个数组： 1234567NSArray *anArray = /* ... */;[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123; // Do something with &apos;object&apos; if (shouldStop) &#123; *stop = YES; &#125;&#125;]; 这个语法比快速枚举稍微复杂点，但它很清楚，并且你可以得的对象和下标两个值。如果你想暂停循环，你可以通过stop参数终止循环，尽管你使用break也可以达到同样的目的。 不仅仅数组可以通过这种方式枚举。同样的block枚举方法也存在NSSet和NSDictionary中： 1- (void)enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id object, BOOL *stop))block 因此，枚举字典和集合就像刚才那样简单： 12345678910111213141516// DictionaryNSDictionary *aDictionary = /* ... */;[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop)&#123; // Do something with &apos;key&apos; and &apos;object&apos; if (shouldStop) &#123; *stop = YES; &#125;&#125;];// SetNSSet *aSet = /* ... */;[aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop)&#123; // Do something with &apos;object&apos; if (shouldStop) &#123; *stop = YES; &#125;&#125;]; 这种方法比别的好很多的原因是你在block中可以直接获得很多信息。在数组那个例子中，你可以从枚举中得到下标。遍历有序set时也是一样的。在字典中，你不需要任何额外的操作就可以得到键和值，因此不需要通过指定键获取值。这种方式也是很快的，因为在字典内部的数据结构中，它们是在一起存储的。 另一个好处是，你可以修改block的方法签名，限制为需要的类型；实际上，你将类型转换交给了block方法签名来做。考虑使用快速枚举对字典进行枚举。如果字典中的对象是一个字符串，你可能这样做： 1234for (NSString *key in aDictionary) &#123; NSString *object = (NSString*)aDictionary[key]; // Do something with &apos;key&apos; and &apos;object&apos;&#125; 而使用block枚举，你可以这样修改block枚举的方法签名： 1234NSDictionary *aDictionary = /* ... */;[aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL *stop)&#123; // Do something with &apos;key&apos; and &apos;obj&apos;&#125;]; 可以这样做的原因是，id类型是非常特殊的，它可以代表任何类型。如果本来的block方法签名定义为NSObject*，这样写就会出问题了。这技巧看上去不起眼，实际非常有用。指定对象的类型后，如果你调用了这个对象不相应的方法，编译器会抛出一个错误。如果你知道集合中对象的类型，使用这种方法指明类型是很重要的。 它也可以进行逆向枚举。数组，字典，集合都实现了前面方法的变体，允许你传入一个选项掩码： 1234- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block- (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id key, id obj, BOOL *stop))block NSEnumerationOptions类型是enum，你可以使用按位或来连接它的值用以表达枚举行为。例如，你可以请求以并发形式迭代，意思是，如果系统资源允许，每次迭代的block都可以并行执行。使用NSEnumerationConcurrent选项开启此功能。如果使用这个选型，会使用GCD去处理并发执行，就像之前讲的dispatch groups一样。但是，本节不会讲具体实现。使用NSEnumerationReverse可以进行逆向枚举。注意这只适用于数组和有序集合这些情况。 最重要的是，block枚举有所有其他方法的收益组合，或者更多。它比快速枚举稍微复杂。但是与快速枚举相比，它能提供所有的下标，遍历字典时提供键与值，还能使用并发迭代功能，所以多点代码还是值得的。 小结 枚举集合有四种方法。最基本的是for循环，其次是NSEnumerator和快速循环。最新最先进的是使用block枚举法。 block枚举通过使用GCD，来允许你并发迭代，不需要任何额外代码。别的枚举方法都不能很容易的达到这个效果。 如果你知道枚举的对象的类型，你可以修改block枚举方法的方法签名。 对自定义内存管理语义的集合使用无缝桥接Objective-C系统框架中集合类是非常多的：数组、字典、set。Foundation框架定义了这些集合的Objective-C类。相似的，CoreFoundation框架也定义了C API，用于操作C类型数据结构的数据集合。例如，NSArray用于操作Objective-C语言的数组，CFArray则用于操作C语言的数组。这两种方法创造出来的数组看起来差距很大，但通过一个强大的被称作无缝桥接的功能，你可以在这两者之间随意转换。 无缝桥接技术允许你将定义在Foundation中的Objective-C对象转化为定义在CoreFoundation中的C数据结构，反之亦然。我之所以称C级别API为数据结构而不是类或对象是因为它与Objective-C的类或对象并不相同。例如，CFArray通过CFArrayRef引用，并且它是指向__CFArray的指针。这个结构体的操作是通过使用这样的函数，例如获取数组大小使用的CFArrayGetCount函数。这和Objective-C中的对应类差别很大，在Objective-C中你可以创建一个NSArray对象，然后调用一个叫做count的方法，去获取这个数组对象的大小。 一个简单的无缝桥接例子如下： 1234NSArray *anNSArray = @[@1, @2, @3, @4, @5];CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(aCFArray));// Output: Size of array = 5 __bridge告诉ARC如何处理相关的Objective-C对象。__bridge意味着ARC仍然拥有Objective-C对象的所有权。__bridge_retained意味着ARC不再拥有Objective-C对象的所有权。如果我们在上面的例子中使用了它，那么我们需要在C数组不再使用时添加CFRelease(aCFArray)。相似的，反向转换使用__bridge_transfer完成。例如，将CFArrayRef转化为NSArray*，并且想讲所有权交给ARC，那么使用这个转换。这三种转换方式被称为桥式转换。 但是，你可能会这样想，为什么你会在一个纯粹的Objective-C应用中使用这个功能?这是因为Foundation中的Objective-C类可以做到CoreFoundation中C数据结构无法做到的事，反之亦然。例如，关于Foundation中的字典就有一个问题，它的键是拷贝，值是保留。如果你不使用无缝桥接，这种语义无法修改。 CoreFoundation中的字典叫做CFDictionary。对应的可变部分叫做CFMutableDictionary。当创建CFMutableDictionary时，你可以使用下面的方法自定义键和值的内存管理语义： 123456CFMutableDictionaryRef CFDictionaryCreateMutable ( CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks) 第一个参数是内存分配器。如果你大部分的时间都是在写Objective-C，那么你对CoreFoundation的这部分感觉陌生。内存分配器对于CoreFoundation对象是必须的，因为数据结构需要占用内存，内存分配器负责初始化和释放。通常，你会将这个值设置为NULL去使用默认内存分配器。 第二个参数指明字典初始化时的大小。它不是用来限制字典的最大尺寸，只是提示内存分配器在开始时要分配多少空间。如果你知道你将要创建的字典有十个键值对，你可以设为10。 最后两个参数都挺有意思的。当键和值存进字典时，它们会调用对应情况的回调。这两个参数都是结构体的指针，它们看起来是这样的： 123456789101112131415struct CFDictionaryKeyCallBacks &#123; CFIndex version; CFDictionaryRetainCallBack retain; CFDictionaryReleaseCallBack release; CFDictionaryCopyDescriptionCallBack copyDescription; CFDictionaryEqualCallBack equal; CFDictionaryHashCallBack hash;&#125;;struct CFDictionaryValueCallBacks &#123; CFIndex version; CFDictionaryRetainCallBack retain; CFDictionaryReleaseCallBack release; CFDictionaryCopyDescriptionCallBack copyDescription; CFDictionaryEqualCallBack equal;&#125;; 现在这个version参数应该是0。它已经成为当前管理，但是如果苹果公司决定修改机构体，那么它可能会发生变化。这个参数用作检测新版和旧版是否兼容。结构体里面其余部分都是指针，当没一个任务发生时，函数应该如何运行。例如，当每个键和值添加进字典时，会调用retain函数。这个参数类型如下： 1234typedef const void* (*CFDictionaryRetainCallBack) ( CFAllocatorRef allocator, const void *value); 由此可见它是一个函数指针，接受CFAllocatorRef类型和const void*类型的参数。传入的value参数代表添加给字典的是键或值。而返回的void*则代表要添加进字典的值。你可以这样定义你自己的回调： 1234const void* CustomCallback(CFAllocatorRef allocator, const void *value)&#123; return value;&#125; 这个简单返回的值是未做改变的。所以，如果使用retain回调创建一个字典，键和值都没有被保留。加上无缝桥接，你就可以创建一个特殊的NSDictionary对象，它的行为不同于Objective-C中直接创建的字典。 下面是一个完整的示例： 1234567891011121314151617181920212223242526272829303132#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreFoundation/CoreFoundation.h&gt;const void* EOCRetainCallback(CFAllocatorRef allocator, const void *value)&#123; return CFRetain(value);&#125;void EOCReleaseCallback(CFAllocatorRef allocator, const void *value)&#123; CFRelease(value);&#125;CFDictionaryKeyCallBacks keyCallbacks = &#123; 0, EOCRetainCallback, EOCReleaseCallback, NULL, CFEqual, CFHash&#125;;CFDictionaryValueCallBacks valueCallbacks = &#123; 0, EOCRetainCallback, EOCReleaseCallback, NULL, CFEqual&#125;;CFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL, 0, &amp;keyCallbacks, &amp;valueCallbacks);NSMutableDictionary *anNSDictionary = (__bridge_transfer NSMutableDictionary*)aCFDictionary; 在设置回调函数时，copyDescription使用NULL值，因为它的默认已经很好了。equal和hash则分别使用CFEqual和CFHash，因为NSMutableDictionary使用了同样的方法。CFEqual最终会调用NSObject的isEqual:方法，CFHash最终会调用NSObject的hash方法。这就是无缝桥接的强大之处。 无论是键还是值的retain和release回调都分别设置的EOCRetainCallback和EOCReleaseCallback函数。为什么要这样做？会想一下前面所说的，NSMutableDictionary的键会被拷贝，值会被保留。如果你没设置copy回调，那会发生什么？在这种情况下，你不能在NSMutableDictionary中使用它，因为它会在运行时抛出一个这样的错误： 1234*** Terminating app due to uncaught exception&apos;NSInvalidArgumentException&apos;, reason: &apos;-[EOCClasscopyWithZone:]:unrecognized selector sent to instance0x7fd069c080b0&apos; 这个错误的意思是这个类不支持NSCopying协议，因为没实现copyWithZone:方法。通过使用CoreFoundation层创建字典，你可以修改键的内存管理语义为保留而非拷贝。 使用类似的方法也可以创建出不保留对象的数组。这个方法可能是有用的，因为如果数组保留元素，可能会导致循环引用，但是请注意，这种情况有更好的办法解决。一个数组不保留对象是非常危险的，如果数组中的某个元素释放了，但它仍在数组中，如果访问这个对象，应用程序将发生崩溃。 小结 无缝桥接允许你将Foundation框架的Objective-C对象和CoreFoundation框架C数据结构互相转换。 使用CoreFoundation创建集合允许你指定多种回调情况，这些回调情况代表你如何处理集合中的元素。如果配合上无缝桥接，你可以将其转化为特殊内存管理语义的Objective-C集合。 使用NSCache替代NSDictionary进行缓存当你开发Mac OS X或者iOS应用时，你通常会遇到这样的问题，即从网络上下载的图片如何缓存它们。第一个好的办法是将其存储在字典中，这样后面再使用时就不需要下载了。有些开发者可能直接就会使用NSDictionary了或者是NSMutableDictionary了，因为这是一个常用的类。但是有一个更好的类，它叫做NSCache，它是Foundation框架的一部分，并且它就是为了这种任务设计的。 NSCache的收益是大于NSDictionary的，当系统资源快要耗尽时，它会自动清除一部分缓存。当使用字典时，你需要对系统进行hook，在系统低内存时，接受通知进行清理。但是，NSCache是自动的；因为它是Foundation框架的一部分，它可以很轻松的hook在系统的深层次。NSCache会优先删除最长时间未使用的对象，但是开发者使用字典实现这个方法却很复杂。 另外，NSCache不拷贝键而是保留它。如果使用NSDictionary也可以办到，但需要更复杂的代码。缓存通常不希望拷贝键，因为键对象可能不支持拷贝。因为NSCache默认不拷贝键，所以它更适合这种需求。另外，NSCache是线程安全的。NSDictionary线程是不安全的NSDictionary，这意味着你可以在多线程中随时进行存取，而不需要加任何锁。这是非常有用的，因为你通常会在某个线程读取它，如果键不存在，则去下载这个键对应的数据。下载的回调很可能处在其他线程，所以你需要在另外一个线程添加缓存了。 你可以控制缓存合适删除内容。有两个对象分别限制存储的对象个数和存储对象花费的大小。当给缓存添加对象时，你可以选择控制它的大小。当对象总数超出了限制或者对象总花费超出了限制，缓存就会像在系统资源不足时做的一样，进行缓存清除。需要注意的是，可能会删除某对象并不代表一定会删除它。这要取决于具体的实现。这意味着，试图通过控制花费大小去优先删减某对象不是一个好主意。 这个花费限制应该仅在添加对象时能很容易计算出它的大小时添加。如果计算它的代价比较大，那么就不要设置这个值了，因为每次向缓存中添加对象还要计算它的大小会导致速度变慢。重要的是，缓存本身就是为了帮助应用更快的响应。例如，如果需要从磁盘或者数据库获得存储对象的大小，这不是一个好主意。但是，如果你存储的是NSData对象；这种情况下，你可以将数据大小指为花费大小。这是因为NSData对象大小是已知的，获取它的大小不过时调用了一个属性。 下面是一个使用NSCache的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &lt;Foundation/Foundation.h&gt;// Network fetcher classtypedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);@interface EOCNetworkFetcher : NSObject- (id)initWithURL:(NSURL*)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;@end// Class that uses the network fetcher and caches results@interface EOCClass : NSObject@end@implementation EOCClass &#123; NSCache *_cache;&#125;- (id)init &#123; if ((self = [super init])) &#123; _cache = [NSCache new]; // Cache a maximum of 100 URLs _cache.countLimit = 100; /** * The size in bytes of data is used as the cost, * so this sets a cost limit of 5MB. */ _cache.totalCostLimit = 5 * 1024 * 1024; &#125; return self;&#125;- (void)downloadDataForURL:(NSURL*)url &#123; NSData *cachedData = [_cache objectForKey:url]; if (cachedData) &#123; // Cache hit [self useData:cachedData]; &#125; else &#123; // Cache miss EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data)&#123; [_cache setObject:data forKey:url cost:data.length]; [self useData:data]; &#125;]; &#125;&#125;@end 在这个例子中，是将下载的URL作为缓存的键。当找不到键对应的数据时，就去下载数据然后将其添加进缓存。这个花费是计算的数据长度。在创建缓存时，将缓存的总数设为100，将总花费设为5M，不过因为总花费单位是字节所以要进行换算。 还有一个类叫做NSPurgeableData，它是NSMutableData的子类，它实现了NSDiscardableContent协议，将它和NSCache配合使用会更强大。如果有对象的内存可以根据需要释放，那么就可以使用它。这意味着当系统资源变少时，可以释放NSPurgeableData数据。NSDiscardableContent协议还定义了一个叫做isContentDiscarded的方法，它可以返回对象内存是否被释放。 如果NSPurgeableData对象需要被访问，你可以调用beginContentAccess方法告诉它这期间不能被释放。当你使用完毕，你可以调用endContentAccess去告诉它可以根据需要释放了。这些调用可以嵌套，所以你可以像引用计数那样成对。仅当引用计数为0，对象才可以丢弃。 如果NSPurgeableData对象添加进NSCache，NSPurgeableData对象会自动从缓存中移除。可以通过设置缓存的evictsObjectsWithDiscardedContent属性去控制开启或者关闭。 使用NSPurgeableData对象对上面示例进行更改： 123456789101112131415161718192021- (void)downloadDataForURL:(NSURL*)url &#123; NSPurgeableData *cachedData = [_cache objectForKey:url]; if (cachedData) &#123; // Stop the data being purged [cacheData beginContentAccess]; // Use the cached data [self useData:cachedData]; // Mark that the data may be purged again [cacheData endContentAccess]; &#125; else &#123; // Cache miss EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data)&#123; NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data]; [_cache setObject:purgeableData forKey:url cost:purgeableData.length]; // Don&apos;t need to beginContentAccess as it begins // with access already marked // Use the retrieved data [self useData:data]; // Mark that the data may be purged now [purgeableData endContentAccess]; &#125;]; &#125;&#125; 注意当创建了一个NSPurgeableData对象时，它会自动加1“引用计数”，所以不需要特地调用beginContentAccess方法，但你必须在使用之后调用endContentAccess方法平衡计数。 小结 使用NSCache替代NSDictionary缓存对象，NSCache提供了对象自动清理行为，线程安全，并且不会像字典一样拷贝键。 使用数量限制和花费限制去定义删除缓存中内容的时机。但它们不是硬限制，它们只是一种指导。 使用NSPurgeableData和NSCache，可实现自动清除功能，当缓存清除时，数据对象也会被清除。 如果你正确使用缓存，会使你的应用程序更快的相应。缓存应该仅存储难以获得的数据，例如需要从网络或者磁盘读取的数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第六章]]></title>
      <url>%2F2017%2F07%2F08%2FBlocks%20and%20Grand%20Central%20Dispatch%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第六章：Block和GCD PS：不使用中文名字进行翻译 block ： block/Block GCD : Grand Central Dispatch 简介多线程开发是每个开发者都会遇到并需要考虑的情况。即使你不认为你的程序是多线程的，但其实它是，因为系统框架通常会在主线程之外做一些事情。最坏的情况就是UI线程被阻塞，应用程序挂起。在Mac OS X上，会有一个彩球一直转；在iOS上，如果阻塞过久，你的程序可能会终止。 幸运的是，苹果已经解决多线程的问题了。现代多线程的核心功能是block和GCD。从技术上讲，它们明显没什么关系，但它们是一起引入的。block提供了词法闭包，这对C、C++、Objective-C都是非常有用的，主要是提供了一种机制，让代码像对象一样传递，并运行在不同的环境下。重要的是，block可以使用它定义范围内的任何事物。 GCD是block的关联技术，基于派发队列概念提供线程的抽象。block可以被排进队列，GCD可以处理所有的事务。GCD会根据系统资源的情况，对每个队列进行创建，暂停，销毁等操作。而且，GCD可以提供很多易于使用的常见功能，例如单一线程代码安全执行，基于系统资源的并发。 现在的Objective-C项目中，block和GCD是主要部分之一。因此，你需要理解它们的功能以及工作原理。 理解Blockblock提供闭包。这项语言特性是作为GCC编译器的扩展，因此适用于所有的现在Clang版本(Clang是开发Mac OS X和iOS的编译器)。而运行期组件则需要Mac OS X 10.4和iOS 4.0之后才能支持block。语言功能是C级别的功能，因此只要运行期组件支持C、C++、Objective-C、Objective-C++的代码都可以使用block。 block的基础block跟函数很相似，但它定义在另一个函数的内部，和另一个函数更享作用域。block使用^符号作为标示，后面跟随一个作用域，作用域包含block的实现。例如，一个简单的block如下： 123^&#123; // Block implementation here&#125; block就是一个值，它也有自己的类型。就像int、float或者Objective-C对象，也可以把block赋值给一个变量，然后就像使用其他变量那样使用它。这种block类型语法跟函数指针很像。下面是一个简单block的例子，它没有参数和返回值： 123void(^someBlock)() = ^&#123; // Block implementation here&#125;; 这个block定义了一个叫做someBlock的变量。它可能看起来是奇怪的，因为它的变量名写在中间，但是一旦你理解了它的语法，它是非常易读的。block的结构语法如下： 1return_type (^block_name)(parameters) 定义一个block，它有两个int类型参数，返回值也是int类型，你会使用下面的语法： 1234int (^addBlock)(int a, int b) = ^(int a, int b) &#123; return a+b;&#125;; block的使用就像函数一样。例如，addBlock可以这样使用： 1int add = addBlock(2, 5); //&lt;add = 7 block还有一个强力的功能，就是允许访问它定义区域的变量。意思是任何适用于block定义范围的变量都适用于block内部。例如，你可以定义一个block然后使用另一个变量： 1234567int additional = 5;int (^addBlock)(int a, int b) = ^(int a, int b)&#123; return a+b+additional;&#125;;int add = addBlock(2, 5); //&lt;add = 12 默认情况下，被block捕捉的变量不能在block中修改。在上面的例子中，如果在block内部对additional变量进行修改，编译器将会编译错误。但是，可以在声明变量时使用特定字符__block修饰，这样就可以修改了。例如，block可以使用数组枚举去确定数组中多少元素小于2： 12345678NSArray *array = @[@0, @1, @2, @3, @4, @5];__block NSInteger count = 0;[array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) &#123; if ([number compare:@2] == NSOrderedAscending) &#123; count++; &#125;&#125;];// count = 2 这个例子也展示了如何使用内连block。这个block通过enumerateObjectsUsingBlock:方法声明为一个内连block，直接调用，并未赋值给一个本地变量。这种常用的代码模式展示了为什么block是非常有用的。在block成为语言的一部分之前，枚举方法只能调用函数指针或者选择器名字。状态不得不通过手动处理，通常使用不透明指针，因此需要额外的代码，并将它们分散在别的地方。声明一个内连block则可以使代码逻辑集中在一个地方。 当block捕捉一个对象类型的变量，它会偷偷的保留它。当block自身被释放时，这个变量才会释放。这就引出一个关于block的重大问题。一个block可以被看做一个对象。实际上，block可以像其他Objective-C对象一样响应许多选择器。重要的是block自身就像其他对象一样，它也有引用计数。当block最后的应用被移除时，block就会被销毁。因此，block捕捉的对象会在这时进行释放，以平衡捕捉时增加的引用计数。 如果block作为一个实例变量定义在一个Objective-C类中，那么可以使用self变量以及类的所有变量。使用实例变量时也永远不需要加上__block前缀。如果一个实例变量被block通过读或者写的方法捕获，它也会捕获self变量，因为实例变量与self持有的实例变量相关联。例如，一个叫做EOCClass的类里面有一个方法，方法里面使用一个block： 1234567891011@interface EOCClass- (void)anInstanceMethod &#123; // ... void (^someBlock)() = ^&#123; _anInstanceVariable = @&quot;Something&quot;; NSLog(@&quot;_anInstanceVariable = %@&quot;, _anInstanceVariable); &#125;; // ...&#125;@end 这个EOCClass的实例变量有一个叫做anInstanceMethod的方法，这个方法运行时会使用到self变量。你会非常容易忘记self变量被block捕捉了，因为代码中没有显示调用self。但是，访问实例变量与下面语法相同： 1self-&gt;_anInstanceVariable = @&quot;Something&quot;; 这就是为什么self变量会被捕捉。通常情况下，使用属性访问实例变量，在这种情况下，就要使用self变量了： 1self.aProperty = @&quot;Something&quot;; 但是，记着self是一个对象，当block捕捉了self，它会被保留。如果self也持有block，这种情况很容易造成循环引用。更多信息看第40节。 block的内部结构在Objective-C中，每一个对象都有一块固定的内存区域。每个对象的内存区域大小是不一样的，这取决于实例变量的个数和关联的数据。一个block也是一个对象，因此它内存区域的第一个变量是一个指向类的指针，叫做isa指针(看第14节)。block的其余内存里面包含各种它正常运行的信息。图6.1展示了block的细节。 Figure 6.1 一个block对象的内存分布。 在这个布局里面最重要的是那个叫做invoke的变量，它是一个函数指针，指向block的实现。函数原型至少有一个void*，它代表块本身。之前说过，block仅是替代函数指针的，之前使用函数指针时，通过使用不透明指针传递状态。而使用block之后，则可把C语言特性改为简单易用的接口。 descriptor变量是每一个block都会有的结构体的指针，声明了block对象的大小，函数指针的拷贝和释放方法。当block的拷贝和释放呗调用时就会运行这些方法，例如，将捕获的对象保留或者释放。 最后，block包含它所捕获的变量的拷贝。这些拷贝存储在descriptor变量后面，捕获多少变量就占用多少空间。请注意，拷贝的并不是这些对象本身，而是指向这些对象的指针变量。当block运行时，被捕捉的变量从内存中被读取，这就是为什么block需要通过参数传递进invoke函数。 全局block、堆block、栈block PS : 经我本人验证，下面的block并不会像书中一样，出了if或者else的区域就被释放，ARC/MRC我都试过。所以各位看书的时候，请自行实验。但是除了例子举的有问题外，别的并无问题。个人看法，欢迎讨论。 当定义block时，它初始化的内存地址是在栈上。这意味着该block仅在它定义的范围内有效。例如，下面的代码是有风险的： 1234567891011void (^block)();if ( /* some condition */ ) &#123; block = ^&#123; NSLog(@&quot;Block A&quot;); &#125;;&#125; else &#123; block = ^&#123; NSLog(@&quot;Block B&quot;); &#125;;&#125;block(); 两个block定义在if和else判断里面，初始化在栈内存上。当每个block初始化栈内存后，编译器都会在内存作用域的最后对它们进行释放。所以每个block仅在它们所在的判断语句内是有效的。这段代码没有任何编译错误，但是在运行时可能出现函数错误。如果被释放的内存没有被重写，代码不会有错误，但是如果重写了，程序将会崩溃。 为了解决这个问题，可以在对block进行拷贝。这样做的原因是可以将block从栈区拷贝到堆区。一旦将其拷贝到堆区，block就可以在它定义区域外使用了。而且，一旦将它拷贝到堆区，block也拥有引用计数了。后续的拷贝操作都不会再真的拷贝只是增加block的引用计数。当一个堆block不再被持有，它需要被释放，如果使用ARC，它会自己释放，如果使用MRC，就手动调用release。当它的引用计数为0时，堆block就像对象一样被释放。栈block不需要手动释放，因为栈的内存是由系统自动释放的，刚才那段代码之所以会有问题就是因为这个原因。 现在，你可以简单的对其使用copy方法使其代码安全： 1234567void (^block)();if ( /* some condition */ ) &#123; block = [^&#123; NSLog(@&quot;Block A&quot;);&#125; copy];&#125; else &#123; block = [^&#123; NSLog(@&quot;Block B&quot;);&#125; copy];&#125; block(); 现在代码是安全的了。如果使用了MRC，需要在最后释放block。 全局block是另一个概念，它不同于堆block和栈block。全局block不捕捉任何状态，例如外围的变量，运行时也不需要状态参与。它的内存地址是在编译时就可以确定的；所以全局block是声明在全局内存中的而不是每次使用都从栈中创建。另外，对全局block使用拷贝也是无效的，因为一个全局block不会被释放。所以这样的block实际上就是一个单例。下面是一个全局block： 123void (^block)() = ^&#123; NSLog(@&quot;This is a block&quot;);&#125;; 全局block的所有信息都必须在编译时就确定。这是一种优化技术；如果简单的block还需要在栈上和堆上做拷贝或释放，等于多做一些无用的操作。 小结 block是一种适用于C、C++、Objective-C的语义闭包。 block参数和返回值都是可选的。 block可以在栈上、堆上、全局初始化。一个栈block可以拷贝到堆上面，这样它就会像其余的Objective-C对象一样，拥有自己的引用计数。 使用typedefs创建通用blockblock具有固有类型；因而，可将其赋给适当的类型变量。block的类型由参数和返回值组成。例如，下面的block： 1234567^(BOOL flag, int value)&#123; if (flag) &#123; return value * 5; &#125; else &#123; return value * 10; &#125;&#125; 这个block有两个参数，分别是Bool型和int型，以及一个int型的返回值。如果要将其赋给一个变量，这个block需要适当的类型。赋值变量的类型是像这样的： 1234int (^variableName)(BOOL flag, int value) = ^(BOOL flag, int value) &#123; // Implementation return someInt;&#125; 这个看起来跟正常类型由很大差别，但如果你使用函数指针，你会感觉到熟悉。这个类型如下： 1return_type (^block_name)(parameters) block变量的定义与普通类型是不同的，它的变量名在中间而不是在右边。这造成它的语法难以记忆和阅读。因此，有一个好办法是为通用block定义类型，特别是你给别人提供API时。你可以起个好读的名字表示block的用途并将它的类型隐藏在后面。 为了隐藏block的复杂类型，你可以使用C语言的一个功能去定义类型。这个功能的关键字是typedef，使用它可以定义一个易于阅读的名字，使它成为类型别名。例如，使用类型定义给一个block定义新的类型，这个block接受一个int参数和一个Bool参数并返回一个int值： 1typedef int(^EOCSomeBlock)(BOOL flag, int value); 就像之前block变量的命名一样名字在^符号右边，新的类型名字也是这样。这条语句向系统增加了一个叫做EOCSomeBlock的类型。所以当你再次创建同类型变量时，你可以使用这个新类型： 123EOCSomeBlock block = ^(BOOL flag, int value)&#123; // Implementation&#125;; 现在这代码就易于阅读了，它就像你平时使用的变量一样定义，类型在左，变量名在右。 使用这个功能可以把API中的block做的更为易用。类里面有些方法可能需要使用一个block参数，例如，一个异步任务完成时的回调，使用这个功能可以使得代码易于阅读。考虑一个情况，一个类有一个叫做start的方法，它有一个在任务结束时调用的block参数。如果没有使用类型定义，这个方法可能是这样的： 1- (void)startWithCompletionHandler:(void(^)(NSData *data, NSError *error))completion; 注意，在方法中的block参数和block变量的语法是不同的。如果方法中block参数可以是一个单词，那么就易读多了。所以你可以定义一个类型信息并且代替它： 12typedef void(^EOCCompletionHandler)(NSData *data, NSError *error);- (void)startWithCompletionHandler:(EOCCompletionHandler)completion; 这样的参数是容易阅读和理解的。更好的是，现在的IDE都是自动支持这种类型定义的，这使得它更易于使用。 如果你想重新构建block的函数时，使用类型定义也是非常有用的。例如，如果你现在想给block添加一个参数，你只需要简单修改类型定义： 1typedef void(^EOCCompletionHandler)(NSData *data, NSTimeInterval duration, NSError *error); 任何使用了这个类型定义的地方，例如方法签名，都会编译失败，然后你可以逐个修复。如果没有类型定义，你需要逐个找到你需要修改的代码。这很容易遗忘一两处，导致难以排查的bug。 通常在使用block类型定义的类中定义它们。也会给类型block添加类名作为前缀。这使得block的用途非常清楚。还可以使用typedef定义更多的别名。这是多多益善的。 在Mac OS X和iOS中的Account框架是有这种例子的。在框架中可以找到下面两个类型定义： 12typedef void(^ACAccountStoreSaveCompletionHandler) (BOOL success, NSError *error);typedef void(^ACAccountStoreRequestAccessCompletionHandler) (BOOL granted, NSError *error); 这两个block都相同的签名，但使用在不同的场景。签名中的类型名字和参数名字可以让开发者很容易理解这个block怎么使用。也可以将这两个block定义为一个单一类型定义，可能统称ACAccountStoreBooleanCompletionHandler，在两个地方都适用它。但是，这样做会使得block的用途不是那么清楚了。 相似的，如果你有几个类都执行相似但不同的异步任务，并且无法放在一个继承中，那么每个类都应该有它自己的block类型定义。可能每一个block的签名都是相同的，但那也好过让每个类都适用同一个block。另一方面，如果这些类可以从一个基类继承，你可以将block类型定义放在基类中，然后让每个子类使用它。 小结 使用类型定义可以使得block变量更易于使用。 定义block名字时务必遵守当前规则，使其不与其他类型冲突。 给相同签名block定义多个别名。当你想重构的代码使用了其中某个别名，只需修改相应typedef中的签名，无须改动其他别名。 使用block去减少代码分离在编写项目时，有一个常用的范例是用户接口需要去执行异步任务。这样当执行长时间的任务时，不会阻塞用户界面的显示和触摸所用的线程，例如文件I/O或者网络请求。这个线程就是我们提到的主线程。如果执行任务的线程是同步的，当任务执行时，用户界面的任何操作都无法响应。在某些情况下，如果应用停止响应一段时间，它将会被自动终结。这是真实存在于iOS应用的；如果主线程长时间被阻断，系统监视器会终结应用。 异步方法需要用过某种方式去通知相关代码任务执行完毕。这有很多实现办法。通用的一个办法就是设计一个协议，让某个对象遵守它。这个对象成为被委托者后就可以在结束时得到通知了，例如一个异步任务的完成。 考虑下面这个从URL获取数据的类。使用委托模式，这个类大概是这样的： 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;@class EOCNetworkFetcher;@protocol EOCNetworkFetcherDelegate &lt;NSObject&gt;- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(NSData*)data;@end@interface EOCNetworkFetcher : NSObject@property (nonatomic, weak) id &lt;EOCNetworkFetcherDelegate&gt; delegate;- (id)initWithURL:(NSURL*)url;- (void)start;@end 某各类可能会这样使用这种API： 123456789101112- (void)fetchFooData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;]; EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; fetcher.delegate = self; [fetcher start];&#125;// ...- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(NSData*)data &#123; _fetchedFooData = data;&#125; 这种方法也不是有问题。但是，block可以使得代码非常清晰。block可以使API变得更加紧凑，并且让使用者更容易使用。这需要定义一个block类型，将其作为完成handler，然后作为参数直接传给start方法： 123456789#import &lt;Foundation/Foundation.h&gt;typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);@interface EOCNetworkFetcher : NSObject- (id)initWithURL:(NSURL*)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;@end 这种做法跟使用委托协议是很像的，但是它在start方法中直接加入了内联block，这可以提升代码的阅读性。例如，考虑使用block风格的API： 1234567- (void)fetchFooData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;]; EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data)&#123; _fetchedFooData = data; &#125;];&#125; 对比委托和block两种方式的代码会发现block这种代码更简洁。异步执行完毕后的逻辑代码和开始任务的代码都在一起。而且，由于block定义在网络获取器的范围内，你可以访问这个范围内的所有变量。在这个简单的例子中，优势不是很明显，但在复杂场景下，就可以看到优势了。 委托模式有一个缺点，就是如果一个类使用了多个网络请求去下载不同的数据，它需要在委托方法中根据不同的网络下载器去处理不同情况。代码如下： 12345678910111213141516171819202122- (void)fetchFooData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;]; _fooFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; _fooFetcher.delegate = self; [_fooFetcher start];&#125;- (void)fetchBarData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/bar.dat&quot;]; _barFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; _barFetcher.delegate = self; [_barFetcher start];&#125;- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(NSData*)data &#123; if (networkFetcher == _fooFetcher) &#123; _fetchedFooData = data; _fooFetcher = nil; &#125; else if (networkFetcher == _barFetcher) &#123; _fetchedBarData = data; _barFetcher = nil; &#125; // etc.&#125; 这种做法会使得委托方法的回调代码变长，网络下载器必须存储为一个实例变量。这样做可能是因为别的原因，例如稍后取消下载，但是它终究会使得类的代码激增。这就是block的优势了，它不需要存储网络获取器，也不需要去做切换。每个回调block的逻辑是定义在每个网络获取器那里的，像这样： 1234567891011121314- (void)fetchFooData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;]; EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data)&#123; _fetchedFooData = data; &#125;];&#125;- (void)fetchBarData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/bar.dat&quot;]; EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data)&#123; _fetchedBarData = data; &#125;];&#125; 这种写法还可以进行扩展，许多现在的基于block的API还有一个用于处理错误的block。有两个方法可以做到这点。第一个是将成功的block与失败的block分开实现。第二个是将两种情况写在一个block里面。使用分开情况大概是这样的： 12345678910#import &lt;Foundation/Foundation.h&gt;@class EOCNetworkFetcher;typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);typedef void(^EOCNetworkFetcherErrorHandler)(NSError *error);@interface EOCNetworkFetcher : NSObject- (id)initWithURL:(NSURL*)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion failureHandler:(EOCNetworkFetcherErrorHandler)failure;@end 使用这种风格的API是这样的： 12345678EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];[fetcher startWithCompletionHander:^(NSData *data)&#123; // Handle success&#125; failureHandle:^(NSError *error) &#123; // Handle failure&#125;]; 这种格式非常好，因为分割了成功和失败两种情况，这意味着使用者可以将成功和失败的逻辑分开。而且，如果需要忽略成功或失败的情况，也是非常容易的。 另一种类型，是将成功情况和失败情况放进同一个block，就像这样： 12345678#import &lt;Foundation/Foundation.h&gt;@class EOCNetworkFetcher;typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data, NSError *error);@interface EOCNetworkFetcher : NSObject- (id)initWithURL:(NSURL*)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;@end 使用这种风格的代码是这样的： 12345678EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];[fetcher startWithCompletionHander: ^(NSData *data, NSError *error)&#123; if (error) &#123; // Handle failure &#125; else &#123; // Handle success &#125;&#125;]; 这种方法需要判断错误变量并需要将所有逻辑放在一个地方。它有一个坏处，因为所有的逻辑都在一个地方，这会使得这个block变得庞大和复杂。但是，这种单一block是非常灵活的。例如，传入错误的同时也能传入数据。考虑这种情况，数据下载到一半发生错误了。这种情况下，可以把数据和相关错误回传给block。这样的话，就可以处理这个问题并可能利用这些成功的数据做一些事情。 把成功和失败情况放入同一个block的另一个原因是当处理成功数据时，使用者发现了一个错误。例如，返回数据太短。这种情况可能需要按网络获取器发生错误时处理一致。如果成功和失败情况分开写在两个block里面，那这就没办法共享一份代码了，如果将方法放在别处处理，那又违反我们使用block将逻辑放在一起的概念了。 总体来说，我建议将错误情况和成功情况放在同一个block内，苹果公司似乎也是使用的这种思路。例如，Twitter框架中的TWRequest和MapKit框架中的MKLocalSearch，它们都使用了单一block处理。 有时需要在某些时间点进行回调。例如，一个网络获取器的使用者可能想在每个下载进度变化时获得回调。委托也可以做到这个。不过继续使用block，你可添加一个进度处理类型的block和一个属性： 12typedef void(^EOCNetworkFetcherCompletionHandler) (float progress);@property (nonatomic, copy) EOCNetworkFetcherProgressHandler progressHandler; 这种模式很好，它将所有的逻辑放在了同一个地方：网络获取器的创建和进度block的定义。 当写处理API时，某些代码需要运行在一个确定的线程。例如，任何Cocoa和Cocoa Touch的UI工作都必须发生在主线程。这相当于GCD中的主队列。因此，最好由API的使用者来决定它在哪条线程上运行。有这样一个API就是NSNotificationCenter，它有一个方法可以让注册者注册某个通知，等到收到通知时，就会在指定的线程执行注册好的那个block。可以给回调block指定一个线程，但不是必须的。如果没有指定线程，它就会运行在发送时的线程上。这个添加观察者的方法如下： 1234- (id)addObserverForName:(NSString*)name object:(id)object queue:(NSOperationQueue*)queue usingBlock:(void(^)(NSNotification*))block; 这里有一个参数是使用NSOperationQueue对象指定在哪个线程上运行的。这是操作队列而不是更深层次的GCD队列，但是语义是相同的(第43节详细讲述了GCD队列与其他的区别)。 你也可以根据自己的业务去设计API，根据所需的实现细节去选择使用操作队列或者GCD队列。 小结 当创建对象时，可以将逻辑以内联block的方法一并声明。 当有多个网络获取器实例时，block是比委托模式更具有优势的。 当设计API时如果用到了处理block，可以考虑让使用者通过一个参数去指定回调的线程。 避免block引用对象时产生循环引用如果没有考虑清楚，block很容易产生循环引用。例如，下面的类提供一个接口，用于下载某个URL的资源。当获取器开始使用时可以设置一个回调block，当下载结束时调用block。为了在下载结束时调用block，需要将其存储在一个实例变量中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// EOCNetworkFetcher.h#import &lt;Foundation/Foundation.h&gt;typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);@interface EOCNetworkFetcher : NSObject@property (nonatomic, strong, readonly) NSURL *url;- (id)initWithURL:(NSURL*)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;@end// EOCNetworkFetcher.m#import &quot;EOCNetworkFetcher.h&quot;@interface EOCNetworkFetcher ()@property (nonatomic, strong, readwrite) NSURL *url;@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;@property (nonatomic, strong) NSData *downloadedData;@end@implementation EOCNetworkFetcher- (id)initWithURL:(NSURL*)url &#123; if ((self = [super init])) &#123; _url = url; &#125; return self;&#125;- (void)startWithCompletionHandler: (EOCNetworkFetcherCompletionHandler)completion &#123; self.completionHandler = completion; // Start the request // Request sets downloadedData property // When request is finished, p_requestCompleted is called&#125;- (void)p_requestCompleted &#123; if (_completionHandler) &#123; _completionHandler(_downloadedData); &#125;&#125;@end 另一个使用的类可能创建一个网络获取器，使用它去下载一个URL的数据，就像这样： 1234567891011121314151617@implementation EOCClass &#123; EOCNetworkFetcher *_networkFetcher; NSData *_fetchedData;&#125;- (void)downloadData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData *data)&#123; NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url); _fetchedData = data; &#125;];&#125;@end 这段代码看起来非常正常。但你可能没发现里面有一个循环引用。即完成处理block引用了self，因为它使用了_fetchedData实例变量。EOCClass的实例创建并持有了网络获取器。网络获取器持有了这个block。图6.2说明了这个循环引用。 Figure 6.2 网络获取器和类实例的循环引用。 这个循环引用可以很轻松的打破，通过令类不再引用_networkFetcher实例变量或者网络获取器类不再引用completionHandler。在这个例子中，这种破坏需要在completionHandler结束时进行，所以网络获取器是一直活跃的直到它释放。例如，completionHandlerblock可以这样修改： 123456[_networkFetcher startWithCompletionHandler:^(NSData *data)&#123; NSLog(@&quot;Request for URL %@ finished&quot;, _networkFetcher.url); _fetchedData = data; _networkFetcher = nil;&#125; 循环引用这种问题在使用完成block的API中是很常见的，所以理解它就很重要。通常，可以通过在合适时机将一方释放解决问题；但是，不是总有这种机会的。在这个例子中，是因为completionHandler运行了，循环引用才被打破。如果completionHandler永远没运行，那么循环引用永远不会打破，就会造成内存泄露。 使用completionHandlerblock还有另一种循环引用的情况。那就是当completionHandlerblock引用的对象也引用了block本身就会发生循环引用。例如，将前面的例子稍作扩展，不在运行期间保留网络获取器的引用，而是使用别的机制另其存货。那么可能会将其加入一个全局的集合，比如set集合，开始时加入其中，结束时将其移除。那么使用者可能会这样修改代码： 12345678910- (void)downloadData &#123; NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;]; EOCNetworkFetcher *networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [networkFetcher startWithCompletionHandler:^(NSData *data)&#123; NSLog(@&quot;Request URL %@ finished&quot;, networkFetcher.url); _fetchedData = data; &#125;];&#125; 多数的网络库使用这种方法，因为令使用者自己保持这个对象是麻烦的。有一个例子是Twitter框架中的TWRequest类。但是，以EOCNetworkFetcher的代码来看，还是会产生循环引用。这比之前更难以发现，completionHandlerblock会使用网络获取器的url，而网络获取器又会通过completionHandler属性持有block。幸运的是，这是很容易解决的。之所以保存completionHandler属性是因为要在稍后使用它。一旦使用完毕，就不再需要持有这个block了。所以可以这样简单的解决这个问题： 123456- (void)p_requestCompleted &#123; if (_completionHandler) &#123; _completionHandler(_downloadedData); &#125; self.completionHandler = nil;&#125; 一旦请求执行完毕，就可以解除循环引用了，然后获取器对象也会在需要的时候释放掉。注意将completionHandler放在start方法中是很好的主意。因为如果将completionHandler暴漏为一个公共属性，你不能在请求结束时将其清空，因为跟你将其设为公共属性的语义不符。这种情况下，只有一种方法可以打破循环引用，那就是使用者自己清空completionHandler属性。但这不是很合理，因为你不能假定一个使用者一定会去做这件事，然后它们会反过来责怪你没处理好内存泄露。 这两种循环引用的情况都很常见。当使用block时很容易产生bug。当然，如果你小心谨慎，它们也是很容易解决的。关键就是考虑清楚block会捕捉哪些对象。如果这些对象中的任意一个对象持有了block，不论是直接持有还是间接持有，都要考虑清楚如何在一个恰当时机打破循环引用。 小结 当block捕捉的对象也捕捉了block时，小心循环引用这种问题。 考虑一个打破循环引用的合适时机，但不要依赖API的使用者自己去打破。 多用Dispatch Queue少用同步锁在Objective-C中，如果你多个线程执行同一份代码可能会遇到一些问题。通常使用锁来解决这个问题。在GCD之前，有两个办法可以解决这个问题，第一个就是构建一个同步block: 12345- (void)synchronizedMethod &#123; @synchronized(self) &#123; // Safe &#125;&#125; 这个结构会自动创建一个基于给定对象的锁，并且直到block里面的代码执行完毕才会解锁。在block代码的最后，锁会自动解除。在这个例子中，同步行为的对象是self。这通常是一个好的选择，因为它能确保对象的每个实例可以同步的运行其同步方法。但是@synchronized(self)的过度使用会带来性能问题，使用相同同步锁的block会按顺序执行。如果你对self进行了大量的同步锁，你不得不等待一些无关紧要的代码的结束。 另一种做法是直接使用NSLock对象： 123456_lock = [[NSLock alloc] init];- (void)synchronizedMethod &#123; [_lock lock]; // Safe [_lock unlock];&#125; 也可以使用NSRecursiveLock这种递归锁，它允许线程多次持有它，并且不会导致死锁。 这两种方法都是好的，但也有它们的缺点。例如，同步block会在极端情况下会导致死锁并且会影响性能。当发生死锁时，直接使用锁会非常麻烦。 对它们可以使用GCD进行替代，它可以提供一套高效和易于管理的锁。属性由于其特性经常会被开发者做成同步的，这时会将其特质设为atomic。使用atomic属性特质可以达到这个效果。或者，如果是手动书写，下面的代码是常用的： 12345678910- (NSString*)someString &#123; @synchronized(self) &#123; return _someString; &#125;&#125;- (void)setSomeString:(NSString*)someString &#123; @synchronized(self) &#123; _someString = someString; &#125;&#125; 重申如果滥用@synchronized(self)是危险的，因为所有这样的block都会抢夺同一个锁。如果多个属性都这样做，每个block都要等它之前的运行完，这肯定不是你想要的。我们只是想令每个属性独立的同步。 顺便说下，你应该知道这只是在某种程度上确保了线程安全，它不能确保绝对安全。当然，访问的属性肯定是原子性的。当你使用属性时，你想确保得到有效的结果，但是当你多次从同一个线程获取值时，可能每次获取的结果不一样。另外的线程可能在访问时对属性进行了修改。 一个简单高效的替代同步block或者锁对象的方法是使用一个连续的同步队列。不论是读还是写都在同一个同步队列中。这样做大概是这样的： 123456789101112131415161718192021_syncQueue = dispatch_queue_create(&quot;com.effectiveobjectivec.syncQueue&quot;, NULL);- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString*)someString &#123; dispatch_sync(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这个模式的思路是所有访问属性的操作都是同步的，因为GCD队列可以确保setter和getter方法运行在一个连续队列上。getter中的__block语法部分，是用于允许block可以设置本地变量，这种方法是更整洁的。所有的加锁都是在GCD中处理的，GCD是一个是现在非常底层的功能，所以它有很多优化。因此，你不需要担心别的事情，只需要聚焦在你的访问器代码上即可。 但是，我们还可以尽一步优化。setter方法不一定需要是同步的。设置实例变量的block不需要返回任何内容。这个意思是你可以这样修改setter方法： 12345- (void)setSomeString:(NSString*)someString &#123; dispatch_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这个简单的变化是从同步派发变为异步派发，从调用者的角度看，它可以使得setter方法执行的更快，而读和写操作仍然会按序执行。如果你测试了性能，你可能发现它是更慢的；因为异步派发需要拷贝block。如果拷贝block的时间大于执行block的时间，那么它是慢的。所以在我们简单的例子中，它是变慢了的。但是这种方法仍是一个好的候选方法，如果block中执行的是非常重的任务。 利用getter方法可以同时发生，getter跟setter需要顺序执行这一点可以进行优化。此时正体现出GCD方法的好处。使用同步block或者锁是没办法轻易做到这个的。不使用连续队列，考虑当使用并发队列时会发生什么： 123456789101112131415_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString*)someString &#123; dispatch_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 按照目前的情况来看，上述代码不是同步执行的。所有的读和写操作执行在同一条队列上，但是队列是并发的，读和写可以在同时发生。我们恰恰想阻止这一点。但是，GCD有一个简单的叫做栅栏的功能，是适用于这种情况的。这个功能是一个队列栅栏： 12void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block); 栅栏必须单独执行不能跟其他队列并行。它是只作用于并发队列的，因为所有的串行队列都是按顺序执行的。当一个队列发现下一个执行的是栅栏block，队列会等所有的当前block执行完毕再去执行栅栏block。当栅栏block执行完毕，队列再向下正常执行。 栅栏可以用在例子中的setter方法内。如果setter方法使用了栅栏，属性读取将同时发生，但是写只能单独执行。图6.3展示了许多读和单一写的队列。 Figure 6.3 并发队列中正常block的读和栅栏block的写。读并发执行；写单一执行，如同栅栏。 实现代码很简单： 1234567891011121314151617_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString*)someString &#123; dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 如果你进行性能测试，你肯定会发现它是比使用串行队列快的。你可以在setter中使用同步栅栏，它可能会更高效，原因如之前所说的一样。每一种性能优化的方法和选择都要基于你的使用场景。 小结 派发队列可以用来提供同步场景，可以用来替代@synchronizedblock和NSLock对象。 将同步与异步派发结合起来一样可以提供同步行为，并且也不会造成线程阻塞。 并发队列和栅栏block使用同步行为更高效。 多使用GCD，少使用performSelector及其相关方法由于Objective-C的动态派发，NSObject中有几个定义的方法，允许你调用任何方法。它们允许延迟执行方法或者指定在某个线程执行。它们是非常有用的功能；但是现在，GCD和block的出现使得它们的重要性大大减少。尽管你经常看到使用它们的代码，但我建议你清理掉它们。 这一系列方法中最基础的那个是performSelector:。它只有单一一个参数，那就是需要执行的选择器，下面是方法签名： 1- (id)performSelector:(SEL)selector 它等价于直接调用这个方法。所以下面两行代码等价： 1[object performSelector:@selector(selectorName)]; [object selectorName]; 它看起来好像是多余的。如果它只能这样用那当然是。但是它真是的强大是可以在运行时决定运行哪个选择器。这样的动态绑定机制意味着你可以这样做： 123456789101112SEL selector;if ( /* some condition */ ) &#123; selector = @selector(foo);&#125; else if ( /* some other condition */ ) &#123; selector = @selector(bar);&#125; else &#123; selector = @selector(baz);&#125;[object performSelector:selector]; 这种代码非常灵活并且可以简化复杂的代码。另外也可以存储一个选择器，在之后的某个时候执行它。在这种情况下，不到运行时编译器无法知道它要执行哪个选择器。但是使用它的代价是，如果你在ARC环境下，编译器将会发出警告： 12warning: performSelector may cause a leak because its selectoris unknown [-Warc-performSelector-leaks] 你可能没料到这点！如果你知道，你可能会理解为什么使用这些方法要小心了。这个警告信息看起来非常奇怪，为什么会担心可能发生内存泄露。最重要的是，你只不过简单的尝试去调用一个方法。这个原因是编译器不知道什么选择器会被调用，因此无法知道方法签名，返回类型甚至会不会有返回值。由于编译器无法知道方法名因此无法通过ARC的内存规则去确定返回值是否该释放。因此，ARC出于谨慎的做法就不会给他添加释放。但是，如果返回的值是一个已经被保留，这样的结果可能会导致内存泄露，。 考虑下面的代码： 123456789SEL selector;if ( /* some condition */ ) &#123; selector = @selector(newObject);&#125; else if ( /* some other condition */ ) &#123; selector = @selector(copy);&#125; else &#123; selector = @selector(someProperty);&#125;id ret = [object performSelector:selector]; 在上面的例子中有轻微的差别用于展示这个问题。在前两个选择器重，ret对象需要通过代码释放；第三个选择器则不需要。不仅在ARC下应该这样做，在MRC也应该这样做，这样才严格遵守了方法命名规范。不使用ARC(因此没有编译警告)，如果第一个或第二个条件为真，ret对象需要被释放，其余不需要。这是很容易被忽略的，就算使用静态分析器也很难找到内存泄露的地方。这就是为什么要弃用performSelector相关方法的原因。 另一个原因是，这些方法只能返回对象或者void。尽管执行的选择器可能返回类型是void，但是performSelector方法返回的类型是id。如果想要返回整数或者浮点数，那么就需要复杂的类型转化，这是不安全的。由于id类型代表的是任意Objective-C对象，从技术上讲，只要返回值大小和指针大小相同即可，在32位架构下，任何类型都是32位，在64位架构下，任何类型读时64位的。如果返回值是一个C的结构体，performSelector方法就不能使用了。 performSelector还有不同的变体，可以在发送消息时传递参数： 12- (id)performSelector:(SEL)selector withObject:(id)object- (id)performSelector:(SEL)selector withObject:(id)objectA withObject:(id)objectB 例如，这个变体可以设置对象中名为value的属性值： 123id object = /* an object with a property called &apos;value&apos; */;id newValue = /* new value for the property */;[object performSelector:@selector(setValue:) withObject:newValue]; 这个方法看起来是有用的，但它也有一个严重的限制。由于参数是id，所以传递的参数必须是一个对象。如果是整形或者浮点型，这些方法就不能用了。另外，使用这个方法的某个变体最多可以传递两个参数，即performSelector:withObject:withObject:。它没有办法执行参数多于两个的选择器。 performSelector的系统方法中另外一些方法还可以延时执行或者在另一个线程执行。这些方法中比较通用的如下： 123456789101112- (void)performSelector:(SEL)selector withObject:(id)argument afterDelay:(NSTimeInterval)delay- (void)performSelector:(SEL)selector onThread:(NSThread*)thread withObject:(id)argument waitUntilDone:(BOOL)wait- (void)performSelectorOnMainThread:(SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait 但是，这些方法有更多的限制。例如，延后执行的方法不可以执行带有两个参数的选择器。在指定线程执行的方法也出于同样的理由限制很大。如果想使用这些方法就需要将这些参数打包在一个字典中然后再方法中将其一个一个取出来，这会增加消耗并可能带来潜在的bug。 所有的这些限制都可以通过使用其他方法解决。主要就是使用block(看第37节)。而且，performSelector系列方法带来的效果都可以使用GCD达到。延后执行可以使用dispatch_after，在另一个线程执行可以使用dispatch_sync和dispatch_async。 例如，去延后执行一个任务，你应该使用后面的格式： 123456789// Using performSelector:withObject:afterDelay:[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];// Using dispatch_afterdispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; [self doSomething];&#125;); 在主线程执行任务： 12345678// Using performSelectorOnMainThread:withObject:waitUntilDone:[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];// Using dispatch_async// (or if waitUntilDone is YES, then dispatch_sync)dispatch_async(dispatch_get_main_queue(), ^&#123; [self doSomething];&#125;); 小结 使用performSelector系列方法有潜在的内存管理问题。如果没办法确定要执行哪个选择器，ARC编译器无法插入恰当的内存管理代码。 使用performSelector系列方法限制非常大，例如返回类型和数字参数都无法使用。 想让方法在某个线程上执行，最好使用GCD来实现。 掌握GCD和操作对象的使用时机GCD是一种非常棒的技术，不过有时使用系统标准库会有更好的效果。要知道所使用的每个库的使用时机，如果使用了不合适的库，会使代码难以管理。 能与GCD的功能机制相媲美的很少。对于那种只执行一次的代码，使用dispatch_once(看第45节)是最好的选择。但是，对于在后台执行任务，使用GCD并不是最好的选择。一种与GCD不同但有关系的技术，叫做NSOperationQueue，允许你去将操作以NSOperation的子类的形式放入队列中，它也可以进行并发操作。它与GCD的相似不是一个巧合。操作队列出现在GCD之前，GCD是基于某些操作队列流行的理念设计的。实际上，从iOS 4和Mac OS X 10.6之后，操作队列的底层都是使用GCD实现的。 两者的第一个不同点是GCD是一个纯C的API，操作队列是一个Objective-C对象。在GCD中任务用block表示，block是一个轻量级的数据结构。另一方面，操作对象是一个Objective-C对象，因此它是更重的。这也就是说，GCD并不总是最好的选择。有时，使用对象带来的好处是远远大于它的消耗的。 使用NSBlockOperation和NSOperationQueue的addOperationWithBlock:方法，操作队列的语法和GCD非常相似。这里列举了一些使用NSOperation和NSOperationQueue的优点： 取消操作队列 使用操作队列是非常简单的。在运行任务之前，可以在NSOperation上调用cancel方法，该方法会设置一个内部标示符去告诉队列这个任务不需要运行了，但是它不能取消已经开始的操作队列了。另一方面，GCD没有办法取消未开始的操作队列。GCD那套架构是加入队列之后就不管了。你也可以在应用层实现取消功能，但那需要大量的代码，而操作队列已经实现了这个功能。 操作队列依赖 一个操作队列可以依赖其他多个操作队列。这样可以创建一个操作队列继承机制，即某个确定的操作队列可以在别的操作队列完成之后再执行。例如，你想从服务器下载一个文件，但是首先需要先下载一个清单文件。依赖可以让其余的下载操作队列在下载完清单文件之后再进行。如果操作队列被设置为并发执行，后续的下载可以同时执行，但是需要清单文件下载完毕。 操作队列属性的KVO 操作队列会有许多可以使用KVO观测的值，例如isCancelled去确定是否取消操作队列，isFinished去确定操作队列是否完成。如果像知道一个任务的状态或者比GCD更详细的观测，使用KVO是非常有用的。 操作队列的优先级 在一条队列中，每个操作队列都有它自己的优先级。高优先级的操作队列是要早于低优先级的。这个操作队列算法虽然是不透明的，但肯定经过认真思考。GCD没有办法直接做到类似事情。它没有任务优先级，但它可以给整条队列队列设置优先级而不是单个block。而令你自己在GCD上写调度算法，又是你所不愿意的。因此，操作队列提供的优先级设置功能是比GCD更适合的。 NSOperations也有自己的线程优先级，它决定了操作队列运行在哪条线程上。你在GCD上也可以做，但操作队列使用属性去控制是更简单的。 操作队列的重用 除非你使用系统构建的NSOperation的子类，例如NSBlockOperation，否则你必须自己创建子类。这个类可以生成正常的Objective-C对象，也可以存储你想存储的信息。对象在运行时可以使用存储的信息，也可以调用类中任意的方法。这使得它比派发队列中单一的block更强大。这些NSOperation类可以重复使用，它遵循软件开发中的不重复原则。 如你所见，有许多原因去使用操作队列而不是派发队列。操作队列提供了大多数你在开发时会用到的功能。不需要你自己去实现复杂功能，例如取消队列和队列优先级，这些操作队列都已经处理好了。 另一个API使用了操作队列而不是派发队列的是NSNotificationCenter，它有一个方法可以让注册者通过一个block而不是选择器去监听通知。这个方法原型如下： 1234- (id)addObserverForName:(NSString*)name object:(id)object queue:(NSOperationQueue*)queue usingBlock:(void(^)(NSNotification*))block 相比于操作队列，这个方法也能通过派发队列去实现。但它并没有这样做，这个设计者只使用了高层的Objective-CAPI。在这个情况下，两者并无性能的差别。设计者可能不想使用派发队列，因为那需要使用GCD；注意block不是GCD，block并不需要依赖GCD。也可能是设计者只想保持所用的都是Objective-C功能。 你可能经常听到你应该使用高层API，仅在需要时使用底层API这种说法。我认为它说的没问题，但我并不盲从。某些功能确实高层的Objective-CAPI可以实现，但底层并不一定比他差。最好的办法还是由性能来决定。 小结 在解决多线程和任务管理时，GCD并不是唯一选择。 Objective-C提供了一种高层次的API，它叫做操作队列，它可以实现大多数GCD能做到的事情。操作队列还做了一些复杂的操作，GCD也可以做到这些复杂操作，但是需要额外的代码。 通过dispatch group机制，根据系统资源状况来执行任务dispatch group是一个GCD功能，它可以让你很轻易的将任务分组。你可以将任务放在一个集合中，当集合中任务执行完毕，你会收到一个回调。这个功能是非常有用的，首先是当你想执行多个并发任务，并想在它们都结束之后做些什么。例如，可以把压缩一系列文件的任务放在一个任务组中。使用下面的函数创建dispatch group： 1dispatch_group_t dispatch_group_create(); dispatch group是一个简单的数据结构，结构之间没有什么不同，它不像派发队列，派发队列是有标示符的。你有两种办法可以将任务加入组内。第一种是使用下面的函数： 1void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 这是正常dispatch_async函数的一个变种，它多了一个派发组参数，它将block任务关联进组内执行。第二个将方法关联进组内的办法是下面这对函数： 12void dispatch_group_enter(dispatch_group_t group);void dispatch_group_leave(dispatch_group_t group); 第一个函数会让派发组中正要执行的任务数增加；第二个与之相反。因此，每次调用dispatch_group_enter，也必须调用dispatch_group_leave。这与引用计数(看第29节)类似，引用计数的retain和release必须成对出现避免内存泄露。在派发组这个例子中，如果调用了一次enter而没有调用leave，那么组将永远不会结束。 下面这个函数可用来等待dispatch group执行完毕： 1long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); 这个函数有两个参数，一个是派发组，一个是超时值。这个超时值指定乐这个函数会等任务组执行多久。如果任务组在超时前结束，那么会返回0；否则，就会返回非0。这个值可以使用DISPATCH_TIME_FOREVER，这样会一直等待组任务执行完毕，也永远不会超时。 下面的函数可以替代上面函数的，它一样可以阻塞当前线程直到任务组执行完毕： 1void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 它们些微不同在于，这个函数可以 让你指定一个block，当组任务结束时，可以运行在某个特定的线程上。如果你不希望当前线程被阻塞，又想知道任务组什么时候结束，这是非常有用的。例如，在Mac OS X和iOS尚，你永远不该阻塞主线程，因为它是绘制UI和事件相应的线程。 如果想让数组中每个对象都执行一个任务，并等待它们执行完毕，可以使用GCD的这个功能。下面代码做到了这点： 123456789dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t dispatchGroup = dispatch_group_create();for (id object in collection) &#123; dispatch_group_async(dispatchGroup, queue, ^&#123; [object performTask]; &#125;);&#125;dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);// Continue processing after completing tasks 如果当前线程不该被阻塞，你应该使用通知函数替代等待函数： 123456dispatch_queue_t notifyQueue = dispatch_get_main_queue();dispatch_group_notify(dispatchGroup, notifyQueue, ^&#123; // Continue processing after completing tasks &#125;); 这个回调所执行的线程应该取决于情况。这里，我使用了主队列，它是一个常用的做法。你也可以使用任意串行队列或者全局并发队列。 在这个例子中，所有任务都派发到同一个队列上。但这样做并不是必须的。你可能想将一些任务放置在高优先级但是仍是在任务结束收到通知： 12345678910111213141516171819dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);dispatch_group_t dispatchGroup = dispatch_group_create();for (id object in lowPriorityObjects) &#123; dispatch_group_async(dispatchGroup, lowPriorityQueue, ^&#123; [object performTask]; &#125;);&#125;for (id object in highPriorityObjects) &#123; dispatch_group_async(dispatchGroup, highPriorityQueue, ^&#123; [object performTask]; &#125;);&#125;dispatch_queue_t notifyQueue = dispatch_get_main_queue();dispatch_group_notify(dispatchGroup, notifyQueue, ^&#123; // Continue processing after completing tasks &#125;); 除了上面例子中的提交到并发队列，也可以将其提交到串行队列中。但是如果所有的任务都在痛一个串行队列，那任务组就没什么用了。因为所有的任务都是顺序执行，你只需要在最后添加一个block，它就等价于任务组的通知了： 1234567dispatch_queue_t queue = dispatch_queue_create(&quot;com.effectiveobjectivec.queue&quot;, NULL);for (id object in collection) &#123; dispatch_async(queue, ^&#123; [object performTask]; &#125;);&#125;dispatch_async(queue, ^&#123; // Continue processing after completing tasks&#125;); 这段代码展示了有些情况你不需要使用任务组。有时采用单个串行队列，以及异步派发也是可以达到同样效果的。 为什么我提到执行任务要基于系统资源呢？当如，如果你往后看刚才的那个并发队列的例子，它是非常清楚的。GCD会自动创建新的线程或者复用旧的线程。在并发队列中，它可以有多个线程，这意味着多个任务block并发执行。并发线程的数量取决于很多因素，但最多的是取决于系统资源。如果CPU是多核的，队列中有许多人物等待执行，那么就会产生很多线程去执行任务。通过dispatch group提供的功能可以很容易的执行多个并发任务，并在结束时收到通知。通过GCD的原生并发队列，执行并发任务将会基于系统可用资源去分配。这样开发者只需要关注商业逻辑不需要去关注处理并发任务的复杂逻辑。 上面集合循环的例子，然后每个元素执行一个任务也能通过一个GCD函数功能达到，如下： 1void dispatch_apply(size_t iterations, dispatch_queue_t queue, void(^block)(size_t)); 这个函数执行给定次数的block，每次执行都会增加传给block的数值，这个值是从0到iterations - 1。它是这样使用的： 1234dispatch_queue_t queue = dispatch_queue_create(&quot;com.effectiveobjectivec.queue&quot;, NULL);dispatch_apply(10, queue, ^(size_t i)&#123; // Perform task&#125;); 实际上，它等价于一个0-9的for循环，像这样： 123for (int i = 0; i &lt; 10; i++) &#123; // Perform task&#125; 需要注意的是dispatch_apply也可以使用并发队列。如果是这样，block将会根据系统资源同时执行，就像刚才那个组任务。如果刚才例子中的集合是一个数组，它也可以使用dispatch_apply实现： 12345dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(array.count, queue, ^(size_t i)&#123; id object = array[i]; [object performTask];&#125;); 这个例子又一次展示了dispatch group不是必须的。但是dispatch_apply会持续阻塞，直到所有任务执行完毕。因此，如果你尝试在并发队列上运行block(或者高于当前队列的一个串行队列)，就会造成死锁。如果你想在后台执行任务，那么还是使用dispatch group吧。 小结 dispatch group用来执行集合中的所有任务。当所有任务执行完毕时，你可以选择获得通知。 dispatch group可以通过并发队列执行多个并发任务。在这种情况下，GCD会基于系统资源去同时处理多个任务。如果你自己实现这个功能需要大量代码。 使用dispatch_once执行只执行一次的线程代码单例模式是Objective-C中常用到的一种模式，一般通过叫做sharedInstance的类方法，它会返回一个单一实例，而不是每次都返回新实例。sharedInstance方法的通常实现如下： 12345678910111213@implementation EOCClass+ (id)sharedInstance &#123; static EOCClass *sharedInstance = nil; @synchronized(self) &#123; if (!sharedInstance) &#123; sharedInstance = [[self alloc] init]; &#125; &#125; return sharedInstance;&#125;@end 我发现单例模式很容易产生激烈辩论，特别是Objective-C。线程安全是辩论的主要问题。上面的代码使用同步锁使创建的单例线程安全。无论好坏，这种代码很简单，所以随处可见。 但是，GCD的一个功能使单例模式更容易实现。这个函数如下： 1void dispatch_once(dispatch_once_t *token, dispatch_block_t block); 这个函数接受一个特殊的dispatch_once_t类型参数，我将其称为标记，此外还有一个block。这个函数确保给予一个标记，这个block会执行一次也仅仅执行一次。这个block金辉在第一次调用时执行，最重要的是，它是线程安全的。注意，每次传入的标记必须完全一致，只有这样它才会只执行一次。因此开发者经常将其声明为静态或者全局变量。 使用这个函数重写单例模式，如下： 12345678+ (id)sharedInstance &#123; static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 使用dispatch_once简化了代码，也是的线程安全，所以你不需要考虑加锁或者同步锁的问题。所有都在GCD底层处理了。那个标记被声明为static，因为它需要每次都是同一个值。将其定义在static区域意味着编译器会确保每次执行sharedInstance方法时都复用旧值而不是创建新的变量。 而且，dispatch_once是非常高效的。它没有使用重量级的同步机制，否则每次运行都要加锁，它使用了原子性去访问标记，用以指示代码是否已经运行。在Mac OS X10.8.2系统64位的电脑上，使用@synchronized访问sharedInstance方法比使用dispatch_once花费的时间要多两倍。 小结 单一线程安全是常见的任务。GCD提供了一种易于使用的工具去达成这个目的，它就是dispatch_once函数。 标记应该声明在static或者global区域中，这样每次执行时得到的标记都是相同的。 避免使用dispatch_get_current_queue当你在使用GCD时，特别是当你派发了任务给不同的队列时，通常都会想确定当前是哪个线程在执行。例如，UI工作一直需要在Mac OS X和iOS的主线程工作，它等价于GCD的主队列。有时，看起来可能需要去确定当前代码是否执行在主线程上。通过阅读文档，你发现可以通过下面的函数获取当前线程： 1dispatch_queue_t dispatch_get_current_queue() 它会返回当前哪个队列在执行。确实是这样，不过使用的时候需要小心。实际上，它在iOS6.0之后就被废弃了，但在Mac OS X 10.8并未废弃。尽管如此，你也应该避免在Mac OS X上使用它。 该函数有一个典型的反面教材，就是去检测当前队列是否是指定队列，用以试图避免同步时的死锁。考虑下面的代码，它使用一个同步队列去访问一个实例变量： 123456789101112131415- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString*)someString &#123; dispatch_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 在getter方法中可能会产生一个问题，如果调用getter方法的队列是与getter方法内部是相同队列，由于dispatch_sync只会在block执行完毕时返回。但是如果目标队列是当前队列，那么block将永远不会得到执行机会，因为应该执行block的目标队列是当前队列，而当前队列又一直阻塞。像这个例子中的getter方法就是不可重入的。 看了dispatch_get_current_queue的文档后，你可能觉得可以通过检测当前队列的方法使得getter方法可以重入，如果这样，直接执行block就行了，不需要执行派发了，如下： 1234567891011121314151617- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_block_t accessorBlock = ^&#123; localSomeString = _someString; &#125;; if (dispatch_get_current_queue() == _syncQueue) &#123; accessorBlock(); &#125; else &#123; dispatch_sync(_syncQueue, accessorBlock); &#125; return localSomeString;&#125; 这个例子在简单环境下可以工作。但是，它仍旧是危险且容易导致死锁的。为什么？考虑下面场景的两条串行队列： 123456789dispatch_queue_t queueA = dispatch_queue_create(&quot;com.effectiveobjectivec.queueA&quot;, NULL);dispatch_queue_t queueB = dispatch_queue_create(&quot;com.effectiveobjectivec.queueB&quot;, NULL);dispatch_sync(queueA, ^&#123; dispatch_sync(queueB, ^&#123; dispatch_sync(queueA, ^&#123; // Deadlock &#125;); &#125;);&#125;); 在最内部的队列A一样会造成死锁，因为它要等待最外层的dispatch_sync完成，而最外层的又不可能完成，因为它要等最内层的执行完成，这样就死锁了。现在考虑使用dispatch_get_current_queue放入相同的检测： 12345678910dispatch_sync(queueA, ^&#123; dispatch_sync(queueB, ^&#123; dispatch_block_t block = ^&#123; /* ... */ &#125;; if (dispatch_get_current_queue() == queueA) &#123; block(); &#125; else &#123; dispatch_sync(queueA, block); &#125; &#125;);&#125;); 但是这一样会导致死锁啊，因为dispatch_get_current_queue返回的是当前队列，在上面的例子中将会返回队列B。所以仍将同步执行最内层的队列A，结果就会像之前那样死锁喽。 在这个例子中，正确的解决办法是使其不可重入。而是应该确保同步队列绝不会访问属性，即不会调用someString方法。这个队列应该只用来同步属性。派发队列是非常轻的，为了使每个属性都有自己的同步队列，我们可以为其创建多个队列。 上边的例子看起来有点做死，但是还是会有别的情况导致这个问题的。队里是可以被安排进层级中的，这意味着block会在其上级队列中执行。队列的最外层是一个全局并发队列。图6.4展示了简单的队列结构。 Figure 6.4 派发队列层级。 队列B或者队列C的block会在队列A后面执行。所以队列A、队列B、队列C的block总会分开执行。但是队列D就可能与队列A或者队列B或者队列C同时执行了，因为队列A和队列D是放在全局并发队列里面了。如果需要执行并发任务，就会依据系统资源来进行分配了，例如GCD的核数。 由于队列有层级关系，所以去检测当前队列是哪个也并没有太大作用了。例如，你确定当前block执行在队列C上面，所以你认为在队列A上面同步执行任务就是安全的。实际上，这仍然会导致死锁。 如果一个API允许你指定回调时的block的运行队列，但是它的内部使用了一个同步串行队里，如果你的目标也是这个队列，依然会造成死锁。使用API的开发者可能以为dispatch_get_current_queue返回的是调用API那个，但其实是它内部使用的那个。 为了解决这个问题，最好的办法是使用GCD提供的队列特有数据，它允许你去将任何数据以键值对的形式添加进队列中。最重要的是，如果根据指定的键找不到数据，它会沿着队列层次一直寻找，直到根队列位置。这么说可能明白怎么使用，所以看下面的例子： 12345678910111213141516171819dispatch_queue_t queueA = dispatch_queue_create(&quot;com.effectiveobjectivec.queueA&quot;, NULL);dispatch_queue_t queueB = dispatch_queue_create(&quot;com.effectiveobjectivec.queueB&quot;, NULL);dispatch_set_target_queue(queueB, queueA);static int kQueueSpecific;CFStringRef queueSpecificValue = CFSTR(&quot;queueA&quot;);dispatch_queue_set_specific(queueA, &amp;kQueueSpecific, (void*)queueSpecificValue, (dispatch_function_t)CFRelease);dispatch_sync(queueB, ^&#123; dispatch_block_t block = ^&#123; NSLog(@&quot;No deadlock!&quot;); &#125;; CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific); if (retrievedValue) &#123; block(); &#125; else &#123; dispatch_sync(queueA, block); &#125;&#125;); 在这个例子中，创建了两个队列。将队列B的目标队列设为队列A，而队列A的目标队里仍旧是默认的全局并发队列。然后给队列A设置一个队列特有值，使用下面这个函数： 1234void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor); 第一个参数是设置数据的目标队列，后面两个是参数和值。参数和值都是不透明的void指针。对于键来说，函数是按照指针来做比较的，而不是内容。所以，队列特有数据的行为是不同于NSDictionary对象的，字典对面是对比键的内容。队列特有数据的行为更像是关联对象。值也是不透明的void指针，所以你可以放置任何值。但是，你必须去管理这个对象的内存。这使得ARC很难去自动管理这个对象的内存。在这个例子中，这个value值是一个CoreFoundation字符串，而ARC不关心任何CoreFoundation对面的内存管理。这样的对象更适合做队列特有数据，因为它可以使用免费桥与Objective-C相关类进行转换。 最后的参数是这个函数的析构函数，当对象持有的键被移除时，它就会运行。因为那时肯定是队列被释放或者有新的键值对被设置。dispatch_function_t的类型是这样定义的： 1typedef void (*dispatch_function_t)(void*) 析构函数必须只能带有一个单一指针并且返回值一定是void。在这个例子中，使用了CFRelease，它就是这样一个函数，不过你也可以自己定义一个函数，在其中调用CFRelease，并对其它需要清理的内容进行清理。 队列特有数据提供的这套简单易用的功能避免了使用dispatch_get_current_queue所带来的坑。另外还可能在调试时使用dispatch_get_current_queue。在这种情况下，它是可以安全使用的，只要你不讲代码编译进发布版本。如果对访问当前队列有特殊需要，而当前函数又无法完成，那么最好的解决办法还是去找苹果公司吧。 小结 dispatch_get_current_queue函数可能不会像你想象的那么有用。它已经被废弃并且现在只应在调试时使用它。 派发队列是有层级结构的；因此，单个队列无法描述当前队列。 队列特有数据可以解决使用dispatch_get_current_queue遇到的常见问题，它可以避免因为无法重入导致的代码死锁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第五章]]></title>
      <url>%2F2017%2F07%2F01%2FMemory%20Management%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第五章：内存管理 简介无论任何面向对象语言，内存管理都是重要的一部分，例如Objective-C。想写出高效无bug的语言，对其语言的内存管理模型一定要了解。 如果你理解了类似规则，你会发现Objective-C的内存管理貌似也不是很复杂，特别当你使用ARC时。ARC将所有的内存管理都交给了编译器，可以让开发者专注业务逻辑。 理解引用计数Objective-C使用引用计数去管理内存，这意味着每个对象都有一个计数器用于增加和减少引用计数。当你想使用某个对象时就增加引用计数，当你不再使用某个对象时，就减少引用计数。当对象引用计数为0，这个对象不再有任何使用者，这时他就会被释放。上面所述是主要概念，如果你想写出优秀的代码，即使你使用ARC(看第30节)机制，你也需要理解上述概念。 在Mac上，垃圾回收机制在10.8之后被废弃，在iOS上更是从来都不能使用。所以理解引用计数就至关重要了，因为你不能在iOS和Mac上使用垃圾回收了。 如果你已经使用了ARC，那你应该知道所有与引用计数相关的方法都无法调用了，暂且忘掉这些吧。在ARC中，这是真的。但是这是讲述引用计数必须的一部分，并且ARC也是一种引用计数机制，所以还是要讲述这些在ARC下无法使用的方法。 引用计数如何工作在引用计数机制下，计数器是代表每个对象有多少事物想令此对象继续存在。这涉及到了一个叫做保留计数的东西，但是他也被称作引用计数。下面三个NSObject的协议方法可以操作引用计数的增加和减少： retain 增加引用计数 release 减少引用计数 autorelease 稍后减少引用计数，当自动释放池释放时减少(我们将在第34节第150页讨论自动释放池) 其中有一个叫做retainCount的方法，但是它不是很准确，即使在调试环境下也是。所以我跟苹果都不推荐你使用它。具体信息看第36节。 每个对象创建时引用计数最少为1。如果想要对象存活，就调用retain方法。当某部分代码不再需要这个对象时就调用release或者autorelease。当引用计数为0时，对象被释放，这意味着这块内存被标为可复用。一旦对象被释放，那么该对象的任何引用都是无效的。 图5.1展示了一个对象的创建，持有和两次释放。 Figure 5.1 一个对象的整个生命周期内它的引用计数的增加和减少 在一个应用的生命周期内，有许多对象被创建。这些对象往往跟另一个对象有所关联。例如，有一个代表人的对象，它会对一个用字符串表示的人名进行引用，也可能有别的引用，例如一个代表它朋友的结合，这些构成了一个对象表。如果一个对象对另一个对象持有一个强引用，那么前者持有后者。这个意思是当某个对象对其余对象有使用的意图时，就可以通过持有的方式保证后者被释放。当它不在需要后者时，再对后者进行释放。 图5.2的对象表中，ObjectA同时被ObjectB和ObjectC持有。当ObjectB和ObjectC不在持有ObjectA并且ObjectA引用计数为0时，ObjectA会被释放。ObjectB和ObjectC被其余对象持有，而其余对象又被别的对象持有。如果你查找整个对象表，你会发现一个根对象。在Mac中，根对象是NSApplication；在iOS中，根对象是UIApplication。这两个对象都是程序启动时创建的一个单例对象。 Figure 5.2 对象表展示一个对象被释放之前它的引用的释放 下面的代码将帮助你理解上图： 123456NSMutableArray *array = [[NSMutableArray alloc] init];NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];// do something with &apos;array&apos;[array release]; 如前面展示的一样，上述代码在ARC下无法编译通过。因为显式调用了release方法。在Objective-C中，调用alloc方法返回的对象由调用者持有。也就是说，调用者通过 alloc方法表达了想让对象存在的想法。但是有一点需要注意，这时它的引用计数并不一定是1。它有可能比1大，因为alloc或者initWithInt:的实现里面有别的对象对他有引用。这样，这个对象的引用计数就最少为1了。你应该这样理解引用计数这个概念。你不应该认为引用计数是几，只应该说清楚引用计数增加或者减少。 然后number对象被添加进数组。数组通过addObject:方法一直保持number的引用。这时，number对象的引用计数最少是2。然后，这段代码不再需要number变量，所以释放它。这时引用计数最少是1。这时，number变量不再可以安全的使用。它调用release的意思是不再能保证所指对象是否存活了。当然，在这个例子中，我们很明显可以知道它在调用了release之后仍然是存活的，因为数组还在引用它。但是不要假定一个对象存活，就是不要像下面这样写代码： 1234NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];NSLog(@&quot;number = %@&quot;, number); 这样的代码即使在这个环境下可以运行，它也不是好的做法。不论出现任何原因导致number对象的引用计数为0，然后被释放，那么当你调用NSLog的时候，程序就可能会崩溃掉了。这里为什么说是可能呢？因为对象释放之后，只是将内存放回可用内存池。如果在你调用NSLog时，内存还没有被覆盖，那么该对象仍然存在，就不会发生崩溃。因此，过早释放对象会造成难以调试的问题。 为了减少这种对象已经被释放的潜在风险，你经常能看到在release之后将对象设为nil的代码。这能确保不会通过指针调用一个无效的对象，这种指针被称为悬垂指针。例如，像下面这样： 1234NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];number = nil; 属性存取器的内存管理正像前面说的那样，对象链接在一起构成了对象表。上面例子中的数组通过对对象进行retain操作持有它们。同样，其它对象也可以使用属性持有其它对象，并通过存取方法去获得或者设置实例变量。如果属性是一个强引用，则设置的属性值会被保留。一个叫做foo的属性的，它有一个叫做_foo的实例变量，它的setter方法像下面这样： 12345- (void)setFoo:(id)foo &#123; [foo retain]; [_foo release]; _foo = foo;&#125; 保存新值，释放旧值。然后更新实例变量指向新的值。这个命令是重要的。如果旧值在新值保留前释放并且这两个值是相同的，这意味着这个对象可能会被过早的释放。后面的retain操作也无法使这个对象存活，然后这个实例变量将会变成一个悬垂指针。 自动释放池在Objective-C的引用计数中有一个重要结构，那就是自动释放池。调用release的会直接减少引用计数(可能导致对象直接释放)，你也可以使用autorelease，它会在之后执行释放操作，通常是在下一次循环事件时递减，不过也可能更早(具体看第34节)。 这个功能是非常有用的，特别是当一个方法返回一个对象时。在这种情况下，我们并不想另调用者手动保存其值。例如，下面的代码： 1234567- (NSString*)stringValue &#123; NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self]; return str;&#125;``` 在这个例子中，`str`的引用计数最少为1，因为调用`alloc`方法会使引用计数加1，并且也没有对应的释放。引用计数加1意味着你作为调用者，必须在某个时刻将其释放，即引用计数减1。但是这并不意味着它的引用计数是1。它可能是更多，因为你不知道`initWithFormat:`的实现细节。你要考虑的是如何处理这一次的保留操作。 但是你不能在这个方法里面释放它，因为它需要返回后才能释放。所以这里应该使用`autorelease`去保证对象可以正常返回，然后进行释放。也就是说，这个方法可以保证对象跨越方法调用边界之后仍然存活。实际上，这个释放会在当前自动释放池释放时(看第34节)发生，除非你创建了自己的自动释放池，否则它会在当前线程的下次事件时释放。对这个字符串对象使用这个方法如下： (NSString*)stringValue { NSString *str = [[NSString alloc] initWithFormat:@”I am this: %@”, self]; return [str autorelease];} 12现在这个方法返回时，对象一定存活。所以这个对象可以这样使用了： NSString *str = [self stringValue];NSLog(@”The string is: %@”, str);12这里不再需要更多的内存管理了，因为`str`对象已经自动释放，达到引用计数平衡了。因为自动释放池要到下一次事件循环才会释放，所以在使用`NSLog`时，不需要再进行保留了。但是，如果对象需要被持有，例如一个实例变量，对象需要`retain`并在稍后使用`release`： _instanceVariable = [[self stringValue] retain];// …[_instanceVariable release];``` 所以autorelease可以延长对象的生命周期，使其跨越方法调用边界之后仍然存在。 循环引用使用引用计数时常遇到的一个场景是循环应用，它发生在多个对象相互引用的时候。它会导致内存泄露，因为没有办法调用到这些循环引用的对象，并将其引用计数设为0。在循环引用中，每个对象都会被最少一个对象持有。在图5.3中，每一个对象都有另外两个对象的引用。在这个循环中，所有对象的引用计数都是1。 Figure 5.3 一个循环引用的对象表 在垃圾回收中，这种情况会被标记为孤岛。这种情况下，垃圾回收器会将三个对象都释放掉。很遗憾在Objective-C的引用计数中不存在这种做法。这个问题的常用做法是使用弱引用(看第33节)或者将这些对象中的某一个放弃持有其它对象。上述的两种做法都可以打破循环引用，这样内存泄露就不存在了。 小结 以引用计数方式进行内存管理是基于计数器进行增加和减少的。一个对象创建后，它的引用计数最少为1。如果引用计数为正，则对象存活。如果引用计数为0，则对象被释放。 在对象的整个生命周期中，一个对象通过引用来保留和释放其他对象。保留和释放会增加和减少引用计数。 ARC使引用计数更加简单理解引用计数概念是很简单的(看第29节)，但是retain和release出现的场景很是频繁。所以Clang编译器搞了一个静态解析器，用于指出引用计数出现问题的地方。例如，考虑下面代码片段的引用计数： 12345if ([self shouldLogMessage]) &#123; NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self]; NSLog(@&quot;message = %@&quot;, message);&#125; 这段代码有一个内存泄露，因为在判断语句的结尾，message对象没有释放。因为出了条件语句后，就没办法引用它了，对象就泄露了。判断内存泄露的规则很简单。它调用了NSString的alloc方法生成了一个对象，使其引用计数最少为1。但是它没有释放。这些规则很容易表达，电脑可以轻易使用这些规则并告诉我们哪个对象发生了泄露。这就是静态编译器要做的事情。 静态分析还有更深层次的用途。因为它可以告诉你哪个地方发生了内存泄露，所以它也可以在需要的地方添加retain或者release，是吧？ARC就是由这个概念诞生的。ARC的就像它名字说的那样：使引用计数自动化。所以上面的代码会在判断语句结束的地方自动加上release操作，自动添加后的代码是这样的： 123456if ([self shouldLogMessage]) &#123; NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self]; NSLog(@&quot;message = %@&quot;, message); [message release]; ///&lt; Added by ARC&#125; 需要记住的是即使使用了ARC，引用计数仍是在执行的。只不过添加retain或者release的操作是ARC做的。除了为方法返回的对象处理内存管理语义ARC还做了更多的事，稍后你将看到。不过这些功能，都是基于核心内存管理语义构建的，这套标准适用于整个Objective-C。 由于ARC会自动的调用retains, releases, autoreleases，所以你在ARC下直接调用内存管理方法是不合法的。尤其是，你不能调用下面这些方法： retain release autorelease dealloc 在ARC下，你直接调用上述方法的任意一个都会导致编译错误，因为你这样做会导致ARC无法正常工作。你必须相信ARC可以处理好这些，这会使某些开发者不是很放心。 实际上，ARC并没有通过正常的Objective-C派发机制去调用这些方法，它直接调用了底层的C函数。这是一种优化，因为retain和release方法调用的是很频繁的，并且也可以减少CPU的工作量。例如，retain是等价于objc_retain的。这就是为什么覆写retain, release, autorelease这些方法是非法的，因为它们并不是直接调用的。对于本章节的其余部分，我仍将讲述与底层C函数等价的Objective-C方法。这对那些使用过手动管理引用计数的人更友好。 ARC中的方法命名规则在Objective-C中，将内存管理语义通过方法名表现出来是惯例，而ARC则将其确定为硬性规则。规则是很简单的并且跟方法名有关联的。一个返回对象的方法，如果方法以下列名词开头，它的所有权归属调用者： alloc new copy mutableCopy 归属调用者的意思是调用那四种方法的调用者需要管理返回值的释放。这是说，返回对象有一个正的引用计数，调用者需要去平衡这一次引用计数。如果有别的对象对其进行了保存或者进行了autorelease，那么它的引用计数会大于1，这就是为什么说retainCount方法没有什么用的原因(看第36节)。 任意别的方法名都代表返回对象的所有权不归属于调用者。这种情况下，对象将自动调用autorelease，这样返回对象的值就可以在跨越边界调用后仍旧有效。如果想确保对象仍然存活，可以调用retain保留它。 ARC自动处理所有需要操作的内存管理规则，包括代码返回值的autorelease，就像下面代码展示的那样： 1234567891011121314151617181920212223242526272829303132333435363738394041+ (EOCPerson*)newPerson &#123; EOCPerson *person = [[EOCPerson alloc] init]; return person; /** * The method name begins with &apos;new&apos;, and since &apos;person&apos; * already has an unbalanced +1 retain count from the * &apos;alloc&apos;, no retains, releases, or autoreleases are * required when returning. */&#125;+ (EOCPerson*)somePerson &#123; EOCPerson *person = [[EOCPerson alloc] init]; return person; /** * The method name does not begin with one of the &quot;owning&quot; * prefixes, therefore ARC will add an autorelease when * returning &apos;person&apos;. * The equivalent manual reference counting statement is: * return [person autorelease]; */&#125;- (void)doSomething &#123; EOCPerson *personOne = [EOCPerson newPerson]; // ... EOCPerson *personTwo = [EOCPerson somePerson]; // ... /** * At this point, &apos;personOne&apos; and &apos;personTwo&apos; go out of * scope, therefore ARC needs to clean them up as required. * - &apos;personOne&apos; was returned as owned by this block of * code, so it needs to be released. * - &apos;personTwo&apos; was returned not owned by this block of * code, so it does not need to be released. * The equivalent manual reference counting cleanup code * is: * [personOne release]; */&#125; ARC通过名称来约定内存管理的规则，新手往往感觉不可思议。很少有其他语言像Objective-C一样把命名看的这么重要。适应这种模式对于成为一个好的Objective-C开发者是重要的。在这个过程中，ARC帮助你做了大量的工作。 ARC除了为你添加retain、release这些方法，还有一些其他好处。它也会做一些手动难以完成或者不能完成的操作。例如，ARC能互相抵消retain、release、autorelease的互相操作。如果某个对象多次进行retain和release，ARC可以成对的移除它们。 ARC也包含有运行期组件。这些优化发生在运行时，这些就是我们为什么应该在ARC下进行开发。前面提到某个对象需要在返回时进行autorelease。但是调用者需要代码存活就会对它进行retain操作，就像下面这个情况： 12// From a class where _myPerson is a strong instance variable_myPerson = [EOCPerson personWithName:@&quot;Bob Smith&quot;]; 调用personWithName:返回了一个自动释放的EOCPerson对象。但是编译器也需要去给那个实例变量添加retain操作，因为它是一个强引用。因此上面的代码等价于下面的手动代码： 12EOCPerson *tmp = [EOCPerson personWithName:@&quot;Bob Smith&quot;];_myPerson = [tmp retain]; 你会发现这里的autorelease和retain都是多余的。去除它们两个可以获得更好的性能收益。但是在ARC下的代码需要考虑向后兼容性，即需要去兼容非ARC的代码。ARC可以移除autorelease这个概念，并且指定所有的方法返回的对象的引用计数都加1。但是，它需要向后兼容。 但是ARC可以在运行时检测到这种多余的行为，即autorelease操作后面跟retain。当一个对象自动释放时，它会调用一个特殊函数，而不是对象的autorelease方法，它叫做objc_autoreleaseReturnValue。这个函数会检查当前函数返回后的那段代码。如果它发现在返回对象后会对对象进行retain操作，它会设置全局数据结构(取决于处理器)中的一个标志，而不执行release操作。同样，对一个自动释放对象进行retain的代码，也不会调用retain，而是执行一个叫做objc_retainAutoreleasedReturnValue的方法。这个方法会检查标志是否存在，如果存在，就不执行retain。对标志进行设置和检查是快过使用autorelease和retain的。 下面的代码展示了ARC是如何使用特殊函数进行优化的： 12345678910// Within EOCPerson class+ (EOCPerson*)personWithName:(NSString*)name &#123; EOCPerson *person = [[EOCPerson alloc] init]; person.name = name; objc_autoreleaseReturnValue(person);&#125;// Code using EOCPerson classEOCPerson *tmp = [EOCPerson personWithName:@&quot;Matt Galloway&quot;];_myPerson = objc_retainAutoreleasedReturnValue(tmp); 为了求得最佳优化，特殊函数在不同处理器都有不同表现。下面的伪代码展示了大概流程： 12345678910111213141516id objc_autoreleaseReturnValue(id object) &#123; if ( /* caller will retain object */ ) &#123; set_flag(object); return object; ///&lt; No autorelease &#125; else &#123; return [object autorelease]; &#125;&#125;id objc_retainAutoreleasedReturnValue(id object) &#123; if (get_flag(object)) &#123; clear_flag(object); return object; ///&lt; No retain &#125; else &#123; return [object retain]; &#125;&#125; objc_autoreleaseReturnValue函数如何检测需要保留对象呢。这取决于处理器。只有编译器的作者知道怎么实现它的，因为它需要使用检查机器码。除了编译器的作者谁知道调用的方法是怎么实现的。 这只是编译器在运行期的一种优化。所以使用ARC是一个好的建议。编译器和运行时日渐成熟，我相信会有更多的优化技术的出现。 变量的内存管理语义ARC也可以处理本地变量和实例变量的内存管理。通常每个变量都对对象持有强引用。这点是非常重要的，特别是实例变量，因为对象相同的代码，在手动引用计数和自动引用计数都是不一样的。例如，考虑下面的代码： 12345678910111213@interface EOCClass : NSObject &#123; id _object;&#125;@end@implementation EOCClass- (void)setup &#123; _object = [EOCOtherClass new];&#125;@end 在手动管理引用计数下，_object实例变量不会自动保留这个值，但是在ARC下会。因此，在ARC下编译这个代码，方法会变成这样： 12345- (void)setup &#123; id tmp = [EOCOtherClass new]; _object = [tmp retain]; [tmp release];&#125; 当然，这种情况下，retain和release都可以取消掉。所以ARC这样做了，就像转换前的代码一样。但是当它发生在设置setter方法时。如果不使用ARC，你可能会这样写： 1234- (void)setObject:(id)object &#123; [_object release]; _object = [object retain];&#125; 但是这样做有一个问题。那就是如果设置的新值和已有的值相同会发生什么？如果这个对象仅有一个引用，那么release会导致这个对象的引用计数变为0并且释放这个对象。后面的retain操作将会导致应用程序崩溃。使用ARC则不可能发生这种错误。ARC下等价的setter方法如下： 1234- (void)setObject:(id)object &#123; _object = object;&#125; ARC执行一种安全的设置变量的方法，先保存新值，然后释放旧值，最后设置实例变量的值。你可能在MRC下已经明白这个问题了并且能正确编写，但是在ARC下你无需考虑这种类似的边界情况。 本地和实例变量可以通过下面这些修饰符进行语义改变： __strong 默认修饰符，这种情况下，变量会被保存。 __unsafe_unretained 这个值不会被保留，这样是不安全的，因为你再次使用它时，可能它已经被释放了。 __weak 这个值也不会被保留，但它是安全的，因为它会在变量为空时，自动设置为nil。 __autoreleasing 把对象按引用传递时始终它，当返回时它会被释放。 例如，想令变量与不使用ARC时一样，可以这样做： 12345@interface EOCClass : NSObject &#123; id __weak _weakObject; id __unsafe_unretained _unsafeUnretainedObject;&#125; 在这种情况下，当设置实例变量时，对象不会被保留。只有在使用新版运行时库(Mac OS X 10.7、iOS 5.0)的时候，weak修饰符才会自动将实例变量置为nil，因为它需要依赖依稀新的特性。 当我们在块(看第40节)中使用本地变量时，通常使用标示符去打破循环引用。块自动的引用所有它捕获的对象，这样加入那些对象中的某一个也保留有块，就会造成循环引用。使用__weak修饰变量可以打破循环应用： 1234567NSURL *url = [NSURL URLWithString:@&quot;http://www.example.com/&quot;];EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];EOCNetworkFetcher * __weak weakFetcher = fetcher;[fetcher startWithCompletion:^(BOOL success)&#123; NSLog(@&quot;Finished fetching from %@&quot;, weakFetcher.url);&#125;]; ARC清理实例变量就像上面展示的一样，ARC会处理实例变量的内存管理。如果要这样做，ARC就需要在释放时期生成清理的代码。凡是使用强引用的变量，ARC都会在dealloc方法中释放它。而在MRC下，需要你自己实现dealloc方法就像这样： 12345- (void)dealloc &#123; [_foo release]; [_bar release]; [super dealloc];&#125; 使用了ARC，dealloc方法就不需要这样写了；因为ARC会借用Objective-C++的一项功能来实现清理。在释放时，Objective-C++对象会调用所有C++对象的析构函数。当编译器发现对象包含C++对象时，它会生成一个叫做.cxx_destruct的方法。ARC借助此方法生成清理内存所有的代码。 但是，如果有不是Objective-C的对象，你仍然需要去手动清理，例如CoreFoundation对象，或者是malloc()分配的堆内存。但是你不需要像之前那样去调用父类的dealloc方法。在ARC下不能直接调用dealloc方法。所以ARC会自动在.cxx_destruct中生成并运行代码，也会在生成的代码中自动调用父类的dealloc方法。在ARC下，一个dealloc方法大概是这样的： 12345- (void)dealloc &#123; CFRelease(_coreFoundationObject); free(_heapAllocatedMemoryBlob);&#125; 由于ARC会生成这个方法，所以一般不需要实现dealloc方法。这可以减少项目源码的大小，并减少模板代码。 覆写内存管理方法在非ARC时代，是可以覆写内存管理方法的。例如，一个单例类通常会覆写release方法，使其什么也不做，因为单例类不需要释放啊。在ARC就不能这样，因为这会影响ARC对对象声明周期的分析。而且，由于不能调用和覆写这些方法，所以ARC就可以不使用Objective-C的消息派发系统从而对retain, release, autorelease方法进行优化。相应的，可以直接调用运行期的C函数。ARC可以对这些进行优化例如刚才说的对一个返回对象进行autorelease操作，然后接着又进行retain操作。 小结 ARC使开发者不用担心内存管理。使用ARC也可以减少类的模板代码。 ARC管理对象生命周期的办法就是在合适地方插入retain或者release。ARC下变量可以通过修饰符去改变内存管理语义，MRC下只能手动进行retain或者release。 方法名字已经指出了返回对象的内存管理语义。ARC将这些规则确定为必须遵守的规则。 ARC仅能处理Objective-C对象。特别是不能处理CoreFoundation的对象，它们必须使用CFRetain/CFRelease去处理。 在deaclloc中释放引用并清除监听状态一个对象走完生命周期后会被释放，那个释放的入口就是dealloc方法。在对象的整个生命周期中，释放只会被调用一次，当对象的引用计数为0时。不过什么时候调用就不知道了。也就是说，你可能通过你手动调用retain或release大概推测出它什么时候调用，但其实这是由系统决定的，它会在你不知道的时候进行释放。你永远不该调用dealloc本身。系统会在运行时在正确时间调用它。而且dealloc被调用后，对象都不再有效，后面的方法也是无效的。 那么你应该在dealloc中做什么呢？主要要做的应该是释放对象的所有持有。这个意思是释放所有的Objective-C对象，ARC会自动帮你添加进dealloc方法，通过自动生成.cxx_destrucr(看第30节)方法。任何非Objective-C也应该在这里释放。例如，CoreFoundation的对象需要释放，因为它是纯C的API。 另一个需要在dealloc中做的事情是清除所有的观察者行为。如果有对象注册了通知者，那么这里是一个移除通知的好地方。这样就不会向这个对象发送通知了，否则会导致应用程序崩溃。 一个dealloc方法大概像这样： 12345- (void)dealloc &#123; CFRelease(coreFoundationObject); [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 注意当你使用MRC而不是ARC时，你应该在这些方法后面调用[super dealloc]。ARC会自动在后面调用，这也是一个ARC比MRC安全简单的原因。并且使用MRC，你不得不讲每个需要释放的Objective-C对象添加进来。 即便如此，你不应该在这里释放开销较大或者系统的稀缺资源。例如文件描述符，套接字，大块内存。你不应该依赖dealloc方法去释放这些对象，因为有时候别的东西也会持有这些对象。这样会造成你不需要某个系统稀缺资源，但是却还在持有它，这是不合理的。通常的做法是当程序不再使用它时，实现别的办法进行释放。这样资源的声明周期就是明确的了。 比如一个管理套接字链接的对象，它需要有清理的方法。或许是一个数据库链接。这样类的接口大概是这样的： 12345678#import &lt;Foundation/Foundation.h&gt;@interface EOCServerConnection : NSObject- (void)open:(NSString*)address;- (void)close;@end 当需要使用时，可以调用open方法打开链接；当链接结束时，可以调用close方法。close方法一定要在链接对象释放前调用；否则，会被认为是一个项目错误，就像你不得不使用retain和release去平衡引用计数一样。 另一个在别的清理方法释放资源的理由是实际上对象的dealloc方法不一定会被调用。边界情况下，当程序意外退出时，对象可能仍然存在。这些对象没有接收到释放信息。相应的，当系统终止后，它们占用的资源也会返回给系统。所以不调用dealloc方法也是一种优化。这也说明不是每个对象都会调用释放方法的。在Mac OS X和iOS中都有一个应用的协议方法，当程序结束时会调用。这个方法可以被用来清理某些必须要清理的对象。 在Mac OS X中，程序结束会调用的协议方法是： 1- (void)applicationWillTerminate:(NSNotification *)notification; 在iOS中，程序结束会调用的协议方法是： 1- (void)applicationWillTerminate:(UIApplication *)application; 如果对象管理着某些资源，那么在dealloc中也应该调用它们的清理方法，以减少意外情况。如果有意外情况发生，那么有一个好办法是，输出一句信息去指明程序发生了一个错误。这是一个编程错误，因为这个关闭方法需要在对象释放前调用；否则，这个方法就不会有效果了。输出信息会警告开发者改正这个问题。在dealloc中去关闭资源依然是一个避免内存泄漏的好习惯。下面有一个这样的例子： 1234567891011121314- (void)close &#123; /* clean up resources */ _closed = YES;&#125;- (void)dealloc &#123; if (!_closed) &#123; NSLog(@&quot;ERROR: close was not called before dealloc!&quot;); [self close]; &#125;&#125; 如果关闭方法没有调用，那么相比输出一个错误，你应该去抛出一个异常指出程序发生了一个严重的错误。另外就是要避免在dealloc方法中调用别的对象。在上面的例子中，在dealloc中调用了一个方法。但那是一个特殊情况：去查明程序错误。无论在这里调用什么方法都不太合适，因为这里的对象已经接近尾声了。如果别的方法还会异步执行任务或者调用它们自己的方法，等到对象执行完任务，对象早被释放了。这会导致很多问题并且可能导致程序崩溃，因为它们会回调告诉对象任务执行完了。如果对象早已被释放，那么就会发生错误。 另外，调用释放方法的线程会进行最终释放，使所有对象的引用计数为0。有些方法需要运行在特定的线程，例如主线程。如果在dealloc中调用它们，无法保证它们运行在正确的线程。没有什么常规代码可以保证它们安全的运行在正确的线程，因为对象已经处于释放状态了，并且运行时已经对内部的数据结构进行释放标示了。 也应该避免在dealloc中调用属性存取器，因为它们可以被覆盖并且去执行一些在释放期不安全的操作。比如，某个对象可能通过KVO监听属性，并且监听者想去做一些事情，例如试图保留对象，或使用这个将被回收的对象。这样做会导致在运行期出现一些莫名错误，并可能导致程序崩溃。 小结 dealloc方法里面只应该被用来释放对象以及取消注册，例如KVO或者NSNotificationCenter通知。 如果一个对象持有系统资源，例如文件标示符，那么应该有一个方法去释放资源。当资源使用结束时，类的使用者应该调用关闭方法。 避免在dealloc方法中调用执行异步操作的方法或者只能正常状态执行的方法。 小心异常安全代码的内存管理现代语言中，异常是一个常见的语言功能。C中不存在异常，但C++和Objective-C中存在异常。实际上，在当前的运行时系统中，C++和Objective-C的异常都是通用的，这意味着一个语言抛出的异常可以被另一个语言捕获。 Objective-C的错误模型表示只有发生致命错误时才应该使用异常，你可能仍需要错误代码去捕获并处理异常。比如使用Objective-C++或者不受你控制的第三方库代码时，应该捕获异常。而且，有些系统库仍在使用异常，仿佛回到了异常频繁使用的年代。例如，如果你想去取消一个尚未注册的观察者，那么KVO就会抛出一个异常。 当异常发生时会带来一个内存管理问题。在try块里面，如果保留了一个对象，然后再对象释放前抛出了异常，那么对象将会发生泄漏除非在catch块中进行处理。C++的析构函数由Objective-C的异常处理来运行。这对于C++是非常重要的，因为这会缩短对象的声明周期，所以抛出异常时要调用析构函数；否则，对象内存将会泄露，特别是别的系统资源，例如文件权柄，是更容易泄露的。 异常处理机制会自动销毁对象，不过在MRC环境下处理对象销毁有些麻烦。考虑下面的Objective-C代码，它是在MRC下： 12345678@try &#123; EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; [object release];&#125;@catch (...) &#123; NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);&#125; 乍看起来，它似乎是正确的。但是如果doSomethingThatMayThrow方法抛出异常呢？下面一行的释放代码将不会运行，因为异常会直接跳入catch块。所以当抛出异常时，这个对象将会泄露。这不是一个好主意。使用@finally块可以解决这个问题，不论是否抛出异常，@finally块一定会运行也只会运行一次。例如，代码将会转换成这样： 1234567891011EOCSomeClass *object;@try &#123; object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow];&#125;@catch (...) &#123; NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);&#125;@finally &#123; [object release];&#125; 注意对象是在@try块之外声明的，因为需要在@finally块中使用它。如果所有的对象都需要释放那是非常单调的。而且，如果这里的逻辑更加复杂，@try块内状态更多，那么是非常容易忽略释放的，从而导致潜在的泄露风险。如果一个稀缺资源的对象泄露，例如文件标示符或者数据库连接，那么这个泄露就是灾难性的，因为最后应用程序占用的所有的系统资源都不会释放。 在ARC下，这种情况会更加严重。下面是与之等价的ARC环境下的代码： 1234567@try &#123; EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow];&#125;@catch (...) &#123; NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);&#125; 现在问题更严重了；你不能将释放放在@finally的块内了，因为不能调用release了。你可能会认为ARC已经处理了这种情况。默认情况下并没有做；因为这样做需要给对象添加大量模板代码，当有异常抛出时追踪对象清理。当抛出异常时，这段代码会严重影响性能。这段额外的代码也会增加应用程序的大小。总之这不是一个好的建议。 虽然默认状态下未开启，但是ARC支持这种异常安全机制。你可以在编译器中使用-fobjc-arc-exceptions开启。其默认不开启的原因是Objective-C定义异常应该只在该异常会导致应用重大错误时抛出(看第21节)。因此，如果应用程序将要终结，那么潜在的内存泄露就无所谓了。所以在应用程序将要终结时添加安全代码是没有什么意义的。 当编译器处于Objective-C++模式时，会自动打开这个-fobjc-arc-exceptions标示。因为C++的异常处理代码在ARC下与Objective-C的额外异常安全代码类似，所以在ARC下自动开启这些代码对性能影响并不大。而且，C++代码用的太多，Objective-C开发者可能也想使用异常处理。 如果你在MRC下开发并且一定要捕捉异常，那么一定记得正确的清理你的代码。如果你在ARC下开发并且一定要捕捉异常，那么你需要开启-fobjc-arc-exceptions标示符。但最重要的是，如果你发现你使用了大量的异常捕捉，那么考虑使用NSError-style重构代替，如第21节展示的一样。 小结 如果捕捉了异常，一定要将在@try块中的代码处理干净。 默认情况下，在异常发生时ARC并不会处理干净代码。你可以通过一个编译器标示符开启它，但这会使得代码包变大和运行时花费变大。 使用弱引用避免循环引用在对象表中会有一种典型的情况，那就是每个对象都持有对方的引用。当它发生在引用计数模型下时，例如Objective-C的内存管理模型，那么某个地方肯定会发生内存泄露，因为最后没有对象持有循环的对象的引用。因此，没有对象可以访问循环引用，循环引用中的对象也不会被释放，因为它们相互持有保证对方的存活。 在最简单的循环引用中，两个对象互相持有。图5.4展示了一个例子。 Figure 5.4 两个互相持有强引用的对象构成了循环引用。 循环引用是非常容易理解的并且也可以通过看代码找到： 123456789101112#import &lt;Foundation/Foundation.h&gt;@class EOCClassA;@class EOCClassB;@interface EOCClassA : NSObject@property (nonatomic, strong) EOCClassB *other;@end@interface EOCClassB : NSObject@property (nonatomic, strong) EOCClassA *other;@end 从代码可以轻易的看出来这个潜在的循环引用；如果将EOCClassA中属性设置为EOCClassB的实例变量，将EOCClassB的属性设置为EOCClassA的实例变量，那么就会发生像图5.4那样的循环引用。 循环引用的结果肯定是内存泄露。当对循环引用中对象的最后一个引用移除时，就会发生内存泄露。这意味着没有对象可以访问它们。在图5.5当ObjectB对象的最后一个引用被移除时，一个涉及四个对象的复杂循环引用就产生了。 Figure 5.5 当对象表中的循环引用的对象的最后引用被移除，循环引用就会发生内存泄露 在MAC OS X上有个选项可以使用垃圾回收机制，垃圾回收机制会找到循环引用的地方并且清理掉没有任何引用的循环引用。但是垃圾回收机制在MAC OS X 10.8被废弃了，在iOS上更是没存在过。因此，在写代码时，需要注意这个循环引用问题并确保它不会发生。 最好的避免循环引用的办法是使用弱引用。这样引用的一方总是非持有关系。通过unsafe_unretained特质也能达到这个效果。下面的例子中使用了这个特质： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@class EOCClassA;@class EOCClassB;@interface EOCClassA : NSObject@property (nonatomic, strong) EOCClassB *other;@end@interface EOCClassB : NSObject@property (nonatomic, unsafe_unretained) EOCClassA *other;@end 在这里，EOCClassB的other属性不会持有EOCClassA实例变量。这个叫做unsafe_unretained的特质指明属性是不安全的并且不会保留对象。如果设置的对象已经被释放了，那么调用它会导致程序崩溃。因为该属性不会保留对象，所以对象有可能被释放。 unsafe_unretained特质与assign特质语义相同。但是，assign通常用在基础类型(int, float, structs, etc.)，unsafe_unretained用于对象类型。这个特质本身就表明对象可能无法安全使用。 不过ARC给Objective-C打来了一项功能那就是可以使用安全的弱引用：一个叫做weak的属性特质，它的作用跟unsafe_unretained相同。但是当对象释放时，它会自动将属性设置为nil。在上面的例子中，可以这样修改EOCClassB的属性： 1@property (nonatomic, weak) EOCClassA *other; 图5.6展示了unsafe_unretained和weak的不同之处。 Figure 5.6 当属性指向的对象释放时，unsafe_unretained和weak的不同之处 当使用unsafe_unretained时，EOCClassB的other属性仍然指向一个已经释放的对象；当使用weak时，EOCClassB的other属性将会指向nil。 但是，使用weak特质不应成为你偷懒的借口。在上面的例子中，当EOCClassA的对象释放后，如果EOCClassB属性仍然指向它，那是一个编程错误。如果发生了这种事情，那就是一个bug。你应该确保这种情况不会发生。但是使用weak特质比使用unsafe_unretained特质安全是肯定的。相对比应用崩溃，应用可能更能接受展示错误的数据。这么做无疑对终端用户更好。但是，在所指对象销毁后，仍使用弱引用，那仍是一个bug。例如有一个用户界面，它有一个属性持有数据源对象，用户界面需要展示数据。假如这样一个属性是弱引用。如果数据源在元素展示之前被释放，那么弱引用意味着虽然不会崩溃但用户界面不会显示任何数据。 通常的规则是如果你不持有一个对象，那么就不要保留它。但是有个例外，那就是集合，集合类虽然不直接持有内容，但它要它所属的对象来保留这些元素。有一个例子，对象的引用会指向自己并不拥有的对象，比如委托模式。 小结 可以通过使用weak避免循环引用。 弱引用可能会也可能不会自动清空。自动清空是由ARC带来的一个在运行期实现的新功能。自动清空的弱引用是安全的，它永远不会引用一个已经释放的对象。 使用自动释放池降低高峰内存值Objective-C对象的存活是受到引用计数(看第29节)控制的。Objective-C的引用计数体系中的一个功能被称作自动释放吃。释放一个对象要么通过调用releas直接减少引用计数，要么通过调用autorelease添加一个自动释放池。一个自动释放池实际上是一个集合对象，它会在将来某个时刻进行释放。当一个自动释放池释放时，自动释放池内所有的对象立即发送release消息。 创建一个自动释放池的语法如下： 123@autoreleasepool &#123; // ...&#125; 如果这里没有自动自释放池，当对象发送autorelease消息时，你将会看下类似下面的输出： 1234Object 0xabcd0123 of class __NSCFString autoreleasedwith no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug 但是你通常不需要担心这个事。因为一个运行在Mac OS X或者iOS上的应用程序，它们都是处于Cocoa(或者Cocoa Touch)环境。系统都会给你创建一些线程，例如主线程或者GCD机制中的线程，每个线程都会有一个自动释放池，每次事件循环它们都会被清空。因此，你不需要创建自动释放池块。通常，你在应用程序的入口，即main函数那里会看到一个自动释放池包裹了整个应用程序。例如，一个iOS应用的main函数通常是这样的： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 从技术上讲，这个自动释放池不是必须的。只有在程序中止的时候，整个操作系统才需要释放所有的内存。但是没有它，UIApplicationMain自动释放的对象就没有自动释放池可以放置了，然后会输出一个警告信息。所以这个自动释放池就是最外围用来捕捉自动释放对象的池。 大括号定义了自动释放池的作用范围。在第一个大括号创建自动释放池，在超出作用域后自动释放。因此任何在这个池中的对象都会在最后发送release消息。自动释放池可以嵌套。当一个对象是自动释放时，它会自动添加进最近的自动释放池。例如： 123456@autoreleasepool &#123; NSString *string = [NSString stringWithFormat:@&quot;1 = %i&quot;, 1]; @autoreleasepool &#123; NSNumber *number = [NSNumber numberWithInt:1]; &#125;&#125; 在前面那个例子中，有两个使用工厂方法创建的对象，它们会自动释放(看第30节)。那个字符串对象将会被加入外层的自动释放池，数值对象将会被加入内层的释放池。嵌套自动释放池可以带来优势，那就是可以控制应用程序的峰值内存不会过高。 考虑下面的代码： 123for (int i = 0; i &lt; 100000; i++) &#123; [self doSomethingWithInt:i];&#125; 如果doSomethingWithInt:方法创建了很多临时对象，它们将会加入自动释放池。例如，那些对象可能是字符串。即使你不在后面使用它们，这些对象仍旧存活，因为它们在自动释放池内，准备释放并回收。但是自动释放池不到下一次事件循环不会释放。这意味着在这次事件循环中，会有越来越多的对象被创建并加入自动释放池。直到最后，事件循环结束，它才会被释放。但是这样在事件循环期间，应用程序的内存肯定会暴增并在最后释放的时候内存暴减。 这种情况是不好的，特别是如果这个事件循环的长度不固定，取决于用户输入。例如，下面从数据库获取集合对象。代码可能是这样的： 123456NSArray *databaseRecords = /* ... */; NSMutableArray *people = [NSMutableArray new]; for (NSDictionary *record in databaseRecords) &#123; EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; [people addObject:person]; &#125; 这个EOCPerson类可能会创建非常多的临时对象，就像刚才那个例子。如果数据库记录是庞大的，那么就会有大量的临时对象一直存活，而它们本应被早收回的。可以在这里增加一个自动释放池帮助提前回收。如果在循环内部包裹一个自动释放池块，那么任何自动释放的对象都是在超出这个池作用域时释放而不是主线程的自动释放池。例如： 12345678NSArray *databaseRecords = /* ... */; NSMutableArray *people = [NSMutableArray new]; for (NSDictionary *record in databaseRecords) &#123; @autoreleasepool &#123; EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; [people addObject:person]; &#125;&#125; 添加了新的自动释放池后，应用程序的内存峰值会一直持续在稳定的水平。内存峰值是指应用程序某个时间段内的最大使用内存。添加自动释放池可以降低这个峰值，因为它会在块结束时释放某些对象。这些临时对象就是需要释放的一部分。 可以把自动释放池比喻成栈。当一个自动释放池被创建，它被推入栈；当它释放时，它从栈中弹出。当一个对象是自动释放时，它自动被放入栈顶的自动释放池。 是否添加自动释放池优化取决于你的应用程序。首先监视内存的峰值然后再决定是否需要使用自动释放池。虽然自动释放池消耗不大，但还是有消耗的，所以如果不需要使用，就避免创建自动释放池。 如果你是一个在ARC出现之前的Objective-C程序员，那么你还记得老式的语法，即使用一个叫做NSAutoreleasePool的对象。这是一个特殊对象，它不同于正常对象，它设计出来就是代表自动释放池的，就像新的块语法一样。这个不是每次for循环都会释放的，它是一个稍重的自动释放池，它通常用在偶尔需要释放的内容上，像这样： 1234567891011121314NSArray *databaseRecords = /* ... */; NSMutableArray *people = [NSMutableArray new]; int i = 0;NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; for (NSDictionary *record in databaseRecords) &#123; EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; [people addObject:person]; // Drain the pool only every 10 cycles if (++i == 10) &#123; [pool drain]; &#125;&#125;// Also drain at the end in case the loop is not a multiple of 10[pool drain]; 不过这种代码风格不再需要了。使用新的语法，ARC带来的更轻量级的自动释放池。所以如果你有代码需要在循环内部释放，你可以使用自动释放池块去包括那部分代码，这样每次循环都会自动创建并清空自动释放池。 @autoreleasepool语法还有一个好处就是它有自己的作用域，这样可以帮助你避免使用那些已经被自动释放的对象。例如，考虑下面的代码风格： 1234NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; id object = [self createObject];[pool drain];[self useObject:object]; 这略微夸大了问题，但是它确实存在。useObject:可能会调用一个释放过的对象。但是，相同点在新样式是这样的： 1234@autoreleasepool &#123; id object = [self createObject];&#125;[self useObject:object]; 这样的代码是无法通过编译的，因为对象变量在作用域外是无效的，所以useObject:不能使用它。 小结 自动释放池排在栈中，当对象发送autorelease消息时，自动将他加入栈顶层的自动释放池。 正确的使用自动释放池可以帮助降低应用程序的内存峰值。 现在的自动释放池使用新的@autoreleasepool语法。 使用僵尸对象调试内存管理问题一直以来，调式内存问题都是麻烦的。向一个已经释放的对象发送消息是不安全的，这点跟我们所想是一样的。但是有时候它会正常工作，有时候它不会。这取决于那块内存是否已经被覆写了。这块内存是否被用来做其它事情呢，又无法确定，所以偶尔会发生崩溃。有时，那块内存仅有一部分被覆写，所以还有部分二进制有效。还有一种可能，就是覆写这块内存区域的是一个有效对象。这时，运行时会把消息传递给新对象，它能或者不能响应这个消息。如果能响应消息，应用不会崩溃，但是你会想为什么收到消息的不是想象中的那个呢？如果它不能响应消息，那么应用依旧会崩溃。 幸运的是，Cocoa的僵尸对象功能可以处理这些情况。当在调试功能打开时，运行时会将所有被销毁实例转换成一个特殊的僵尸对象而不是销毁它们。这种对象的内存不会被回收，因为也就不会被覆写。当僵尸对象收到消息时，它会抛出一个异常，并说明发送消息的对象以及转换僵尸对象前的对象。使用僵尸对象是调式内存管理问题的最佳办法。 这项功能是通过设置NSZombieEnabled环境变量为YES使用的。例如，如果你使用脚本并且在Mac OS X上运行它，你可以这样写： 12export NSZombieEnabled=&quot;YES&quot; ./app 当给僵尸对象发送消息时，将会在控制台输出一条消息，并且应用程序会终止。这条消息看起来是这样的： 12*** -[CFString respondsToSelector:]: message sent to deallocated instance 0x7ff9e9c080e0 你也可以在Xcode中设置这个环境变量，当你从Xcode运行时，它会自动读取。为了这样做，你需要编译应用程序的scheme，选择Run配置，然后点击Diagnostics标签，最后打开Enable Zombie Objects。图5.7展示了Xcode的设置界面，以及打开僵尸对象的选项。 Figure 5.7 在Xcode的scheme编辑器中打开僵尸对象 那么僵尸对象是如何工作的呢？它实现在Objective-C运行期、Foundation、CoreFoundation框架的底层。当一个对象被释放时，如果这个功能开启了，就会多一步操作。多出来的一步就是将对象转化为一个僵尸对象而不是直接释放。 去看多出来的一步做了什么，考虑下面的代码： 12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt; #import &lt;objc/runtime.h&gt;@interface EOCClass : NSObject@end@implementation EOCClass@endvoid PrintClassInfo(id obj) &#123; Class cls = object_getClass(obj); Class superCls = class_getSuperclass(cls); NSLog(@&quot;=== %s : %s ===&quot;, class_getName(cls), class_getName(superCls));&#125;int main(int argc, char *argv[]) &#123; EOCClass *obj = [[EOCClass alloc] init]; NSLog(@&quot;Before release:&quot;); PrintClassInfo(obj); [obj release]; NSLog(@&quot;After release:&quot;); PrintClassInfo(obj);&#125; 代码使用MRC是的更容易看清对象如何转化为僵尸对象。ARC会使obj对象尽可能的长时间存活，意味着这个简单的例子不会转化为僵尸对象。这意思不是说在ARC下对象不会转化为僵尸对象。使用ARC这个内存bug依然存在，只不过需要更复杂的代码才能表现出来。 上述例子中有一个函数用来输出给定对象的类和父类的名字。代码使用了object_getClass()方法，这是一个运行时函数，而不是给类发送Objective-C消息。如果那个对象是一个僵尸对象，发送任何Objective-C消息都会导致打印错误信息，并使得应用崩溃。上述代码的输出像下面这样： 1234Before release:=== EOCClass : NSObject === After release:=== _NSZombie_EOCClass : nil === 对象的类从EOCClass变为_NSZombie_EOCClass了。但是这个类从哪里来的呢？代码里面没有定义这个类啊。而且，在启用僵尸对象功能后，编译器给每个类创建一个额外的类那效率也太低了。这个类是在运行时第一个EOCClass对象转变为僵尸对象时生成的。它使用了运行时函数，用来操作类列表。 僵尸类是从一个叫做_NSZombie_的模板类复制的。僵尸类并不做太多的事请，它仅仅是作为一个标记。你将会看到它如何做为一个标记的。首先看下面的伪代码，它展示了如何如何根据需要创建僵尸类并将对象转化为僵尸对象。 123456789101112131415161718192021222324252627282930// Obtain the class of the object being deallocatedClass cls = object_getClass(self); // Get the class&apos;s nameconst char *clsName = class_getName(cls); // Prepend _NSZombie_ to the class nameconst char *zombieClsName = &quot;_NSZombie_&quot; + clsName; // See if the specific zombie class existsClass zombieCls = objc_lookUpClass(zombieClsName);// If the specific zombie class doesn&apos;t exist, // then it needs to be createdif (!zombieCls) &#123; // Obtain the template zombie class called _NSZombie_ Class baseZombieCls = objc_lookUpClass(&quot;_NSZombie_&quot;); // Duplicate the base zombie class, where the new class&apos;s // name is the prepended string from above zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0); // Perform normal destruction of the object being deallocated&#125;objc_destructInstance(self);// Set the class of the object being deallocated // to the zombie classobjc_setClass(self, zombieCls);// The class of &apos;self&apos; is now _NSZombie_OriginalClass 这个过程发生在NSObject对象的dealloc方法中。当NSZombieEnabled环境开启时，运行时会交换(看第13节)dealloc方法的实现和前面的代码实现。在这个过程的最后，对象的类已经变为_NSZombie_OriginalClass类了，其中OriginalClass是它本来类的类名。 重要的是，这个对象的内存并没有被释放。因此，这块内存不会被再次使用。尽管它发生了内存泄露，但它是一个调试工具并且不会将其发布在正式包中，所以不要在意这个。 但是系统为什么会为每一个僵尸对象创建一个新类呢？这样做是因为当给僵尸对象发送消息时，可以确定它原来的类是什么。如果所有对象的类都是_NSZombie_，那么原来类的名字就不知道了。通过运行时的objc_duplicateClass()函数创建一个新类，拷贝整个僵尸类然后给一个新的名字。它的父类，实例变量，方法都跟原来一模一样。另一个方法是通过继承_NSZombie_类创建一个新类而不是拷贝它。但是使用相应函数时，它的效率没有直接拷贝的高。 僵尸类的作用体现在消息转发机制(看第12节)中。_NSZombie_类不实现任何方法。它也不需要任何父类，因此它自身就是一个根类，就像NSObject一样，只有一个叫做isa的实例变量，它是所有Objective-C根类都要有的。这个轻量级的类不实现任何方法，所以所有发送给它的消息都会走完整的消息转发机制。 消息转发机制的核心是___forwarding___，你可能在调式的时候通过栈回溯看到过它。它要做的第一件事就是检查接受消息的类的名字。如果名字前缀是_NSZombie_，那么就肯定它是一个僵尸对象，那么就会特殊处理。应用程序会在这里终止，然后打印一条消息指出接受消息的类的类型。这时就可以看出来在僵尸类命中加入原类名的好处了。将_NSZombie_从僵尸类名中移除就是原来类的名字了。下面的伪代码展示了发生的事情： 123456789101112131415161718// Obtain the object&apos;s classClass cls = object_getClass(self); // Get the class&apos;s nameconst char *clsName = class_getName(cls);// Check if the class is prefixed with _NSZombie_if (string_has_prefix(clsName, &quot;_NSZombie_&quot;) &#123; // If so, this object is a zombie // Get the original class name by skipping past the // _NSZombie_, i.e. taking the substring from character 10 const char *originalClsName = substring_from(clsName, 10); // Get the selector name of the message const char *selectorName = sel_getName(_cmd); // Log a message to indicate which selector is // being sent to which zombie Log(&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;, originalClsName, selectorName, self); // Kill the application abort(); &#125; 尝试给开头的那个例子进行扩展，给将是对象发送消息： 1234567EOCClass *obj = [[EOCClass alloc] init]; NSLog(@&quot;Before release:&quot;); PrintClassInfo(obj);[obj release]; NSLog(@&quot;After release:&quot;); PrintClassInfo(obj);NSString *desc = [obj description]; 如果僵尸对象开启了，你将会看到下面的输出信息： 12345Before release:=== EOCClass : NSObject ===After release:=== _NSZombie_EOCClass : nil ===*** -[EOCClass description]: message sent to deallocated instance 0x7fc821c02a00 如你所见，上面的信息清楚的展示了选择器已经对象的原来类，也指出了已释放的消息接受对象的指针值。如果你在做功能调试，这个信息是非常有用的，如果与合适的工具配合使用，例如Instruments，那会有更好的效果。 小结 当一个对象释放时，它可以转化为一个僵尸对象而不用释放。这个功能仅能通过NSZombieEnabled环境变量开启。 对象转换为僵尸对象是通过更改它的isa指针值去指向特殊僵尸类。僵尸类可以响应所有发给僵尸对象的消息，然后会打印一条信息，程序终止。 避免使用retainCountObjective-C使用引用技术去管理内存(看第29节)。每个对象都有一个计数器去确定有多少别的事物希望它保持存活。当一个对象呗创建，它的引用计数一样大于0。retain和release会使引用计数增加或减少。当引用计数为0时，对象被释放销毁。 NSObject的协议定义了一个方法允许你获取某个对象当前的引用计数： 1- (NSUInteger)retainCount 但是，ARC已经废弃了这个方法。实际上，在ARC下，如果你试图调用它，编译器将会抛出一个错误，就像retain、release、autorelease这些方法一样。即使官方已经废弃了它，但还是有人无解它，并且应该避免使用它。如果你不使用ARC，你仍然可以使用它，并且没有编译器错误。所以理解为什么要避免使用这个方法是非常重要的。 这个方法看起来很有用的。因为它返回了引用计数，毕竟这个属性对每个对象都是很重要的。但个问题就在于，引用计数通常与开发者所应关注的没什么关系。即使你只是在调试环境下使用，它也不是有帮助的。 避免使用的主要原因是这个方法返回的值引用计数是在某个时间的值。因为这个值不包含将要减去的引用计数，例如在一个自动释放池中，这个值并不能真的代表引用计数。因此，下面的代码是有问题的： 123while ([object retainCount]) &#123; [object release];&#125; 这代码的第一个错误点在于它没有考虑可能有自动释放的情况，只是一直减少引用计数直到释放为止。如果对象处于一个自动释放池，这时自动释放池释放了，那么这个对象也会释放，那么肯定会崩溃了。 其次，这代码是危险的，因为retainCount永远不会返回0；因为有时系统会对对象释放行为进行优化，意思是当它释放时，如果它的引用计数是1，会直接执行销毁。否则，才会减少引用计数并销毁。因此，引用计数永远不会是1。不幸的是，即使这种代码有时能正常运行，那也是运气大于判断。当对象回收后，如果while循环还在运行，那么现代运行时很可能直接让其崩溃。 这样的代码不该使用。这样的代码实现的应该交由内存管理去处理。当你想让某个对象释放时，你应该确保它在该处已经达到引用计数平衡了。如果没有释放，应该查明是否有引用计数未平衡并且查明为什么没释放。 你可能尝试使用retainCount并且疑惑为什么返回值有时候非常巨大。例如，下面的代码： 123456NSString *string = @&quot;Some string&quot;;NSLog(@&quot;string retainCount = %lu&quot;, [string retainCount]);NSNumber *numberI = @1;NSLog(@&quot;numberI retainCount = %lu&quot;, [number retainCount]);NSNumber *numberF = @3.141f;NSLog(@&quot;numberF retainCount = %lu&quot;, [numberFloat retainCount]); 在64位Mac OS X 10.8.2，使用Clang 4.1编译，输出如下： 123string retainCount = 18446744073709551615 numberI retainCount = 9223372036854775807 numberF retainCount = 1 第一个值是2^64 - 1，第二个值是2^63 - 1。对象的引用计数为什么这么大，因为它们代表了单一对象。如果可以，系统会将字符串实现为单一对象的。如果像本例一样，字符串是一个编译期常量。在这种情况下，编译器会制作一个特殊的对象，代替NSString对象在二进制文件中的位置，并在运行时使用常量代替它。在这种设计下，NSNumber也是类似的对象；指针包含了所有的数字信息。运行时系统会在消息转发时发现这个标签，并对其做相应操作，使其行为和一个真正的NSNumber对象一样。这种优化仅使用这种特定的值，比如例子中的浮点数值就没有做这种优化，它的引用计数就是1。 另外，这种单一对象的引用计数永远不会发生改变。保留和释放都是空操作。即使两个单一对象，它们的引用计数值也不一样，系统借此指出，不要考虑使用引用计数作什么。如果你更改NSNumber对象的引用计数，当它是一个标签指针时，那么代码就会发生错误。 那么，你只想用retainCount去调试呢？即使这样，它也没什么用。这个值可能没你想的那么精确，就像它处于自动释放池中。而且，其他库也可能去释放或者保留对象。如果你检查引用计数，你可能以为自己错了，因为可能有其余库修改了它的引用计数啊。例如，下面的代码： 123id object = [self createObject];[opaqueObject doSomethingWithObject:object];NSLog(@&quot;retainCount = %lu&quot;, [object retainCount]); 它的引用计数是多少？可以是任何值吧。doSomethingWithObject:方法里面集合可能添加了这个对象，增加引用计数。或者可能多次保留对象并自动释放它，其中的某些自动释放池可能稍后才会清空。所以这引用计数没你想的那样有用。 你什么时候可以使用引用计数？最好的答案是：永远不用，尤其是苹果在引入ARC后已经将其废弃。 小结 引用计数看似有用，实则无用，因为任何时间点，绝对引用计数都无法代表对象的完整生命面貌。 当在ARC环境下时，retainCount方法被废弃，如果使用它还会导致编译器报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第四章]]></title>
      <url>%2F2017%2F06%2F19%2FProtocols%20and%20Categories%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第四章：协议和分类 简介协议是Objective-C语言的一个功能，类似Java的接口。Objective-C没有多重继承，因此我们把某个类应该实现的方法定义在协议中。协议最多的用法是实现委托模式(看第23节)，但是它也有别的用法。了解并使用它们可以使代码更易于维护，因为这是记录代码接口的好方法。 分类也是Objective-C语言的一个重要功能。它提供了一种给类添加方法而不需要添加子类的机制，而在其他方法中则不行。由于运行时的高度动态性，这一特性成为可能，但它也有一些缺陷，你应该在使用之前了解这些缺陷。 通过委托与数据源协议进行对象间通信对象之间经常需要通信。Objective-C开发者都知道一种叫做委托协议的设计模式。它的本质是定义一个接口，使任何遵循这个接口的类成为另一个类的委托(PS:为了便于理解，定义接口的类是委托类，遵循接口的类是被委托类)。当事件发生时，委托类就可以获取一些信息或者告知被委托类。 使用这种模式可以使得数据解耦。例如，一个展示数据列表的类应该只处理数据展示的逻辑，而不需要知道数据的类型或者数据之间的逻辑。这个视图对象应该有某个属性去处理数据和事件。它们各自被称为数据源和委托。 在Objective-C中，实现这种模式的常用方法是使用协议这种语言特性，它被用于整个Cocoa框架。如果你使用了这种功能，你会发现你的代码非常健壮。 例如，有一个类是从网络获取数据的。这个类从远端服务器获得数据。服务器可能需要花费很多时间才会相应，如果一直处在等待中，这是一种坏的体验。所以，通常会使用委托模式，这个网络类会有一个协议对象，并且当数据返回时，回调这个对象。图4.1展示了这个概念；EOCDataModel对象是被委托类，EOCNetworkFetcher是委托类。EOCDataModel让EOCNetworkFetcher执行一个异步任务，当任务执行完毕时，EOCNetworkFetcher调用这个委托。 Figure 4.1 一次委托回调的流程。注意委托对象并不需要一定是EOCDataModel实例，也可以是另外的实例。 使用Objective-C的协议可以很容易的实现这个模式。像图4.1这种情况，这个协议可能是这样定义的: 12345678@protocol EOCNetworkFetcherDelegate- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error;@end 一个委托协议的命名通常是类名后面追加delegate，整个名字使用骆驼命名法。给你的委托协议使用这种命名法可以使任何使用者都感到熟悉。 类会使用协议声明一个属性用于存放被委托者。在我们的例子中， 定义属性的类就是EOCNetworkFetcher类。因此，这个类的接口是这样的： 123@interface EOCNetworkFetcher : NSObject@property (nonatomic, weak) id &lt;EOCNetworkFetcherDelegate&gt; delegate;@end 确保这个属性定义为weak而不是strong是非常重要的，因为它必须是非拥有关系。通常情况下，被委托者对象也会持有本对象。例如，一个对象想使用EOCNetworkFetcher，它将会持有EOCNetworkFetcher对象直到用完为止。如果属性使用strong特质持有被委托者对象，那么就会形成循环引用。因此，这个协议属性需要定义成weak或者unsafe_unretained，如果需要在释放时自动情况值，那么需要使用weak，如果不需要释放，那么就使用unsafe_unretained。它们的持有关系如图4.2。 Figure 4.2 持有关系图展示了不保留delegate属性，可以避免循环引用。 实现委托的办法是声明某个类遵循协议，然后实现任何你想使用的协议方法。你可以在接口文件中声明类遵循的协议，也可以在类扩展(看第27节)中实现。如果你想告诉别人你事先了某个协议那么在接口中实现；但是像委托这种情况，一般都是在类的内部使用。所以它通常像这样被声明在类扩展中： 12345678910111213141516@interface EOCDataModel () &lt;EOCNetworkFetcherDelegate&gt;@end@implementation EOCDataModel- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data &#123; /* Handle data */&#125;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error &#123; /* Handle error */&#125;@end 通常，协议中的方法是可以选择实现的，因为被委托对象可能并不关心所有的方法。在这个例子中，DataModel类可能不关心错误的方法，所以它可能不会实现networkFetcher:didFailWithError:这个方法。为了指明可选方法，通过使用@optional关键字标注大部分或者所有的方法： 12345678910@protocol EOCNetworkFetcherDelegate@optional- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error;@end 如果要在通过被委托对象调用可选方法，那么就要判断被委托对象是否能响应这个方法。在EOCNetworkFetcher这个例子中，它可能是这样写的： 123456NSData *data = /* data obtained from network */;if ([_delegate respondsToSelector: @selector(networkFetcher:didReceiveData:)]) &#123; [_delegate networkFetcher:self didReceiveData:data];&#125; respondsToSelector:这个方法用于确认被委托者是否实现了某个方法。如果实现了，就调用它；如果没实现，什么也不做。这样的话，协议方法就是可选的了，并且不会因为没有实现某个方法而出问题。即使没有设置被委托对象，也是没有问题的，因为给空发送消息将会使得if语句的值为false。 协议中的方法名也是很重要的。方法名应该准确描述当前发生了什么，以及为什么要处理此事件。在这个例子中，协议方法读起来非常清楚，一个存在的EOCNetworkFetcher对象刚刚接收到了一些数据。你应该通过协议方法将被委托对象传递出去，就像上面的例子一样，这样当有特殊情况时可以根据被委托实例进行区分。例如： 12345678- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data &#123; if (fetcher == _myFetcherA) &#123; /* Handle data */ &#125; else if (fetcher == _myFetcherB) &#123; /* Handle data */ &#125;&#125; 这里有两个被委托实例，所以要区分到底哪个实例接受了数据。如果没有传入被委托实例，那么同一时间只能处理一个网络请求，这样不是很好。 协议方法也可以用来从被委托者中获取消息。例如，EOCNetworkFetcher类可能想提供这样一个机制，当获取数据发生重定向时，那么将向被委托对象询问是否允许发生重定向。这个协议方法看起来是这样的： 1- (BOOL)networkFetcher:(EOCNetworkFetcher*)fetcher shouldFollowRedirectToURL:(NSURL*)url; 这个例子解释了为什么这种模式叫做委托模式，因为是一个对象委托另一个对象去处理一些行为。 协议也可以提供一套接口给需要获取数据的类使用。这种委托模式被称为数据源模式，因为它的作用是给委托者提供数据。数据源模式中，信息从被委托者流向委托者；而正常的委托模式，信息是从委托者流向被委托者。图4.3展示了这个流程。 Figure 4.3 数据源模式中，信息从被委托者流向委托者；而在普通的委托模式，信息是从委托者流向被委托者。 例如，用户界面的列表对象使用数据源协议获取数据用于展示在列表中。列表视图还有一个委托协议用来处理用户操作。通过分隔数据源和委托协议，提供了一个清晰的接口，因为它们的逻辑也被分离了。另外，你可以使用一个对象处理数据源，另一个对象处理委托。然而，一般情况下，两者都是同一个对象。 如果数据源的方法和委托的方法大多数可选的，那么你将会写大量类似这样的代码： 1234if ([_delegate respondsToSelector:@selector(someClassDidSomething:)]) &#123; [_delegate someClassDidSomething];&#125; 检查被委托者是否实现了一个确定的方法是非常迅速的，但是如果一直这样做，那么除了第一次之外其余的是多余的。如果被委托对象本身没有发生变化，那么不太可能会突然开始响应或停止响应某个方法。因此，可以将被委托者是否能响应方法的结果缓存在协议中。例如，EOCNetworkFetcher类有一个被委托对象，它用于表示获取进度的回调方法，每当进度发生变化，就会调用被委托对象实现的协议方法。那么在这个生命周期中，这个方法将会被多次调用，并且每次都会检查是否相应这个方法。 将刚才说的方法加进协议中，目前协议中的定义是这样的： 12345678910111213@protocol EOCNetworkFetcherDelegate@optional- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didReceiveData:(NSData*)data;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didFailWithError:(NSError*)error;- (void)networkFetcher:(EOCNetworkFetcher*)fetcher didUpdateProgressTo:(float)progress;@end 这里新增了一个叫做networkFetcher:didUpdateProgressTo:的方法。缓存这个相应结果的最好办法是使用位段数据结构。这是一项很少使用的C语言特性，但在这里确实很合适的。它允许你定义一个确定的结构体位段，并且设置特定的值。看起来是这样的： 123456struct data &#123; unsigned int fieldA : 8; unsigned int fieldB : 4; unsigned int fieldC : 2; unsigned int fieldD : 1;&#125;; 在这个结构体中，fieldA使用8个二进制位，fieldB使用4个二进制位，fieldC使用2个二进制位，fieldD使用1个二进制位。所以fieldA可以表示0-255的数字，fieldD可以表示0或者1。如果创建的结构体中只有大小为1的位段，那么就能把许多布尔值塞入数据中了。以EOCNetworkFetcher类为例，你可以设置一个包含有位段的结构体为实例变量，结构体中的没一个变量代表一个协议方法。这个结构体是这样的： 1234567891011@interface EOCNetworkFetcher () &#123; struct &#123; unsigned int didReciveData : 1; unsigned int didFailWithError : 1; unsigned int didUpdateProgressTo : 1; &#125; _delegateFlags;&#125;@end 这里，我使用了类扩展去添加实例变量，具体描述在第27节；这个实例变量是一个结构体包含三个位段，每个位段代表一个协议方法。在EOCNetworkFetcher类中，可以像下面这样查询并设置结构体中的位段： 123456// Set flag_delegateFlags.didReceiveData = 1;// Check flagif (_delegateFlags.didReceiveData) &#123; // Yes, flag set&#125; 这个结构体用来魂村被委托对象是否能相应某个指定方法的结果。实现缓存功能的代码可以写在delegate属性的setter方法中： 1234567- (void)setDelegate:(id&lt;EOCNetworkFetcher&gt;)delegate &#123; _delegate = delegate; _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector (networkFetcher:didUpdateProgressTo:)] ;&#125; 这样每次调用delegate的相关方法时，就不需要检测被委托对象是否能响应指定的方法了，可以直接查询结构体中的标志： 1234if (_delegateFlags.didUpdateProgressTo) &#123; [_delegate networkFetcher:self didUpdateProgressTo:currentProgress];&#125; 如果多次调用判断方法，那么这个优化是有价值的。是否优化需要取决你的代码。你应该使用性能检测工具检测你的代码是否遇到性能瓶颈，如果需要优化可以使用类似技巧。如果频繁从数据源获取数据，那么该优化技术极大可能提高程序效率。 小结 委托模式为对象提供了一套接口，使其可将相关事件告诉其他对象。 在协议中把可能需要处理的事件定义成方法。 当一个对象需要从别的对象获取数据时，使用委托模式。在这种情况下，该模式被称为数据源模式。 如果需要，可以实现包含位段的结构体，用于缓存被委托者相应指定方法的结果。 使用便于管理的分类分散类的实现代码随着许多方法放置在实现文件中，一个类很容易变得臃肿。有时候，这样是没问题的，即使你对它们进行了重构也并不能变得更好。在这种情况下，可以使用Objective-C的类别功能，将其分封在几个区域中，这对开发和调试都有好处。 比如有一个模型类代表人的信息。那么这个类就会有一些方法： 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;/* Friendship methods */- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;/* Work methods */- (void)performDaysWork;- (void)takeVacationFromWork;/* Play methods */- (void)goToTheCinema;- (void)goToSportsGame;@end 这个类的实现会包含长长的方法列表。如果有更多方法加进这个类，这个类会随着时间越来越难以管理。所以分隔这个类是常用的办法。例如，使用类别功能，上面的类可能这样写： 123456789101112131415161718192021222324252627282930313233#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;@end@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work)- (void)performDaysWork;- (void)takeVacationFromWork;@end@interface EOCPerson (Play)- (void)goToTheCinema;- (void)goToSportsGame;@end 现在，类的每个不同部分都被划分到不同的类别中了。毫不奇怪，这项语言的特性被称作类别。在这个例子中，类的基础部分包括属性和初始化方法，所以声明在主实现中。附加的那些方法，根据不同功能，分封在不同的类别中。 你仍然可以将所有的声明和实现放在一个类中，但随着类别的增长，单一的实现文件也很容易变得难以管理。在这个例子中，类别也可以拥有它们自己的实现文件。例如，EOCPerson可以这样分隔实现： EOCPerson+Friendship(.h/.m) EOCPerson+Work(.h/.m) EOCPerson+Play(.h/.m) 例如，Friendship分类可以这样实现： 123456789101112131415161718192021222324252627// EOCPerson+Friendship.h#import &quot;EOCPerson.h&quot;@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import &quot;EOCPerson+Friendship.h&quot;@implementation EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person &#123; /* ... */&#125;- (void)removeFriend:(EOCPerson*)person &#123; /* ... */&#125;- (BOOL)isFriendsWith:(EOCPerson*)person &#123; /* ... */&#125;@end 这个类已经被分隔成多个易于管理的代码块，并且利于单独检查。使用分类机制之后，如果要使用分类方法，要记得将有关的类别头导入EOCPerson的头文件。虽然稍微有点麻烦，但这是使代码易于管理的好办法。 即使类不是很大，也可以通过分类机制将不同模块的代码放入不同的功能域。在Cocoa框架中有一个这样的例子，那就是NSURLRequest和它的可变版本NSMutableURLRequest。这个类经常使用HTTP请求获取网络数据，但是它也能使用别的协议。然而，与标准的URL相比，HTTP请求需要额外的附加信息，例如HTTP方法(Get、Post等)和HTTP头。 但是NSURLRequest不是易于子类化的，因为它包含了一套操作CFURLRequest结构体的C函数，以及所有的HTTP方法。所以给NSURLRequest添加了一个叫做NSHTTPURLRequest的类别，用于放置HTTP相关方法，还添加了一个叫做NSMutableHTTPURLRequest的类别，用于放置可变版本的方法。这样所有的CFURLRequest的方法都封装在同一个类里面了，但是仍要将HTTP方法单独拆分，不然使用者可能会想，为什么FTP协议的请求可以设置HTTP方法？ 另一个使用类别的原因是便于调试：对于某个分类中的所有办法来说，分类名称会出现在其符号中。例如，addFriend:输出的符号名是这样的： 1-[EOCPerson(Friendship) addFriend:] 当它在调试器的回溯中出现时，通常是这样的： 1frame #2: 0x00001c50 Test&apos;-[EOCPerson(Friendship) addFriend:] + 32 at main.m:46 在回溯中的类别名称可以很容易的区分类方法属于哪个功能区，对私有方法特别有用。在这种情况下，可能会创建一个叫做private的类别包含这些私有方法。这种类别的方法通常只用在类或者框架的内部。如果使用者通过回溯看到了这个信息，就知道不该直接调用这个私有方法。这算是一种自我描述式代码的办法。 当你决定创建一个库给别人使用时，私有的类别是非常有用的。通常，有一些方法不应该暴漏在外部，但是却适合在类库内部使用。在这种情况下，创建一个私有分类是非常有用的，因为可以在任何需要使用的内部导入它的头文件。如果类别头文件不随着类库一并公开，那么类库的使用者是不会知道这些私有类别的。 小结 使用类别分隔某个类，使其易于管理。 创建一个私有类别用于隐藏那些不该暴漏的方法。 总是为第三方类的分类名称加前缀类别通常被用做给已存在的但无源码的类添加功能。这是一个非常有用的功能，但是这样做也很容易出问题。产生问题的原因是如果类本身有某个方法，而分类又实现了这个方法，那么类本身的方法将会被覆盖。在运行时会将分类中的每个方法加入到类的方法列表中。如果类中有这个方法，而分类又实现一次，那么分类中的方法就会覆盖类中的。实际上这个问题可能会发生不止一次，因为某个类别覆盖了类的本身实现，别的类别覆盖了上个类别。那么调用时将会调用最后一个覆盖的方法。 例如，你创建一个NSString的类别，并提供一些用于处理HTTP URL的方法。你可能会这样定义： 123456@interface NSString (HTTP)// Encode a string with URL encoding- (NSString*)urlEncodedString;// Decode a URL encoded string- (NSString*)urlDecodedString;@end 这看起来非常好啊，但是考虑一下如果另一个类别也给NSString添加了同样的方法。第二个类别也添加了一个叫做urlEncodedString的方法，但是实现却与你的类别有些微差异。如果那个类别在你的类别之后加载，那么调用方法时将会调用第二个类别的。这会导致你的代码不能正确的工作，并且会得到意料之外的结果。这种问题是难以排查的，因为你不知道实际上你的方法并没有运行。 解决这种问题，一般的做法是使用命名空间区分类别和类别中的方法。而Obejective-C中命名空间的做法是给相关名称加上前缀。就像之前给类添加前缀一样，给分类选择前缀也要选择恰当才行。通常，前缀名与你的应用名或者库名相同。因此，NSString类别加上ABC前缀之后大概是这样的： 12345678@interface NSString (ABC_HTTP)// Encode a string with URL encoding- (NSString*)abc_urlEncodedString;// Decode a URL encoded string- (NSString*)abc_urlDecodedString;@end 从技术上讲，并不一定需要把类别名称加前缀。两个同名类别不会出现问题。但是这是不好的，因为编译器会发出这样的编译警告： 1warning: duplicate definition of category &apos;HTTP&apos; on interface &apos;NSString&apos; 即使这样也可能会有别的类别覆盖你的方法，但是这样做可以大大减少这种情况，因为别的类和你使用相同的前缀名是不太可能的。这样做也能避免类的开发者以后更新类的时候覆盖你的方法。例如，如果苹果给NSString添加了urlEncodedString方法，而你的方法又没有增加前缀，那么你将覆盖苹果的方法。这是不合适的，因为别的NSString类的使用者想得到的结果是苹果的代码输出，而非你的返回结果。或者苹果实现的方法带有一些别的效果，你的方法如果覆盖了苹果的方法并且没有响应的效果，那么就会产生难以排查的问题。 此外要记住的是你使用分类给某个类添加的方法，该类的每一个实例都可以调用。如果你给系统提供的类添加功能，例如NSString、NSArra、NSNumber，那么即使这些类的实例不是由你的代码初始化出来的，它们也可以调用你添加的方法。如果你无意中把自己类别中的方法起的和其他分类或者第三方库一样，那么将会产生难以预料的问题，因为你以为执行的是自己的方法，但是实际上却不是。同样的，使用类别故意覆盖方法也是不好的，尤其是当你的方法是以类库形式提供给别人使用时，而他们又要依赖系统中的功能。如果其他开发者覆盖相同的方法，那么就更不能确定到底运行的是哪个类别的方法了。这又一次说明了给类别方法使用命名空间的重要性。 小结 向第三方类中添加分类时，总应给你的分类加上相应的前缀。 向第三方类中添加分类时，总应给你分类中的方法加上相应的前缀。 避免在类别中使用属性属性是用来封装数据的(看第6节)。从技术上讲你可以在类别中声明属性，但你不应该这样做。理由是，除了类扩展(看第27节)这种特殊类别会产生实例变量并加入类中，普通类别中的属性并不会产生实例变量。 在阅读了第24节之后，你决定将一个代表人的类的实现分隔进不同的类别中。你可能会创建一个朋友的类别用来存放所有操作朋友属性的方法。如果你不知道“应该避免在类别中使用属性这个问题”，你可能会这样写： 1234567891011121314151617181920212223242526#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;@end@implementation EOCPerson// Methods@end@interface EOCPerson (Friendship)@property (nonatomic, strong) NSArray *friends;- (BOOL)isFriendsWith:(EOCPerson*)person;@end@implementation EOCPerson (Friendship)// Methods@end 如果你就这样编译它，那么你会得到两个编译警告： 1234567warning: property &apos;friends&apos; requires method &apos;friends&apos; to bedefined - use @dynamic or provide a method implementation inthis category [-Wobjc-property-implementation] warning: property &apos;friends&apos; requires method &apos;setFriends:&apos; to bedefined - use @dynamic or provide a method implementation inthis category [-Wobjc-property-implementation] 这个警告的意思是属性不能自动合成变量，所以需要提供存取方法去实现属性。或者，你可以使用@dynamic声明属性，告诉编译器你会在运行时添加，而不是编译时。如果你在运行时使用消息转发机制(看第12节)拦截消息，并且提供实现这也是个办法。 关于为什么类别不能生成变量，你可以去看关联对象(对，去看第10节)。例如，在类别中，你可能需要这样实现： 1234567891011121314151617181920#import &lt;objc/runtime.h&gt;static const char *kFriendsPropertyKey = &quot;kFriendsPropertyKey&quot;;@implementation EOCPerson (Friendship)- (NSArray*)friends &#123; return objc_getAssociatedObject(self, kFriendsPropertyKey);&#125;- (void)setFriends:(NSArray*)friends &#123; objc_setAssociatedObject(self, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这样做也可以使代码正常工作，但这不是一个好主意。这是一个重复且容易在内存管理上出错的做法，因为你很容易忘记属性的实现。例如，你修改了它关联属性的内存管理语义，那么你总是需要记着修改setter方法中的内存管理语义。尽管这不是坏的解决办法，但我也不推荐这样做。 并且，你可能想让返回的friends数组是可变的。你可以对传入的数组使用mutableCopy，但这样又会产生另一个编程问题。综上所述，在主文件中定义属性是比在类别中更清楚易懂的。 在这个例子中，正确的做法是将所有的属性定义在主文件中。所有的数据封装都应该定义在主文件，那里是唯一可以定义变量的地方。因为属性其实只是实例变量以及存取方法的语法糖。类别的唯一用途就是给类添加额外的方法而不是存储数据。 话虽如此，有时也可以在类别中使用只读属性。例如，你可能想创建一个NSCalendar的分类，并且返回一个包含所有月份字符串的数组。因此这个方法不需要访问任何属性也不需要产生实例变量，你可以像下面这样定义它： 1234567891011121314151617181920212223@interface NSCalendar (EOC_Additions)@property (nonatomic, strong, readonly) NSArray *eoc_allMonths;@end@implementation NSCalendar (EOC_Additions)- (NSArray*)eoc_allMonths &#123; if ([self.calendarIdentifier isEqualToString:NSGregorianCalendar]) &#123; return @[@&quot;January&quot;, @&quot;February&quot;, @&quot;March&quot;, @&quot;April&quot;, @&quot;May&quot;, @&quot;June&quot;, @&quot;July&quot;, @&quot;August&quot;, @&quot;September&quot;, @&quot;October&quot;, @&quot;November&quot;, @&quot;December&quot;]; &#125; else if ( /* other calendar identifiers */ ) &#123; /* return months for other calendars */ &#125;&#125;@end 这样属性就无需生成实例变量了，因为所有需要的方法(仅仅在属性是只读的情况下)都已经实现。因此，编译器也不会有任何警告。即使在这种情况下，也最好避免使用属性。属性要表达的意思是它持有某些数据。属性是用来封装数据的。在这个例子中，你应该声明一个方法去替代属性的使用： 12345@interface NSCalendar (EOC_Additions)- (NSArray*)eoc_allMonths;@end 小结 保持所有属性都声明在主文件中。 除非是类扩展这种特殊类别，否则类别中尽量不要定义属性，但可以定义存取方法。 使用类扩展隐藏类实现细节通常，你的类里面的很多方法和实例变量是只想给内部使用的。你可以表面上暴漏它们但将它们标记为私有的，那么使用者就不会使用这些了。最重要的是，在Objective-C中是没有私有变量或私有方法的，这完全因为Objective-C的动态消息派发系统(看第11节)。然而，只暴漏需要暴漏的公共方法才是正确的原则，但是我们应该在哪里声明不该暴漏的属性和方法呢？这时就需要特殊的类别，即类扩展了。 类扩展不像普通的类别，它必须定义在类的实现文件中。重要的是，它是仅有的允许声明实例变量的类别。而且，这个类别不需要特殊的实现。任何定义在这里的方法和属性都能正常的出现在类的使用中。不像其他类别，这个特殊的类别也没有名字。一个EOCPerson类的类扩展大概是这样的： 123@interface EOCPerson ()// Methods here@end 为什么这个类别有用？它有用是因为这里可以定义实例变量和方法。这种可能性来源于稳定的ABI(看第6节)，这意味着不需要知道对象的大小也可以使用它。因此，内部使用的实例变量不需要定义在公共接口中，这样类的使用者也不会知道类的内存布局。因此，使用类扩展给类添加实例变量等同于在类实现中添加变量。为了这样做，你只需要在类扩展右侧加上大括号，并将变量放置在那里。 12345678910111213@interface EOCPerson () &#123; NSString *_anInstanceVariable;&#125;// Method declarations here@end@implementation EOCPerson &#123; int _anotherInstanceVariable;&#125;// Method implementations here@end 这样做有什么意义吗？你可以在公共接口中定义实例变量啊。但是这样做可以将实现细节隐藏在类扩展或者实现块中，使其仅为本类使用。即使你在公共接口中将其标位private，但依然泄露了实现细节。例如，你不想别人知道你在类的内部使用了某个秘密的类。假如你在类中使用了秘密的类并且将其定义在公共接口中，那么看起来像这样： 123456789#import &lt;Foundation/Foundation.h&gt;@class EOCSuperSecretClass;@interface EOCClass : NSObject &#123;@private EOCSuperSecretClass *_secretInstance;&#125;@end 这个叫做EOCSuperSecretClass的类已经泄露了。你可以不将其类型信息表现出来并使用id代替。但这样做是不好的，因为你在内部使用时，无法获得编译器的任何帮助。仅仅因为不想暴漏类型就要失去编译器的帮助？类扩展可以很好的达成这个目标。现在它的定义像这样： 12345678910111213141516171819202122// EOCClass.h#import &lt;Foundation/Foundation.h&gt;@interface EOCClass : NSObject@end// EOCClass.m#import &quot;EOCClass.h&quot;#import &quot;EOCSuperSecretClass.h&quot;@interface EOCClass () &#123; EOCSuperSecretClass *_secretInstance;&#125;@end@implementation EOCClass// Methods here@end 同样的，实例变量也可以定义在类实现块中，在语义上它跟定义在类扩展中是一样的。我更推荐将其添加在类扩展中，因为它可以保持定义地方的一致性。你可能已经将属性定义在这里了，所以这是一个好的添加额外变量的地方。这些变量并不是真正意义上的私有，在运行时通过某些方法依然可以得到它们，但在我们的目的上，它们是私有的。而且，如果它们没有声明在公共头文件中，如果你的代码是某个库的一部分，那它们会隐藏的更深。 另一个使用类扩展的地方是在你混写Objetive-C和C++代码时。在混写环境下，你所写的代码两种语言都可以使用。游戏通常出于性能和移植性的考虑，一般会使用C++。有时，你可能需要使用C++，因为你使用了一个第三方库并且那个库是用C++写的。这种情况下，类别同样可以处理。假设在你使用类别之前，你可能会这样写： 12345678910#import &lt;Foundation/Foundation.h&gt; #include &quot;SomeCppClass.h&quot;@interface EOCClass : NSObject &#123;@private SomeCppClass _cppClass;&#125;@end 这个类的实现文件应该叫做EOCClass.mm，这个.mm告诉编译器应该允许混编，没有这个符号，就无法导入SomeCppClass.h了。然而这样会把整个SomeCppClass类导入进来，因为编译器需要知道_cppClass的全部信息。所以任何包含了EOCClass.h的类也需要能进行混合编译，因为它也包含了SomeCppClass.h。这很容易导致失去控制使得整个项目都需要进行混合编译。这么做完全可以，但是我不推荐这种做法，特别是当你的代码以第三方库的形式给别人使用时，这会让使用者需要给所有的文件重新命名并加上.mm后缀。 你可能会使用前向声明的方法导入这个C++类，并将其实例变量声明为一个指针，如下： 12345678910#import &lt;Foundation/Foundation.h&gt;class SomeCppClass;@interface EOCClass : NSObject &#123;@private SomeCppClass *_cppClass;&#125;@end 这个实例变量现在需要声明为一个指针，如果它不是指针，编译器无法得知它的大小，这将会产生一个错误。指针的大小是固定的，所以需要告诉编译器它是一个指针。这时问题又出现了，别的导入了EOCClass的类，当它们发现class这个关键字时，这是一个C++关键字，它们也需要能进行混编才能编译通过。这是没有必要的，因为这是一个私有变量，别的类根本不关心它的存在。这时，类扩展又一次派上用场了。像下面这样使用它： 12345678910111213141516171819202122// EOCClass.h#import &lt;Foundation/Foundation.h&gt;@interface EOCClass : NSObject@end// EOCClass.mm#import &quot;EOCClass.h&quot; #include &quot;SomeCppClass.h&quot;@interface EOCClass () &#123; SomeCppClass _cppClass;&#125;@end@implementation EOCClass@end 现在头文件从C++中脱离出来了，而使用了这个头文件的其他类也无需担心C++了，现在C++的使用是秘密了。在系统的一些类库中也使用了这种模式，例如WebKit，这是一个网页浏览器框架，它同样是使用C++写的并且提供了只有Objective-C语言的接口。这个模式在CoreAnimation中也有用到，内部都是使用C++书写，给外部使用的接口都是Objective-C。 类别的另一个用途是在公共接口中提供只读属性在内部对属性进行修改。通常你会调用属性的setter方法而不是直接调用实例变量，是因为你不知道是否有其他对象监听了你的属性，而直接调用实例变量不会触发KVO。出现在类扩展或者类别中的属性，必须与主文件中的属性特质一致，但是只读特质可以改变为读写特质。例如，下面类的公共文件如下： 12345678910#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName;@end 通常类扩展中会修改这两个属性的读写特质： 123456@interface EOCPerson ()@property (nonatomic, copy, readwrite) NSString *firstName;@property (nonatomic, copy, readwrite) NSString *lastName;@end 一切准备妥当了。现在EOCPerson的实现文件可以通过setFirstName:和setLastName:方法或者点语法自由的设置数据了。这样做也可以保证外部是不可变的，内部仍可根据需要修改。这样封装的数据就由类本身的实例进行控制，外部就无法控制了。第18节有更多关于这个话题的信息。请注意，现在有一个潜在的问题，如果观察者正在读取这个值，而内部则正在对这个值进行修改，则有可能引发竞争条件。合理的使用同步(看第41节)机制将减少问题的发生。 另一个使用类扩展的地方是在其中声明私有方法，即只在类内部使用的方法。因为它表示这些方法都是在内部使用的。看起来是这样的： 12345@interface EOCPerson ()- (void)p_privateMethod;@end 这个地方使用前缀的原因是第20节讲述了使用前缀标示私有方法。在最新的编译器版本，不需要严格遵守这条约定。但是，在类似的类扩展中将方法标示出来仍然是一个好主意。我经常像这样先把方法原型写出来。然后再去考虑实现这些方法。这是一个提高类可读性的办法。 最后，类扩展也是一个遵循协议私有化的好地方。通常，你不需要在公共接口中泄露你遵守了哪些确定的协议，可能因为那个协议是私有API的一部分。例如，EOCPerson类遵循一个叫做EOCSecretDelegate的协议。如果在公共接口中声明，它大概是这样的： 1234567891011#import &lt;Foundation/Foundation.h&gt; #import &quot;EOCSecretDelegate.h&quot;@interface EOCPerson : NSObject &lt;EOCSecretDelegate&gt;@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName;@end 你可能认为你可以仅仅前向声明这个协议而不是导入它(或者在头文件定义它)。你使用前向声明代替导入： 1@protocol EOCSecretDelegate; 然而任何一个导入了这个头文件的地方，编译器都会有下面的警告： 1warning: cannot find protocol definition for &apos;EOCSecretDelegate&apos; 这个警告是因为编译器知道不会有机会知道协议中到底定义了什么方法。但是它是一个私有的内部协议，你甚至没必要泄露它的名字。类扩展再次救场！替代EOCPerson在公共接口中遵循EOCSecretDelegate协议，你可以在类扩展中这样写： 12345678910#import &quot;EOCPerson.h&quot;#import &quot;EOCSecretDelegate.h&quot;@interface EOCPerson () &lt;EOCSecretDelegate&gt;@end@implementation EOCPerson/* ... */@end 公共接口对协议的遵循被移除。私有协议不在暴漏，使用者如果不深入查找也不知道它的存在。 小结 使用类扩展给类添加实例变量。 如果在公共接口中声明的属性需要在内部进行修改，使用类扩展修改它的读写特质。 在类扩展中声明私有方法。 使用类扩展去遵循你想私有的协议。 通过协议提供匿名对象协议定义了一系列遵循对象应该实现或者必须实现的方法。因此我们可以通过协议隐藏自己所写的API细节，将返回的对象设计为遵从此协议的id类型。这样就不会泄露API中特定类的名字了。当你想有许多不同类的行为时这是非常有用的，并且也不需要指定特定的类。例如，许多类并不能以标准的继承方式实现时，因此它们没有共同的基类。 这个概念被称为匿名对象，它并不像别的语言中的匿名对象。别的语言的匿名对象是指通过一个类的内联函数创建的没有名字的对象。在Objective-C中，它并不是这个意思。在第23节，委托和数据源已经展示了匿名对象的使用。例如，委托的属性可能这样定义： 1@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate; 这个属性的类型是id&lt;EOCDelegate&gt;，因此这个类的对象可以是任何东西；即使它不继承自NSObject也行。只要它遵循EOCDelegate协议。对具有此属性的类，这个就是匿名对象。如果你想知道匿名对象的类型信息也是可以的，只要在运行时检查对象的类型就可以了。但是这样做不是个好习惯，因为既然选择了这种属性类型就是不需要关心类型信息。 NSDictionary是这个概念的另一个例子。字典的key的内存管理语义是当设置值时拷贝它。因此，在一个可变数组中，设置一组键值对的方法如下： 1- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key key参数的类型是id&lt;NSCopying&gt;，因为它只需要任何遵循NSCopying协议的对象，只要能成功接收拷贝的消息就可以当做key。这个key参数也可以是匿名的。就像刚才的委托属性，字典也不关心key的类并且它也不需要。它只需要知道key这个参数可以接收拷贝信息即可。 使用匿名对象的另一个例子是当一个对象是从一个库返回时，这个库是用于处理数据库连接的。你可能不想泄露处理数据库的类，因为它可能不是同一个数据库。这些方法不是来自一个同样的基类，你只能强制它们返回id类型。但是，你可以创建一个协议并且声明通用的方法，让所有的处理数据库连接的类声明并遵循它。这个协议看起来是这样的： 12345678@protocol EOCDatabaseConnection- (void)connect;- (void)disconnect;- (BOOL)isConnected;- (NSArray*)performQuery:(NSString*)query;@end 然后你创建一个处理数据库的单例类，用以提供数据库连接。它的接口大概是这样的： 1234567891011#import &lt;Foundation/Foundation.h&gt;@protocol EOCDatabaseConnection;@interface EOCDatabaseManager : NSObject+ (id)sharedInstance;- (id&lt;EOCDatabaseConnection&gt;)connectionWithIdentifier: (NSString*)identifier;@end 这样，这个类就可以处理数据库连接而不暴漏来自不同的框架不同的类并且都返回同样的方法。所有使用这个API的人只要关心这个对象可以执行连接和断开连接就可以了。这一点很重要。在这个例子中，后端代码去处理数据库连接可以使用不同的第三方库去连接不同的数据库。(例如，MySQL, PostgreSQL)。由于这些类来自不同的第三方库，让它们继承同一个基类是不可能的事情。所以可以把这些第三方类简单的包装起来，使匿名对象成为其子类，并遵循EOCDatabaseConnection协议。然后可以通过connectionWithIdentifier:方法返回这些类对象。在开发后续呢版本时，无需改变公共API即可切换后端的实现类。 当你想表达的对象类型是不重要的时候，你也可以选择匿名类型，但更重要的是对象有没有实现某些方法。即使你实现中的某个类型总是确定的，你可能仍想使用匿名类型来表达它类型是不重要的。在CoreData框架中有一个这种用法的例子。这个类叫做NSFetchedResultsController，它用来处理查询CoreData数据库的结果，如果有需要，处理时还会把数据分区。在负责查询结果的控制器上有一个叫做sections的字段用来处理分区。它是一个遵循NSFetchedResultsSectionInfo协议的对象数组而不是一个具体类型的数组。使用控制器去获取分段信息就像这样： 12345NSFetchedResultsController *controller = /* some controller */;NSUInteger section = /* section index to query */;NSArray *sections = controller.sections;id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = sections[section];NSUInteger numberOfObjects = sectionInfo.numberOfObjects; sectionInfo是一个匿名对象。在制作API时要把通过对象获取分段信息这个功能清晰的展示出来。在代码内部，这个对象可能是结果控制器通过内部状态创建出来的。也没必要把这个状态暴漏在公共接口总，因为这个控制器的使用者并不关心数据段是如何存储的。它们需要的只是能通过这个控制器去查询数据。sections数组中返回的内部状态对象就是遵循了某个协议的匿名对象。使用者只要知道它实现了一些方法就可以了，这样也隐藏了对象的其余实现细节。 小结 协议可以在某种程度上提供匿名对象。对象的类型可以降低为遵循了某协议并实现了某些方法的id类型。 当类型信息应该被隐藏时，使用匿名对象。 当类型信息不重要时，并且对象实现了该实现的方法(某个协议定义的)，那么可匿名对象表示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第三章]]></title>
      <url>%2F2017%2F06%2F08%2FInterface%20and%20API%20Design%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第三章：接口和API设计 简介一旦你构建过一个应用程序，那么你可能会想在将来的项目中重用部分代码。你甚至可能想要发布一些代码给他人使用。即使你认为你不会这样做，你也可能在别的地方用到。当你阅读过本节，它将帮你写出合适的接口声明。这意味着你需要理解各种缺陷，才能写出标准模板一样的Objective-C代码。 近年来，随着iOS的问世，带来了大量的开源社区和流行的组件，你经常会在自己的项目里使用别人的代码。相似的，别人也可能会使用你的代码，所以写出清晰的代码可以使别人更快、更容易的整合你的代码。并且谁也不知道，你写下的某个库会不会被成千上万的应用使用呢！ 使用前缀名去避免命名空间冲突不像别的语言，Objective-C没有命名空间功能。由于这个原因，如果没有采取措施去避免，命名冲突是非常容易出现的。由于符号重复编译错误，命名冲突对应用的影响是可能导致项目无法链接，例如： 123456duplicate symbol _OBJC_METACLASS_$_EOCTheClass in: build/something.o build/something_else.oduplicate symbol _OBJC_CLASS_$_EOCTheClass in: build/something.o build/something_else.o 这个错误结果是因为某个符号在EOCTheClass类和其元类(看第14节)的符号表定义了两次。在应用程序的两部分代码中，同时存在EOCTheClass类的两个实现，那个符号也就自然会定义两次。 更糟糕的是，如果在链接时没有发现某个库包含了一份重复的代码，而是在运行时加载。在这种情况下，动态加载器将会遭遇重复符号错误并且导致应用程序崩溃。 仅有一种办法去避免这个问题就是去使用一个粗糙的命名空间：给所有的名字加上一个确定的前缀。这个前缀应该选择你公司名字或者应用名字或者两者结合。例如，如果你的公司名字叫做Effective Widgets，你可能决定在应用中使用EWS前缀，如果是EWB前缀，仅仅因为你的应用叫做Effective Browser。即使你加上了前缀也不会没有名称冲突，但是会减少发生的次数。 如果你使用Cocoa创建应用程序，需要注意苹果已经表明可能会使用任意两个字母作为前缀，所以在这种情况下，你应该选择三个字母做前缀。例如，如果你不遵守这项约定并使用了TW作为前缀，那么将会产生问题。当iOS 5.0的SDK发布时，它带来了Twitter框架，并且选择TW作为前缀，有一个叫做TWRequest的类用于支持Twitter API的HTTP请求。如果你的公司叫做Tiny Widgets，并且有你自己用的API，那么你很大可能会有一个叫做TWRequest的类。 在你的应用中，前缀不该带有类名但应该适用于所有的类。第25节讲述了如果类别基于存在的类，类别名字和方法名字前缀的重要性。另一个常被忽视的问题是与C函数的冲突或者你在类的实现文件中使用的全局变量。通常很容易忘记全局变量在编译后的目标文件中是作为顶级符号出现的。例如，在iOS SDK中的AudioToolbox框架，它有一个函数用于播放一个声音文件。你可以给它一个回调从而在它结束时调用它。你可能会去写一个类，当声音文件播放结束时，去调用它，像下面这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// EOCSoundPlayer.h#import &lt;Foundation/Foundation.h&gt;@class EOCSoundPlayer;@protocol EOCSoundPlayerDelegate &lt;NSObject&gt;- (void)soundPlayerDidFinish:(EOCSoundPlayer*)player;@end@interface EOCSoundPlayer : NSObject@property (nonatomic, weak) id &lt;EOCSoundPlayerDelegate&gt; delegate;- (id)initWithURL:(NSURL *)url;- (void)playSound;@end// EOCSoundPlayer.m#import &quot;EOCSoundPlayer.h&quot;#import &lt;AudioToolbox/AudioToolbox.h&gt;void completion(SystemSoundID ssID, void *clientData) &#123; EOCSoundPlayer *player = (__bridge EOCSoundPlayer*)clientData; if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) &#123; [player.delegate soundPlayerDidFinish:player]; &#125;&#125;@implementation EOCSoundPlayer &#123; SystemSoundID _systemSoundID;&#125;- (id)initWithURL:(NSURL *)url &#123; if (self = [super init]) &#123; AudioServicesCreateSystemSoundID((__bridge CFURLRef)url, &amp;_systemSoundID); &#125; return self;&#125;- (void)dealloc &#123; AudioServicesDisposeSystemSoundID(_systemSoundID);&#125;- (void)playSound &#123; AudioServicesAddSystemSoundCompletion( _systemSoundID, NULL, NULL, completion, (__bridge void*)self); AudioServicesPlaySystemSound(_systemSoundID);&#125;@end 这看起来没什么问题，但是从这个目标文件的符号表中发现了一点不同，如下： 1234567891011121314151600000230 t -[EOCSoundPlayer .cxx_destruct]0000014c t -[EOCSoundPlayer dealloc]000001e0 t -[EOCSoundPlayer delegate]0000009c t -[EOCSoundPlayer initWithURL:]00000198 t -[EOCSoundPlayer playSound]00000208 t -[EOCSoundPlayer setDelegate:]00000b88 S _OBJC_CLASS_$_EOCSoundPlayer00000bb8 S _OBJC_IVAR_$_EOCSoundPlayer._delegate00000bb4 S _OBJC_IVAR_$_EOCSoundPlayer._systemSoundID00000b9c S _OBJC_METACLASS_$_EOCSoundPlayer00000000 T _completion00000bf8 s l_OBJC_$_INSTANCE_METHODS_EOCSoundPlayer00000c48 s l_OBJC_$_INSTANCE_VARIABLES_EOCSoundPlayer00000c78 s l_OBJC_$_PROP_LIST_EOCSoundPlayer00000c88 s l_OBJC_CLASS_RO_$_EOCSoundPlayer00000bd0 s l_OBJC_METACLASS_RO_$_EOCSoundPlayer 注意符号表的中间部分，有一个符号叫做_completion。它是completion函数创建的用于在声音播放结束时做一些事情。即使它是在实现文件实现的，并且没有在头文件声明它，它依然作为顶级符号出现在这里。因此，如果某处创建的函数也叫做completion，那么将会出现一个错误，像下面这样的： 123duplicate symbol _completion in: build/EOCSoundPlayer.o build/EOCAnotherClass.o 更糟糕的是如果你把库给别人用，他们在自己的应用中使用它。如果你暴漏了一个类似_completion的符号，任何使用你这个库的人都可能会创建一个叫做_completion的函数，这是非常不幸的。 所以你应该给它加上类似于C函数的前缀。例如，在之前的例子中，你可以将completion命名为EOCSoundPlayerCompletion。如果符号曾在回溯堆栈时出现，即使出现问题，也是异域排查的。 当你使用第三方库或者将你的代码制作成库给别人使用时，你要特别小心重复符号的问题。当你在你的应用程序中使用了第三方库时，重复符号错误是容易发生的。在这种情况下，通常会使用自己的前缀去给所有的第三方库加上前缀。例如，如果你的库叫做EOCLibrary并且你添加了一个叫做XYZLibrary的库，你将给XYZLibrary添加EOC前缀。然后应用程序使用XYZLibrary时，就没有命名冲突的机会了，如图3.1。 Figure 3.1 避免第三方库两次编译：一次应用程序本身另一次是库本身 仔细检查并更改所有的名字，看起来是件乏味的事情，但如果你想避免命名冲突，那是很有用的。你可能会问为什么需要这样做，并且为什么应用程序不能简单的包含XYZLibrary库本身并且使用它的实现。这也是可以的，但你考虑下面这个场景，你的应用程序包含另一个第三方库，叫做ABCLibrary，并且它也使用了XYZLibrary。在这种情况下，如果你和ABCLibrary库的作者都没有前缀，那么应用程序仍将发生重复符号的错误。或者你使用XYZLibrary的X版本，但是应用需要的功能是Y版本，那么它将会自动拷贝。如果你在开发的时候使用流行的第三方库，你将经常看到这种类型的前缀。 小结 选择一个适合的前缀，可以是公司名，应用名，或者都可以。并且一直使用这个前缀。 当你使用的第三方库依赖你自己的库，考虑给它的名字加上你的前缀。 提供指定的初始化器所有的对象都需要初始化。当你初始化一个对象时，有时你不需要给他任何信息，有时需要。这种情况通常出现在没有信息就不能执行相应的方法的情况。例如，iOS的UIKit框架中的UITableViewCell，组中不同类型的cell需要不同的类型和标示符，这样可以使用cell对象的复用功能，而不需要一直去创建。在初始化时，赋予对象执行任务所需的信息，在术语上称为指定初始化器。 一个类中有多种方法去创建实例，那么这个类可能会有多个初始化方法。这是很好的，但是应该其余方法调用指定的初始化方法。一个例子是NSDate，像下面这样的初始化方法： 123456- (id)init- (id)initWithString:(NSString*)string- (id)initWithTimeIntervalSinceNow:(NSTimeInterval)seconds- (id)initWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate*)refDate- (id)initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds- (id)initWithTimeIntervalSince1970:(NSTimeInterval)seconds 上述情况中的指定初始化器是- (id)initWithTimeIntervalSinceReferenceDate:，类中的文档说明了这一点。它的意思是别的初始化方法其实都是调用了这个初始化方法。因此，指定的初始化器是存储内部数据的唯一地方。如果需要改变数据存储，那么仅需要改变这个方法就可以了。 例如，考虑一个代表范围的类。它的接口应该像下面这样： 12345#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject@property (nonatomic, assign, readonly) float width;@property (nonatomic, assign, readonly) float height;@end 注意上述属性是只读(看第18节)的。这意味着矩形对象不能在外部修改它的属性。所以你可能创建一个这样的初始化方法： 123456789- (id)initWithWidth:(float)width andHeight:(float)height&#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125; 但是如果某些调用使用[[EOCRectangle alloc] init]去创建实例呢？这样做是合法的，因为EOCRectangle的父类是NSObject，NSObject实现了一个叫做init的方法，它将所有的对象设置为0(或者是等价于0的数据类型)。如果这个方法被调用，那么EOCRectangle实例的宽和高都将为0。虽然这可能是你想要的，但是你可能更喜欢设置一个默认值，或者通过抛出异常告诉调用者，必须使用你的指定的初始化方法。在EOCRectangle这种情况下，它可能会这样覆盖init方法： 123456789101112// Using default values- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125; // Throwing an exception- (id)init &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:andHeight: instead.&quot; userInfo:nil];&#125; 注意设置默认值的版本如何调用初始化方法的。它也可以通过直接设置_width和_height两个实例变量。然而，如果类的存储发生了一些变化。例如，通过一个结构体去存储宽和高的值的集合，你将会需要修改两个方法的逻辑。在这个简单例子中，这还不算坏，但是想象下一个复杂的类有很多初始化方法和复杂的数据。那么将会很容易忘记修改其中的一个，从而导致冲突。 想象下，你现在想去给EOCRectangle创建一个叫做EOCSquare的子类。这种使用场景很常见，但是初始化器该怎么办？很明显，应该强制宽和高相等，因为它是一个正方形！所以你可能决定这样创建初始化： 12345678910111213#import &quot;EOCRectangle.h&quot;@interface EOCSquare : EOCRectangle- (id)initWithDimension:(float)dimension;@end@implementation EOCSquare- (id)initWithDimension:(float)dimension &#123; return [super initWithWidth:dimension andHeight:dimension];&#125;@end 它将变成EOCSquare的初始化器。注意它如何调用父类的指定初始化器。如果你往回看了EOCRectangle的指定初始化器，你将会看到它也调用了父类的指定初始化器。指定初始化器链条是重要的。然而，它仍然可能调用initWithWidth:andHeight:或者init方法去创建对象。你当然不想这样喽，因为有人可能会创建一个宽高不一致的正方形。这是一个重要的点在你子类化某个类时。在子类中如果你有一个不同名字的指定初始化器，你应该总是覆盖指定初始化器。在EOCSquare这种情况下，你可以覆盖EOCRectangle的指定初始化器： 1234- (id)initWithWidth:(float)width andHeight:(float)height &#123; float dimension = MAX(width, height); return [self initWithDimension:dimension];&#125; 注意EOCSquare的指定初始化器是如何调用的。在这种实现情况下，如果调用者调用init方法，仍将产生神奇的事情。回想下EOCRectangle类，init方法的实现是去调用自身的指定初始化器，并且设置默认值。它仍然工作，但是因为initWithWidth:andHeight:方法已经被覆盖，所以它会调用EOCSquare的实现，它会依次调用初始化方法。这样一切正常，并不会创建一个宽高不等的正方形。 有时，你并不想去覆盖父类的指定初始化器，因为没有意义。例如，你可能会觉得一个EOCSquare对象使用initWithWidth:andHeight:方法创建很奇怪。你可能会认为它是一个使用错误。这种情况下，通常的做法是覆盖这个方法并且抛出一个异常： 123456- (id)initWithWidth:(float)width andHeight:(float)height &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instead.&quot; userInfo:nil];&#125; 这看起来有点过于严格，但有时是必要的，这样可以保持内部数据的一致性。在EOCRectangle和EOCSquare这种情况下，这意味着如果调用init方法会抛出错误，因为init方法会调用initWithWidth:andHeight:。这时，你可能会去重写init方法，并让其调用initWithDimension:。 123- (id)init &#123; return [self initWithDimension:5.0f];&#125; 然而，在Objective-C中，抛出异常代表这是一个致命错误(看21节)，如果不能初始化实例，抛出异常应该是最后的选择。 在一些情况下，你可能需要多个指定初始化器。当对象可以以两种不同方式去初始化，那么就需要不止一个指定初始化器了。一个例子是NSCoding的协议，这是一种序列化机制，允许对象进行编码和解码。这种机制在Appkit和UIKit中也是使用广泛的，这两个UI框架分别源于Mac OS X和iOS，并且给对象提供用XML序列化NIB的能力，视图控制器控制解压缩。 NSCoding协议定义了序列化时应该实现下面的方法： 1- (id)initWithCoder:(NSCoder*)decoder; 这种方法通常不是你的主要的指定初始化器，因为它还需要解码器去解码它。例外，如果父类也实现了NSCoding协议，那也需要调用父类的initWithCoder:方法。严格来说，你有两个指定初始化器，因为不止一个初始化方法调用父类的初始化方法。 应用到EOCRectangle类是这样的： 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject &lt;NSCoding&gt;@property (nonatomic, assign, readonly) float width;@property (nonatomic, assign, readonly) float height;- (id)initWithWidth:(float)width andHeight:(float)height;@end@implementation EOCRectangle// Designated initializer- (id)initWithWidth:(float)width andHeight:(float)height&#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// Superclass&apos;s designated initializer- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Initializer from NSCoding- (id)initWithCoder:(NSCoder*)decoder &#123; // Call through to super&apos;s designated initializer if ((self = [super init])) &#123; _width = [decoder decodeFloatForKey:@&quot;width&quot;]; _height = [decoder decodeFloatForKey:@&quot;height&quot;]; &#125; return self; &#125;@end 注意NSCoding的初始化方法，它调用了父类的初始化而不是它自己的初始化。然而，如果父类也实现了NSCoding，它将调用NSCoding自身的指定初始化器。例如下面的类： 123456789101112131415161718192021222324#import &quot;EOCRectangle.h&quot;@interface EOCSquare : EOCRectangle- (id)initWithDimension:(float)dimension;@end@implementation EOCSquare// Designated initializer- (id)initWithDimension:(float)dimension &#123; return [super initWithWidth:dimension andHeight:dimension];&#125;// Superclass designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; float dimension = MAX(width, height); return [self initWithDimension:dimension];&#125;// NSCoding designated initializer- (id)initWithCoder:(NSCoder*)decoder &#123; if ((self = [super initWithCoder:decoder])) &#123; // EOCSquare&apos;s specific initializer &#125; return self; &#125;@end 所有的初始化方法都调用到父类的实现，即initWithCoder:。子类在初始化的任何事情之前调用它，先完成父类的初始化。这样，EOCSquare也可以完全兼容NSCoding协议。如果你是调用你自己的初始化方法或者别的父类的初始化方法，对于EOCSquare的实例来说，EOCRectangle的initWithCoder:方法永远不会被调用，并且宽高两个实例变量永远不会被解码。 小结 在你的类中指定初始化器，并且用文档标明它。所有的别的初始化器都应该调用它。 如果子类的初始化器不同于父类的初始化器，确保你覆写了父类的初始化器。 当子类覆写了父类的初始化器，不应该抛出异常。 实现description方法在调试的时候，你经常会输出一个对象来获得有用的信息。其中一个办法是输出对象的所有属性，通常像下面这样： 1NSLog(@&quot;object = %@&quot;, object); 当你以字符串方式输出对象时，这时对象将调用description方法并且替代%@符号。所以，如果输出对象是一个数组，大概是这样的： 12NSArray *object = @[@&quot;A string&quot;, @(123)];NSLog(@&quot;object = %@&quot;, object); 它的输出是： 1234object = ( &quot;A string&quot;, 123 ) 但是如果你尝试输出一个自己的类，你经常看到这样的结果： 1object = &lt;EOCPerson: 0x7fd9a1600600&gt; 这样的输出是没有数组的输出有帮助的。除非你在你的类中覆写了description方法，否则只会调用NSObject的默认实现。这个方法定义在NSObject协议中，但是NSObject类实现了它。NSObject协议有许多方法，它这样做的原因是NSObject并不是唯一根类。例如NSProxy是另一个根类，它遵循NSObject协议。因为其余根类的子类也可能需要实现协议中的某些方法。如你所见，默认实现并没有太大用。它仅仅展示了对象的类名以及内存地址。如果你仅仅想知道两个对象是不是相同，那它是有用的。然而你可能更想知道它更多的信息。 为了输出有用的东西，你需要去覆写description方法并且返回你想知道的信息。例如，考虑下面的类的描述方法： 12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName;@end@implementation EOCPerson- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; &#125; return self;&#125;@end 一个典型的description方法实现是这样的： 12345- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@\&quot;&gt;&quot;, [self class], self, _firstName, _lastName];&#125; 如果你像这样调用它，它将输出这些信息： 12345EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&quot;Bob&quot; lastName:@&quot;Smith&quot;];NSLog(@&quot;person = %@&quot;, person);// Output:// person = &lt;EOCPerson: 0x7fb249c030f0, &quot;Bob Smith&quot;&gt; 这样的输出很清晰，并且输出了很多有用的信息。我建议应该像默认实现那样，展示类名和指针地址，因为它有时候是有用的。尽管之前的NSArray并没有输出这些，并且也没有明文规定。不过你在description方法中输出的应该是所用到的。 有一个简单的办法去实现包含大量信息的description方法，那就是在返回中包含字典。它的返回值大概是这样的： 1234&#123; key: value; foo: bar;&#125; 可以通过在自己的description方法中形成一个字典并返回包含此词典的字符串。例如，下面的类描述一个位置对象包含一个标题和经纬度： 12345678910111213141516171819202122232425262728#import &lt;Foundation/Foundation.h&gt;@interface EOCLocation : NSObject@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign, readonly) float latitude;@property (nonatomic, assign, readonly) float longitude;- (id)initWithTitle:(NSString*)title latitude:(float)latitude longitude:(float)longitude;@end@implementation EOCLocation- (id)initWithTitle:(NSString*)title latitude:(float)latitude longitude:(float)longitude &#123; if ((self = [super init])) &#123; _title = [title copy]; _latitude = latitude; _longitude = longitude; &#125; return self;&#125;@end 如果description方法能同时输出标题和经纬度就非常好了。如果使用字典，那么description方法可能像这样： 12345678910- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;, [self class], self, @&#123;@&quot;title&quot;:_title, @&quot;latitude&quot;:@(_latitude), @&quot;longitude&quot;:@(_longitude)&#125; ];&#125; 它的输出是这样的： 12345location = &lt;EOCLocation: 0x7f98f2e01d20, &#123; latitude = &quot;51.506&quot;; longitude = 0; title = London;&#125;&gt; 这比刚才仅有指针和类名是有用多的，并且对象的所有属性都很好的展示了出来。你可以总是使用字符串去描述每个变量，但是当更多的属性被加入这个类，字典这种方法更易于操作。 NSObject协议中另一个与之类似的方法叫做debugDescription。它们的不同在于debugDescription是在调式器中输出对象时调用的。NSObject类默认实现就是调用description方法。例如，以EOCPerson类为例，在调试器中运行应用程序，并且断点在输出对象之后，像下面这样： 1234EOCPerson *person = [[EOCPerson alloc] initWithFirstName:@&quot;Bob&quot; lastName:@&quot;Smith&quot;];NSLog(@&quot;person = %@&quot;, person);// Breakpoint here 当断点触发时，控制台准备接收输出。在LLDB调试器中，使用po命令输出对象，像下面这样的： 123EOCTest[640:c07] person = &lt;EOCPerson: 0x712a4d0, &quot;Bob Smith&quot;&gt;(lldb) po person(EOCPerson *) $1 = 0x0712a4d0 &lt;EOCPerson: 0x712a4d0, &quot;Bob Smith&quot;&gt; 注意，调试器中加上了一些额外的信息(EOCPerson *) $1 = 0x0712a4d0。后面的部分来源于debugDescription方法。 你可能只想在description方法中展示正常的人名，在debugDescription方法展示更深入的信息。这种情况下，这两个方法看起来是这样的： 12345678- (NSString*)description &#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName];&#125;- (NSString*)debugDescription &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@\&quot;&gt;&quot;, [self class], self, _firstName, _lastName];&#125; 这次运行相同的代码，并且打印对象，输出如下： 123EOCTest[640:c07] person = Bob Smith(lldb) po person(EOCPerson *) $1 = 0x07117fb0 &lt;EOCPerson: 0x7117fb0, &quot;Bob Smith&quot;&gt; 这种做法是当你在正常调试时不需要看到类名、对象地址等额外信息，在调试器的环境下仍能轻松访问完整信息时使用。Foundation框架中的NSArray类就是一个很好的例子。例如： 123NSArray *array = @[@&quot;Effective Objective-C 2.0&quot;, @(123), @(YES)];NSLog(@&quot;array = %@&quot;, array);// Breakpoint here 这时，运行程序，在断点处停止，并且输出数组对象： 1234567891011EOCTest[713:c07] array = ( &quot;Effective Objective-C 2.0&quot;, 123, 1)(lldb) po array(NSArray *) $1 = 0x071275b0 &lt;__NSArrayI 0x71275b0&gt;( Effective Objective-C 2.0, 123, 1) 小结 覆写description方法以提供实例的字符串描述。 如果想要对象在调试器中做更多事，那么覆写debugDescription方法。 尽量使用不可变对象在设计一个类时，理想情况下，考虑使用属性(看第6节)去存储数据。当使用属性时，你可以限制属性是只读的。默认情况下，属性是可读写的，这使你所有类都是可变的。然而，通常读取到数据之后是不需要改变的。例如，对象存储的数据来自只读的web service，如地图上的兴趣点列表，那么没有情况需要对象可变。如果这样的对象发生了改变，数据将不会被发送给服务器。如第8节所述，如果可变对象存储在集合中，则集合的内部数据结构很容易变得不一致。因此，我建议只在对象需要改变时，使用可变对象。 实际上，这意味着将外部属性设为只读，并且只暴漏需要暴漏的数据。例如，考虑一个类来处理地图上的兴趣点，这些数据来自web service。你可以像下面这样从某个类开始： 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface EOCPointOfInterest : NSObject@property (nonatomic, copy) NSString *identifier;@property (nonatomic, copy) NSString *title;@property (nonatomic, assign) float latitude;@property (nonatomic, assign) float longitude;- (id)initWithIdentifier:(NSString*)identifier title:(NSString*)title latitude:(float)latitude longitude:(float)longitude;@end 所有的数据都来自web service，标示符是服务端给一个兴趣点的标记。一旦兴趣点被创建，并且从服务端拿到数据之后，就不应该在任何场景下去修改。在别的语言中，你可能会创建一个私有变量，并且仅有一个getter方法。然而，在Objective-C中，当你使用属性时，这是非常容易的并且不需要考虑私有变量。 为了使EOCPointOfInterest类不可变，你可以给所有的属性添加只读特质： 1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface EOCPointOfInterest : NSObject@property (nonatomic, copy, readonly) NSString *identifier;@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign, readonly) float latitude;@property (nonatomic, assign, readonly) float longitude;- (id)initWithIdentifier:(NSString*)identifier title:(NSString*)title latitude:(float)latitude longitude:(float)longitude;@end 这确保任何人试图修改某个属性值，编译时都会报错。这些属性的值还可以正常读取，但不能改变，所以EOCPointOfInterest数据不会产生不同。因此，任何人使用这个对象的人都可以确信数据不会被修改的。对象自身的数据结构也不会变的不一致。这种情况下，地图上显示的EOCPointOfInterest对象兴趣点的经纬度都不用担心被修改。 你可能会想为什么会有内存管理语义，因为它是只读的，是没有setter方法的。好吧，你可以简化上面的代码： 1234@property (nonatomic, readonly) NSString *identifier;@property (nonatomic, readonly) NSString *title;@property (nonatomic, readonly) float latitude;@property (nonatomic, readonly) float longitude; 但是，使用内存管理语义是有用的，对你之后将属性特质设置为读写也是容易的。 你可能希望在对象内部对数据进行修改，而不是外部。在这种情况下，通常的做法是重新声明它为读写特质。当然，当属性特质是非原子性时，多个线程同时读写会造成权限的竞争。这是可能的，在一个观察者读取的同时，在内部修改这个属性。这种情况应该被杜绝，所有的访问无论是内部的还是外部的，或者是不同的队列(看第41节)，都应该是同步的。 通过使用分类功能在类的内部将属性重新声明为读写特质。你可以像写在头文件一样重新声明它，只要拥有相同的特质和扩展的读写状态。在EOCPointOfInterest的例子中，类别中的声明可能是这样的： 1234567891011121314#import &quot;EOCPointOfInterest.h&quot;@interface EOCPointOfInterest ()@property (nonatomic, copy, readwrite) NSString *identifier;@property (nonatomic, copy, readwrite) NSString *title;@property (nonatomic, assign, readwrite) float latitude;@property (nonatomic, assign, readwrite) float longitude;@end@implementation EOCPointOfInterest/* ... */@end 现在，这属性可以在EOCPointOfInterest类的实现内部进行修改了。更准确的说，通过使用KVC这种方法，在外部也可以对对象进行修改，例如下面这种： 1[pointOfInterest setValue:@&quot;abc&quot; forKey:@&quot;identifier&quot;]; 这是因为KVC是直接调用的identifier的setter方法，即使你这个方法并没有暴漏在头文件。然而，这样做被视为对类API的非法入侵，如果有什么问题，还是需要开发者自身去解决。 一个不讲道理的开发者可以通过在类上使用内省来确定类对象的内存布局中属性的实例变量的偏移量而不是setter方法。开发者可以通过这种办法去设置实例变量，但这种行为被视为对类API的非法入侵。但从技术上来说，围绕缺失了头文件的setter方法这种可能性，你不应该忽略使你的对象是不可变的。 在定义类的公共API时，要记住的另一点是集合类属性是否是可变的或不可变的。例如，你有一个代表人的类，并且可以存储这个人的朋友列表，你可能想使用一个属性去存储这个人的朋友列表。如果这个人的朋友会添加和删除，那么这个属性应该设置为可变的。在这种情况下，应该暴漏一个只读特质并且不可变的集合，但它其实是拷贝了内部的可变集合。例如，像下面类的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSSet *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;@end// EOCPerson.m#import &quot;EOCPerson.h&quot;@interface EOCPerson ()@property (nonatomic, copy, readwrite) NSString *firstName;@property (nonatomic, copy, readwrite) NSString *lastName;@end@implementation EOCPerson &#123; NSMutableSet *_internalFriends;&#125;- (NSSet*)friends &#123; return [_internalFriends copy];&#125; - (void)addFriend:(EOCPerson*)person &#123; [_internalFriends addObject:person];&#125; - (void)removeFriend:(EOCPerson*)person &#123; [_internalFriends removeObject:person];&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; _firstName = firstName; _lastName = lastName; _internalFriends = [NSMutableSet new]; &#125; return self;&#125;@end 你也可以直接将friends属性设置为可变集合并通过直接操作集合去删除和增加朋友，而不是通过addFriend:和removeFriend:方法。但是这样数据就能随意修改，容易产生bug。如果EOCPerson类中的朋友集合可以被外部改变，这可能会造成一些问题。例如，当添加朋友或者删除朋友时，这个对象想做一些别的事情，这时，这个对象就会变得不一致。 在这点上，同样重要的是不要给你反回的对象做内省，去判断它是否是可变的。例如，你可能使用一个包含EOCPerson类的库。库的开发者可能没有返回一个内部可变集合的拷贝，而是直接返回了可变集合本身。如果这个集合非常大，这是合法合理的，因为拷贝的代价太大。它返回一个NSMutableSet是合法的，因为它是NSSet的子类，在这种情况下，你可能会这样写： 123456EOCPerson *person = /* ... */;NSSet *friends = person.friends;if ([friends isKindOfClass:[NSMutableSet class]]) &#123; NSMutableSet *mutableFriends = (NSMutableSet*)friends; /* mutate the set */&#125; 无论如何，你应该避免这种写法。你并没有跟EOCPerson类预定什么，所以你不应该在此处使用内省。重点是，这个对象可能没办法处理你要的操作。因此，你不应该假设它可以。 小结 尽量创建不可变对象。 如果属性需要在内部设置，那么暴露给外部的应该设置为只读，在类别中设置为读写。 通过方法去操作可变集合，而不是直接暴漏可变集合本身。 使用清晰而协调的命名方式在Objective-C中，类的命名，方法的命名，变量的命名等等都是重要的因素。新手总是说语言冗长，因为使用的语法结构可以像自然语言一样阅读。命名的时候常常包括一些介词(in、for、with等等)，而别的语言经常忽略这些。例如，考虑下面的代码段： 12NSString *text = @&quot;The quick brown fox jumped over the lazy dog&quot;;NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;fox&quot; withString:@&quot;cat&quot;]; 上述代码经常被认为是把一个简单的表达式复杂成了一句啰嗦的话。毕竟，执行的替换方法长达48个字符。但是它读起来像一句话：“使用cat字符串替换text字符串中的fox字符串并且赋值给一个新的字符串。” 这句话完美的表达了正在发生的事情。在不冗长的语言中，大概是这样的： 12string text = &quot;The quick brown fox jumped over the lazy dog&quot;;string newText = text.replace(&quot;fox&quot;, &quot;cat&quot;); 但是上面的命令中，text.replace的参数是什么意思？fox字符串替代cat，还是相反？而且，替换函数替换所有字符还是第一个？这非常不清晰。虽然Objective-C的语法更长，但是却非常清晰。 你还会注意到不论是变量名还是方法名，使用的都是首字母小写的骆驼式命名法。另外，类名是以大写字母开头并且带有两个或者三个字符的前缀（看第15节）。这个风格遍布整个Objective-C代码。如果你愿意你可以使用你自己的风格，但是在Objective-C中骆驼风格将确保你命名的健壮。 方法命名如果你之前学过别的语言，例如C++或者Java，你习惯于函数命名的简洁，并且必须查看函数原型以确定参数做什么。然而，这使得代码难以阅读，因为你经常需要返回原型来记住函数的作用。例如，考虑一个代表范围的类。在C++中，你可能这样定义它： 123456789class Rectangle &#123;public: Rectangle(float width, float height); float getWidth(); float getHeight();private: float width; float height;&#125;; 如果你不熟悉C++，那也没关系。你只需要意识到有一个叫做Rectangle的类，里面有两个实例变量，宽和高。它也有一个接受宽和高的方法用于创建类的实例，叫做构造器。它也有宽高的访问方法。当使用这个类时，你会这样创建实例： 1Rectangle *aRectangle = new Rectangle(5.0f, 10.0f); 当你回头看这些代码时，你不能清楚的知道5.0f和10.0f代表什么。你大概可以猜到它是构成矩形的宽高，但你知道第一个参数是宽还是高？你需要回头去看看定义的构造方法。 Objective-C通过更长的方法命名解决了这个问题。与上述C++代码等价的Objective-C代码如下： 12345678910#import &lt;Foundation/Foundation.h&gt;@interface EOCRectangle : NSObject@property (nonatomic, assign, readonly) float width;@property (nonatomic, assign, readonly) float height;- (id)initWithSize:(float)width :(float)height;@end 这样的写法可以轻松的知道等价的构造器方法和方法名叫做initWithSize:。你可能认为它很奇怪或者在第二个参数的冒号前面没有字符是语法错误的。实际上，语法是非常合理的，但它犯了和C++函数命名一样的毛病。如果你使用这个类，你会在相同的位置看到这个问题: 12EOCRectangle *aRectangle = [[EOCRectangle alloc] initWithSize:5.0f :10.0f]; 一个更好的写法是像下面这样的： 1- (id)initWithWidth:(float)width andHeight:(float)height; 这是冗长的，但对于使用时，每个变量的意思都是清晰的： 1EOCRectangle *aRectangle = [[EOCRectangle alloc] initWithWidth:5.0f andHeight:10.0f]; 新手往往很难使用Objective-C冗长的命名，尽管冗长的命名可以增加代码的可读性。不要害怕使用长的方法名。确保方法名是他们需要表达的，但不是让你使用极长的命名。你的方法名应该统一和清晰。 以EOCRectangle类为例子。好的方法命名像下面这样： 12- (EOCRectangle*)unionRectangle:(EOCRectangle*)rectangle- (float)area 不好的的方法命名像下面这样： 12- (EOCRectangle*)union:(EOCRectangle*)rectangle // Unclear- (float)calculateTheArea // Too verbose 清楚地方法命名就像读一篇文章一样，从左到右阅读。遵循方法命名规则并不是强制的，但这样做将会确保你的代码易于维护和被其他人阅读。 NSString类是一个好的命名示例，它遵循了良好的命名规则。这有一些它的方法以及为什么这样命名的解释： + string 这是一个工厂方法，用于创建一个新的空字符串。通过方法名表示返回值。 + stringWithString: 这是一个工厂方法，使用另一个字符串创建一个新的字符串。同创建空的字符串的工厂方法一样，它通过方法名的第一个单词表示返回值。 + localizedStringWithFormat: 这是一个工厂方法，使用指定的格式去创建一个本地化的字符串。它的返回值是方法名的第二个单词，这是因为对返回类型进行修饰是合理的。尽管它返回的仍然是字符串，但它是一种更具体的字符串，因为它已经本地化了。 - lowercaseString 将一个字符的所有字符转化为小写。它创建了一个新的字符串而不是转化者本身，因此它遵循返回类型作为方法名的一部分的规则。不过修饰符仍应在类型之前。 - intValue 将字符串解析为整数。因为它的返回类型是int，所以它的第一个单词是int。通常你不会缩写类型。例如string不会缩写成str。int是类型名字，所以方法名的后缀带有value而不是单一单词。单一单词通常用在属性上面。因为int不是属性，所以添加value限制它。 - length 获取字符串的长度。这是一个单独的短语，因为它实际上是一个字符串的属性。对于这个方法有一个不好的名字，叫做stringLength。string这个单词是多余的，因为这个方法的接收者本身就是个字符串。 - lengthOfBytesUsingEncoding: 获取使用给定编码方式编码的字节数组长度。这与length方法类似，所以可以用同样的理由解释。另外，这个方法需要一个参数。方法名称在描述其类型的名词之后立即放置参数。 - getCharacters:range: 在字符串的给定范围内获取单个字符。这是一个例子，因为这不是一个访问方法，所以添加get前缀，不像一些其他的语言。这里使用的原因是字符是通过作为第一个参数传入的数组返回的。完整的方法签名如下： - (void)getCharacters:(unichar*)buffer range:(NSRange)aRange 第一个参数，缓冲区，应该是指向足够容纳所请求范围内字符的数组的指针。该方法通过一个参数（通常称为out-parameter）返回，而不是通过返回值，因为它从内存管理角度更有意义。该方法的调用者处理所有内存管理，而不是由方法执行创建，并要求调用方释放它。第二个参数是以名词描述其类型，就像正常参数一样。有时，这些参数名前面都有一个介词；例如，这个方法可以叫做getCharacters:inRange:。如果参数超过其他参数需要额外的意义，通常是这样做的。 - hasPrefix: 确定字符串前缀是否是给定字符。它的返回值是一个Bool值，所以通常这样使用它，像读句子一样。例如： 1[@&quot;Effective Objective-C&quot; hasPrefix:@&quot;Effective&quot;] == YES 如果方法名是prefix:，它不容易理解的。相似的，如果是isPrefixedWith:，它是太长的并且听起来也过于笨拙。 - isEqualToString: 确定两个字符串是否相等。它的返回值是一个Bool值，就像上面的hasPrefix:方法一样，方法的名称确保该方法像句子一样阅读。另一个使用is前缀的地方是Bool属性。如果属性名是enabled，例如它的访问方法是setEnabled:和isEnabled。总之，遵循一些规则将帮助你给方法命名。 如果方法返回一个新值，那么方法的第一个单词应该是它的类型，除非它需要一个修饰词，例如localizedString方法。这个规则不适用于属性访问器，因为他们在逻辑上没有创建一个新的对象。即使它们可能会返回一个拷贝的内部对象。这些访问器方法代表属性本身。 一个参数应该紧挨着一个描述它类型的名词。 如果一个对象需要参数来执行操作，那么导致对象上发生动作的方法应该包含一个动词，然后是一个名词（或多个名词）。 不要使用缩写，例如str，使用全名，例如string。 Bool属性的前缀应该使用is。方法返回一个Bool值但不应该直接返回属性应该带有has或者is前缀，这取决于你使用的场景。 使用前缀get的方法，返回值应该是某个输出参数，例如填充C风格的数组。 类名和协议名应该给类和协议提供前缀以避免命名空间冲突（看第15节）并且应该结构化，使它们从左到右阅读，就像方法一样。例如，NSArray类和它的对应可变类NSMutableArray，mutable应该在array之前，因为它描述了一个指定的类型。 为了说明命名惯例，考虑下面UIKit中的类： UIView (class) 所有的视图都继承自这个类。它们是用户界面的构建块，执行按钮、文本字段和表的绘制。类的名字是对它的解释以及整个UIKit框架的UI前缀。 UIViewController (class) 一个视图处理绘画视图但不负责控制在视图中显示。这就是这个类的工作：一个“视图控制器”。它以这样的方式命名，它保持左到右可读性。 UITableView (class) 这是一个特定的视图，用于显示列表数据。所以给父类名字添加特定前缀来区别视图的种类。在命名管理中，使用给父类加前缀是常见的。它可以被命名为UITable，但这样不能清除的指出它是一个视图。你需要查找接口声明以确定它是什么。如果你要创建一个表格视图用于显示图像，你可以创建一个子类叫做EOCImageTableView。例如，你总是使用自己的前缀，而不是父类的前缀。原因是你没有权利向另一个框架的命名空间添加一些东西，而另一个框架可能决定在将来创建一个同名的类。 UITableViewController (class) 正如表格是一种特定的视图，这是一种特殊的视图控制器专门设计用来控制表格视图。因此，它以类似的方式命名。 UITableViewDelegate (protocol) 该协议定义了一个接口，通过该接口，表格视图可以与另一个对象通信，并以它定义委托接口的类命名，从而保证了正确的可读性。（关于委托模式的更多信息，请参阅项目23）。 最重要的是，你应该使你的命名保持一致。另外，如果你的类在另一个框架，确保遵守命名约定。例如，你创建一个视图的子类，那么类名的后缀应该加上view。类似地，如果创建了自己的委托协议，则应该将它命名为它代表的类，带有Delegate后缀。坚持这种命名结构将确保当你或其他人稍后使用它时，你的代码是易懂的。 小结 创建接口时，遵循Objective-C的命名规则，接口将会是健壮的。 确保方法名称简洁而精确，并使其使用像阅读句子一样从左向右。 在方法命中避免使用类型缩写。 最重要的是，确保你自己的代码中方法名的一致性。 为私有方法名加前缀一个类做的事情远比外部调用多的多。编写类实现时，通常会编写一些给类内部使用的方法。对于这样的方法，我建议给它们的名称加上前缀。通过将公共方法与私有方法区分开来，有助于调试。 给私有方法加标记的另一个原因是在修改方法名时易于区分。如果一个方法是公开的，那么修改它时应该加倍小心，因为可能对外部造成影响。因此，这个类的使用者也需要进行修改。但是，如果该方法是内部方法，则只有类自己的代码需要更改，对公开的API没有影响。对私有方法进行标记意味着在进行这种更改时很容易看出区别。 要使用什么样的前缀看你个人喜好，但我有一个好的选择是前缀包含一个字母p和_。因为p代表private，_在方法名开始之前有了视觉的差距。方法名仍继续使用骆驼命名法，即第一个字母小写。例如，一个叫做EOCObject的类，它的私有方法可能是这样的： 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;@interface EOCObject : NSObject- (void)publicMethod;@end@implementation EOCObject- (void)publicMethod &#123; /* ... */ &#125;- (void)p_privateMethod &#123; /* ... */ &#125;@end 与公共方法不同，私有方法不会出现在接口定义中。有时，您希望在类扩展中声明私有方法（看第27节）；然而，最近的编译器修改意味着在使用方法之前不需要声明它。通常，私有方法只能在它们的实现中声明。 如果你是从C++或者Java转行过来的，你可能会很疑问为什么只加前缀，而不是声明它为私有方法。在目标Objective-C中，没有办法将方法标记为私有的。所有的对象都能相应所有的消息(看第12节)，并且可以在运行时决定是否相应某个消息(看第14节)。Objective-C是在运行时执行给定消息的查找的，并且没有机制去限制什么东西、什么时候、什么范围影响消息。只剩下命名约定来指定语义，如私有方法。新手可能对这种方式感到不太舒服，但Objective-C就是这样一门语言，需要你去接受它的动态性和活力。但是动态性也是需要规则的，使用命名约定是实现这一目标的一种方法。 苹果倾向于使用单一下划线来作为它私有方法的前缀。所以你可能认为遵循苹果的提示并使用下划线是个好主意。然而，这有一个潜在的灾难性的问题；如果你继承了一个苹果的类，并在这个子类中使用了这种方法，你可能会无意中覆盖苹果的一个私有方法。基于这个原因，苹果已经说明了你应该避免使用下划线作为前缀。动态方法调度，从无法给方法指定作用域这点来看，这是不好的地方，但从另一方面看，它又是强大的。 覆盖苹果私有方法这种情况是常有的，例如，如果你正在创建一个iOS应用的视图控制器，你需要子类化UIViewController。视图控制器可以有很多状态，你需要一个清楚所有状态的方法，当你的控制器出现在屏幕上时，调用这个方法。因此，你可能会实现这样的方法： 12345678910111213#import &lt;UIKit/UIKit.h&gt;@interface EOCViewController : UIViewController@end@implementation EOCViewController- (void)_resetViewController &#123; // Reset state and views&#125;@end 然而，UIViewController也实现了一个叫做_resetViewController的私有方法。从你写了这个私有方法开始，当你调用它时，总是会调用EOCViewController的这个方法，而不是UIViewController的。除非你深入了解这个库，否则你不会你知道这一点，因为这个方法并未暴漏出来。毕竟，这是一种用下划线表示的私有方法。在这种情况下，你的视图控制器可能会发生一些奇怪的事情，因为UIViewController的实现未被调用，或者你会诧异为什么这个方法的调用次数过于频繁。 总之，当你在一个既不是苹果也不是你自己的框架中对类进行子类化时，除非文档说明，否则你无法知道框架使用的什么私有前缀（如果有的话）。在这种情况下，你可以选择使用你的类前缀（看第15节）作为私有方法前缀，从而大大减少潜在冲突的风险。同样，你也应该考虑其他人也可能会子类化你的类。这就是为什么你应该为私有方法名添加前缀。如果没有实现的源代码，除非使用非常复杂的工具，否则没有办法找出类实现的私有方法。 小结 给私有方法名添加前缀，这样很容易与公共方法区别开来。 避免使用单个下划线作为方法前缀，因为这是由苹果使用的。 理解objective-c错误模型许多现代语言，包括Objective-C，都有异常处理。如果你是一个java后台，你可能习惯于使用异常来处理错误情况。如果你习惯于异常处理任务，你需要忘记你知道的关于异常的一切并重新开始。 首先要注意的是，默认情况下异常机制在ARC(看第30节)下是不安全的。实际上，这个意思是任何该在异常作用域结束时释放的对象都不会被释放。当然你可以通过打开一个编译器标志使异常得到安全处理，但是这需要引入额外的代码，并且即使没有抛出异常，这部分额外代码也需要运行。这个编译器标志是-fobjc-arc-exceptions。 即使不使用ARC，也很难写出不会引起内存泄露的安全代码。假设一个资源被创建并在不再需要时释放它。如果在资源释放之前抛出异常，则该资源将永远无法释放： 123456789id someResource = /* ... */;if ( /* check for error */ ) &#123; @throw [NSException exceptionWithName:@&quot;ExceptionName&quot; reason:@&quot;There was an error&quot; userInfo:nil];&#125;[someResource doSomething];[someResource release]; 当然，解决这个问题的办法就是把释放代码放在抛出异常之前。但是，如果有很多的资源释放和更复杂的代码路径，代码很容易变得杂乱。另外，如果在这样的代码中添加了某些代码，那么在抛出异常之前，很容易忘记添加释放。 Objective-C现在使用的方法是只抛出重大异常，并且不需要再恢复了，即直接退出应用程序。这样就不用再考虑异常安全的代码了。 记住异常只能用于致命错误，例如当你创建了一个抽象基类，别人使用基类初始化或者未覆盖初始化方法时抛出异常。Objective-C不像其他语言一样，它没有构造方法一说。因此达到这个目的的最简单办法就是如果子类未重写父类必须重写的办法，那就抛出异常。任何试图使用基类创建实例的做法都将会抛出异常： 123456789- (void)mustOverrideMethod &#123; NSString *reason = [NSString stringWithFormat: @&quot;%@ must be overridden&quot;, NSStringFromSelector(_cmd)]; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];&#125; 但是如果异常仅适用于致命错误，那么其他类型的错误呢？当错误发生时，Objective-C的通常选择是返回nil或者0，或者是使用NSError。有一个例子就是当初始化失败，返回nil或者0： 12345678910- (id)initWithValue:(id)value &#123; if ((self = [super init])) &#123; if ( /* Value means instance can&apos;t be created */ ) &#123; self = nil; &#125; else &#123; // Initialize instance &#125; &#125; return self;&#125; 在这种情况下，如果value值为空，则实例不能创建，将self设置为nil，并且返回nil。这样初始化的方法将知道发生了一个错误，因为没有实例被创建。 使用NSError可以提供许多的灵活性，因为可以将错误返回给调用者。一个NSError对象封装了三条信息： Error domain (String) 错误产生的范围。这个通常是一个全局变量，用于表示错误的根源。例如，NSURL的处理系统，如果在获得数据时发生了错误，那么就会使用NSURLErrorDomain来表示。 Error code (Integer) 唯一的错误代码，用于指示错误域内具体的错误。通常，使用枚举来代表多种错误情况的集合。例如，HTTP请求失败时的HTTP状态码。 User info (Dictionary) 有关此错误的额外信息，例如一个本地化字符串或者导致该错误的别的错误信息，这样可以构成一个错误链。 在API设计中，NSError的第一种常见用法是通过委托协议传递。当错误发生时，该错误会通过协议的某个方法传递给调用者。例如，NSURLConnection的协议NSURLConnectionDelegate包含了下面的方法： 1- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error 当一个连接出现错误时，例如一个远程连接超时，就会调用此方法处理相关错误。这个代理方法不是必须实现的，这取决于使用者是否想知道有关错误。这比直接抛一个异常要好，因为它可以由使用者去决定是否实现。 另一个常用的使用方式是将NSError对象作为方法的一个参数。它看起来是这样的： 1- (BOOL)doSomething:(NSError**)error 传递给方法的是一个指针，而这个指针又指向一个指针，这个才是指向NSError对象的。或者也可以把它当做一个直接指向NSError对象的指针。这样可以使方法在经由输出参数返回错误信息的同时还能返回一个普同的值。用法如下： 12345NSError *error = nil;BOOL ret = [object doSomething:&amp;error];if (error) &#123; // There was an error&#125; 通常像这样返回错误的方法也会返回一个Bool值用来表示操作成功或者失败。如果你不关心错误信息，你可以直接判断Bool值，反之，你可以判断错误信息。当你不在乎错误信息时，你可以将它设置为nil。比如说，你可以这样写： 1234BOOL ret = [object doSomething:nil];if (ret) &#123; // There was an error&#125; 实际上，当使用ARC时，编译器会自动将NSError**转化成NSError*__autoreleasing*；这意味着这个指针对象将会自动释放。这个对象必须自动释放，因为doSomething:这个方法不能保证调用者会释放NSError对象，所以必须加入autorelease。这与大部分方法的返回值语义相同了（以new、alloc、copy、mutableCopy开头的方法当然不在此列）。 方法通过输出参数返回错误类似这样： 12345678910111213- (BOOL)doSomething:(NSError**)error &#123; // Do something that may cause an error if ( /* there was an error */ ) &#123; if (error) &#123; // Pass the &apos;error&apos; through the out-parameter *error = [NSError errorWithDomain:domain code:code userInfo:userInfo]; &#125; return NO; ///&lt; Indicate failure &#125; else &#123; return YES; ///&lt; Indicate success &#125;&#125; 通过使用*error语法，为错误参数解引用，这意味着错误参数所指的那个指针要指向新的NSError对象了。这个错误参数必须检测它是否为空，因为空指针解引用会导致段错误并且程序崩溃。因为调用者可能会将其设为空，所以必须判断这种情况。 NSError对象里的错误范围、错误码、额外的错误信息将根据错误的具体情况填入适当的内容。这使得调用者可以根据不同错误情况进行不同的处理。错误范围最好定义为一个全局常量字符串，错误码最好是枚举类型。例如，你可以这样定义它们： 1234567891011// EOCErrors.hextern NSString *const EOCErrorDomain;typedef NS_ENUM(NSUInteger, EOCError) &#123; EOCErrorUnknown = 1, EOCErrorInternalInconsistency = 100, EOCErrorGeneralFault = 105, EOCErrorBadInput = 500,&#125;;// EOCErrors.mNSString *const EOCErrorDomain = @&quot;EOCErrorDomain&quot;; 在你的库中创建一个错误范围是考虑周到的，因为它允许你创建并且返回一个NSError对象，使用者可以确定它来自你的库。为错误码创建一个枚举类型是好的主意，因为它记录具体的错误并且给代码一个有意义的名字。你甚至可以在头文件以注释形式定义更多更详细的错误信息。 小结 仅应在发生致命错误导致程序崩溃时使用NSExceptions。 对于不致命的错误，提供一个协议方法处理错误或者传入一个NSError对象是好的办法。 理解NSCopying协议我们经常会对一个对象就行拷贝。在Objective-C中，是通过copy方法进行拷贝的。而对类进行拷贝的方法是实现NSCopying协议，它只包含了一个方法： 1- (id)copyWithZone:(NSZone*)zone 以前的空间是使用不同的段内存的并且创建对象都是一个确定的空间。现在，每一个应用都只有一个空间：默认空间。虽然你还需要实现这个协议方法，但是你不需要担心那个空间参数。 这个拷贝方法在NSObject实现了，但仅仅是通过默认空间调用了copyWithZone:。不止copy方法需要覆盖重写，copyWithZone:也需要覆盖重写。 为了让类支持拷贝，你需要遵循NSCopying协议，并且实现协议中唯一的方法。例如，有个表示人的类。在这个类的接口中，你需要声明你遵循NSCopying协议： 123456789101112#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &lt;NSCopying&gt;@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;@end 然后，你需要实现这个协议的方法： 123456- (id)copyWithZone:(NSZone*)zone &#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; return copy;&#125; 这个例子简单的使用初始化方法进行了复制。有时，你可能需要更进一步的工作，例如，你要拷贝的某个对象并没有在初始化方法中进行赋值。例如，EOCPerson类有一个数组用于表示这个人的朋友，并且通过一些方法去增加和删除其余的EOCPerson对象。在这种情况下，你还需要复制好友数组。下面是一个完整的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &lt;NSCopying&gt;@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;@end@implementation EOCPerson &#123; NSMutableSet *_friends;&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; _friends = [NSMutableSet new]; &#125; return self;&#125;- (void)addFriend:(EOCPerson*)person &#123; [_friends addObject:person];&#125;- (void)removeFriend:(EOCPerson*)person &#123; [_friends removeObject:person];&#125;- (id)copyWithZone:(NSZone*)zone &#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [_friends mutableCopy]; return copy;&#125;@end 这一次，这个协议方法有了一些变化，增加了对_friends变量的拷贝。注意这里使用了-&gt;语法，因为这是一个内部变量。其实也可以声明为一个属性，但因为从未在外部使用，所以也就没什么必要了。 这个例子引出了一个有趣的问题：为什么要拷贝_friends变量？你可以不进行拷贝，这样每个对象都将使用相同的可变集合。但是这样做的话，当原始对象的_friends变量添加了一个朋友，那么所有拷贝的对象都将添加一个朋友。这显然不是你想要的。但是如果集合是不可变的，那么您可以选择不拷贝，反正集合不能修改，并且这样可以避免内存中存在两个完全一样的集合。 通常情况下，应该像本例这样，使用指定的初始化器去进行拷贝。但是有些时候不需要这样做，因为初始化方法有时候会产生一些副作用，比如一些无用的附加操作。比如，初始化方法可能会设置一个复杂的内部数据结构，并且这个数据结构马上要被别的数据所覆盖，那么就没必要进行初始化了。 如果你回头去看copyWithZone:方法，你会发现_friends是使用mutableCopy方法进行复制的。这个方法来自另一个协议，叫做NSMutableCopying。它的定义跟NSCopying协议是很相似的： 1- (id)mutableCopyWithZone:(NSZone*)zone mutableCopy就像上面的copy方法一样，都是使用默认空间调用的。如果你的类分为了可变和不可变两个版本，那么你也需要实现这个协议。当你这样使用时，你需要在copyWithZone:中返回一份不可变拷贝。不论你拷贝的对象是可变还是不可变，都应该在mutableCopyWithZone:中返回一份可变拷贝。类似的，如果你需要一份不可变拷贝，那么你应该调用copy方法。 下面的规则适用于可变数组和不可变数组的所有情况： 12-[NSMutableArray copy] =&gt; NSArray-[NSArray mutableCopy] =&gt; NSMutableArray 有一个微妙的情况需要注意，一个可变对象调用可copy方法会返回一个不可变实例。这样做可以很容易的在可变对象和不可变对象之间进行切换。另一种可以达到这个目的办法是使用三个方法：copy、immutableCopy、mutableCopy，copy总是返回相同的类，其余两个方法返回特定的实例。但是如果使用者并不知道其所用实例是否可变，那么就不太好了。例如某个方法把可变对象当做不可变对象给了你，你使用这个对象调用copy。这时，你以为它是不可变对象但它其实是可变的。 你可以通过内省(看第14节)来确定对象的类型，但是这样会增加拷贝的复杂度。为了安全起见，你会只使用immutableCopy和mutableCopy，但是这样又回到了两个方法的情况。这和只有copy和mutableCopy是一样的。为什么会叫copy而不是immutableCopy呢，是因为这两个方法并不完全是为可变类和不可变类设计的，有些类是没有可变和不可变之分的。所以immutableCopy是一个坏名字。 拷贝还有一个问题是，进行的拷贝是深拷贝还是浅拷贝。深拷贝会对拷贝所有数据。通常，我们使用的容器类，都是浅拷贝，即只拷贝容器本身，不拷贝容器元素。这样做的主要原因是容器中可能含有无法拷贝的元素；另外，复制每个对象是不好的。图3.2展示了深拷贝和浅拷贝的区别。 Figure 3.2 深拷贝和浅拷贝的区别。浅拷贝的所有内容都指向原始内容。深拷贝的所有内容都指向拷贝后的内容。 通常，你希望自己的类遵循系统框架的拷贝模式，即使用copyWithZone:进行浅拷贝。但是如果需要，也可以添加一个深拷贝的方法。例如NSSet，它就在初始化时提供了一个方法进行深拷贝： 1- (id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems 如果copyItems为YES，那么集合中的所有元素都会接收到拷贝的消息，然后以拷贝后的元素组成新的集合，并返回。 在EOCPerson的例子中，朋友的集合是使用copyWithZone:进行拷贝的，根据上面内容得知，它们进行的是浅拷贝，不会逐个复制集合的元素。但是如果需要一个深拷贝，你可以提供这样一个方法： 12345678910- (id)deepCopy &#123; EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;&#125; 没有实现深拷贝的协议，这个事情是留给你的每个类去做的。你只需要决定你是否提供深拷贝。另外，你也不应该假设NSCopying协议实现的是深拷贝。在绝大多数情况下，这是一个浅拷贝。如果你需要任何对象的深拷贝，除非有文档指出这个NSCopying协议实现的是深拷贝，要么找到相关方法，要么自己实现。 小结 如果你的对象需要拷贝，那么你需要实现NSCopying协议。 如果你需要可变和不可变两个版本，那么你需要实现NSCopying和NSMutableCopying协议。 开发者可以选择使用深拷贝还是浅拷贝，但尽量使用浅拷贝。 如果你的对象需要深拷贝，那么添加一个深拷贝方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第二章]]></title>
      <url>%2F2017%2F05%2F14%2FObject%2C%20Messaging%2C%20and%20the%20Runtime%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第二章：对象、消息、运行时 简介在Objective-C等面向对象的语言中，对象就是基石，提供数据存储和传递的功能。消息是在过程中对象之间进行数据传递和执行操作。深入理解这些功能如何工作对于构建高效和可维护代码是至关重要的。 当程序运行后，Objective-C中的runtime为其提供相关支持。runtime提供了关键的函数使对象之间可以传递消息以及创建类实例的所有逻辑。理解这一切如何工作会使你成为一个更好的开发者。 理解属性属性是Objective-C的一个功能，用于对象对数据的封装。Objective-C对象通常会把它们所需要的数据保存为各种实例变量。实例变量的访问通常通过存取方法。getter方法用来读取变量，setter方法用来设置变量。这个概念是标准的，并且通过属性这个功能成为了Objective-C 2.0的一部分，这让开发者令编译器去自动生成读写方法。这个功能引入了一个新语法即点语法，通过点语法访问数据存储可以减少代码的冗长。你可能已经使用了属性，但你可能不知道它所有的功能。而且，还有很多与之相关的问题。第6节主要说明哪些问题可以通过属性解决并且指出主要的功能。 用一个类去表示一个人的信息可能要存储名字，出生日期，地址等等。你可能这样在一个类的公共接口中声明这些变量： 12345678910#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &#123; @public NSString *_firstName; NSString *_lastName;@private NSString *_someInternalData;&#125;@end 如果你从事过Java或者C++开发，这种写法是熟悉的，你可以定义变量的作用域。然而，这种技术在Objective-C中很少使用。这种方法的问题是在编译时就定义了对象的布局。无论任何时候访问_firstName变量，都会通过编译器偏移硬编码去访问存储对象的内存空间。如果你不在_firstName之前添加任何变量这样做都是没问题的。例如：假设在_firstName之前添加一个变量： 译者言：由于对象布局在编译时已定，对象内存偏移量自然固定，此处硬编码代指偏移量。 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject &#123; @public NSDate *_dateOfBirth; NSString *_firstName; NSString *_lastName;@private NSString *_someInternalData;&#125;@end 之前的偏移量代表_firstName而现在代表_dateOfBirth了。任何通过硬编码读取的地方都将读取到一个错误的值。为了说明这一点，假设指针是4个字节，图2.1分别展示了添加_dateOfBirth变量之前和之后的类的内存布局。 Figure 2.1 添加变量前类的布局和添加变量后类的布局 当类定义发生变化时，如果代码使用了编译时的偏移量那么将出现问题，除非重新编译。例如，一个代码库中的代码使用了旧的类定义。如果链接的代码使用了新的类定义，那么在运行时将出现不兼容的情况。为了解决这个问题，各种语言都提出了自己的解决办法。Objective-C的做法是，将实例变量看做特殊的变量，由类变量(第14节详细的讲述了类对象)去存储它的偏移量。在运行时，会去查找偏移量，当类定义发生改变，偏移量也随之改变。这样无论如何访问一个变量，都会使用正确的偏移量。你甚至可以在运行期间给类添加实例变量。这就是稳固的ABI(应用程序二进制接口)。ABI定义了许多内容，其中一项是生成代码时的规则。稳固的ABI也意味着你可以在类扩展中或者实现文件中定义实例变量。因此，你不需要在接口文件中声明所有的实例变量，因此你不需要在公共接口中泄露任何你的内部实现信息。 另一种解决这个问题的办法是使用存取方法而不是直接访问实例变量。虽然属性最终仍是由实例变量实现的，但是属性提供了一种简洁的抽象。你可以自己编写存取方法，但是在标准的Objective-C代码格式中，存取方法遵循严格的命名规则。因为严格的命名，Objective-C才能根据变量名自动创建存取方法。这就是@property语法的来源。 在对象接口的定义中使用@property，这是一种标准的写法，以提供对象的存取方法。因此，可以把属性当做一种简称，通过它去访问一个给定类型和给定名字的变量。例如，考虑下面的代码： 1234@interface EOCPerson : NSObject@property NSString *firstName;@property NSString *lastName;@end 对于类的使用者，上面的代码是等价于下面的代码的： 123456@interface EOCPerson : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end 使用属性，你可以使用点语法。在C中你访问栈结构体的成员也是使用类似语法。编译器会将点语法转化为存取方法，与你直接调用是一样的。因此，使用点语法和直接调用时没有任何差异的。下面展示了等价的代码： 1234567EOCPerson *aPerson = [EOCPerson new]; aPerson.firstName = @&quot;Bob&quot;; // Same as;[aPerson setFirstName:@&quot;Bob&quot;]; NSString *lastName = aPerson.lastName; // Same as;NSString *lastName = [aPerson lastName]; 属性的好处还不止这些。如果你使用它，编译器将会通过一个叫做自动合成的功能生成那些方法代码。需要强调的是，编译器会在编译时自动生成代码，所以你在编辑器中是看不到自动合成的方法的。除了自动生成上述代码，编译器也会自动生成一个合适类型的变量，并且会在名字前面加下划线。在前面的代码中，他自动生成了两个变量：_firstName和_lastName。通过在类实现中使用@synthesize语法，这两个实例变量名字是可以控制的，像这样： 1234@implementation EOCPerson@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 使用上面的语法会产生两个实例变量，分别叫做_myFirstName和_myLastName，用于代替默认生成的。不过一般不会去改变默认的变量名；然而如果你不喜欢使用下划线去命名变量，你可以使用这个方法去设置你想要的。但是我建议你使用默认的命名规则，如果每个人都遵循这个规则，那么每个人读代码都是容易理解的。 如果你不想编译器给你自动生成存取方法，你可以自己去实现这些方法。然而，如果你仅实现了存取方法中的一个，那么编译器仍会自动生成另一个方法。另一种阻止它自动生成的办法是使用@dynamic关键字，这会告诉编译器不要自动生成实例变量返回给属性并且不会自动生成存取方法。而且，当编译代码访问这个属性时，编译器将会忽略实际上存取方法还没有定义的情况，并且相信它在运行时是可以使用的。例如，如果一个类继承自NSManagedObject类，它的存取方法需要在运行时动态创建。NSManagedObject类之所以这样做是因为子类的属性不是实例变量。它的数据来源于后台数据库。例如： 12345678@interface EOCPerson : NSManagedObject@property NSString *firstName;@property NSString *lastName;@end@implementation EOCPerson@dynamic firstName, lastName;@end 在这个类中，编译器不会自动生成存取方法或者实例变量。如果你尝试去访问某个属性，编译器也没有警告信息。 属性特质属性的另一个问题是你应该知道它所有的特质。你可以通过它去影响编译器生成的存取方法。例如下面这个属性使用了三个特质： 1@property (nonatomic, readwrite, copy) NSString *firstName; 属性可以使用4类特质。 原子性通常，生成的存取方法包含锁去保持原子性。如果你设置了nonatomic特质，那么就不会有锁了。请注意，尽管没有atomic特质(atomic特质是由你不设置nonatomic特质得来的)，但是你仍何以在属性特质中写上，并且编译器不会报错。如果你自己实现存取方法，你应该指定与其相符的原子性。 读写权限 readwrite 读写权限时，getter和setter方法都是可用的。如果属性是自动合成的，那么编译器将会自动生成两个方法。 readonly 只读权限时，只有getter方法是可用的，如果属性是自动合成的，那么编译器将只生成getter方法。当你想暴漏一个只读属性给外部，并且需要在内部重新定义它为可读写时，你可以使用它。第27节讲了更多内容。 内存管理语义属性用于封装数据，数据需要有具体的所有权。它仅仅影响setter方法。例如，用setter方法设置一个值时，它是应该保持新值还是将其直接赋给底层实例变量?当编译器自动生成存取方法时，它要取决于这些特质去生成代码。如果你自己实现存取方法，你应该指定与其相符的特质。 assign 它的setter方法只会简单的给标量类型的值赋值，例如CGFloat或者NSInteger。 strong 这种特质表示定义了一个拥有关系。当为这个属性赋值时，首先持有新值，接着释放旧值，然后将新值赋给这个属性。 weak 这种特质表示定义了一个非拥有关系。当为这个属性赋值时，它是不持有新值的；也不释放旧值。它是类似于assign特质的，但当目标对象释放时，它的值会被自动置为nil。 unsafe_unretained 它同assign语义相似，但是它适用于对象类型，它表达了一个非拥有关系，当目标对象销毁时，它不会自动置为nil，这点与weak是有区别的。 copy 这种特质类似strong特质，定义一个拥有关系；然而，它是用拷贝替代持有新值的。当属性是类似与NSString *时，经常用此特质保证其封装性，因为可能通过setter方法给予其一个可变值。如果赋的值是可变的，那么这个属性的类型可能就在对象不知道的情况下改变。所以就需要使用copy特质去使对象中的字符串不会在无意中被改变。任何需要保持不可变的对象都应该使用copy去修饰。 方法名通过使用下面的特质可以控制存取方法的名字： getter= 指定getter的名字。当你想给一个Boolean属性加上is前缀时，通常使用这个方法。例如，在UISwitch类中，表示状态开关的属性就是这样定义的： 1@property(nonatomic,getter=isOn) BOOL on; setter= 指定setter的名字。这个方法不常用的。 你可以通过这些特质细微的控制自动生成的存取方法。然而，需要谨记的是，如果你实现了自己的存取方法，你应该遵循指定的特质。例如，一个属性使用了copy特质，你需要在setter中拷贝它。否则，会误导属性的使用者。而且，如果不遵守这个约定，那么将会产生bug。 即使你可以通过别的方法设置属性，你也要遵循定义时的特质。例如，考虑扩充下EOCPerson类。属性声明时，使用了copy特质，因为它可能是可变的。这个类也增加了一个初始化方法，用于设置名和姓的值： 123456789@interface EOCPerson : NSManagedObject@property (copy) NSString *firstName;@property (copy) NSString *lastName;- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName;@end 在实现自定义初始化方法时，遵循定义时的copy语义是非常重要的。因为属性定义就像类和对象之间的协议一样。所以初始化的代码应该是这样的： 12345678910- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName &#123; if ((self = [super init])) &#123; _firstName = [firstName copy]; _lastName = [lastName copy]; &#125; return self;&#125; 你可能会问为什么不简单的使用属性的setter方式去设置，如果总是使用setter设置，那将会保证属性的正确设置。你永远不该在init方法中使用存取方法，具体请看第7节。 如果你已经读了第18节，你应该知道，最好使对象不可变。将上述内容应用在EOCPerson类中，你需要设置两个属性为readonly。在初始化中设置它们的值，然后它们将不能被修改。在本例中，对你使用的值使用内存管理语义是重要的。所以属性定义的代码是这样的： 12@property (copy, readonly) NSString *firstName;@property (copy, readonly) NSString *lastName; 因为是只读属性，所以编译器不会为其自动生成setter方法。这样做是重要的，可以表明在初始化时设置了这两个属性值。没有这样的声明，使用这个类的人就可能不知道已经在init方法中使用了copy，因此他们可能会在调用初始化方法之前自行拷贝。这种操作是多余且低效的。 如果你想知道atomic和nonatomic的区别。前面说过，使用了atomic的属性的存取方法会自动加锁确保原子性。这个意思是如果两个线程同时对属性进行读写操作，这个值不论在任何时候始终是有效的。如果不加所得情况下，当一个线程正在进行修改时，另一个线程进行读取，可能会将其未修改完的值读出来。如果发生了这种情况，读到的值可能是无效的。 如果你是在iOS中开发，那么你会注意到所有属性声明为nonatomic。这样做的历史原因是，加锁消耗比较大，可能会产生性能问题。通常，原子性并不是必须的，因为它不能确保线程安全，需要更深层次的锁定机制才能保证其线程安全。例如，即使使用了原子性，一个线程在连续读取某个属性值时，另一个线程修改了这个属性，仍将不能确保读到的是正确的值。因此，在iOS开发中你将一直使用nonatomic去修饰属性。但是在Mac OS X中，你不需要担心atomic带来的性能问题。 小结 @property语法提供了一种对象封装数据的定义。 使用正确的特质提供数据存储。 在设置属性所对应的实例变量时，需要遵循该属性的语义。 在iOS中使用nonatomic，因为它会严重消耗性能。 在对象内部直接访问实例变量属性总是用于访问外部对象的实例变量，但是在Objective-C社区中如何访问内部变量却是争执不休的。有些建议仍使用属性去访问实例变量，有些建议直接访问实例变量，有些两者混用。作者强烈推荐在读取实例变量时直接访问而在设置值时使用属性访问。 考虑下面的代码： 12345678@interface EOCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; // Convenience for firstName + &quot; &quot; + lastName: - (NSString*)fullName; - (void)setFullName:(NSString*)fullName; @end 这两个便捷方法fullName和setFullName可能是这样实现的： 123456789101112131415- (NSString*)fullName &#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName]; &#125; /** The following assumes all full names have exactly 2 * parts. The method could be rewritten to support more * exotic names. */ - (void)setFullName:(NSString*)fullName &#123; NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;]; self.firstName = [components objectAtIndex:0]; self.lastName = [components objectAtIndex:1]; &#125; 在setter和getter中，我们使用点语法访问实例变量。假设现在重写setter和getter方法直接访问变量： 1234567891011- (NSString*)fullName &#123; return [NSStringstringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName]; &#125; - (void)setFullName:(NSString*)fullName &#123; NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;]; _firstName = [components objectAtIndex:0]; _lastName = [components objectAtIndex:1]; &#125; 这两种方式是有些许差异的： 毫无疑问直接访问实例变量是更快的，因为它不需要通过Objective-C方法派发(看第11节)。编译器通过代码直接访问存储对象实例的内存空间。 直接调用实例变量会绕过setter的内存管理语义。例如，你的属性声明了copy特质，直接调用实例变量不会发生copy事件。新的值将会被保存，旧的值将会被释放。 当直接访问实例变量时，KVO不会被触发。这可能会是一个问题，不过这主要取决你对这个对象的行为。 通过属性访问可以更轻易的定位到与这个属性有关的问题，因为你可以给setter、getter方法添加断点去看谁在什么时候访问了这个属性。 一个好的折中的办法是在写时通过setter方法设置，读时直接调用实例变量。这样做可以在读时有更高的效率，在写时也不会失去控制。最重要的是通过setter方法去写将保证你遵循内存管理语义。然而，这样做会有一些小的问题。 第一个问题是当你的值是在初始化方法中设置的时候。这里，你应该一直使用直接调用实例变量的方法，因为子类可能重写了它的setter方法。考虑下EOCPerson有一个叫做EOCSmithPerson的子类，这个类是专门用于表示名字叫smith的。这个子类可能会覆盖lastName的setter方法： 1234567- (void)setLastName:(NSString*)lastName &#123; if (![lastName isEqualToString:@&quot;Smith&quot;]) &#123; [NSException raise:NSInvalidArgumentException format:@&quot;Last name must be Smith&quot;]; &#125; self.lastName = lastname; &#125; EOCPerson基类可能在初始化时将名字设为空字符。如果它通过setter方法去这样设置，那么子类的setter将会被调用并且会抛出一个异常。然而，在有一些情况中，你必须在初始化时使用setter方法。当实例变量是声明在一个父类中的时候；你不能通过直接调用实例变量时，那么你必须使用setter方法。 另一个问题是当属性使用懒加载时。在这种情况下，你必须通过getter访问；如果没有，那个实例变量将永远不会初始化。例如，EOCPerson类可能有一个属性通过一个复杂对象去代表人脑。如果这个属性很少用并且初始化成本较高的，你可能在getter中使用懒加载，像这样： 123456- (EOCBrain*)brain &#123; if (!_brain) &#123; _brain = [Brain new]; &#125; return _brain; &#125; 如果你直接调用实例变量且没有调用过getter方法，大脑这个属性永远不会创建，所以你需要通过属性的存取方法去访问它。 小结 在内部使用数据时，通过直接调用实例变量来读，通过调用属性来写。 在初始化和销毁中，不论读还是写都通过实例变量直接访问。 当你使用了懒加载时，你需要使用属性去读。 理解对象的等同性比较对象相等是非常有用的。然而，使用等于操作符去判断相等通常不是你想做的，因为这样做比较的是它们的指针本身，而不是指针指向的对象。相应的，你应该使用声明在NSObject协议中的isEqual:方法去检验两个对象是否相等。通常情况下，两个不同类的对象总是不相等的。如果你已经知道你要检查的两个对象是同一个类，那么你可以使用它们自己提供的相同性检测方法。例如，下面的代码： 12345NSString *foo = @&quot;Badger 123&quot;; NSString *bar = [NSString stringWithFormat:@&quot;Badger %i&quot;, 123]; BOOL equalA = (foo == bar); //&lt; equalAequalA = NO BOOL equalB = [foo isEqual:bar]; //&lt; equalBequalB = YES BOOL equalC = [foo isEqualToString:bar]; //&lt; equalCequalC = YES 你可以看到等号操作符与使用等价方法的不同。NSString是一个自己实现了等价比较方法的类，方法名叫做isEqualToString:。使用这个方法的对象一定是一个NSString对象；否则，比较结果就会返回undefined。使用这个方法是比使用isEqual:更快的，它需要别的步骤，因为它不知道比较的对象是什么类型的。 这两个方法的核心等价判断是NSObject的协议方法： 12- (BOOL)isEqual:(id)object;- (NSUInteger)hash; 这两个NSObject类的方法的默认实现是只有两个对象指向相同的地址时才相等。为了在自定义对象中覆写这些方法，你必须去了解它们的原理。任意两个对象使用isEqual:方法比对结果是相等，那么它们的hash方法也一定会返回相同的值。然而，两个对象的hash方法返回相同的值，它们isEqual:方法的比对结果不一定相等。 例如，考虑下面的类： 12345@interface EOCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; @property (nonatomic, assign) NSUInteger age; @end 如果所有条件都是相等的，那么两个EOCPerson对象相等。所以isEqual:方法应该这样写： 12345678910111213- (BOOL)isEqual:(id)object &#123; if (self == object) return YES; if ([self class] != [object class]) return NO; EOCPerson *otherPerson = (EOCPerson*)object; if (![_firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES; &#125; 首先，对比两个对象的指针是否相同。如果指针相同，那么对象一定相等，因为它们是同一个对象。其次，比较两个对象的类。如果两个对象的类不同，那么两个对象不相等。毕竟，一个EOCPerson类不可能等于EOCDog类。当然，你可能希望一个EOCPerson实例等于它一个子类的实例；例如，EOCSmithPerson。这说明在继承层次中，判断相等性是一个常见问题。当你实现了isEqual:方法时，你应该考虑这个问题。最后，没一个属性去检查相等性。如果它们中的任何一个不相等，那么两个对象被认为是不相等；否则，它们是相等的。 接下来实现hash方法。回想一下相等性原则，当两个对象相等，那么它们的哈希码一定相等，但是两个对象的哈希码相等，它们本身却不一定相等。因此如果你复写了isEqual:方法，通常也会覆写hash方法。一个更好的hash方法是像下面这样的： 123- (NSUInteger)hash &#123; return 1337; &#125; 可是，如果在集合中使用这种办法，这将可能会产生性能问题。因为集合使用哈希表中的哈希码做索引。一个集合的实现是使用哈希存储对象到不同的数组。当给集合添加新对象时，会根据哈希码找到与其对应的数组，对比所有对象，看其是否与新加对象相等。如果相等，说明新加的对象已经在集合里面了。因此，如果所有的对象哈希码都一样，那么在集合中已有1000000个对象时，每次给集合添加对象都会遍历对比这1000000个对象。 另一种实现哈希方法如下： 123456- (NSUInteger)hash &#123; NSString *stringToHash = [NSStringstringWithFormat:@&quot;%@:%@:%i&quot;, _firstName, _lastName, _age]; return [stringToHash hash]; &#125; 这次的哈希算法是通过创建一个字符串并将字符串的哈希码返回。这么做符合约定，因为两个相等的EOCPerson总会生成相等哈希码。然而，这种方法是比返回单一数值的速度慢的，因为你需要创建一个字符串。当给一个集合添加对象时，这仍会导致性能问题，因为要给集合添加对象，仍然需要去计算对象的hash值。 第三种也是最后一种方法是创建一个类似于这样的哈希码： 123456- (NSUInteger)hash &#123; NSUInteger firstNameHash = [_firstName hash]; NSUInteger lastNameHash = [_lastName hash]; NSUInteger ageHash = _age; return firstNameHash ^ lastNameHash ^ ageHash; &#125; 这种方法是一个这种的办法，既能保持一定的效率，又能使生成的哈希码在一定范围之内。当然，这样还会导致生成相同的哈希码的碰撞，但是至少不会重复太多次。在编写哈希码时，你应该基于当前的业务要求去权衡哈希碰撞频率和创建哈希的性能消耗。 特定类的等同性方法除了前面说的NSString类提供了特定的等同性方法，还提供特定方法的类还有NSArray(isEqualToArray:)和NSDictionary(isEqualToDictionary:)，如果对比的对象不是数组或者字典，这两种方法都会抛出异常。Objective-C在编译器并没有严格的类行检测，这样就容易使用错误的对象去对比，所以你应该确定当前对象的类型是正确的。 如果等同性对比比较频繁，那么你可能会创建自己的等同性方法；因此，效率高的重要原因是不需要检查类型。另一个原因是，提供一个指定方法是用于修饰的，它看起来是更好、更易读的，这也是NSString类提供isEqualToString:方法的动机之一。使用此种方法的代码是更易读的，并且也不需要再去检查两个对比对象的类型了。 如果你创建一个特定等同性方法，你需要覆盖isEqual:方法并且通过判断两个对比对象的类型是否相同。如果不相同，就使用父类的实现方法去判断。例如，EOCPerson类的实现应该像这样： 12345678910111213141516171819- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123; if (self == object) return YES; if (![_firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES; &#125; - (BOOL)isEqual:(id)object &#123; if ([self class] == [object class]) &#123; return [self isEqualToPerson:(EOCPerson*)object]; &#125; else &#123; return [super isEqual:object]; &#125; &#125; 等同性对比的深度当你创建一个等价方法时，你需要决定是检查整个对象的等同性或者仅仅只是一些条件的等同性。NSArray的对比方法是先对比两个数组包含的个数，其次遍历它们，使用isEqual:对比每个元素。如果所有的元素都相等，那么可以认为两个数组相等，这是深度等同性对比。不过有时你仅需要判断一部分数据段是相等的，这对于等同性对比也是可以的。 例如，使用EOCPerson类，如果实例来源于一个数据库，它们可能会添加一个属性用于唯一标示，即使用数据库中的主键。 1@property NSUInteger identifier; 在这种情况下，可能仅仅需要去检查identifier是否匹配即可，尤其是如果identifier属性特质被声明为只读，那么你可以确定如果两个对象拥有同样的表示符，它们确实代表了相同的对象并且相等。这可以避免对比每个EOCPerson对象的每个数据位，如果你确定它们的标示符相等，那么剩下的数据也相等，因为它们是相同的数据源。 在你的等同性方法中，是否需要检查所有条件的等同性，取决于被检测的对象。只有你才知道在什么情况下两个实例相等。 容器中可变类的等同性考虑一个重要的情况，在容器中添加一个可变类。一旦你将一个对象添加入一个集合中，那么这个对象的哈希码不应该再改变。前面，我说了集合是根据哈希码去存储对象的。如果哈希码一旦发生变化，集合中的对象将会产生一个错误。为了解决这个问题，你可以确保哈希码不是根据可变部分的对象计算出来的或者保证一旦放入集合中就不再修改它。在第18节，我详细阐述了为了你需要使对象不可变。对于这个问题，下面有一个很好的例子。 通过测试NSMutableSet和NSMutableArrays，你可以看到这个问题。开始的时候给集合添加一个数组： 123456NSMutableSet *set = [NSMutableSetnew]; NSMutableArray *arrayA = [@[@1, @2] mutableCopy]; [set addObject:arrayA]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 集合中现在有一个对象：带有两个元素的数组。现在使用相同的方法给集合添加一个同样顺序的数组，下面的代码展示了给集合添加一个新的数组以及添加后集合的情况： 1234NSMutableArray *arrayB = [@[@1, @2] mutableCopy]; [set addObject:arrayB]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 这个集合仍然只保存了一个对象，因为新添加的数组对象是已经在集合中存在的了。现在我们添加一个跟集合中不同的数组： 1234NSMutableArray *arrayC = [@[@1] mutableCopy]; [set addObject:arrayC]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1),(1,2))&#125; 果然，集合现在包含了两个数组：一个原来的数组和一个新的数组，因为arrayC与集合中已有的数组不相等。最后，我们修改arrayC使其等于之前集合中的数组： 123[arrayC addObject:@2]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2),(1,2))&#125; 哦，我的天，现在在集合中存在两个相同的数组了。这个集合没有遵守集合的定义，但是我们现在却无法确保这点了。因为我们修改了一个已经在集合中的对象了。如果我们拷贝这个集合，将会更加可怕： 123NSSet *setB = [set copy]; NSLog(@&quot;setB = %@&quot;, setB); // Output: setB = &#123;((1,2))&#125; 这个拷贝出来的集合仅有一个对象，这个集合像是先创建一个空的集合，然后逐步从原集合中添加元素得到的。这可能是也可能不是你想要的结果。你可能想要忽视这个错误，按原样复制一个集合。或者你就是想这样做。这两种拷贝情况都是有效的，这进一步说明了刚才的问题，如果修改某个已经加入集合的对象，将会产生不可预料的情况。 举这个例子是想告诉大家，当你修改某个已经加入集合的对象会造成什么后果。这不是说不能这样做，而是你这样做了之后要考虑其后果。 小结 如果想检测等同性，你需要提供isEqual:和hash方法。 相同的对象，哈希码一定是相等的；但是哈希码相等，对象却不一定相等。 确定你对比对象同等性时是否需要对比每个对象。 编写哈希算法时，应该使用计算速度快并且碰撞几率低的算法。 使用类簇模式隐藏实现细节在一个抽象基类中，使用类簇可以很好的隐藏实现细节。在Objective-C的系统框架中，这种模式是非常普遍的。UIKit中有一个例子，就是iOS的UI框架中的UIButton类。创建一个按钮，你会调用下面的方法： 1+ (UIButton*)buttonWithType:(UIButtonType)buttonType; 返回对象的类型取决于按钮类型。所有的子类都继承自相同的基类，即UIButton类。这样做使用者就不需要关心生成的按钮类型以及按钮如何绘画的具体细节。这一切只需要知道如何创建一个按钮；如何设置标题这样的属性；如何设置点击的动作。 回到按钮绘画的问题上面，它可以通过使用一个类去处理所有按钮的绘画并且基于它们的类型： 1234567- (void)drawRect:(CGRect)rect &#123; if (_type == TypeA) &#123; // Draw TypeA button &#125; else if (_type == TypeB) &#123; // Draw TypeB button &#125; /* ... */ &#125; 这样看起来是清晰的，但是如果有许多方法基于这个类型的切换去绘制，那么这个方法就会变得非常笨重。一个好的程序员会对这进行重构，通过创建多个子类去实现特定的功能用于对应每种按钮类型。然而这样做需要使用者知道所有的子类。这时就该使用类簇模式了，这种模式提供多个子类，并通过将其实现细节隐藏在基类，用以保持头文件的干净。你不需要创建子类的实例，你通过基类创建它们即可。 创建一个类簇有一个关于如何创建类簇的例子，考虑一个处理雇员的类，这个类包含雇员的名字和销售额以及每天该做的工作。但是每个雇员每天的工作是不一样的。管理者不关心每个雇员如何完成任务，他只会告诉每个雇员该做什么。 首先，你需要定义这个基类： 12345678910111213141516171819202122232425262728293031323334353637383940typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123; EOCEmployeeTypeDeveloper, EOCEmployeeTypeDesigner, EOCEmployeeTypeFinance, &#125;; @interface EOCEmployee : NSObject @property (copy) NSString *name; @property NSUInteger salary; // Helper for creating Employee objects + (EOCEmployee*)employeeWithType:(EOCEmployeeType)type; // Make Employees do their respective day&apos;s work - (void)doADaysWork; @end @implementation EOCEmployee + (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123; switch (type) &#123; case EOCEmployeeTypeDeveloper: return [EOCEmployeeDeveloper new]; break; case EOCEmployeeTypeDesigner: return [EOCEmployeeDesigner new]; break; case EOCEmployeeTypeFinance: return [EOCEmployeeFinance new]; break; &#125; &#125; - (void)doADaysWork &#123; // Subclasses implement this. &#125; @end 每一个具体的子类继承自基类。例如： 12345678910@interface EOCEmployeeDeveloper : EOCEmployee @end @implementation EOCEmployeeDeveloper - (void)doADaysWork &#123; [self writeCode]; &#125; @end 在这个例子中，这个基类实现了一个基类方法的声明，它通过雇员的类型去创建并初始化不同的实例。这个工厂模式是创建一个类簇的一种方法。 不幸的是，Objective-C语言没有指定一个类是基类的功能。相应的，开发者通常会在这个类中写明类的用法。在这种情况下，头文件没有声明初始化方法，它意味着实例变量并不是立即创建的。另一种确定没使用基类实例的方法是在基类的doADaysWork方法中抛出一个异常。然而，这种做法是非常极端的并且也不是必需的。 还有一个点需要注意的，当使用的对象的类是类簇的一个成员时，要注意它的类型信息(看第14节)。因为你可能认为你创建的是某个类的实例，但实际上确实它的某个子类的实例。在前面的例子中，你可能以为调用[employee isMemberOfClass:[EOCEmployee class]]的结果是YES，但employee其实不是EOCEmployee类初始化的对象，而是其子类，所以它会返回NO。 Cocoa中的类簇系统框架中有许多类簇。大多数的集合类都是类簇，例如NSArray和它对应的可变类NSMutableArray。所以，实际上它有两个基类：一个可变数组和一个不可变数组。它仍然是一个类簇但是却有两个公共接口。不可变类中定义的方法适用于所有的数组，可变类定义的方法仅适用于可变数组。实际上类簇意味着它们在实现自身时可以共享代码，以及可以在创建时把不可变数组变为可变数组，反之亦然。 在NSArray中，当你创建一个实例时，它其实是另一个类创建的实例，这个类的用途就是占位。之后这个占位数组会转化为另一个的实例，而那个类则是NSArray的具体子类。这是一个很好的实现，但它超出了本书的讲解范围。 理解像NSArray这样的类是一个类簇是重要的，因为别的原因，你可能会写出这样的代码： 1234id maybeAnArray = /* ... */; if ([maybeAnArray class] == [NSArray class]) &#123; // Will never be hit &#125; 知道了NSArray是一个类簇，可以使你理解上面的代码是错误的，其中if语句的条件永远不可能为真。[maybeAnArray class]返回的类永远不可能是NSArray类，因为NSArray初始化方法返回的变量是由隐藏在类簇内部的某个隐藏类实现的。 注意在类簇中对比实例变量的类是可以的。不适用之前的方法，你应该使用类型信息查询方法。第14节讲述了那些方法。替换之前类对象等同性比较方法，你因该这样写： 1234id maybeAnArray = /* ... */; if ([maybeAnArray isKindOfClass:[NSArray class]]) &#123; // Will be hit &#125; 给类簇添加具体的子类是正常的需求，但是这么做的时候要小心。在Emloyee的例子中，如果没有工厂方法代码，去添加新的子类是不可能的。在Cocoa的类簇中，例如NSArray，它是可以的，但是有一些规则必须去遵守。这几条规则如下： 子类应该继承自类簇的抽象基类。 在NSArray中，它可以继承自不可变数组的基类或者可变数组的基类。 子类应该定义自己的存储方式。 开发者编写NSArray子类时，经常在这个问题上受阻。子类必须用一个实例标量存储数组中的对象。这看起来与我们预想相反，我们以为NSArray自己会存储它们。但是请记住，NSArray仅仅是一个包在其他隐藏对象外面的壳，它只是定义了一些数组通用的接口。对于这个子类来说，可以是用NSArray来保存其实例。 子类应当覆写父类文档中指明需要覆写的方法。 每个抽象基类都有一些方法需要子类一定实现的。在NSArray中，需要实现的方法有count和objectAtIndex:。另外的方法，像lastObject，不需要去实现，因为可以使用前两个方法实现这个方法。 实现子类时所需要遵循的规范一般都在类的文档中，所以你首先应该阅读它们。 小结 类簇模式可以使用一套简单的公共接口隐藏实现的细节。 类簇在系统框架中是经常使用的。 在定义类簇的子类时，需要注意遵循基类的协议。如果有文档，那么首先阅读它。 在既有类中使用关联对象存放自定义数据有时，你想在对象中存储信息。通常，你通常会从那个对象类继承一个子类，然后使用子类去存储。然而，你不能一直这样做，因为类的实例可能是因为某种机制所创建的，并且你不能使这种机制使用你的类创建实例。这时候Objective-C中一个叫做Associated Objects的功能就派上用场了。 对象关联其它对象，并使用一个键去表示它。它们使用存储策略是维持存储对象的内存管理语义。这个存储策略由objc_AssociationPolicy的枚举值定义，表2.1展示了它所包含的值，同事还列出了与之等价的属性的特质(第6节讲述了属性的信息)。 Table 2.1 对象关联类型 关联对象的管理是使用下面语法实现的： void objc_setAssociatedObject(id object, void*key, id value, objc_AssociationPolicy policy) 使用给定的键和存储策略为对象设置关联对象值。 id objc_getAssociatedObject(id object, void*key) 使用给定的键从对象中获取关联对象值。 void objc_removeAssociatedObjects(id object) 移除对象的所有关联对象。 关联对象的存取方法是类似字典对象这种的，字典通过调用[object setObject:value forKey:key]与[object objectForKey:key]存取，关联对象同样使用特定的键存储关联的值。但是有一个重要的不同需要知道，关联对象的键是个指针。而字典对象的键是一个字符串，只需要字符串相同就可以了。但是关联对象的键必须是同一个指针才可以匹配。因此，关联对象通常使用全局静态变量作为键。 一个使用关联对象的例子在iOS开发中，经常会使用UIAlertView类，给用户提供一个基于当前视图的弹窗。当用户点击按钮时有一个代理协议用于处理这个点击事件；然而，使用代理协议需要拆分创建代码和点击事件。由于代码分成两块，所以读起来有些不方便。下面有一个使用UIAlertView的例子，与我们一般写法一致： 1234567891011121314151617181920- (void)askUserAQuestion &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Question&quot; message:@&quot;What do you want to do?&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Continue&quot;, nil]; [alert show]; &#125; // UIAlertViewDelegate protocol method - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; if (buttonIndex == 0) &#123; [self doCancel]; &#125; else &#123; [self doContinue]; &#125; &#125; 如果你想在同一个类弹出超过一个弹窗，那么这种写法将会变得更加凌乱，因为你接着需要通过代理方法去检查弹窗的参数，并基于此选择相应的逻辑。如果弹窗创建时就可以决定每个按钮该做什么，那么逻辑就会清楚很多。这时可以使用关联对象去处理。一个解决办法是当创建弹窗时给它设置一个block并且当协议方法触发时调用这个blcok。它实现是这样的： 123456789101112131415161718192021222324252627282930313233343536#import &lt;objc/runtime.h&gt; static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;; - (void)askUserAQuestion &#123; UIAlertView *alert = [[UIAlertViewalloc] initWithTitle:@&quot;Question&quot; message:@&quot;What do you want to do?&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Continue&quot;, nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123; if (buttonIndex == 0) &#123; [self doCancel]; &#125; else &#123; [self doContinue]; &#125; &#125;; objc_setAssociatedObject(alert, EOCMyAlertViewKey, block, BJC_ASSOCIATION_COPY); [alert show]; &#125; // UIAlertViewDelegate protocol method - (void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey); block(buttonIndex); &#125; 使用这种方法，创建弹窗的代码和回调结果的代码都在同一个位置，这样比之前的代码更易读，因为你不需要在两处代码之间来回看就可知道为什么使用弹窗了。然而使用这种办法你需要小心一个问题，如果block捕捉了某些变量，这可能会造成循环引用。关于这个问题更具体的信息请看第40节。 如你所见，这种方法是非常好用的，但是你应该确保仅仅是你没有别的办法达到你想做的时再去使用它。如果滥用它，你的代码将会很快超出控制并且难以排查问题。循环引用产生的原因是难以发现的，因为关联对象之间并没有明确的定义，内存管理语义定义在关联时期，而不是声明时期。所以当你使用这种方法时需要小心，不要因为某处可以用它就使用它。另一个实现弹窗的办法是创建子类，将block作为一个属性添加进子类。如果多次使用弹窗时，我认为使用这种办法是优于使用关联对象的。 小结 关联对象提供了一种方法去关联两个对象。 定义关联对象时可使用内存管理语义去模仿属性的拥有或非拥有关系。 当另一种方法不能实现时，才去使用关联对象，因为它可能产生难以查找的异常。 理解objc_msgSend的作用在Objective-C中通过对象调用方法是做的最多的事情之一。在Objective-C术语中，它被称作消息传递。消息有名字或者选择器，带有参数，并且可能会有一个返回值。 因为Objective-C是C的超集，去了解C中的函数调用时一个好的主意。众所周知，C的函数调用时静态绑定，即在编译时就知道函数的调用。例如，考虑下面的代码： 1234567891011121314151617#import &lt;stdio.h&gt; void printHello() &#123; printf(&quot;Hello, world!\n&quot;); &#125; void printGoodbye() &#123; printf(&quot;Goodbye, world!\n&quot;); &#125; void doTheThing(int type) &#123; if (type == 0) &#123; printHello(); &#125; else &#123; printGoodbye(); &#125; return 0; &#125; 忽略内联函数这种情况，当上述代码编译时，printHello函数和printGoodbye函数是已知的，编译器会直接发出指令去调用函数。在指令集中函数的地址就是有效的硬编码。现在考虑下下述代码： 12345678910111213141516171819#import &lt;stdio.h&gt; void printHello() &#123; printf(&quot;Hello, world!\n&quot;); &#125; void printGoodbye() &#123; printf(&quot;Goodbye, world!\n&quot;); &#125; void doTheThing(int type) &#123; void (*fnc)(); if (type == 0) &#123; fnc = printHello; &#125; else &#123; fnc = printGoodbye; &#125; fnc(); return 0; &#125; 在这里就需要使用动态绑定了，因为在运行时之前都不知道函数如何调用。在第一个和第二个例子中，编译器生成的指令集是不同的。第一个例子中，函数的调用是在if和else这两种情况中的。第二个例子中，仅有一个调用，不过是有一定代价的，即待调用的函数地址无法硬编码在指令集中，而是要在运行期读取出来。 在Obejctvie-C中，当传递消息给对象时，是通过动态绑定机制去决定调用哪个方法的。在底层所有的方法都是普通的C函数，但是当对象接收到信息后，调用哪一个方法完全取决于运行时，甚至可以在程序运行过程去修改它，这使得Objective-C成为一门真正的动态语言。 给对象发送消息看起来是这样的： 1id returnValue = [someObject messageName:parameter]; 在这个例子中，someObject是消息接收者，messageName:是选择器。选择器和参数的组合被称作消息。当编译器看到这个消息时，它将这个消息转化为一条标准的C函数，所调用的函数是消息传递机制中的核心函数，叫做objc_msgSend，其原型如下： 1void objc_msgSend(id self, SEL cmd, ...) 这是一个参数个数可变的参数，它可以接受两个或两个以上的参数。第一个参数是消息接收者，第二个参数是选择器(SEL的类型是selector)，剩下的参数就是消息参数，顺序与它们传递时一致。选择器指的是方法的名字。在计算机术语中，选择器和方法这两个术语经常交替使用。编译器会将上面的例子中的消息转化成这样： 123id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); objc_msgSend函数会依据消息接收者和选择器去调用合适的方法。为了做到这一点，这个函数会去查找消息接收者所属类中的方法实现列表，如果能查找到与接收器名字匹配的方法，就跳转至其实现代码。如果没有找到，这个函数会遍历其继承层次查找这个方法并跳转至其实现代码。如果仍没有找到匹配的方法，那么就执行消息转发。更详细的消息转发机制请看第12节。 这样说来，调用一个方法会需要很多步骤。幸运的是，objc_msgSend会在快速查找表中缓存结果，每个类都有这样一块缓存，所以后面给相同的类和方法组合发送消息是非常快速的。即使这样，快速查找仍然是比静态绑定方法的速度慢的，但是一旦方法缓存，也不会差太多。实际上，消息传递并不是一个应用程序的瓶颈。如果是，你可以编写纯C函数，只在调用需要时，将Objective-C对象状态传递进去。 上面说的仅仅基于确定的消息。另外的边缘情形则需要交给Objective-C运行时的另一些函数： objc_msgSend_stret 如果发送的消息返回结构体，那么可交由此函数处理。当返回的类型是结构体且能被放进CPU寄存器时，使用这个函数处理。如果寄存器不能容纳返回类型，那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。 objc_msgSend_fpret 如果发送消息的返回值是浮点数，那么可交由此函数处理。某些处理器调用函数时，需要对浮点型寄存器进行特殊处理，这意味着标准的objc_msgSend是不适合的。这个函数存在的作用是处理x86等架构中的一些特殊的情况。 objc_msgSendSuper 发送消息给父类，例如[super message:parameter]，使用这个方法。它也有两个等价于objc_msgSend_stret和objc_msgSend_fpret的函数，用于处理发给父类的消息。 刚才提到过，objc_msgSend等函数一旦搜寻到正确的方法实现就跳转至其实现代码。之所以能这样做，是因为每个Objective-C对象方法都能看做是一个简单的C函数，它的原型如下： 1&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...) 函数的名字可能不像上面那样，但我用类和选择器去组合它，仅仅是为了说明它的原理。每个类里面都有一张表，其中的指针会指向函数，以选择器名字为键去查找。objc_msgSend等函数正是通过这张表来寻找应该执行的方法并跳至其实现的。注意原型和objc_msgSend函数很相似，但这不是巧合。它简化跳转方法并且可以更好的使用尾调用优化。 当一个方法的最后一行是调用另一个函数，那么就可以使用尾调用优化。编译器可产生跳转至下一个函数的指令码，也不用生成新的栈帧。这仅当一个函数最后的操作是调用另一个函数且不需要使用返回值做任何事情，才能执行尾调用优化。这项优化对objc_msgSend是非常重要的，因为没有它，每次调用Objective-C方法，栈将会在栈踪迹中显示所有objc_msgSend调用的函数。并且，也将会经常发生栈溢出现象。 实际上，你在写Objective-C代码时，不需要担心这些问题，但是理解这些操作的本质对开发来说是有益的。如果你理解了在发送消息时发生了什么，你可以了解你的代码是如何执行的并且在调试时，也能理解为什么栈回溯中总会出现objc_msgSend函数。 小结 一个消息由一个接收者，一个选择器，参数组成。给对象发送消息相当于对象调用方法。 当调用时，所有的消息都需要通过动态消息发送系统来处理，它会查找方法的实现然后运行它们。 理解消息转发第11节解释了理解对象消息机制是重要的。第12节探讨当对象遇到无法处理的消息时发生了什么。类可以理解消息仅仅是因为它实现了相对应的方法。类接收到一个无法理解的信息会发生错误，但它并不是发生在编译时。因为方法是在运行时被添加到类中的，所以编译器并不知道对应的方法是否存在。当某个类接受到一个它不理解的消息，对象通过使用消息转发，一个允许开发者预处理的设计。开发者可以通过它去处理那些类无法理解的消息。 即使你不知道消息转发，但你可能已经遇到过由消息转发流程处理的消息了。每次你在控制台看到这样的信息，它是因为你给某个对象传递了消息但是那个对象无法处理它，所以它通过转发机制，将消息转发给了NSObject的默认实现。 12345-[__NSCFNumber lowercaseString]: unrecognized selector sent to instance 0x87 *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber lowercaseString]: unrecognized selector sent to instance 0x87&apos; 这是从NSObject的doesNotRecognizeSelector:方法抛出的一个异常，它告诉你这个消息的接收者类型是__NSCFNumber，并且这个接收者无法理解这个叫做lowercasrString的选择器。在上述示例中这并不奇怪，因为NSNumber是没有那个方法的(__NSCFNumber是为了实现无缝桥接而使用的内部类，当你初始化一个NSNumber实例时，它会被创建)。在这个例子中，应用程序最后以崩溃而告终，但是你可以在你的类中拦截到转发机制去执行你想要的逻辑替代崩溃。 转发路径是分为两大阶段的。第一个阶段是给接收者的类一个机会去动态的添加一个方法，用于处理未知的选择器。这叫做动态方法解析。第二个阶段涉及完整的消息转发机制。如果运行时间已经过了第一阶段，那么接收者就无法再以添加方法的方式去相应选择器。所以它告诉接收者自己去尝试处理。这也分为两步。首先，它会问别的对象是否接受这个消息。如果有，运行时会转移消息并结束消息转发。如果没有替代的接收者，则启动完整的转发机制，使用NSInvocation对象去把所有与消息有关的细节包装起来并给开发者最后一个机会去处理它。 动态方法解析当一个对象接收到一个它不能理解的方法时，在它所属类中调用的第一个方法是： 1+ (BOOL)resolveInstanceMethod:(SEL)selector; 这个方法带有一个当前类无对应实现的选择器并且返回一个布尔值指示是否在运行期有可以对应选择器的实例方法添加到本类。因此，在触发其余转发机制之前这个类有第二次机会去添加对应的实现。还有一个类似的方法，叫做resolveClassMethod:，当一个未实现的方法是类方法而不是实例方法时会调用它。 使用这种方法依赖于这个方法实现已经是可用的，准备动态的插入类中。这个方法经常被用做实现@dynamic属性(看第6节)，例如在CoreData中访问NSManagedObjects属性，因为访问方法需要去手动实现，这样属性才可以在编译时被知道。 这样一个resolveInstanceMethod:实现，对于使用@dynamic属性看起来是这样的： 123456789101112131415161718192021id autoDictionaryGetter(id self, SEL _cmd); void autoDictionarySetter(id self, SEL _cmd, id value); + (BOOL)resolveInstanceMethod:(SEL)selector &#123; NSString *selectorString = NSStringFromSelector(selector); if ( /* selector is from a @dynamic property */ ) &#123; if ([selectorString hasPrefix:@&quot;set&quot;]) &#123; class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;); &#125; else &#123; class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;); &#125; return YES; &#125; return [super resolveInstanceMethod:selector]; &#125; 首先将选择器转为一个字符串，并且检查它是否是一个setter方法。如果前缀带有set字符，假定它是一个setter方法；否则，假定它是一个getter方法。在每种情况下，都会对给定选择器的类添加一个方法，它指向一个C函数的实现。在这些C函数中将会通过代码来控制类使用某种数据结构去存储属性数据。例如，在CoreData中，这些方法将通过后端数据库去检索或更新值。 备用接收者第二步处理未知选择器的方法是询问接收者是否有一个可用的替代接收者去处理相应的消息。这个方法是这样的： 1- (id)forwardingTargetForSelector:(SEL)selector 传递未知的选择器并且返回符合预期的接收者，当未找到符合预期的接收者，将返回nil。这个方法可以让我们通过组合来模拟多重继承的某些特性。一个对象内部可能还有一系列别的对象，在这个方法中它可以返回能够处理的选择器相关的内部对象，并使其在外界看来像是它亲自处理一样。 注意，我们无法再这一步对消息做出改变。如果消息需要在发送给备用接收者之前做改变，那么我们需要使用完整的转发机制。 完整转发机制如果转发算法已经走到这一步，那么能做的事仅有使用完整的转发机制了。首先创建一个NSInvocaton对象，用于包含不能处理的消息的所有细节。这个对象包含选择器，目标接收者，和参数。在触发NSInvocaton对象可时，这将导致消息派发系统去将消息派发给指定的对象。 此步骤调用的转发方法： 1- (void)forwardInvocation:(NSInvocation*)invocation 一个简单的实现是改变这个对象的目标并触发它。这样的实现与备用接收者是等价的，但是很少有人使用这么简单的实现。更有用的实现是可以在调用前通过某些办法改变这个消息，比如拼接另一个参数或者改变选择器。 实现此方法时，如果发现调用不是由该类处理，那么应该调用它的父类去处理。这意味着在继承链上的所有父类都有机会去处理这个调用，直至NSObject的实现。如果最后该消息仍没有处理，那么仍会调用doesNotRecognizeSelector:抛出异常。 完整的转发机制图图2.2这张流程图描述了消息转发机制处理消息的各个步骤。 在每一步，接收者都有机会去处理消息。每一步处理代价都比上一步大。最好的处理时机在第一部，因为方法在运行时被添加将会被运行时缓存，当你使用同一个类的实例再次调用时，它不需要再走转发机制就可以找到这个选择器了。如果能找到一个备用接收者，那么在第二步处理是优于第三步处理的。在第三步中，仅是修改有关的调用目标，那在第二步做这个是比第三步更简单的，并且也不需要再去创建NSInvocaton对象。 动态方法解析的完整示例为了说明如何使用消息转发机制，下面的例子展示了使用动态方法解析显现@dynamic属性。考虑一个对象允许你存储任何对象进去，类似一个字典，但需要通过属性提供存取方法。这个类的设计思路是你可以添加属性定义并使用@dynamic声明它，类将处理存储和获取方法。这听起来是不是很不错？ 这个类的接口大概是这样的： 12345678#import &lt;Foundation/Foundation.h&gt; @interface EOCAutoDictionary : NSObject @property (nonatomic, strong) NSString *string; @property (nonatomic, strong) NSNumber *number; @property (nonatomic, strong) NSDate *date; @property (nonatomic, strong) id opaqueObject; @end 在这个例子中，这些属性具体是什么是不重要的。我之所以写这么多类型只是为了展示这个功能的强大。在类的内部，每一个属性将都存放在字典中，所以类开始的实现是下面这样的，包含使用@dynamic声明属性，这样这些属性的实例变量和存取方法就不会自动生成了： 12345678910111213141516#import “EOCAutoDictionary.h&quot; #import &lt;objc/runtime.h&gt; @interface EOCAutoDictionary () @property (nonatomic, strong) NSMutableDictionary *backingStore; @end @implementation EOCAutoDictionary @dynamic string, number, date, opaqueObject; - (id)init &#123; if ((self = [super init])) &#123; _backingStore = [NSMutableDictionary new]; &#125; return self; &#125; 然后是本例重要的部分： 12345678910111213141516+ (BOOL)resolveInstanceMethod:(SEL)selector &#123; NSString *selectorString = NSStringFromSelector(selector); if ([selectorString hasPrefix:@&quot;set&quot;]) &#123; class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;); &#125; else &#123; class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;); &#125; return YES; &#125; @end 首次调用一个位于EOCAutoDictionary实例中的属性时，运行时找不到对应的选择器，因为它们即没有直接实现也没有自动合成。例如，假如要向opaqueObject对象写入信息，那么将会调用setOpaqueObject:方法。同理，在读取该属性时，会调用opaqueObject方法。resolveInstanceMethod:方法会检测方法是不是含有set前缀，以此区分setter和getter方法。在每种情况下，都会向类中增加一个方法去处理选择器，这两个方法分别是autoDictionarySetter及autoDictionaryGetter函数的指针。这时就可以使用运行时的class_addMethod方法，给类动态的添加方法，用于处理对应的选择器，并且带有所添加方法的指针。最后一个参数表示实现方法的类型编码。在本例中，编码开头的字符表示方法的返回值类型，后续字符则表示其所接受的各个参数。 getter函数的实现： 1234567891011id autoDictionaryGetter(id self, SEL _cmd) &#123; // Get the backing store from the object EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self; NSMutableDictionary *backingStore = typedSelf.backingStore; // The key is simply the selector name NSString *key = NSStringFromSelector(_cmd); // Return the value return [backingStore objectForKey:key]; &#125; 最后，setter函数的实现： 123456789101112131415161718192021222324252627282930void autoDictionarySetter(id self, SEL _cmd, id value) &#123; // Get the backing store from the object EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self; NSMutableDictionary *backingStore = typedSelf.backingStore; /** The selector will be for example, &quot;setOpaqueObject:&quot;. * We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first * letter of the remainder. */ NSString *selectorString = NSStringFromSelector(_cmd); NSMutableString *key = [selectorString mutableCopy]; // Remove the &apos;:&apos; at the end [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)]; // Remove the &apos;set&apos; prefix [key deleteCharactersInRange:NSMakeRange(0, 3)]; // Lowercase the first character NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString]; [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar]; if (value) &#123; [backingStore setObject:value forKey:key]; &#125; else &#123; [backingStore removeObjectForKey:key]; &#125; &#125; 使用EOCAutoDictionary的方法很简单： 1234EOCAutoDictionary *dict = [EOCAutoDictionary new]; dict.date = [NSDate dateWithTimeIntervalSince1970:475372800]; NSLog(@&quot;dict.date = %@&quot;, dict.date); // Output: dict.date = 1985-01-24 00:00:00 +0000 其它属性在字典中的实现也类似于日期属性，如果要添加新的属性，也可以使用@property定义，@dynamic声明它。在iOS的CoreAnimation框架中，CALayer类也是用来类似的方法。这是的CALayer成为可以兼容键值对容器的类，这意味着你可以随意添加键值对，并以属性的方法访问它。于是，开发者就可以向其中新增自定义的属性了，这些属性值的存储工作由基类直接负责，我们只需在CALayer的子类中定义新属性即可。 小结 如果对象无法响应选择器，则进入消息转发流程。 运行时的动态方法解析可以使我们给类添加我们需要使用的方法。 对象可以把无法处理的选择器交给其他对象去处理。 当前述步骤未处理选择器时，启动完成的转发机制。 考虑使用方法交换去调式不透明方法在Objective-C中，当给对象发送消息时，它的一系列调用是发生在运行期的，第11节详细阐述了这个过程。你可能会在运行时修改给定选择器的对应方法。这是可以的。这个功能有巨大的用途，你可以使用它修改类中的方法对于某些你没有代码的方法，不需要子类和重载方法。因此，这个新的函数可以被所有类的实例使用而不仅是重载方法的子类实例。这种方法通常被称为Method Swizzling。 一个类的方法列表中包含一个选择器名字列表用于映射，告诉动态消息系统在哪里找到给定方法的实现。这个实现是作为函数指针被存储的，叫做IMPs，如下面的原型： Figure 2.3 NSString的选择器表 1id (*IMP)(id, SEL, ...) NSString类可以响应这些选择器的调用lowercaseString，uppercaseString，capitalizedString以及其它方法。每一个选择器指向一个不同的实现，类似于图2.3。 Objective-C运行时暴露的一些方法可以操作这张表。你可以给列表添加选择器，改变实现指向，或者交换两个选择器的实现。执行其中的一些操作，类方法表可能像图2.4。 Figure 2.4 执行了一些操作后，NSString选择器的表 添加了一个新的叫做newSelector选择器，改变了capitalizedString的实现，并且交换了lowercaseString和uppercaseString的实现。上述修改均无须编写子类，只要修改了方法表的布局，就会反映到程序中所有的NSString实例之上。怎么样，这是一个强大的功能吧。 这节的话题会讲述两个方法交换的过程。这样做可以为已有方法添加新功能。在讲述如何给已有方法添加功能之前，我将先讲述如何去交换两个已经存在的方法。交换方法实现，你应该使用下面的函数： 1void method_exchangeImplementations(Method m1, Method m2) 这个函数中的参数用于交换。它们可以通过下面的函数获取： 1Method class_getInstanceMethod(Class aClass, SEL aSelector) 这个方法使用给定的选择器在类中去检索方法。在前面的例子中，交换lowercaseString和uppercaseString的实现，需要执行下面的代码： 1234567Method originalMethod = class_getInstanceMethod([NSStringclass], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSStringclass], @selector(uppercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); 从这时起，所有的NSString实例调用lowercaseString方法时，都会调用uppercaseString的实现，反之亦然： 123456789NSString *string = @&quot;ThIs iS tHe StRiNg&quot;; NSString *lowercaseString = [string lowercaseString]; NSLog(@&quot;lowercaseString = %@&quot;, lowercaseString); // Output: lowercaseString = THIS IS THE STRING NSString *uppercaseString = [string uppercaseString]; NSLog(@&quot;uppercaseString = %@&quot;, uppercaseString); // Output: uppercaseString = this is the string 上面展示了如何交换两个方法实现，但是在实际使用中，简单的交换两个实现不是非常有用的。毕竟，你为什么要交换lowercaseString和uppercaseString的实现，它们已经做的不错了。你没有任何理由去交换它们。但是同样的方法可以用来给已有的方法添加新功能。假如你想记录调用lowercaseString时的某些信息。同样的办法可以达到这个目的。它需要你去实现一个新的方法并包含你想要的功能，然后通过交换去替代掉原有方法。 可以使用category去添加的方法，如下： 123@interface NSString (EOCMyAdditions) - (NSString*)eoc_myLowercaseString; @end 这个方法与原有的lowercaseString方法交换，交换后的方法表如图2.5。 新方法的实现如下： 1234567@implementation NSString (EOCMyAdditions) - (NSString*)eoc_myLowercaseString &#123; NSString *lowercase = [self eoc_myLowercaseString]; NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase); return lowercase; &#125; @end 这看起来像是会陷入递归调用的死循环，但是要记住它们的实现已经交换了。所以在运行时，当查找eoc_myLowercaseString选择器时，它会调用lowercaseString的实现。最后，交换两个方法的实现，像下面这样使用： 1234567Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); 从现在起，所有的NSString实例调用lowercaseString方法时，都会在日志中打印出如下信息： 123NSString *string = @&quot;ThIs iS tHe StRiNg&quot;; NSString *lowercaseString = [string lowercaseString]; // Output: ThIs iS tHe StRiNg =&gt; this is the string 通过这个方案，开发者可以对那些无法知道实现的方法增加日志输出，这对调试来时是非常有用的。然而此方法也应只在调试模式使用它。很少有人在全局类中使用它。不要因为你能使用它就去用它。过多的使用会使你的代码难以阅读和难以控制。 小结 在运行时可以给类中添加方法或者替换某个指定的选择器的实现。 使用一个方法实现去替代另一个方法实现，叫做Method Swizzling，开发者通常用其为已有方法添加功能。 在调试模式下，通过运行时去修改方法实现是好的做法，但是不能滥用。 理解类对象Objective-C实际上是一门极其动态的语言。第11节讲述了在运行时如何查找一个方法的实现，第12节讲述了当一个类不能响应一个确定的选择器时的转发机制。但是消息接收者是什么：那个对象自身？runtime怎么知道那个对象的类型？在编译时对象的类型并未绑定，而是在运行时确定的。此外，一个特殊的类型id，它可以表示任意的Objective-C对象类型。通常，指定的对象类型是已知的，所以编译器才能在它认为接收者无法接收某条消息时发出警告。相反的，当对象类型是id时，编译器将假定它可以相应所有的消息。 从第12节你可以知道，编译器无法知道一个确定类型到底能理解多少选择器，因为它们可以在运行时动态添加。然而，即使知道可能会在运行时添加方法，编译器也觉得可以在某个头文件中看到方法原型的定义，这样它可以知道完整的方法签名，用于生成消息派发所需的正确代码。 在运行时检查对象的类型也被称作内省，这是一个强大且有用的功能，它作为NSObject协议的一部分内置在Foundation框架中，凡是由公共根类(NSObject与NSProxy)继承来的类都要遵守它。使用这些方法而不是直接对比对象的类是明智的，我将在后面讲述为什么不要直接对比。不过在介绍类型信息查询技术之前，我们先讲一些基础知识，看看Objective-C对象的本质是什么。 每一个Objective-C对象实例指向一块内存区域。这就是为什么当你声明一个变量时，看到类型后面有一个*： 1NSString *pointerVariable = @&quot;Some string&quot;; 编过C语言程序的人都知道这是什么意思。对于没写过C语言的程序员来说，pointerVariable是一个存放内存地址的变量，而NSString自身的数据就存于那个地址中。因此这个变量指向NSString实例。所有的Objective-C对象都是这样的；如果想在栈上初始化一个对象，你将会收到一个来自编译器的错误： 12String stackVariable = @&quot;Some string&quot;; // error: interface type cannot be statically allocated 通用的对象类型id，它本身就是一个指针，所以你可以这样使用它： 1id genericTypedString = @&quot;Some string&quot;; 这个定义的语义与NSString*是相同的。它们的区别在于指明类型的情况下，对于这个实例如果你尝试调用一个类中不存在的方法，编译器可以帮助你检查，并且发出警告信息。 在runtime的头文件中，所有的对象的数据结构都是这样定义的，id类型本身也在这定义： 123typedef struct objc_object &#123; Class isa; &#125; *id; 因此，每个对象的首个成员是Class类型的变量。这个变量定义了对象所属的类型，常常被称为isa指针。例如，刚才的例子中的对象是一个NSString。类对象也定义在runtime的头文件中： 12345678910111213typedef struct objc_class *Class; struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; &#125;; 这个结构体存放类的元数据，例如类实例的方法实现和实例变量。实际上这个结构体也有一个isa指针，并且是第一个变量，它意味着Class自身也是一个Objective-C对象。这个结构体也有另一个变量，叫做super_class，这个是类的父类。类的类型是另一个类，叫做元类，用来表述类对象本身所具备的元数据。类方法就定义在元类中，因为它可以理解成类对象的实例方法。每个类仅有一个类对象，每个类对象也只有一个元类。 一个叫做someClass的类继承自NSObject，继承链如图2.6。 Figure 2.6 SomeClass的实例继承链，它继承自NSObject，包含元类的继承。 super_class指针确立了继承关系，isa指针则描述了实例所属的类。你可以通过操作这个布局来执行内省(检查对象的类型)。你可以通过它找到一个对象是否可以响应某个确定的选择器并且遵循某个确定的协议，并且确定对象所属类的继承信息。 检查类的继承内省方法可以用作去检查类的继承。你可以使用isMemberOfClass:判断一个对象是否是某个确定类的实例，或者使用isKindOfClass:去检查某个对象是否是某个确定类或者任何继承自它的类的实例。例如： 12345NSMutableDictionary *dict = [NSMutableDictionary new]; [dict isMemberOfClass:[NSDictionary class]]; ///&lt; NO [dict isMemberOfClass:[NSMutableDictionary class]]; ///&lt; YES [dict isKindOfClass:[NSDictionary class]]; ///&lt; YES [dict isKindOfClass:[NSArray class]]; ///&lt; NO 像这种内省类型的原理是通过isa指针获得对象的类，并且使用super_class去遍历整条继承链。由于对象类型是动态的，所以这个功能是非常重要的。Objective-C与你了解的其他语言不同，在Objective-C中，必须查询类型信息，才能完全了解对象的真实类型。 由于Objective-C使用动态类型绑定，所以查询对象所属类的功能是非常有用的。当你从集合中获取对象时，内省是非常常用的，因为它们不是强类型，意思是指当对象是从集合中获取的时候，它们通常是id类型。如果需要知道具体的类型，那么就可以使用内省：例如，想根据数组中存储的对象生成以逗号分隔的字符串，并将其存至文本文件，就可以使用下列代码： 12345678910111213141516- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array &#123; NSMutableString *string = [NSMutableString new]; for (id object in array) &#123; if ([object isKindOfClass:[NSString class]]) &#123; [string appendFormat:@&quot;%@,&quot;, object]; &#125; else if ([object isKindOfClass:[NSNumber class]]) &#123; [string appendFormat:@&quot;%d,&quot;, [object intValue]]; &#125; else if ([object isKindOfClass:[NSData class]]) &#123; NSString *base64Encoded = /* base64 encoded data */; [string appendFormat:@&quot;%@,&quot;, base64Encoded]; &#125; else &#123; // Type not supported &#125; &#125; return string; &#125; 去检查类对象的等价性也是可以的。如果你要这样做，那么可以使用==操作符而不要使用你对比对象时常用的isEqual:方法(看第8节)。理由是在一个应用程序中，没个类都是单例，并且每个类仅会有一个类对象存在。因此，另外一种可以准确判断对象是否为某类实例的办法如下： 1234id object = /* ... */; if ([object class] == [EOCSomeClass class]) &#123; // &apos;object&apos; is an instance of EOCSomeClass &#125; 即使能这样做，你也应该使用内省方法去判断而不是直接调用==操作符，因为内省方法可以完整的处理消息转发(看第12节)的情况。考虑下一个对象将它的所有选择器都转发给另一个对象了，这样的对象叫做代理，并且对于这些类似的对象都以NSProxy为根类。 通常情况下，假如这样的代理对象调用class方法，那将返回代理类(例如：NSProxy的子类)，而非接受的代理的对象所属的类。然而，如果是这样的内省方法，例如isKindOfClass:，那么代理对象会把这个方法转发给接受代理的对象。这意味着这条消息的返回值与直接在接受代理对象上面查询的结果是一样的。因此，这样检查出来的类对象与调用class方法返回的类对象不同，class方法所返回的类表示发起代理的对象，而非接受代理的对象。 小结 每个实例都有一个isa指针，用于表明它的类型与指向类对象，而类对象构成了类的继承链。 当在编译时不能确实对象类型时，应该使用内省去确定对象的具体类型。 应该总是使用内省去检查对象类型，而不是直接对比类对象，因为对象可能实现了消息转发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[译《Effective Objective-C 2.0》第一章]]></title>
      <url>%2F2017%2F04%2F29%2FAccustoming%20Yourself%20to%20Objective-C%2F</url>
      <content type="text"><![CDATA[这是翻译《Effective Objective-C 2.0》的第一章：对Objective-C的认识 简介Objective-C通过一种完整的新的写法为C语言带来了面向对象的功能。由于Objective-C使用大量的方括号和长的方法名，常被认为是繁琐的、冗长的。它生成的源代码非常易读但是不同于C++或Java的主流开发。 书写Objective-C代码可以让你快速的学习它但是经常会有许多细节和功能被忽视。类似的，一些功能在尚未完全理解的情况下被滥用，由此写出的代码是难以维护和DEBUG的。本章节讲解Objective-C的基本部分；后续章节讲解关于语言的特定领域和相关的框架。 了解Objective-C的本源Objective-C同其他面向对象的语言是相似的，例如C++和Java，但是也有许多不同的地方。如果你有别的面向对象语言的经验，你将会理解它许多示例和使用的模式。然而，它的语法仍可能是陌生的因为它使用消息机制而不是函数调用。Objective-C源于Smalltalk，Smalltalk源于消息机制。消息机制与函数调用的不同看起来是这样的： 1234567// Messaging (Objective-C) Object *obj = [Object new]; [obj performWith:parameter1 and:parameter2]; // Function calling (C++) Object *obj = new Object; obj-&gt;perform(parameter1, parameter2); 两者的区别在于在消息机制中，是在运行时决定code的行为。而在函数调用中，是在编译时决定code的行为。当多态被引入到函数调用中时，查找它的方式是在运行时通过一个已知的虚拟表中查找。但是在消息机制中，一直是在运行时查找。事实上，编译器根本不在乎接收的对象类型。它也是在运行时查找，通过动态绑定确定类型，在第11节会有更详细的介绍。 Objective-C在运行时做了更多的工作而不是编译时。runtime包含了所有的数据结构和函数，它确保了Objective-C面向对象功能的正常使用。例如，runtime包含所有内存管理的方法。本质上，runtime是代码的集合，连接你所有代码和你以动态库方式引用的代码。因此，每当runtime更新时，你的应用将会享受到性能提升带来的收益。一门在编译时做更多工作的语言需要重新编译才能受益于性能的提升。 Objective-C是C的超集，当你写Objective-C代码时，C的所有特性也是可以使用的。因此，书写Objective-C代码实际上需要你理解OC和C的核心概念。尤其是理解C的内存模式将会帮助你理解Objective-C的内存模式以及引用计数的工作原理。这需要理解在Objective-C中一个指针是被用来代表一个对象。当你声明一个变量时，将会持有一个对象的引用，语法是这样的： 1NSString *someString = @&quot;The string&quot;; 这种语法大多来源于C，声明一个叫做someString的变量，类型是NSString *。它的意思是这是一个NSString类型的指针。所有的Objective-C对象都必须通过这种方式声明，因为对象的初始化一直在堆上并且绝不会再栈上。像下面这种声明是不合法的： 12 NSString stackString;// error:interface type cannot be statically allocated someString变量指向某个内存地址，在堆上初始化，包含一个NSString对象。这个意思是创建另一个变量指向同样的内存地址，不是copy，而是产生两个变量指向同一个对象： 12NSString *someString = @&quot;The string&quot;;NSString *anotherString = someString; Figure 1.1 内存布局展示了一个在堆上初始化的NSString实例和两个栈上初始化的变量指向它 这仅有一个NSString实例，但有两个变量指向同它。这两个变量的类型是NSString *，意思是当前栈上已经初始化了2bit大小的指针(32位下每个指针占4个字节，64位下每个指针占8个字节)。这2bit内存保存了同样的值：NSString实例的内存地址。 图1.1说明了这个结构。NSString实例存储了表示实际字符串所需要的字节。 在堆上分配的内存需要程序员管理，而栈上分配的内存是系统管理的，在它们所在的栈弹出时自动清理。 Objective-C堆上的内存管理是已经抽象的。你不需要使用malloc和free去初始化和释放对象内存。Objective-C的runtime通过一种被称为引用计数的管理机制抽象了它(具体看第29节)。 有时在Objective-C中你会遇到这种不带有*的声明并且使用栈控件的变量。这些变量不持有Objective-C对象。例如CGRect，来源于CoreGraphics框架： 12345CGRect frame;frame.origin.x = 0.0f;frame.origin.y = 10.0f;frame.size.width = 100.0f;frame.siez.height = 150.0f; CGRect是一个C的结构体，定义是这样的： 12345struct CGRect &#123; CGRect origin; CGSize size;&#125;;typedef struct CGRect CGRect; 这些类型的结构体被用于整个系统框架，在其中使用Objective-C对象可能会影响性能。创建对象会产生额外开销，而结构体不会，例如初始化和释放堆内存。当保存的数据类型不是对象时，通常会使用一个结构体，如CGRect。 在开始书写Objective-C之前，我建议你去读C语言的文档并且熟悉它的语法。如果你直接书写Objective-C代码，你可能会找到部分令你困惑的语法。 小结 Objective-C是C的超集，添加了面向对象的功能。 Objective-C使用消息机制和动态绑定，意思是一个对象的类型是在运行时确定的。 Objective-C是运行时而不是编译时，通过消息决定代码如何运行。 了解C语言的核心概念将帮助写出更有效的Objective-C代码。特别是你需要理解内存模式和指针。 减少在头文件中使用importObjective-C使用头文件和实现文件就像C和C++一样。当在Objective-C写一个类，标准方法是创建的每个文件名均以类名命名，后缀带有.h的是头文件，带有.m的是实现文件。当你创建一个类时，它看起来是这样的： 12345678910111213141516// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@end// EOCPerson.m#import &quot;EOCPerson.h&quot;@implementation EOCPerson// Implementation of methods@end 对所有类来说，导入Foundation.h是必须的，你将在Objective-C中一直使用它。或者你在某个类的父类中导入框架的头文件。例如，你创建一个iOS应用，你通常会创建UIViewController的子类。这些类的头文件将会导入UIKit.h。 目前来讲，这个类的写法是没问题的。它导入了整个Foundation框架，但是并不需要在意。EOCPerson类继承自Foundation框架中的某一个类，它将会使用框架的一大部分功能。继承自UIViewController的类也是一样，它将会使用UIKit框架的一大部分功能。 随着时间的推移，你可能创建了一叫做EOCEmployer的新类。然后你决定一个EOCPerson实例持有一个EOCEmployer实例。所以你提前给它加了一个属性： 12345678910// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 一个问题出现了，当你编译时发现EOCEmployer是缺失的。这个时候编译器一定会提示你在EOCPerson.h中导入EOCEmployer.h。通常你是在EOCPerson.h顶部加入导入的方法： 1#import &quot;EOCEmployer.h&quot; 这将使他正常编译，但这是一个坏的习惯。因为编译EOCPerson不需要知道EOCEmployer的详细信息。仅需要知道有一个叫做EOCEmployer的类存在即可。幸运的是，有一个办法可以告诉编译器这样： 1@class EOCEmployer; 这叫做向前声明这个类。这样EOCPerson的头文件看起来是这样的： 123456789101112// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interfrace EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) EOCEmployer *employer;@end 当你为了在实现文件中使用它时，你需要知道EOCEmployer的全部信息，你可以在实现文件导入它。所以实现文件看起来是这样的： 1234567// EOCPerson.m#import &quot;EOCPerson.h&quot;#import &quot;EOCEmployer.h&quot;@implementation EOCPerson// Implementation of methods@end 推迟导入是必要的，在需要的时候导入，可以使你限制它的作用域。在例子中，如果EOCEmployer.h是在EOCPerson.h中导入，你最后会有许多重复导入，那毫无疑问是会增加编译时间的。 使用前向声明会缓解两个类互相引用的问题。考虑下当EOCEmployer有两个方法去添加和移除EOCPerson的实例会发生什么，在头文件像这样定义： 12- (void)addEmployee:(EOCPerson *)person;- (void)removeEmployee:(EOCPerson *)person; 这时，在相反的情况下处于同样的原因，EOCPerson类需要对编译器可见。可是，通过在别的每个头文件导入它去实现会产生一个”先有鸡还是先有蛋”的问题。当一个头文件被解析时，它导入了别的头文件，而别的头文件也导入了它，那么哪个是第一个导入呢。使用#import而不是#include可以避免这个问题，但是其中有一个类会不能正确编译。如果你不相信我就自己试试喽。 有时，你需要在一个头文件导入另一个头文件。你一定需要导入你所继承类的头文件。类似的，如果你有任何协议需要去实现它，你将不得不使用完整的定义并且不能使用向前声明。编译器需要知道这个协议的所有定义而不是通过向前声明确定协议的存在。 例如，假设一个矩形类继承自一个形状类并要实现一个协议用于绘画： 12345678910// EOCRectangle.h#import &quot;EOCShape.h&quot;#import &quot;EOCDrawable.h&quot;@interface EOCRectangle : EOCShape &lt;EOCDrawable&gt;@property (nonatomic, assign) float width;@property (nonatomic, assign) float height;@end 这个导入是无法避免的。对于这样的协议，放置它们在自己类的头文件应该是谨慎的。如果EOCDrawable协议是一个大的头文件的一部分，你将不得不导入它的所有内容。如前面所描述的一样会产生同样的依赖和额外的编译时间的问题。 即使如此，也不是所有协议都是这样的。例如，代理协议(看第23节)，需要放置在自己头文件中。在这种情况下，协议的使用场景仅在当它作为委托类的一部分一起定义时。在这种情况下，它最好声明在你的实现文件中，即.m中使用类扩展声明它。这意思是在实现文件中导入包含协议的头文件而不是在头文件中。 每当在头文件导入文件时，总是问自己这是否是必要的。如果导入可以用向前声明代替，那么使用向前声明。如果导入它为了使用一些属性，实例变量或者实现协议并且可以移动到实现文件中时，那么移动它。那将会尽可能减少编译时间和相互依赖的可能性，可以修复问题或者在公共API中减少你暴漏的代码。 小结 总在尽可能深的层次导入头文件。经常在头文件使用向前声明并且在实现文件导入它们。这样做可以尽量避免两个类的相互引用。 有时，向前声明是不适用的，在声明协议遵循时。在这种情况下，考虑移动协议遵循到类的实现文件中。或者，导入仅有协议定义的头文件。 多使用Literal Syntax少使用与之等价的方法 译者言:有人将Literal Syntax称为字面量语法，Literal Number称为字面量数字，Literal Array称为字面量数组，Literal Dictionary称为字面量字典。 当使用Objective-C时，你总会遇到几个类。这几个类是基础框架的一部分。从技术上讲，你不需要使用Foundation去书写Objective-C代码，你通常在练习中使用它们。这些类是NSString、NSNumber、NSArray、NSDictionary。它们的数据结构即是它们自身所代表的意思。 众所周知Objective-C拥有冗长的语法。这是真的。然而，自从Objective-C 1.0开始，有一个非常简单的办法去创建一个NSString对象。它被称为String Literal并且看起来像这样： 1NSString *someString = @&quot;Effective Objective-C 2.0&quot;; 这种类型的语法是不存在的，通常创建一个NSString对象是需要调用alloc方法后，调用init方法的。幸运的是，这种被称作Literal Syntax，在最近的编译器版本中已经支持的了。同样也包括NSNumber、NSArray、NSDictionary的实例。使用Literal Syntax减少了代码大小，并且使代码更易读。 Literal Numbers有时，你需要在一个对象中包含一个整数，或者浮点数，或者布尔值。你可以通过使用NSNumber实现它，它可以处理一系列的数字类型。使用Literal Number之前，你创建实例时是这样的： 1NSNumber *someNumber = [NSNumber numberWithInt:1]; 它创建了一个数值，并将值设为1。然而，使用Literal Number使它更简单： 1NSNumber *someNumber = @1; 如你所见，Literal Number是更简洁的。然而好处远远不止这些。这种语法包含所有NSNumber实例可以代表的数据类型。例如： 12345NSNumber *intNumber = @1;NSNumber *floatNumber = @2.5f;NSNumber *doubleNumber = @3.14159;NSNumber *boolNumber = @YES;NSNumber *charNumber = @&apos;a&apos;; 这种Literal Syntax也适用于表达式： 123int x = 5;float y = 6.32f;NSNumber *expressionNumber = @(x * y); 使用Literal Syntax对于数值来说是非常有用的。这样做可以使NSNumber对象更简洁明了，因为声明的大部分是值而不是多余的语法。 Literal Arrays数组是一个常用的数据结构。使用Literal Syntax之前，你是这样创建一个数组的： 1NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil]; 使用Literal Syntax之后，仅需要使用下面的语法： 1NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;]; 这已经是一种很简单的语法了，但是它对数组的好处远不止于此。一个常见的操作是根据一个确定的下标从数组中取值。使用Literal Array这也是简单的。通常你会使用objectAtIndex: method:: 1NSString *dog = [animals objectAtIndex:1]; 而使用Literal Syntax，只需要像下面的做法一样： 1NSString *dog = animals[1]; 这称作下标取值，就像其他的Literal Syntax一样，它更简洁明了的指出它做了什么。此外，它看起来与别的语言的取值方法非常相似。 然而，当你使用Literal Syntax创建一个数组时你需要知道一件事情。如果任何的对象为空，会抛出一个异常，因为Literal Syntax仅仅是创建一个数组然后添加方括号中所有元素的语法糖。这个异常看起来是这样的： 1234*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[0]&apos; 这将导致当使用Literal Syntax时会产生一个常见的问题。下面的代码创建了两个数组，每一个语法如下： 123456id object1 = /*...*/;id object2 = /*...*/;id object3 = /*...*/; NSArray *arrayA = [NSArray arrayWithObjects:object1, object2, object3, nil];NSArray *arrayB = @[object1, object2, object3]; 现在考虑这样一个场景，当object1和object3指向一个有效的Objective-C对象，但是object2是空的。这literal array，arrayB，将会抛出一个异常。然而，arrayA 仍将会被创建但只包含object1对象。原因是arrayWithObjects:方法添加参数，遇到nil终止，这比预想的结束的早。 这种微小的不同意味着Literal Synta更加安全。抛出一个异常，可能导致程序结束是更好的，而不是创建一个比预想中元素要少的数组。程序员最可能的错误是往数组中插入一个空的对象，并且异常意味着更容易被发现。 Literal Dictionaries字典提供一个map数据结构在其中添加键值对。类似于数组，字典也是Objective-C代码中常用的。创建一个使用是这样的： 12345NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Matt&quot;, @&quot;firstName&quot;, @&quot;Galloway&quot;, @&quot;lastName&quot;, [NSNumber numberWithInt:28], @&quot;age&quot;, nil]; 这令人相当困惑，因为这顺序是object, key, object, key, …。然而，你通常认为字典应当是key对应value。因此，它读起来不是很好理解。然而，Literal Syntax再一次令语法变得清楚： 1234NSDictionary *personData = @&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, @&quot;lastName&quot; : @&quot;Galloway&quot;, @&quot;age&quot; : @28&#125;; 这样写是更简洁的，并且key在value之前，正是你所期望的。也要注意在示例中，Literal Numbers也是适用的。字典的value和key必须是Objective-C对象，所以你不能直接使用整数18区存储，相应的，你必须将它包含在一个NSNumber实例中。但是Literal Syntax意味着它只是一个额外的字符。 就像数组一样，如果某个value为空，Literal Syntax会抛出异常。然而，由于同样的理由，这是一个好事。由于dictionaryWithObjectsAndKeys:方法在第一个value为空处结束，这意味着可能会创建出一个缺失value的字典，而不是抛出一个异常。 另一个类似数组的地方，字典也可以通过Literal Syntax进行值的存取。旧的存取一个值的方法需要义哥确定的key如下面这样： 1NSString *lastName = [personData objectForKey:@&quot;lastName&quot;]; 与之等价的Literal Syntax是这样的： 1NSString *lastName = personData[@&quot;lastName&quot;]; 再一次，Literal Syntax减少了复杂的代码，留下了易读的代码。 Mutable Arrays and Dictionaries以同样的方法，你可以通过下标去访问数组元素或者通过key访问字典元素。如果它们是可变的，你还可以设置它们。通过正常方法设置可变数组或可变字典是这样的： 12[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;]; 通过Literal Syntax设置时这样的： 12mutableArray[1] = @&quot;dog&quot;;mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;; Limitations使用Literal Syntax有一个小限制，除了字符串外，其余创建对象的类必须是基础框架中的一个。没有办法指定你自己创建的子类替代它的创建。如果你想使用自定义的子类创建实例，那么你不能使用Literal Syntax。然而，由于NSArray、NSNumber、NSDictionary是类簇（看第9节），它们很少被继承，因为这样做意义不大。此外，标准的实现通常是足够好的。字符串可以使用自定义的子类，但是它必须通过编译器去设置。除非你知道你想做什么，否则你是不会想去设置它的，你将会希望一直使用NSString类。 同样的，在这种情况下，字符串、数组、字典，仅有它们的可变类可以通过Literal Syntax创建对象。如果需要一个可变变量，mutableCopy必须被调用，像这样： 1NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy]; 它添加了一个额外方法的调用，并且一个额外的对象将会被创建，但是使用Literal Syntax的好处是超过它的坏处的。 小结 使用Literal Syntax去创建字符串，数字，数组，字典。它是比正常的创建对象的语法简洁和清晰地。 通过下标法访问数组或者字典。 使用Literal Syntax给数组或者字典插入一个空的值将会产生一个异常。因此，尽量确定它们的值不为空。 优先使用类型常量，减少使用#define预处理在写代码时，你经常想去定义一个常量。例如，一个UIView类出现和消失时它自身的动画。你可能想定义一个常量来代表动画持续的时间。你已经学会了Objective-C和C的基础，所以你决定使用的方法是这样的： 1#define ANIMATION_DURATION 0.3 这是一个预处理指定；每当在你的代码中出现ANIMATION_DURATION字符，就用0.3替代。这看起来就是你想要的，但是这种定义没有类型信息。它就像是声明了一个叫做“duration”的事物意指它的value与时间有关系，但它并不是明确的。并且，它会将所有ANIMATION_DURATION替换掉，如果它声明在头文件中，别的任何导入了这个头文件的类都将被替代。 为了解决这个问题，你应该使用编译器。有一个比使用预处理更好的办法，去定义一个常量。例如，下面这种定义常量类型为NSTimeInterval： 1static const NSTimeInterval kAnimationDuration = 0.3; 注意这种格式，它是有类型信息的，这种用法是好的，因为我们可以清楚地知道常量的定义。它的类型是NSTimeInterval，并且它有助于指出变量的使用。如果你定义了许多常量，它将会帮助以后阅读代码的人。 也会指出这个变量如何命名的。通常的惯例是在常量前面加上小写字母k（加k的原因据说是constant的首字母读音，或者德语一般写作konstant）并将其放置在实现文件中。对于需要暴露给其它类的常量，通常使用其类名作为前缀。第19节展示了更多的命名标准。 在哪里定义常量是重要的。有时，使用预处理定义常量是诱人的，但这是一个坏的习惯，特别是命名方式没有遵循标准的时候，它们不会冲突。例如：ANIMATION_DURATION常量定义在头文件是一个坏的命名。它将显示在所有导入了这个头文件的文件中。甚至作为标准的static const也不该出现在头文件中。自从Objective-C不使用命名空间（namespaces），上面的代码将会声明一个叫做kAnimationDuration的全局变量。它的名字前缀应该使用其所作用的类的名字，例如EOCViewClassAnimationDuration。第19节展示了更多的关于使用清晰命名的方案。 一个不需要暴露给外界的常量，应该在需要使用它的实现文件中定义。例如，如果那个动画持续时间的常量被用在一个UIView的子类，子类在一个iOS应用中，它看起来是这样的： 123456789101112131415161718192021//EOCAnimatedView.h#import &lt;UIKit/UIKit.h&gt;@interface EOCAnimatedView : UIView- (void)animate;@end//EOCAnimatedView.m#import &quot;EOCAnimatedView.h&quot;static const NSTimeInterval kAnimationDuration = 0.3;@implementation EOCAnimatedView- (void)animate &#123; [UIView animateWithDuration:kAnimationDuration animations:^()&#123; // Perform animations &#125;];&#125;@end 使用static const声明常量是重要的。使用const修饰符代表如果你试图在之后修改值，编译器将会报错。在这种情况下，这种做法是必需的。这个值不应该被改变。static修饰符的意思是其作用范围在定义它的编译单元内。编译器将其接收到的内容编译成一个目标文件，这个目标文件就是编译单元。在Objective-C中，每一个编译单元就是每一个实现文件。所以在前面的例子中，kAnimationDuration将被声明在EOCAnimatedView.m生成的目标文件中。如果变量没有使用static修饰，编译器将会创建一个外部符号给它。如果另一个编译单元也声明了一个相同名字的变量，将会抛出一个类似的错误： 123duplicate symbol _ kAnimationDuration in: EOCAnimatedView.o EOCOtherView.o 实际上，当使用static和const声明一个变量时，编译器最终不会创建一个符号，而是使用存在的值去替代变量，就像宏定义一样。谨记，无论如何，显示类型信息的做法是更好的。 有时，你会想给外部暴漏一个常量。例如，如果你的类使用NSNotificationCenter通知别的类，你可能想这样做。这个功能是一个对象发送通知，另一个对象注册并接收它。通知有一个字符串做名字，并且你可能将其声明为一个外部可见的常量。这样做的意思是可以让任何一个想去注册接收通知的类不需要知道实际的字符名字，而仅使用这个常量。 这种常量需要出现在全局的符号表中，从而可以在声明它之外的编译单元使用。因此，这些常量需要声明在不同与static const示例的地方。这个变量应该像这样被声明： 12345// In the header fileextern NSString *const EOCStringConstant;// In the implementation fileNSString *const EOCStringConstant = @&quot;VALUE&quot;; 这个常量声明在头文件，定义在实现文件。在常量类型中，const修饰符是非常重要的。这些声明是从后向前读的，意思是在这种情况下，EOCStringConstant是一个常量指向一个字符串。这正是我们想要的；常量不允许修改所指向的字符串对象。 当编译器在文件中发现一个extern修饰的常量被使用时，extern关键字会告诉编译器，在导入的类中去寻找。这个关键字告诉编译器在全局符号表中有一个EOCStringConstant的符号。这意味着编译器可以不知道常量的定义而去使用它。编译器简单的知道当文件链接为二进制文件时常量是存在的。 常量必须被定义并且仅定义一次。它通常定义在实现文件，声明在它的头文件。编译器将会为从实现文件生成的目标文件的数据段中的字符串分配存储空间。无论它在哪里被使用，当这个目标文件跟其他文件链接生成最后的二进制时，链接器都将能找到它的全局符号。 实际上，符号出现在全局符号表的意思是你应该小心常量的命名。例如，一个处理登录的类会在登录后对整个应用发送一个通知。这个通知看起来是这样的： 1234567891011121314151617181920212223242526272829// EOCLoginManager.h#import &lt;Foundation/Foundation.h&gt;extern NSString *const EOCLoginManagerDidLoginNotification;@interface EOCLoginManager : NSObject- (void)login;@end// EOCLoginManager.m#import &quot;EOCLoginManager.h&quot;NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;;@implementation EOCLoginManager- (void)login &#123; // Perfoem login asynchronously, then call &apos;p_didLogin&apos;.&#125;- (void)p_didLogin &#123; [[NSNotificationCenter defaultCenter] postNotificationName:EOCLoginManagerDidLoginNotification object:nil];&#125;@end 注意常量的名字。常量前缀使用类的名字是谨慎的并且可以帮助你去避免冲突。这在整个系统框架中都是常见的。UIKit，例如，将通知名称以相同的办法声明为全局常量。这些名字包括UIApplicationDidEnterBackgroundNotification和UIApplicationWillEnterForegroundNotification. 其它类型的常量同样可以这样做。如果动画持续时间需要暴露在EOCAnimatiedView类之外，在上面的例子中，你可以这样声明： 12345//EOCAnimatedView.hextern const NSTimeInterval kAnimationDuration;//EOCAnimatedView.mconst NSTimeInterval kAnimationDuration = 0.3; 用这种方法定义一个常量是优于使用宏定义的，因为编译器可以确定这个值不能被改变。在EOCAnimatedView.m定义一次，它的值可以在任何地方使用。一个宏定义可以重复定义，意味着一个程序的不同部分可能使用了不同的值。 综上所述，对于常量避免使用宏定义。相反，使用编译器可以观察的常量，如在实现文件中使用static、const声明常量。 小结 避免宏定义。它们不包含任何类型信息并且可以在编译前被简单的查找替换。它们可以重新定义并且没有警告，使得整个应用的值不一致。 使用static、const在实现文件中定义特定编译单元的常量。这些常量将不会被暴露在全局字符表中，所以它们的名字不需要命名空间。 使用extern在头文件声明它们，在关联的实现文件定义它们。这些常量将出现在全局字符表，所以它们的名字应该需要命名空间，通常使用类名作为前缀是合理的。 使用枚举表示状态、选项、状态码因为Objective-C是基于C的，C的所有功能Objective-C都是适用的。其中一个就是枚举类型，enum。它在系统框架中被广泛使用，但是常常被开发者忽略。它用于定义命名常量是非常有用的，例如，错误状态码和定义选项是可以组合的。感谢C++11标准支持了它，最近的系统版本包含枚举类型。是的，Objective-C也得益于C++11的标准。 枚举仅仅是命名常量的一种方法。一个简单的枚举集合可以用来表示一个对象的状态。例如，一个socket链接使用枚举表示如下： 12345enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;; 使用一个枚举意味着代码是可读的，因为每一个状态可以通过一个易读的值去代表。在枚举中编译器给每个成员一个唯一的值，从0开始每个成员加1。这种枚举是依靠编译器支持的但需要足够的位数去表示枚举。在前面的枚举中，仅需要1个字节就够了，因为它的最大值是2。 然而定义枚举变量的方式却不太简洁，需要使用下面的语法： 1enum EOCConnectionState state = EOCConnectionStateDisconnected; 如果每次不用使用enum只使用EOCConnectionState就好了。为了这样做，你添加一个typedef给枚举定义： 123456enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef enum EOCConnectionState EOCConnectionState; 它的意思是使用EOCConnectionState代替enum EOCConnectionState。 1EOCConnectionState state = EOCConnectionStateDisconnected; C++11标准的问世给枚举带来了一些变化。其中一个变化是可以决定使用哪种“数据类型”去存储枚举类型。这样做的好处是可以使用向前声明了。如果不指定数据类型，枚举类型无法使用向前声明，因为编译器无法知道数据类型的大小。因此，当用到枚举类型时，编译器无法知道应该给变量分配多大的空间。 给枚举指定数据类型，你可以使用下面这种语法： 1enum EOCConnectionStateConnectionState : NSInteger &#123; /*...*/&#125;; 上面代码的意思是保证枚举的变量类型是NSInteger。如果你乐意，这种类型的向前声明可以写成这样： 1enum EOCConnectionStateConnectionState : NSInteger; 你可以给枚举成员定义一个确切的值，而不是让编译器帮你指定。这语法看起来是这样的： 12345enum EOCConnectionStateConnectionState &#123; EOCConnectionStateDisconnected = 1, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;; 这意思是EOCConnectionStateDisconnected的值为1而不是0.别的成员变量的值同之前一样，依次递增1。例如，EOCConnectionStateConnected的值就是3。 另一种使用枚举类型的情况是去定义选项，特指当选项可以组合在一起时。只要当各选项定义的对，那么就可以使用“按位或运算符”去组合它们。例如，考虑下面的枚举类型，在iOS的UI框架中，用来表示某个视图如何调整大小： 123456789enum UIViewAutoresizing &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,&#125;; 每一个选项都可以开启或者关闭，使用上面的语法可以控制它因为每个选项都仅有单一的一位值去代表它自身。使用“按位或操作”可以组合多个选项。例如：UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight。图1.2展示了每个枚举成员和组合两个成员后的位布局。 通过“按位与操作”是可以判断出某个选项是否启用： 123456enum UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123; // UIViewAutoresizingFlexibleWidth is set &#125; 图1.2每个选项值的二进制表示形式，以及两个选项值运用“按位或运算”之后的二进制形式。 枚举在系统框架中使用非常广泛。另一个例子是iOS中的UIKit框架中的，用枚举值列举视图所支持的方向并告诉系统。它使用一个叫做UIInterfaceOrientationMask的枚举类型来实现，并且你可以实现一个叫做supportedInterfaceOrientations的方法去告诉系统视图所支持的方向： 1234- (NSUInteger)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft; &#125; 在Foundation框架中有一些辅助宏定义，用这些宏定义可以指定枚举值的数据类型。它们提供了向后兼容性，当编译器支持新的语法特性时，它们使用新的语法；当编译器只支持旧语法特性时，它们使用旧的语法特性。这些宏是由#define预处理指令定义的。一个支持像EOCConnectionState这种普通类型的枚举，另一个支持像UIViewAutoresizing这种一系列选项的枚举。你可以像下面这样使用它们： 1234567891011typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 这些宏的定义如下： 123456789101112131415161718#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L&amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum)) ) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum)) #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #if (__cplusplus) #define NS_OPTIONS(_type, _name) type _name; enum : _type #else #define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type #endif #else #define NS_ENUM(_type, _name) _type _name; enum #define NS_OPTIONS(_type, _name) _type _name; enum #endif 由于要处理不同的情况所以要用多种方式去定义两个宏。第一个判断是检查编译器是否支持新式枚举的特性。这个布尔逻辑看起来相当复杂，但它的意思就是判断编译器是否支持新特性。如果不支持，那么就用老的方式。 如果新特性是可用的，那么NS_ENUM宏所定义的类型展开后是这样的： 123456typedef enum EOCConnectionState : NSUInteger EOCConnectionState; enum EOCConnectionState : NSUInteger &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected, &#125;; NS_OPTIONS宏的展开是取决于编译形式的。如果以C++形式编译，那么NS_OPTIONS宏展开与NS_ENUM宏展开是不一样的，否则是一样的。为什么？因为C++环境下两个枚举值通过按位或运算结果与非C++环境下是不同的。前面已经提到了，作为选项的枚举值经常会通过按位或运算进行组合。当两个值通过按位或运算后，C++认为它们所代表的值类型是NSUInteger。并且也不允许饮食转换为枚举类型。为了说明这个，我们考虑将EOCPermittedDirection以NS_ENUM形式展开： 1234567typedef enum EOCPermittedDirection : int EOCPermittedDirection; enum EOCPermittedDirection : int &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 考虑下面的代码： 12EOCPermittedDirection permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp; 当在C++或者Objective-C++环境下，将会出现下面的错误： 12error: cannot initialize a variable of type &apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos; 你必须将通过按位或操作的结果显示的转化为EOCPermittedDirection。所以，在C++的环境下应该使用NS_OPTIONS，省去显示转化这一步。因此，如果需要按位或操作的枚举值应当尽量使用NS_OPTIONS，而不需要的，则使用NS_ENUM。 枚举可以用在很多情况下。选项和状态已经在前面讲过了；然后更多的情况同样适用。对错误使用状态码是一个好的习惯。把逻辑含义相似的代码放入一个枚举中，用于替代使用预定义和常量。另一个好的地方是样式。例如，你有一个UI元素可以创建不同的样式，一个枚举集合可以完美的表示每个样式。 最后一点是关于在switch中使用枚举变量。又是，你会这样定义它们： 1234567891011121314151617typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected, &#125;; switch (_currentState) &#123; EOCConnectionStateDisconnected: // Handle disconnected state break; EOCConnectionStateConnecting: // Handle connecting state break; EOCConnectionStateConnected: // Handle connected state break; &#125; 我们习惯在switch语句中加上默认分支。然而，当使用枚举值表示状态时，最好不要写一个默认分支。这样做的原因是，当你在稍后添加了一个新的状态，那么编译器将会警告你，提示你有新的状态未加入switch分支。如果有一个默认的分支，编译器将会处理它，那么编译器将不会发出警告。这个问题同样适用于别的使用NS_ENUM的定义中。例如，你定义一个UI元素，你将会希望每个情况都有一个确定的样式。 小结 使用枚举来表示状态机的状态，传递给函数的选项，或者错误码，并且起一个易读的名字。 如果把一个传递给方法的选项表示为枚举类型，同时还需要多重操作，可以将它们的值设为2的幂，然后通过按位或操作将其组合起来。 使用NS_ENUM和NS_OPTIONS宏最好给枚举定义一个明确的数据类型。这样做的意思是确定枚举的数据类型是开发者设置的，而不是编译器指定的。 在switch中使用枚举时，不要设置默认分支。这样在你添加新枚举后，编译器会提醒你添加新分支。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本内容图解]]></title>
      <url>%2F2017%2F04%2F17%2FBasePrinciple_Img%2F</url>
      <content type="text"><![CDATA[Some principle！！！ 最近抽空总结了一些基础东西，偷得浮生半日闲啊。首先是编译型语言和解释型语言的区别，图解: 就是整理了上面的东西之后，发现需要整理下app的运行时内存的情况，然后… 突然又发现里面的寄存器不是很明白，又去大致看了下计算机的硬件组成，摊手。谁让这东西早还给老师了，又整理如下 对于计算机硬件这块，没有深入了解，只是大致理了了流程。目前图解整理就这么多啦……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码解析]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_3%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex中文件夹的作用以及重要性，这一篇将正式开始Weex源码的解析，版本是0.10.0 入口学习一个开源库，最好是知其思想，找其入口，学其核心。大致思想在第一篇，核心文件夹的分类在第二篇，这一篇就从其入口文件开始学习。 WeexDemo的入口是[WXSDKEngine initSDKEnvironment];。这个Method的主要代码，如下： 123NSString *filePath = [[NSBundle bundleForClass:self] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];[WXSDKEngine initSDKEnvironment:script]; 首先，读取一个叫做main.js的文件内容，然后将其内容作为[WXSDKEngine initSDKEnvironment:script]初始化的参数。我们继续来看这个method的代码，如下： 123456if (!script || script.length &lt;= 0) &#123; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_LOAD, @&quot;framework loading is failure!&quot;); return;&#125;[self registerDefaults];[[WXSDKManager bridgeMgr] executeJsFramework:script]; 注册和执行Register首先，是对传递进来的js代码做判断，其次调用了一个registerDefaults的method，代码如下： 123456static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers];&#125;); Register Componet这个method使用了单例模式，对Weex定义的Component、Module、Handler进行注册，注册代码太长，我就不贴了。注册Component，代码如下： 1234567891011121314151617181920212223242526+ (void)registerComponent:(NSString *)name withClass:(Class)clazz&#123; [self registerComponent:name withClass:clazz withProperties: @&#123;@&quot;append&quot;:@&quot;tree&quot;&#125;];&#125;+ (void)registerComponent:(NSString *)name withClass:(Class)clazz withProperties:(NSDictionary *)properties&#123; if (!name || !clazz) &#123; return; &#125; WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the component, please check if the parameters are correct ！&quot;); [WXComponentFactory registerComponent:name withClass:clazz withPros:properties]; NSMutableDictionary *dict = [WXComponentFactory componentMethodMapsWithName:name]; dict[@&quot;type&quot;] = name; if (properties) &#123; NSMutableDictionary *props = [properties mutableCopy]; if ([dict[@&quot;methods&quot;] count]) &#123; [props addEntriesFromDictionary:dict]; &#125; [[WXSDKManager bridgeMgr] registerComponents:@[props]]; &#125; else &#123; [[WXSDKManager bridgeMgr] registerComponents:@[dict]]; &#125;&#125; 第一个method中比较让人迷惑的也就是Properties中的参数了，这个其实是vue的渲染模式。@&quot;append&quot;:@&quot;tree&quot;代表是整个vue结点包括子结点生成完之后才会一次性渲染到屏幕，@&quot;append&quot;:@&quot;node&quot;代表是先渲染自身然后再渲染子节点。第二个method中先对name和class进行判空，其次使用WXComponentFactory进行注册，在这之前先讲几个相关类的功能，免得迷糊。 WXInvocationConfig：抽象单例类，为什么用单例(懵逼脸)，使用时需要子类继承 WXComponentConfig: 继承WXInvocationConfig类，存储每个Component的method、name、classname WXComponentFactory：单例类，通过字典存储WXComponentConfig对象，通过每个WXComponentConfig对象操作每个Component的method、name、classname。 首先通过WXComponentFactory调用- (void)registerComponent:(NSString *)name withClass:(Class)clazz withPros:(NSDictionary *)pros方法注册。使用Assert判断，然后创建一个WXComponentConfig对象，先从字典中取，不论是否存在都重新初始化，并将其覆盖，调用[config registerMethods];将类中的method通过runtime存储在WXComponentConfig中，存取时加锁保证安全。其次调用- (NSMutableDictionary *)_componentMethodMapsWithName:(NSString *)name方法获取某个component所有的method，同样是加锁读取。根据有没有properties传递不同参数，如果类中有导出给weex用的方法，那么一定会传递method和name过去。最后调用JS方法registerComponents，我在vue.js的源码中是找到这个方法了的。对于具体调用JS的过程，会在ExecuteJs模块讲解。 1234567891011121314export function registerComponents (newComponents) &#123; if (Array.isArray(newComponents)) &#123; newComponents.forEach(component =&gt; &#123; if (!component) &#123; return &#125; if (typeof component === &apos;string&apos;) &#123; components[component] = true &#125; else if (typeof component === &apos;object&apos; &amp;&amp; typeof component.type === &apos;string&apos;) &#123; components[component.type] = component &#125; &#125;) &#125;&#125; Register Module注册Module，代码如下： 1234WXAssert(name &amp;&amp; clazz, @&quot;Fail to register the module, please check if the parameters are correct ！&quot;); NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz];NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName];[[WXSDKManager bridgeMgr] registerModules:dict]; 先介绍几个类： WXModuleConfig：继承WXInvocationConfig类，存储每个Component的method、name WXModuleFactory：单例类，通过字典操作WXModuleConfig对象 查阅下这两个类的代码会发现跟Component结构类似，跟注册Component流程也一样，感觉没必要废话一遍了，最后调用JS方法registerModules。 Register Handler注册Handler，代码如下： 123WXAssert(handler &amp;&amp; protocol, @&quot;Fail to register the handler, please check if the parameters are correct ！&quot;); [WXHandlerFactory registerHandler:handler withProtocol:protocol]; 照例介绍几个类： WXHandlerFactory：单例类，通过字典存储协议对象，将协议的字符串作为key存储 注册Handler，这个不需要传给weex，因为就是我们Native端进行调用。所以只需要使用WXHandlerFactory操作就行了。 ExecuteJs最后调用[[WXSDKManager bridgeMgr] executeJsFramework:script];执行js代码。这一块的知识点是Weex与js的交互，所以需要了解下面几个类，并且对OC中的JavaScriptCore框架有所了解。 首先介绍几个类： WXSDKInstance：普通类，这个类是一个类似于Controller的类，具有非常多的功能，目前不需要了解具体功能 WXSDKManager：单例类，通过一个字典存储所有WXSDKInstance实例，key是一个唯一值；一个WXBridgeManager实例 WXBridgeManager：单例类，注册，渲染功能都通过调用WXBridgeContext对象去跟JS交互 WXBridgeContext：功能其实不多，render，regist component，regist module，executeJs。就是处理了需要调用js的逻辑。 WXJSCoreBridge: 这个类才是真正的处理JS调用的类。它实现了WXBridgeProtocol协议，对JavaScriptCore进行了封装，使WXBridgeContext调用 现在可以从那句代码开始讲了，[WXSDKManager bridgeMgr]这个对象是一个单例，他在JS线程调用executeJsFramework，代码如下： 12345if (!script) return;__weak typeof(self) weakSelf = self;WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx executeJsFramework:script];&#125;); 先是判空，其次weakSelf防止循环引用，然后在一个叫做&quot;com.taobao.weex.bridge&quot;的线程调用executeJsFramework方法，代码如下： 123456789101112131415161718192021222324252627282930313233WXAssertBridgeThread();WXAssertParam(script); WX_MONITOR_PERF_START(WXPTFrameworkExecute); [self.jsBridge executeJSFramework:script]; WX_MONITOR_PERF_END(WXPTFrameworkExecute); if ([self.jsBridge exception]) &#123; NSString *message = [NSString stringWithFormat:@&quot;JSFramework executes error: %@&quot;, [self.jsBridge exception]]; WX_MONITOR_FAIL(WXMTJSFramework, WX_ERR_JSFRAMEWORK_EXECUTE, message);&#125; else &#123; WX_MONITOR_SUCCESS(WXMTJSFramework); //the JSFramework has been load successfully. self.frameworkLoadFinished = YES; [self executeAllJsService]; JSValue *frameworkVersion = [self.jsBridge callJSMethod:@&quot;getJSFMVersion&quot; args:nil]; if (frameworkVersion &amp;&amp; [frameworkVersion isString]) &#123; [WXAppConfiguration setJSFrameworkVersion:[frameworkVersion toString]]; &#125; //execute methods which has been stored in methodQueue temporarily. for (NSDictionary *method in _methodQueue) &#123; [self callJSMethod:method[@&quot;method&quot;] args:method[@&quot;args&quot;]]; &#125; [_methodQueue removeAllObjects]; WX_MONITOR_PERF_END(WXPTInitalize);&#125;; 首先断言当前线程是否是&quot;com.taobao.weex.bridge&quot;线程，其次断言js代码，使用WXBridgeProtocol协议对象执行js代码，接着判断js执行是否有异常，有异常输出，无异常，标记读取结束，执行所有的jsService，获取JSFMVersion，执行methodQueue中所有的method，清除信息，结束。 JavaScriptCoreJavaScriptCore简介上面只是理清了逻辑，如果对JavaScriptCore不了解的人可能看源码时有些懵逼，下面我讲解一些JavaScriptCore的基本概念以及用法。 JSVirtualMachine：为JavaScript提供运行资源 JSContext：为JavaScript提供运行环境 JSValue：可以将JavaScript变量转换为OC变量，也可以将OC变量转换为JavaScript变量 JavaScriptCore示例这些是Weex使用的JavaScriptCore框架一部分功能，其实还有别的。先来一段代码好了： 简单使用12345JSContext *context = [[JSContext alloc] init];JSValue *value = [context evaluateScript:@&quot;var sum = 2 + 3; sum&quot;];NSLog(@&quot;%@&quot;, value); 输出5context[@&quot;sum&quot;] = @&quot;40&quot;;NSLog(@&quot;%@&quot;, context[@&quot;sum&quot;]); 输出40 首先初始化一个JSContext对象，可以使用JSVirtualMachine对象初始化，也可以直接初始化，直接初始化系统仍会在内部给你初始化一个JSVirtualMachine对象，所以这个js运行的资源，不可或缺。 第二句代码的意思是先使用context对象运行js代码，定义一个叫做sum的变量，并赋值2+3，然后将sum赋值给value。 第三句代码输出value的值是5，第四句代码给sum赋值40，第五句输出sum值为40。这主要是因为JSContext是js的环境，而且在js中，所有全局变量和方法都是一个全局变量的属性。所以在第四句，你可以直接从context中取出sum这个变量，并赋值。 异常处理1234_jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123; context.exception = exception; NSString *message = [NSString stringWithFormat:@&quot;[%@:%@:%@] %@\n%@&quot;, exception[@&quot;sourceURL&quot;], exception[@&quot;line&quot;], exception[@&quot;column&quot;], exception, [exception[@&quot;stack&quot;] toObject]];&#125;; 另一个要注意的点就是这里，JavaScriptCore会在exceptionHandler中抛出异常，为了我们能在这个时候做点什么，所以我们赋值给他一个blcok。并且如果你要在block中使用context对象，要么将其作为参数传递进block，要么使用[JSContext currentContext]获取当前的context。如果直接引用外部的context会造成循环饮用。 invokeMethod1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;]; JSValue *sum = [[context globalObject] invokeMethod:@&quot;add&quot; withArguments:@[@(3), @(4)]];NSLog(@&quot;%@&quot;, sum); 输出7 初始化一个context，将一个名为add的method加入到context中，使用js全局变量调用add方法，并传入参数3，4，输出结果为7。 总结上面讲了Weex注册的基本逻辑和JavaScriptCore框架的一些基本使用，我想应该对理解Weex框架的运作原理有帮助的。其实剩下的源码还有很多，比如向js端发送消息等，但其实质逃不过上面的流程，所以我认为也没有往下写的必要了。最后，为大家整理下类的调用顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex源码文件夹的解释]]></title>
      <url>%2F2017%2F03%2F14%2FWeex_2%2F</url>
      <content type="text"><![CDATA[上一篇介绍了Weex在iOS端的用法，这一篇介绍下Weex中文件夹的作用，版本是0.10.0 Weex文件夹*最不重要的文件夹：Controller、Debug、Handler *不重要的文件夹：Loader、Monitor、Network、Utility、WebSocket *稍微重要的文件夹：Component、Module、Protocol *重要的文件夹：Display、Events、Layout、View *最重要的文件夹：Bridge、Engine、Manager、Model Controller: 一个继承UIViewController的类，一个继承UINavigationController.你完全用不到，酱油； Debug：一个调试类，酱油； Handler：两个类实现了两个Weex的Protocol，酱油； Loader：一个类是Network的回调实现，一个类是WebSocket的回调。 Monitor：一个监测的类，输出一些信息。 Network:一个小型的网络请求库 Utility：一些常用方法的封装 WebSocket：对SRWebSocket的封装 Componet：对各种view的封装，如果需要扩展view就跟这个有关 Module：提供各种方法给Componet使用，Weex封装的都是给Weex定义的Componet用，一般都是自定义Method Protocol：提供各种协议，Handler所实现的协议就是这里面的，感觉weex提供的已经够用了。 Display：WXComponent的展示 Events：WXComponent的事件 Layout：WXComponent的布局 View：WXComponent的View Bridge：Weex与NativeJS之间的桥接 Engine：Weex的入口，用于初始化Env，注册Componet、Module、Handler，重载等 Model：WXComponent是Componet的根类，WXSDKInstance类似Native的Controller，拥有自身的生命周期，以单链表形式存储的父WXSDKInstance实例，自身的view，render等。 Manager：Weex中各种管理的类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Book]]></title>
      <url>%2F2017%2F02%2F26%2FReadBook_iOS%2F</url>
      <content type="text"><![CDATA[iOS相关书籍… 《iOS7应用开发技术详解》在朋友那看到的一本书，花了两天时间把这本书翻了一遍，感觉适合有一些编程概念的人看。其次，这本书某些知识点对于当下过于古老，如14.2手势事件、11.3.5的UIViewAutoresizing等，我也不太清楚这本书是否有新版。此外，如果未用到CoreData和Audio/Video的，建议粗略查看16、17章，这两个知识点每个都是一个领域，当然如果就是冲着这知识点去的，那也可以当成基础概念的了解及使用。总的来说，这本书对于修补基础知识空缺或是iOS初学者还是有不错的帮助。 《iOS开发进阶》这本书作者是唐巧，第一部分讲了很多工具，占了一半书的厚度；第二部分讲了很多的实战小窍门，第三部分初步讲了一下OC对象，指针，block原理这些。这本书真的是书如其名，进阶开发。。。并没有讲解很多的原理层次的东西，更多的就是业务层次的。所以有很多人说就是混的，也有人说写的OK，我感觉仁者见仁，智者见智吧。 《Objective-C高级编程》这本书是一个日本人写的，反正不知道叫什么，哈哈哈。这本书也有几年了，主要讲了三个东西引用计数，Block，GCD。引用计数这块引用了很多GNUstep的源码，主要是苹果这部分源码不开放，摊手；Block这块主要看的是clang rewrite 之后的代码；GCD是参考的苹果开源的libdispatch和XNU内核源码，但是这块讲解的不是非常深入，只是列举了调用的API。这本书讲解内容相对来说比较深，并且与业务有关的不多，适合想了解这几个知识点原理的人看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS-Weex的简单使用]]></title>
      <url>%2F2017%2F02%2F01%2FWeex_1%2F</url>
      <content type="text"><![CDATA[本篇主要讲解一下Weex的大概原理以及简单的使用 Weex 与RN相同原理，某些方面优于RN js语法，比Native体验稍差，比hybrid app体验好太多 js一端代码，三端使用 iOS/Android脱离写UI的噩梦 文档不够完善 Weex原理 Weex使用 首先，在AppDelegate中调用[WXSDKEngine initSDKEnvironment]进行注册 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXSDKEngine initSDKEnvironment]; return YES;&#125; 其次，在需要使用的ViewController中定义一个WXSDKInstance实例和UI个UIView实例 12@property (nonatomic) WXSDKInstance *instance;@property (nonatomic) UIView *weexView; 紧接着，初始化WXSDKInstance实例，设置它的viewController、frame属性，实现它的生命周期 123456789101112131415161718192021222324252627_instance = [[WXSDKInstance alloc] init];_instance.viewController = self;_instance.frame = [UIScreen mainScreen].bounds; __weak typeof(self) weakSelf = self;_instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView];&#125;; _instance.onFailed = ^(NSError *error) &#123; NSLog(@&quot;failed %@&quot;,error);&#125;; _instance.renderFinish = ^(UIView *view) &#123; NSLog(@&quot;render finish&quot;);&#125;; _instance.onRenderProgress = ^(CGRect renderRect) &#123; NSLog(@&quot;renderProgress&quot;);&#125;; _instance.updateFinish = ^(UIView *view) &#123; NSLog(@&quot;update Finish&quot;);&#125;; 最后，使用WXSDKInstance实例调用renderWithURL:方法即可。记得在dealloc中释放WXSDKInstance实例哦😯 [self.instance renderWithURL:[NSURL URLWithString:renderURL]]; Weex的自定义 Component: Weex组件，weex官方基本把原生的定义过了，所以你基本不需要自定义。如果需要自定义，普通组件继承WXComponent，滑动组件继承WXScrollerComponent handler: Native提供一个协议。weex官方定义了常用的部分，如WXImgLoaderProtocol图片下载。如果需要自定义，注意需遵守协议WXModuleProtocol module：js调用Native, 返回值可有可无。这个基本用到就是自定义，遵守协议WXModuleProtocol，需要自定义Method，如果需要返回值使用WXModuleCallback返回 总结：Component、handler、module都需要在使用前进行注册，一般都是在AppDelegate中，如下： 123[WXSDKEngine registerModule:@&quot;test&quot; withClass:[WeexCustomModule class]];[WXSDKEngine registerModule:@&quot;user&quot; withClass:[HMBUserModule class]];[WXSDKEngine registerHandler:[HMBWeexImageLoader new] withProtocol:@protocol(WXImgLoaderProtocol)]; 基本的Weex知识就是这些，具体使用方法请参照官方文档和demo链接。下篇开始讲解weex源码，未使用过weex的建议先尝试使用weex。]]></content>
    </entry>

    
  
  
</search>
